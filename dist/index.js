(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/peerjs-js-binarypack/lib/bufferbuilder.js
  var require_bufferbuilder = __commonJS({
    "node_modules/peerjs-js-binarypack/lib/bufferbuilder.js"(exports, module) {
      var binaryFeatures = {};
      binaryFeatures.useBlobBuilder = function() {
        try {
          new Blob([]);
          return false;
        } catch (e) {
          return true;
        }
      }();
      binaryFeatures.useArrayBufferView = !binaryFeatures.useBlobBuilder && function() {
        try {
          return new Blob([new Uint8Array([])]).size === 0;
        } catch (e) {
          return true;
        }
      }();
      module.exports.binaryFeatures = binaryFeatures;
      var BlobBuilder = module.exports.BlobBuilder;
      if (typeof window !== "undefined") {
        BlobBuilder = module.exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder;
      }
      function BufferBuilder() {
        this._pieces = [];
        this._parts = [];
      }
      BufferBuilder.prototype.append = function(data) {
        if (typeof data === "number") {
          this._pieces.push(data);
        } else {
          this.flush();
          this._parts.push(data);
        }
      };
      BufferBuilder.prototype.flush = function() {
        if (this._pieces.length > 0) {
          var buf = new Uint8Array(this._pieces);
          if (!binaryFeatures.useArrayBufferView) {
            buf = buf.buffer;
          }
          this._parts.push(buf);
          this._pieces = [];
        }
      };
      BufferBuilder.prototype.getBuffer = function() {
        this.flush();
        if (binaryFeatures.useBlobBuilder) {
          var builder = new BlobBuilder();
          for (var i = 0, ii = this._parts.length; i < ii; i++) {
            builder.append(this._parts[i]);
          }
          return builder.getBlob();
        } else {
          return new Blob(this._parts);
        }
      };
      module.exports.BufferBuilder = BufferBuilder;
    }
  });

  // node_modules/peerjs-js-binarypack/lib/binarypack.js
  var require_binarypack = __commonJS({
    "node_modules/peerjs-js-binarypack/lib/binarypack.js"(exports, module) {
      var BufferBuilder = require_bufferbuilder().BufferBuilder;
      var binaryFeatures = require_bufferbuilder().binaryFeatures;
      var BinaryPack = {
        unpack: function(data) {
          var unpacker = new Unpacker(data);
          return unpacker.unpack();
        },
        pack: function(data) {
          var packer = new Packer();
          packer.pack(data);
          var buffer = packer.getBuffer();
          return buffer;
        }
      };
      module.exports = BinaryPack;
      function Unpacker(data) {
        this.index = 0;
        this.dataBuffer = data;
        this.dataView = new Uint8Array(this.dataBuffer);
        this.length = this.dataBuffer.byteLength;
      }
      Unpacker.prototype.unpack = function() {
        var type3 = this.unpack_uint8();
        if (type3 < 128) {
          return type3;
        } else if ((type3 ^ 224) < 32) {
          return (type3 ^ 224) - 32;
        }
        var size;
        if ((size = type3 ^ 160) <= 15) {
          return this.unpack_raw(size);
        } else if ((size = type3 ^ 176) <= 15) {
          return this.unpack_string(size);
        } else if ((size = type3 ^ 144) <= 15) {
          return this.unpack_array(size);
        } else if ((size = type3 ^ 128) <= 15) {
          return this.unpack_map(size);
        }
        switch (type3) {
          case 192:
            return null;
          case 193:
            return void 0;
          case 194:
            return false;
          case 195:
            return true;
          case 202:
            return this.unpack_float();
          case 203:
            return this.unpack_double();
          case 204:
            return this.unpack_uint8();
          case 205:
            return this.unpack_uint16();
          case 206:
            return this.unpack_uint32();
          case 207:
            return this.unpack_uint64();
          case 208:
            return this.unpack_int8();
          case 209:
            return this.unpack_int16();
          case 210:
            return this.unpack_int32();
          case 211:
            return this.unpack_int64();
          case 212:
            return void 0;
          case 213:
            return void 0;
          case 214:
            return void 0;
          case 215:
            return void 0;
          case 216:
            size = this.unpack_uint16();
            return this.unpack_string(size);
          case 217:
            size = this.unpack_uint32();
            return this.unpack_string(size);
          case 218:
            size = this.unpack_uint16();
            return this.unpack_raw(size);
          case 219:
            size = this.unpack_uint32();
            return this.unpack_raw(size);
          case 220:
            size = this.unpack_uint16();
            return this.unpack_array(size);
          case 221:
            size = this.unpack_uint32();
            return this.unpack_array(size);
          case 222:
            size = this.unpack_uint16();
            return this.unpack_map(size);
          case 223:
            size = this.unpack_uint32();
            return this.unpack_map(size);
        }
      };
      Unpacker.prototype.unpack_uint8 = function() {
        var byte = this.dataView[this.index] & 255;
        this.index++;
        return byte;
      };
      Unpacker.prototype.unpack_uint16 = function() {
        var bytes = this.read(2);
        var uint16 = (bytes[0] & 255) * 256 + (bytes[1] & 255);
        this.index += 2;
        return uint16;
      };
      Unpacker.prototype.unpack_uint32 = function() {
        var bytes = this.read(4);
        var uint32 = ((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3];
        this.index += 4;
        return uint32;
      };
      Unpacker.prototype.unpack_uint64 = function() {
        var bytes = this.read(8);
        var uint64 = ((((((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3]) * 256 + bytes[4]) * 256 + bytes[5]) * 256 + bytes[6]) * 256 + bytes[7];
        this.index += 8;
        return uint64;
      };
      Unpacker.prototype.unpack_int8 = function() {
        var uint8 = this.unpack_uint8();
        return uint8 < 128 ? uint8 : uint8 - (1 << 8);
      };
      Unpacker.prototype.unpack_int16 = function() {
        var uint16 = this.unpack_uint16();
        return uint16 < 32768 ? uint16 : uint16 - (1 << 16);
      };
      Unpacker.prototype.unpack_int32 = function() {
        var uint32 = this.unpack_uint32();
        return uint32 < Math.pow(2, 31) ? uint32 : uint32 - Math.pow(2, 32);
      };
      Unpacker.prototype.unpack_int64 = function() {
        var uint64 = this.unpack_uint64();
        return uint64 < Math.pow(2, 63) ? uint64 : uint64 - Math.pow(2, 64);
      };
      Unpacker.prototype.unpack_raw = function(size) {
        if (this.length < this.index + size) {
          throw new Error("BinaryPackFailure: index is out of range " + this.index + " " + size + " " + this.length);
        }
        var buf = this.dataBuffer.slice(this.index, this.index + size);
        this.index += size;
        return buf;
      };
      Unpacker.prototype.unpack_string = function(size) {
        var bytes = this.read(size);
        var i = 0;
        var str = "";
        var c;
        var code;
        while (i < size) {
          c = bytes[i];
          if (c < 128) {
            str += String.fromCharCode(c);
            i++;
          } else if ((c ^ 192) < 32) {
            code = (c ^ 192) << 6 | bytes[i + 1] & 63;
            str += String.fromCharCode(code);
            i += 2;
          } else {
            code = (c & 15) << 12 | (bytes[i + 1] & 63) << 6 | bytes[i + 2] & 63;
            str += String.fromCharCode(code);
            i += 3;
          }
        }
        this.index += size;
        return str;
      };
      Unpacker.prototype.unpack_array = function(size) {
        var objects = new Array(size);
        for (var i = 0; i < size; i++) {
          objects[i] = this.unpack();
        }
        return objects;
      };
      Unpacker.prototype.unpack_map = function(size) {
        var map3 = {};
        for (var i = 0; i < size; i++) {
          var key = this.unpack();
          var value = this.unpack();
          map3[key] = value;
        }
        return map3;
      };
      Unpacker.prototype.unpack_float = function() {
        var uint32 = this.unpack_uint32();
        var sign2 = uint32 >> 31;
        var exp = (uint32 >> 23 & 255) - 127;
        var fraction = uint32 & 8388607 | 8388608;
        return (sign2 === 0 ? 1 : -1) * fraction * Math.pow(2, exp - 23);
      };
      Unpacker.prototype.unpack_double = function() {
        var h32 = this.unpack_uint32();
        var l32 = this.unpack_uint32();
        var sign2 = h32 >> 31;
        var exp = (h32 >> 20 & 2047) - 1023;
        var hfrac = h32 & 1048575 | 1048576;
        var frac = hfrac * Math.pow(2, exp - 20) + l32 * Math.pow(2, exp - 52);
        return (sign2 === 0 ? 1 : -1) * frac;
      };
      Unpacker.prototype.read = function(length) {
        var j = this.index;
        if (j + length <= this.length) {
          return this.dataView.subarray(j, j + length);
        } else {
          throw new Error("BinaryPackFailure: read index out of range");
        }
      };
      function Packer() {
        this.bufferBuilder = new BufferBuilder();
      }
      Packer.prototype.getBuffer = function() {
        return this.bufferBuilder.getBuffer();
      };
      Packer.prototype.pack = function(value) {
        var type3 = typeof value;
        if (type3 === "string") {
          this.pack_string(value);
        } else if (type3 === "number") {
          if (Math.floor(value) === value) {
            this.pack_integer(value);
          } else {
            this.pack_double(value);
          }
        } else if (type3 === "boolean") {
          if (value === true) {
            this.bufferBuilder.append(195);
          } else if (value === false) {
            this.bufferBuilder.append(194);
          }
        } else if (type3 === "undefined") {
          this.bufferBuilder.append(192);
        } else if (type3 === "object") {
          if (value === null) {
            this.bufferBuilder.append(192);
          } else {
            var constructor = value.constructor;
            if (constructor == Array) {
              this.pack_array(value);
            } else if (constructor == Blob || constructor == File || value instanceof Blob || value instanceof File) {
              this.pack_bin(value);
            } else if (constructor == ArrayBuffer) {
              if (binaryFeatures.useArrayBufferView) {
                this.pack_bin(new Uint8Array(value));
              } else {
                this.pack_bin(value);
              }
            } else if ("BYTES_PER_ELEMENT" in value) {
              if (binaryFeatures.useArrayBufferView) {
                this.pack_bin(new Uint8Array(value.buffer));
              } else {
                this.pack_bin(value.buffer);
              }
            } else if (constructor == Object || constructor.toString().startsWith("class")) {
              this.pack_object(value);
            } else if (constructor == Date) {
              this.pack_string(value.toString());
            } else if (typeof value.toBinaryPack === "function") {
              this.bufferBuilder.append(value.toBinaryPack());
            } else {
              throw new Error('Type "' + constructor.toString() + '" not yet supported');
            }
          }
        } else {
          throw new Error('Type "' + type3 + '" not yet supported');
        }
        this.bufferBuilder.flush();
      };
      Packer.prototype.pack_bin = function(blob) {
        var length = blob.length || blob.byteLength || blob.size;
        if (length <= 15) {
          this.pack_uint8(160 + length);
        } else if (length <= 65535) {
          this.bufferBuilder.append(218);
          this.pack_uint16(length);
        } else if (length <= 4294967295) {
          this.bufferBuilder.append(219);
          this.pack_uint32(length);
        } else {
          throw new Error("Invalid length");
        }
        this.bufferBuilder.append(blob);
      };
      Packer.prototype.pack_string = function(str) {
        var length = utf8Length(str);
        if (length <= 15) {
          this.pack_uint8(176 + length);
        } else if (length <= 65535) {
          this.bufferBuilder.append(216);
          this.pack_uint16(length);
        } else if (length <= 4294967295) {
          this.bufferBuilder.append(217);
          this.pack_uint32(length);
        } else {
          throw new Error("Invalid length");
        }
        this.bufferBuilder.append(str);
      };
      Packer.prototype.pack_array = function(ary) {
        var length = ary.length;
        if (length <= 15) {
          this.pack_uint8(144 + length);
        } else if (length <= 65535) {
          this.bufferBuilder.append(220);
          this.pack_uint16(length);
        } else if (length <= 4294967295) {
          this.bufferBuilder.append(221);
          this.pack_uint32(length);
        } else {
          throw new Error("Invalid length");
        }
        for (var i = 0; i < length; i++) {
          this.pack(ary[i]);
        }
      };
      Packer.prototype.pack_integer = function(num) {
        if (num >= -32 && num <= 127) {
          this.bufferBuilder.append(num & 255);
        } else if (num >= 0 && num <= 255) {
          this.bufferBuilder.append(204);
          this.pack_uint8(num);
        } else if (num >= -128 && num <= 127) {
          this.bufferBuilder.append(208);
          this.pack_int8(num);
        } else if (num >= 0 && num <= 65535) {
          this.bufferBuilder.append(205);
          this.pack_uint16(num);
        } else if (num >= -32768 && num <= 32767) {
          this.bufferBuilder.append(209);
          this.pack_int16(num);
        } else if (num >= 0 && num <= 4294967295) {
          this.bufferBuilder.append(206);
          this.pack_uint32(num);
        } else if (num >= -2147483648 && num <= 2147483647) {
          this.bufferBuilder.append(210);
          this.pack_int32(num);
        } else if (num >= -9223372036854776e3 && num <= 9223372036854776e3) {
          this.bufferBuilder.append(211);
          this.pack_int64(num);
        } else if (num >= 0 && num <= 18446744073709552e3) {
          this.bufferBuilder.append(207);
          this.pack_uint64(num);
        } else {
          throw new Error("Invalid integer");
        }
      };
      Packer.prototype.pack_double = function(num) {
        var sign2 = 0;
        if (num < 0) {
          sign2 = 1;
          num = -num;
        }
        var exp = Math.floor(Math.log(num) / Math.LN2);
        var frac0 = num / Math.pow(2, exp) - 1;
        var frac1 = Math.floor(frac0 * Math.pow(2, 52));
        var b32 = Math.pow(2, 32);
        var h32 = sign2 << 31 | exp + 1023 << 20 | frac1 / b32 & 1048575;
        var l32 = frac1 % b32;
        this.bufferBuilder.append(203);
        this.pack_int32(h32);
        this.pack_int32(l32);
      };
      Packer.prototype.pack_object = function(obj) {
        var keys4 = Object.keys(obj);
        var length = keys4.length;
        if (length <= 15) {
          this.pack_uint8(128 + length);
        } else if (length <= 65535) {
          this.bufferBuilder.append(222);
          this.pack_uint16(length);
        } else if (length <= 4294967295) {
          this.bufferBuilder.append(223);
          this.pack_uint32(length);
        } else {
          throw new Error("Invalid length");
        }
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            this.pack(prop);
            this.pack(obj[prop]);
          }
        }
      };
      Packer.prototype.pack_uint8 = function(num) {
        this.bufferBuilder.append(num);
      };
      Packer.prototype.pack_uint16 = function(num) {
        this.bufferBuilder.append(num >> 8);
        this.bufferBuilder.append(num & 255);
      };
      Packer.prototype.pack_uint32 = function(num) {
        var n = num & 4294967295;
        this.bufferBuilder.append((n & 4278190080) >>> 24);
        this.bufferBuilder.append((n & 16711680) >>> 16);
        this.bufferBuilder.append((n & 65280) >>> 8);
        this.bufferBuilder.append(n & 255);
      };
      Packer.prototype.pack_uint64 = function(num) {
        var high = num / Math.pow(2, 32);
        var low = num % Math.pow(2, 32);
        this.bufferBuilder.append((high & 4278190080) >>> 24);
        this.bufferBuilder.append((high & 16711680) >>> 16);
        this.bufferBuilder.append((high & 65280) >>> 8);
        this.bufferBuilder.append(high & 255);
        this.bufferBuilder.append((low & 4278190080) >>> 24);
        this.bufferBuilder.append((low & 16711680) >>> 16);
        this.bufferBuilder.append((low & 65280) >>> 8);
        this.bufferBuilder.append(low & 255);
      };
      Packer.prototype.pack_int8 = function(num) {
        this.bufferBuilder.append(num & 255);
      };
      Packer.prototype.pack_int16 = function(num) {
        this.bufferBuilder.append((num & 65280) >> 8);
        this.bufferBuilder.append(num & 255);
      };
      Packer.prototype.pack_int32 = function(num) {
        this.bufferBuilder.append(num >>> 24 & 255);
        this.bufferBuilder.append((num & 16711680) >>> 16);
        this.bufferBuilder.append((num & 65280) >>> 8);
        this.bufferBuilder.append(num & 255);
      };
      Packer.prototype.pack_int64 = function(num) {
        var high = Math.floor(num / Math.pow(2, 32));
        var low = num % Math.pow(2, 32);
        this.bufferBuilder.append((high & 4278190080) >>> 24);
        this.bufferBuilder.append((high & 16711680) >>> 16);
        this.bufferBuilder.append((high & 65280) >>> 8);
        this.bufferBuilder.append(high & 255);
        this.bufferBuilder.append((low & 4278190080) >>> 24);
        this.bufferBuilder.append((low & 16711680) >>> 16);
        this.bufferBuilder.append((low & 65280) >>> 8);
        this.bufferBuilder.append(low & 255);
      };
      function _utf8Replace(m) {
        var code = m.charCodeAt(0);
        if (code <= 2047)
          return "00";
        if (code <= 65535)
          return "000";
        if (code <= 2097151)
          return "0000";
        if (code <= 67108863)
          return "00000";
        return "000000";
      }
      function utf8Length(str) {
        if (str.length > 600) {
          return new Blob([str]).size;
        } else {
          return str.replace(/[^\u0000-\u007F]/g, _utf8Replace).length;
        }
      }
    }
  });

  // node_modules/sdp/sdp.js
  var require_sdp = __commonJS({
    "node_modules/sdp/sdp.js"(exports, module) {
      "use strict";
      var SDPUtils2 = {};
      SDPUtils2.generateIdentifier = function() {
        return Math.random().toString(36).substr(2, 10);
      };
      SDPUtils2.localCName = SDPUtils2.generateIdentifier();
      SDPUtils2.splitLines = function(blob) {
        return blob.trim().split("\n").map(function(line) {
          return line.trim();
        });
      };
      SDPUtils2.splitSections = function(blob) {
        var parts = blob.split("\nm=");
        return parts.map(function(part, index) {
          return (index > 0 ? "m=" + part : part).trim() + "\r\n";
        });
      };
      SDPUtils2.getDescription = function(blob) {
        var sections = SDPUtils2.splitSections(blob);
        return sections && sections[0];
      };
      SDPUtils2.getMediaSections = function(blob) {
        var sections = SDPUtils2.splitSections(blob);
        sections.shift();
        return sections;
      };
      SDPUtils2.matchPrefix = function(blob, prefix) {
        return SDPUtils2.splitLines(blob).filter(function(line) {
          return line.indexOf(prefix) === 0;
        });
      };
      SDPUtils2.parseCandidate = function(line) {
        var parts;
        if (line.indexOf("a=candidate:") === 0) {
          parts = line.substring(12).split(" ");
        } else {
          parts = line.substring(10).split(" ");
        }
        var candidate = {
          foundation: parts[0],
          component: parseInt(parts[1], 10),
          protocol: parts[2].toLowerCase(),
          priority: parseInt(parts[3], 10),
          ip: parts[4],
          address: parts[4],
          port: parseInt(parts[5], 10),
          type: parts[7]
        };
        for (var i = 8; i < parts.length; i += 2) {
          switch (parts[i]) {
            case "raddr":
              candidate.relatedAddress = parts[i + 1];
              break;
            case "rport":
              candidate.relatedPort = parseInt(parts[i + 1], 10);
              break;
            case "tcptype":
              candidate.tcpType = parts[i + 1];
              break;
            case "ufrag":
              candidate.ufrag = parts[i + 1];
              candidate.usernameFragment = parts[i + 1];
              break;
            default:
              candidate[parts[i]] = parts[i + 1];
              break;
          }
        }
        return candidate;
      };
      SDPUtils2.writeCandidate = function(candidate) {
        var sdp = [];
        sdp.push(candidate.foundation);
        sdp.push(candidate.component);
        sdp.push(candidate.protocol.toUpperCase());
        sdp.push(candidate.priority);
        sdp.push(candidate.address || candidate.ip);
        sdp.push(candidate.port);
        var type3 = candidate.type;
        sdp.push("typ");
        sdp.push(type3);
        if (type3 !== "host" && candidate.relatedAddress && candidate.relatedPort) {
          sdp.push("raddr");
          sdp.push(candidate.relatedAddress);
          sdp.push("rport");
          sdp.push(candidate.relatedPort);
        }
        if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
          sdp.push("tcptype");
          sdp.push(candidate.tcpType);
        }
        if (candidate.usernameFragment || candidate.ufrag) {
          sdp.push("ufrag");
          sdp.push(candidate.usernameFragment || candidate.ufrag);
        }
        return "candidate:" + sdp.join(" ");
      };
      SDPUtils2.parseIceOptions = function(line) {
        return line.substr(14).split(" ");
      };
      SDPUtils2.parseRtpMap = function(line) {
        var parts = line.substr(9).split(" ");
        var parsed = {
          payloadType: parseInt(parts.shift(), 10)
        };
        parts = parts[0].split("/");
        parsed.name = parts[0];
        parsed.clockRate = parseInt(parts[1], 10);
        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
        parsed.numChannels = parsed.channels;
        return parsed;
      };
      SDPUtils2.writeRtpMap = function(codec) {
        var pt = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt = codec.preferredPayloadType;
        }
        var channels = codec.channels || codec.numChannels || 1;
        return "a=rtpmap:" + pt + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
      };
      SDPUtils2.parseExtmap = function(line) {
        var parts = line.substr(9).split(" ");
        return {
          id: parseInt(parts[0], 10),
          direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
          uri: parts[1]
        };
      };
      SDPUtils2.writeExtmap = function(headerExtension) {
        return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + "\r\n";
      };
      SDPUtils2.parseFmtp = function(line) {
        var parsed = {};
        var kv;
        var parts = line.substr(line.indexOf(" ") + 1).split(";");
        for (var j = 0; j < parts.length; j++) {
          kv = parts[j].trim().split("=");
          parsed[kv[0].trim()] = kv[1];
        }
        return parsed;
      };
      SDPUtils2.writeFmtp = function(codec) {
        var line = "";
        var pt = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt = codec.preferredPayloadType;
        }
        if (codec.parameters && Object.keys(codec.parameters).length) {
          var params2 = [];
          Object.keys(codec.parameters).forEach(function(param) {
            if (codec.parameters[param]) {
              params2.push(param + "=" + codec.parameters[param]);
            } else {
              params2.push(param);
            }
          });
          line += "a=fmtp:" + pt + " " + params2.join(";") + "\r\n";
        }
        return line;
      };
      SDPUtils2.parseRtcpFb = function(line) {
        var parts = line.substr(line.indexOf(" ") + 1).split(" ");
        return {
          type: parts.shift(),
          parameter: parts.join(" ")
        };
      };
      SDPUtils2.writeRtcpFb = function(codec) {
        var lines = "";
        var pt = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt = codec.preferredPayloadType;
        }
        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
          codec.rtcpFeedback.forEach(function(fb) {
            lines += "a=rtcp-fb:" + pt + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
          });
        }
        return lines;
      };
      SDPUtils2.parseSsrcMedia = function(line) {
        var sp = line.indexOf(" ");
        var parts = {
          ssrc: parseInt(line.substr(7, sp - 7), 10)
        };
        var colon = line.indexOf(":", sp);
        if (colon > -1) {
          parts.attribute = line.substr(sp + 1, colon - sp - 1);
          parts.value = line.substr(colon + 1);
        } else {
          parts.attribute = line.substr(sp + 1);
        }
        return parts;
      };
      SDPUtils2.parseSsrcGroup = function(line) {
        var parts = line.substr(13).split(" ");
        return {
          semantics: parts.shift(),
          ssrcs: parts.map(function(ssrc) {
            return parseInt(ssrc, 10);
          })
        };
      };
      SDPUtils2.getMid = function(mediaSection) {
        var mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
        if (mid) {
          return mid.substr(6);
        }
      };
      SDPUtils2.parseFingerprint = function(line) {
        var parts = line.substr(14).split(" ");
        return {
          algorithm: parts[0].toLowerCase(),
          value: parts[1]
        };
      };
      SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
        var lines = SDPUtils2.matchPrefix(
          mediaSection + sessionpart,
          "a=fingerprint:"
        );
        return {
          role: "auto",
          fingerprints: lines.map(SDPUtils2.parseFingerprint)
        };
      };
      SDPUtils2.writeDtlsParameters = function(params2, setupType) {
        var sdp = "a=setup:" + setupType + "\r\n";
        params2.fingerprints.forEach(function(fp) {
          sdp += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
        });
        return sdp;
      };
      SDPUtils2.parseCryptoLine = function(line) {
        var parts = line.substr(9).split(" ");
        return {
          tag: parseInt(parts[0], 10),
          cryptoSuite: parts[1],
          keyParams: parts[2],
          sessionParams: parts.slice(3)
        };
      };
      SDPUtils2.writeCryptoLine = function(parameters) {
        return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
      };
      SDPUtils2.parseCryptoKeyParams = function(keyParams) {
        if (keyParams.indexOf("inline:") !== 0) {
          return null;
        }
        var parts = keyParams.substr(7).split("|");
        return {
          keyMethod: "inline",
          keySalt: parts[0],
          lifeTime: parts[1],
          mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
          mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
        };
      };
      SDPUtils2.writeCryptoKeyParams = function(keyParams) {
        return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
      };
      SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
        var lines = SDPUtils2.matchPrefix(
          mediaSection + sessionpart,
          "a=crypto:"
        );
        return lines.map(SDPUtils2.parseCryptoLine);
      };
      SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
        var ufrag = SDPUtils2.matchPrefix(
          mediaSection + sessionpart,
          "a=ice-ufrag:"
        )[0];
        var pwd = SDPUtils2.matchPrefix(
          mediaSection + sessionpart,
          "a=ice-pwd:"
        )[0];
        if (!(ufrag && pwd)) {
          return null;
        }
        return {
          usernameFragment: ufrag.substr(12),
          password: pwd.substr(10)
        };
      };
      SDPUtils2.writeIceParameters = function(params2) {
        return "a=ice-ufrag:" + params2.usernameFragment + "\r\na=ice-pwd:" + params2.password + "\r\n";
      };
      SDPUtils2.parseRtpParameters = function(mediaSection) {
        var description = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: [],
          rtcp: []
        };
        var lines = SDPUtils2.splitLines(mediaSection);
        var mline = lines[0].split(" ");
        for (var i = 3; i < mline.length; i++) {
          var pt = mline[i];
          var rtpmapline = SDPUtils2.matchPrefix(
            mediaSection,
            "a=rtpmap:" + pt + " "
          )[0];
          if (rtpmapline) {
            var codec = SDPUtils2.parseRtpMap(rtpmapline);
            var fmtps = SDPUtils2.matchPrefix(
              mediaSection,
              "a=fmtp:" + pt + " "
            );
            codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
            codec.rtcpFeedback = SDPUtils2.matchPrefix(
              mediaSection,
              "a=rtcp-fb:" + pt + " "
            ).map(SDPUtils2.parseRtcpFb);
            description.codecs.push(codec);
            switch (codec.name.toUpperCase()) {
              case "RED":
              case "ULPFEC":
                description.fecMechanisms.push(codec.name.toUpperCase());
                break;
              default:
                break;
            }
          }
        }
        SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach(function(line) {
          description.headerExtensions.push(SDPUtils2.parseExtmap(line));
        });
        return description;
      };
      SDPUtils2.writeRtpDescription = function(kind, caps) {
        var sdp = "";
        sdp += "m=" + kind + " ";
        sdp += caps.codecs.length > 0 ? "9" : "0";
        sdp += " UDP/TLS/RTP/SAVPF ";
        sdp += caps.codecs.map(function(codec) {
          if (codec.preferredPayloadType !== void 0) {
            return codec.preferredPayloadType;
          }
          return codec.payloadType;
        }).join(" ") + "\r\n";
        sdp += "c=IN IP4 0.0.0.0\r\n";
        sdp += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
        caps.codecs.forEach(function(codec) {
          sdp += SDPUtils2.writeRtpMap(codec);
          sdp += SDPUtils2.writeFmtp(codec);
          sdp += SDPUtils2.writeRtcpFb(codec);
        });
        var maxptime = 0;
        caps.codecs.forEach(function(codec) {
          if (codec.maxptime > maxptime) {
            maxptime = codec.maxptime;
          }
        });
        if (maxptime > 0) {
          sdp += "a=maxptime:" + maxptime + "\r\n";
        }
        sdp += "a=rtcp-mux\r\n";
        if (caps.headerExtensions) {
          caps.headerExtensions.forEach(function(extension) {
            sdp += SDPUtils2.writeExtmap(extension);
          });
        }
        return sdp;
      };
      SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
        var encodingParameters = [];
        var description = SDPUtils2.parseRtpParameters(mediaSection);
        var hasRed = description.fecMechanisms.indexOf("RED") !== -1;
        var hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
        var ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map(function(line) {
          return SDPUtils2.parseSsrcMedia(line);
        }).filter(function(parts) {
          return parts.attribute === "cname";
        });
        var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
        var secondarySsrc;
        var flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map(function(line) {
          var parts = line.substr(17).split(" ");
          return parts.map(function(part) {
            return parseInt(part, 10);
          });
        });
        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
          secondarySsrc = flows[0][1];
        }
        description.codecs.forEach(function(codec) {
          if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
            var encParam = {
              ssrc: primarySsrc,
              codecPayloadType: parseInt(codec.parameters.apt, 10)
            };
            if (primarySsrc && secondarySsrc) {
              encParam.rtx = { ssrc: secondarySsrc };
            }
            encodingParameters.push(encParam);
            if (hasRed) {
              encParam = JSON.parse(JSON.stringify(encParam));
              encParam.fec = {
                ssrc: primarySsrc,
                mechanism: hasUlpfec ? "red+ulpfec" : "red"
              };
              encodingParameters.push(encParam);
            }
          }
        });
        if (encodingParameters.length === 0 && primarySsrc) {
          encodingParameters.push({
            ssrc: primarySsrc
          });
        }
        var bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
        if (bandwidth.length) {
          if (bandwidth[0].indexOf("b=TIAS:") === 0) {
            bandwidth = parseInt(bandwidth[0].substr(7), 10);
          } else if (bandwidth[0].indexOf("b=AS:") === 0) {
            bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
          } else {
            bandwidth = void 0;
          }
          encodingParameters.forEach(function(params2) {
            params2.maxBitrate = bandwidth;
          });
        }
        return encodingParameters;
      };
      SDPUtils2.parseRtcpParameters = function(mediaSection) {
        var rtcpParameters = {};
        var remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map(function(line) {
          return SDPUtils2.parseSsrcMedia(line);
        }).filter(function(obj) {
          return obj.attribute === "cname";
        })[0];
        if (remoteSsrc) {
          rtcpParameters.cname = remoteSsrc.value;
          rtcpParameters.ssrc = remoteSsrc.ssrc;
        }
        var rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
        rtcpParameters.reducedSize = rsize.length > 0;
        rtcpParameters.compound = rsize.length === 0;
        var mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
        rtcpParameters.mux = mux.length > 0;
        return rtcpParameters;
      };
      SDPUtils2.parseMsid = function(mediaSection) {
        var parts;
        var spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
        if (spec.length === 1) {
          parts = spec[0].substr(7).split(" ");
          return { stream: parts[0], track: parts[1] };
        }
        var planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map(function(line) {
          return SDPUtils2.parseSsrcMedia(line);
        }).filter(function(msidParts) {
          return msidParts.attribute === "msid";
        });
        if (planB.length > 0) {
          parts = planB[0].value.split(" ");
          return { stream: parts[0], track: parts[1] };
        }
      };
      SDPUtils2.parseSctpDescription = function(mediaSection) {
        var mline = SDPUtils2.parseMLine(mediaSection);
        var maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
        var maxMessageSize;
        if (maxSizeLine.length > 0) {
          maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
        }
        if (isNaN(maxMessageSize)) {
          maxMessageSize = 65536;
        }
        var sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
        if (sctpPort.length > 0) {
          return {
            port: parseInt(sctpPort[0].substr(12), 10),
            protocol: mline.fmt,
            maxMessageSize
          };
        }
        var sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
        if (sctpMapLines.length > 0) {
          var parts = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:")[0].substr(10).split(" ");
          return {
            port: parseInt(parts[0], 10),
            protocol: parts[1],
            maxMessageSize
          };
        }
      };
      SDPUtils2.writeSctpDescription = function(media, sctp) {
        var output = [];
        if (media.protocol !== "DTLS/SCTP") {
          output = [
            "m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n",
            "c=IN IP4 0.0.0.0\r\n",
            "a=sctp-port:" + sctp.port + "\r\n"
          ];
        } else {
          output = [
            "m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n",
            "c=IN IP4 0.0.0.0\r\n",
            "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"
          ];
        }
        if (sctp.maxMessageSize !== void 0) {
          output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
        }
        return output.join("");
      };
      SDPUtils2.generateSessionId = function() {
        return Math.random().toString().substr(2, 21);
      };
      SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
        var sessionId;
        var version = sessVer !== void 0 ? sessVer : 2;
        if (sessId) {
          sessionId = sessId;
        } else {
          sessionId = SDPUtils2.generateSessionId();
        }
        var user = sessUser || "thisisadapterortc";
        return "v=0\r\no=" + user + " " + sessionId + " " + version + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
      };
      SDPUtils2.writeMediaSection = function(transceiver, caps, type3, stream) {
        var sdp = SDPUtils2.writeRtpDescription(transceiver.kind, caps);
        sdp += SDPUtils2.writeIceParameters(
          transceiver.iceGatherer.getLocalParameters()
        );
        sdp += SDPUtils2.writeDtlsParameters(
          transceiver.dtlsTransport.getLocalParameters(),
          type3 === "offer" ? "actpass" : "active"
        );
        sdp += "a=mid:" + transceiver.mid + "\r\n";
        if (transceiver.direction) {
          sdp += "a=" + transceiver.direction + "\r\n";
        } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
          sdp += "a=sendrecv\r\n";
        } else if (transceiver.rtpSender) {
          sdp += "a=sendonly\r\n";
        } else if (transceiver.rtpReceiver) {
          sdp += "a=recvonly\r\n";
        } else {
          sdp += "a=inactive\r\n";
        }
        if (transceiver.rtpSender) {
          var msid = "msid:" + stream.id + " " + transceiver.rtpSender.track.id + "\r\n";
          sdp += "a=" + msid;
          sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].ssrc + " " + msid;
          if (transceiver.sendEncodingParameters[0].rtx) {
            sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].rtx.ssrc + " " + msid;
            sdp += "a=ssrc-group:FID " + transceiver.sendEncodingParameters[0].ssrc + " " + transceiver.sendEncodingParameters[0].rtx.ssrc + "\r\n";
          }
        }
        sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].ssrc + " cname:" + SDPUtils2.localCName + "\r\n";
        if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
          sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].rtx.ssrc + " cname:" + SDPUtils2.localCName + "\r\n";
        }
        return sdp;
      };
      SDPUtils2.getDirection = function(mediaSection, sessionpart) {
        var lines = SDPUtils2.splitLines(mediaSection);
        for (var i = 0; i < lines.length; i++) {
          switch (lines[i]) {
            case "a=sendrecv":
            case "a=sendonly":
            case "a=recvonly":
            case "a=inactive":
              return lines[i].substr(2);
            default:
          }
        }
        if (sessionpart) {
          return SDPUtils2.getDirection(sessionpart);
        }
        return "sendrecv";
      };
      SDPUtils2.getKind = function(mediaSection) {
        var lines = SDPUtils2.splitLines(mediaSection);
        var mline = lines[0].split(" ");
        return mline[0].substr(2);
      };
      SDPUtils2.isRejected = function(mediaSection) {
        return mediaSection.split(" ", 2)[1] === "0";
      };
      SDPUtils2.parseMLine = function(mediaSection) {
        var lines = SDPUtils2.splitLines(mediaSection);
        var parts = lines[0].substr(2).split(" ");
        return {
          kind: parts[0],
          port: parseInt(parts[1], 10),
          protocol: parts[2],
          fmt: parts.slice(3).join(" ")
        };
      };
      SDPUtils2.parseOLine = function(mediaSection) {
        var line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
        var parts = line.substr(2).split(" ");
        return {
          username: parts[0],
          sessionId: parts[1],
          sessionVersion: parseInt(parts[2], 10),
          netType: parts[3],
          addressType: parts[4],
          address: parts[5]
        };
      };
      SDPUtils2.isValidSDP = function(blob) {
        if (typeof blob !== "string" || blob.length === 0) {
          return false;
        }
        var lines = SDPUtils2.splitLines(blob);
        for (var i = 0; i < lines.length; i++) {
          if (lines[i].length < 2 || lines[i].charAt(1) !== "=") {
            return false;
          }
        }
        return true;
      };
      if (typeof module === "object") {
        module.exports = SDPUtils2;
      }
    }
  });

  // node_modules/rtcpeerconnection-shim/rtcpeerconnection.js
  var require_rtcpeerconnection = __commonJS({
    "node_modules/rtcpeerconnection-shim/rtcpeerconnection.js"(exports, module) {
      "use strict";
      var SDPUtils2 = require_sdp();
      function fixStatsType(stat) {
        return {
          inboundrtp: "inbound-rtp",
          outboundrtp: "outbound-rtp",
          candidatepair: "candidate-pair",
          localcandidate: "local-candidate",
          remotecandidate: "remote-candidate"
        }[stat.type] || stat.type;
      }
      function writeMediaSection(transceiver, caps, type3, stream, dtlsRole) {
        var sdp = SDPUtils2.writeRtpDescription(transceiver.kind, caps);
        sdp += SDPUtils2.writeIceParameters(
          transceiver.iceGatherer.getLocalParameters()
        );
        sdp += SDPUtils2.writeDtlsParameters(
          transceiver.dtlsTransport.getLocalParameters(),
          type3 === "offer" ? "actpass" : dtlsRole || "active"
        );
        sdp += "a=mid:" + transceiver.mid + "\r\n";
        if (transceiver.rtpSender && transceiver.rtpReceiver) {
          sdp += "a=sendrecv\r\n";
        } else if (transceiver.rtpSender) {
          sdp += "a=sendonly\r\n";
        } else if (transceiver.rtpReceiver) {
          sdp += "a=recvonly\r\n";
        } else {
          sdp += "a=inactive\r\n";
        }
        if (transceiver.rtpSender) {
          var trackId = transceiver.rtpSender._initialTrackId || transceiver.rtpSender.track.id;
          transceiver.rtpSender._initialTrackId = trackId;
          var msid = "msid:" + (stream ? stream.id : "-") + " " + trackId + "\r\n";
          sdp += "a=" + msid;
          sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].ssrc + " " + msid;
          if (transceiver.sendEncodingParameters[0].rtx) {
            sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].rtx.ssrc + " " + msid;
            sdp += "a=ssrc-group:FID " + transceiver.sendEncodingParameters[0].ssrc + " " + transceiver.sendEncodingParameters[0].rtx.ssrc + "\r\n";
          }
        }
        sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].ssrc + " cname:" + SDPUtils2.localCName + "\r\n";
        if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
          sdp += "a=ssrc:" + transceiver.sendEncodingParameters[0].rtx.ssrc + " cname:" + SDPUtils2.localCName + "\r\n";
        }
        return sdp;
      }
      function filterIceServers2(iceServers, edgeVersion) {
        var hasTurn = false;
        iceServers = JSON.parse(JSON.stringify(iceServers));
        return iceServers.filter(function(server) {
          if (server && (server.urls || server.url)) {
            var urls = server.urls || server.url;
            if (server.url && !server.urls) {
              console.warn("RTCIceServer.url is deprecated! Use urls instead.");
            }
            var isString = typeof urls === "string";
            if (isString) {
              urls = [urls];
            }
            urls = urls.filter(function(url) {
              var validTurn = url.indexOf("turn:") === 0 && url.indexOf("transport=udp") !== -1 && url.indexOf("turn:[") === -1 && !hasTurn;
              if (validTurn) {
                hasTurn = true;
                return true;
              }
              return url.indexOf("stun:") === 0 && edgeVersion >= 14393 && url.indexOf("?transport=udp") === -1;
            });
            delete server.url;
            server.urls = isString ? urls[0] : urls;
            return !!urls.length;
          }
        });
      }
      function getCommonCapabilities(localCapabilities, remoteCapabilities) {
        var commonCapabilities = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: []
        };
        var findCodecByPayloadType = function(pt, codecs) {
          pt = parseInt(pt, 10);
          for (var i = 0; i < codecs.length; i++) {
            if (codecs[i].payloadType === pt || codecs[i].preferredPayloadType === pt) {
              return codecs[i];
            }
          }
        };
        var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
          var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
          var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
          return lCodec && rCodec && lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
        };
        localCapabilities.codecs.forEach(function(lCodec) {
          for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
            var rCodec = remoteCapabilities.codecs[i];
            if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() && lCodec.clockRate === rCodec.clockRate) {
              if (lCodec.name.toLowerCase() === "rtx" && lCodec.parameters && rCodec.parameters.apt) {
                if (!rtxCapabilityMatches(
                  lCodec,
                  rCodec,
                  localCapabilities.codecs,
                  remoteCapabilities.codecs
                )) {
                  continue;
                }
              }
              rCodec = JSON.parse(JSON.stringify(rCodec));
              rCodec.numChannels = Math.min(
                lCodec.numChannels,
                rCodec.numChannels
              );
              commonCapabilities.codecs.push(rCodec);
              rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
                for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
                  if (lCodec.rtcpFeedback[j].type === fb.type && lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                    return true;
                  }
                }
                return false;
              });
              break;
            }
          }
        });
        localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
          for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {
            var rHeaderExtension = remoteCapabilities.headerExtensions[i];
            if (lHeaderExtension.uri === rHeaderExtension.uri) {
              commonCapabilities.headerExtensions.push(rHeaderExtension);
              break;
            }
          }
        });
        return commonCapabilities;
      }
      function isActionAllowedInSignalingState(action, type3, signalingState) {
        return {
          offer: {
            setLocalDescription: ["stable", "have-local-offer"],
            setRemoteDescription: ["stable", "have-remote-offer"]
          },
          answer: {
            setLocalDescription: ["have-remote-offer", "have-local-pranswer"],
            setRemoteDescription: ["have-local-offer", "have-remote-pranswer"]
          }
        }[type3][action].indexOf(signalingState) !== -1;
      }
      function maybeAddCandidate(iceTransport, candidate) {
        var alreadyAdded = iceTransport.getRemoteCandidates().find(function(remoteCandidate) {
          return candidate.foundation === remoteCandidate.foundation && candidate.ip === remoteCandidate.ip && candidate.port === remoteCandidate.port && candidate.priority === remoteCandidate.priority && candidate.protocol === remoteCandidate.protocol && candidate.type === remoteCandidate.type;
        });
        if (!alreadyAdded) {
          iceTransport.addRemoteCandidate(candidate);
        }
        return !alreadyAdded;
      }
      function makeError(name, description) {
        var e = new Error(description);
        e.name = name;
        e.code = {
          NotSupportedError: 9,
          InvalidStateError: 11,
          InvalidAccessError: 15,
          TypeError: void 0,
          OperationError: void 0
        }[name];
        return e;
      }
      module.exports = function(window2, edgeVersion) {
        function addTrackToStreamAndFireEvent(track, stream) {
          stream.addTrack(track);
          stream.dispatchEvent(new window2.MediaStreamTrackEvent(
            "addtrack",
            { track }
          ));
        }
        function removeTrackFromStreamAndFireEvent(track, stream) {
          stream.removeTrack(track);
          stream.dispatchEvent(new window2.MediaStreamTrackEvent(
            "removetrack",
            { track }
          ));
        }
        function fireAddTrack(pc, track, receiver, streams) {
          var trackEvent = new Event("track");
          trackEvent.track = track;
          trackEvent.receiver = receiver;
          trackEvent.transceiver = { receiver };
          trackEvent.streams = streams;
          window2.setTimeout(function() {
            pc._dispatchEvent("track", trackEvent);
          });
        }
        var RTCPeerConnection2 = function(config) {
          var pc = this;
          var _eventTarget = document.createDocumentFragment();
          ["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function(method) {
            pc[method] = _eventTarget[method].bind(_eventTarget);
          });
          this.canTrickleIceCandidates = null;
          this.needNegotiation = false;
          this.localStreams = [];
          this.remoteStreams = [];
          this._localDescription = null;
          this._remoteDescription = null;
          this.signalingState = "stable";
          this.iceConnectionState = "new";
          this.connectionState = "new";
          this.iceGatheringState = "new";
          config = JSON.parse(JSON.stringify(config || {}));
          this.usingBundle = config.bundlePolicy === "max-bundle";
          if (config.rtcpMuxPolicy === "negotiate") {
            throw makeError(
              "NotSupportedError",
              "rtcpMuxPolicy 'negotiate' is not supported"
            );
          } else if (!config.rtcpMuxPolicy) {
            config.rtcpMuxPolicy = "require";
          }
          switch (config.iceTransportPolicy) {
            case "all":
            case "relay":
              break;
            default:
              config.iceTransportPolicy = "all";
              break;
          }
          switch (config.bundlePolicy) {
            case "balanced":
            case "max-compat":
            case "max-bundle":
              break;
            default:
              config.bundlePolicy = "balanced";
              break;
          }
          config.iceServers = filterIceServers2(config.iceServers || [], edgeVersion);
          this._iceGatherers = [];
          if (config.iceCandidatePoolSize) {
            for (var i = config.iceCandidatePoolSize; i > 0; i--) {
              this._iceGatherers.push(new window2.RTCIceGatherer({
                iceServers: config.iceServers,
                gatherPolicy: config.iceTransportPolicy
              }));
            }
          } else {
            config.iceCandidatePoolSize = 0;
          }
          this._config = config;
          this.transceivers = [];
          this._sdpSessionId = SDPUtils2.generateSessionId();
          this._sdpSessionVersion = 0;
          this._dtlsRole = void 0;
          this._isClosed = false;
        };
        Object.defineProperty(RTCPeerConnection2.prototype, "localDescription", {
          configurable: true,
          get: function() {
            return this._localDescription;
          }
        });
        Object.defineProperty(RTCPeerConnection2.prototype, "remoteDescription", {
          configurable: true,
          get: function() {
            return this._remoteDescription;
          }
        });
        RTCPeerConnection2.prototype.onicecandidate = null;
        RTCPeerConnection2.prototype.onaddstream = null;
        RTCPeerConnection2.prototype.ontrack = null;
        RTCPeerConnection2.prototype.onremovestream = null;
        RTCPeerConnection2.prototype.onsignalingstatechange = null;
        RTCPeerConnection2.prototype.oniceconnectionstatechange = null;
        RTCPeerConnection2.prototype.onconnectionstatechange = null;
        RTCPeerConnection2.prototype.onicegatheringstatechange = null;
        RTCPeerConnection2.prototype.onnegotiationneeded = null;
        RTCPeerConnection2.prototype.ondatachannel = null;
        RTCPeerConnection2.prototype._dispatchEvent = function(name, event) {
          if (this._isClosed) {
            return;
          }
          this.dispatchEvent(event);
          if (typeof this["on" + name] === "function") {
            this["on" + name](event);
          }
        };
        RTCPeerConnection2.prototype._emitGatheringStateChange = function() {
          var event = new Event("icegatheringstatechange");
          this._dispatchEvent("icegatheringstatechange", event);
        };
        RTCPeerConnection2.prototype.getConfiguration = function() {
          return this._config;
        };
        RTCPeerConnection2.prototype.getLocalStreams = function() {
          return this.localStreams;
        };
        RTCPeerConnection2.prototype.getRemoteStreams = function() {
          return this.remoteStreams;
        };
        RTCPeerConnection2.prototype._createTransceiver = function(kind, doNotAdd) {
          var hasBundleTransport = this.transceivers.length > 0;
          var transceiver = {
            track: null,
            iceGatherer: null,
            iceTransport: null,
            dtlsTransport: null,
            localCapabilities: null,
            remoteCapabilities: null,
            rtpSender: null,
            rtpReceiver: null,
            kind,
            mid: null,
            sendEncodingParameters: null,
            recvEncodingParameters: null,
            stream: null,
            associatedRemoteMediaStreams: [],
            wantReceive: true
          };
          if (this.usingBundle && hasBundleTransport) {
            transceiver.iceTransport = this.transceivers[0].iceTransport;
            transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
          } else {
            var transports = this._createIceAndDtlsTransports();
            transceiver.iceTransport = transports.iceTransport;
            transceiver.dtlsTransport = transports.dtlsTransport;
          }
          if (!doNotAdd) {
            this.transceivers.push(transceiver);
          }
          return transceiver;
        };
        RTCPeerConnection2.prototype.addTrack = function(track, stream) {
          if (this._isClosed) {
            throw makeError(
              "InvalidStateError",
              "Attempted to call addTrack on a closed peerconnection."
            );
          }
          var alreadyExists = this.transceivers.find(function(s) {
            return s.track === track;
          });
          if (alreadyExists) {
            throw makeError("InvalidAccessError", "Track already exists.");
          }
          var transceiver;
          for (var i = 0; i < this.transceivers.length; i++) {
            if (!this.transceivers[i].track && this.transceivers[i].kind === track.kind) {
              transceiver = this.transceivers[i];
            }
          }
          if (!transceiver) {
            transceiver = this._createTransceiver(track.kind);
          }
          this._maybeFireNegotiationNeeded();
          if (this.localStreams.indexOf(stream) === -1) {
            this.localStreams.push(stream);
          }
          transceiver.track = track;
          transceiver.stream = stream;
          transceiver.rtpSender = new window2.RTCRtpSender(
            track,
            transceiver.dtlsTransport
          );
          return transceiver.rtpSender;
        };
        RTCPeerConnection2.prototype.addStream = function(stream) {
          var pc = this;
          if (edgeVersion >= 15025) {
            stream.getTracks().forEach(function(track) {
              pc.addTrack(track, stream);
            });
          } else {
            var clonedStream = stream.clone();
            stream.getTracks().forEach(function(track, idx) {
              var clonedTrack = clonedStream.getTracks()[idx];
              track.addEventListener("enabled", function(event) {
                clonedTrack.enabled = event.enabled;
              });
            });
            clonedStream.getTracks().forEach(function(track) {
              pc.addTrack(track, clonedStream);
            });
          }
        };
        RTCPeerConnection2.prototype.removeTrack = function(sender) {
          if (this._isClosed) {
            throw makeError(
              "InvalidStateError",
              "Attempted to call removeTrack on a closed peerconnection."
            );
          }
          if (!(sender instanceof window2.RTCRtpSender)) {
            throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");
          }
          var transceiver = this.transceivers.find(function(t) {
            return t.rtpSender === sender;
          });
          if (!transceiver) {
            throw makeError(
              "InvalidAccessError",
              "Sender was not created by this connection."
            );
          }
          var stream = transceiver.stream;
          transceiver.rtpSender.stop();
          transceiver.rtpSender = null;
          transceiver.track = null;
          transceiver.stream = null;
          var localStreams = this.transceivers.map(function(t) {
            return t.stream;
          });
          if (localStreams.indexOf(stream) === -1 && this.localStreams.indexOf(stream) > -1) {
            this.localStreams.splice(this.localStreams.indexOf(stream), 1);
          }
          this._maybeFireNegotiationNeeded();
        };
        RTCPeerConnection2.prototype.removeStream = function(stream) {
          var pc = this;
          stream.getTracks().forEach(function(track) {
            var sender = pc.getSenders().find(function(s) {
              return s.track === track;
            });
            if (sender) {
              pc.removeTrack(sender);
            }
          });
        };
        RTCPeerConnection2.prototype.getSenders = function() {
          return this.transceivers.filter(function(transceiver) {
            return !!transceiver.rtpSender;
          }).map(function(transceiver) {
            return transceiver.rtpSender;
          });
        };
        RTCPeerConnection2.prototype.getReceivers = function() {
          return this.transceivers.filter(function(transceiver) {
            return !!transceiver.rtpReceiver;
          }).map(function(transceiver) {
            return transceiver.rtpReceiver;
          });
        };
        RTCPeerConnection2.prototype._createIceGatherer = function(sdpMLineIndex, usingBundle) {
          var pc = this;
          if (usingBundle && sdpMLineIndex > 0) {
            return this.transceivers[0].iceGatherer;
          } else if (this._iceGatherers.length) {
            return this._iceGatherers.shift();
          }
          var iceGatherer = new window2.RTCIceGatherer({
            iceServers: this._config.iceServers,
            gatherPolicy: this._config.iceTransportPolicy
          });
          Object.defineProperty(
            iceGatherer,
            "state",
            { value: "new", writable: true }
          );
          this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
          this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
            var end = !event.candidate || Object.keys(event.candidate).length === 0;
            iceGatherer.state = end ? "completed" : "gathering";
            if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
              pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
            }
          };
          iceGatherer.addEventListener(
            "localcandidate",
            this.transceivers[sdpMLineIndex].bufferCandidates
          );
          return iceGatherer;
        };
        RTCPeerConnection2.prototype._gather = function(mid, sdpMLineIndex) {
          var pc = this;
          var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
          if (iceGatherer.onlocalcandidate) {
            return;
          }
          var bufferedCandidateEvents = this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
          this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
          iceGatherer.removeEventListener(
            "localcandidate",
            this.transceivers[sdpMLineIndex].bufferCandidates
          );
          iceGatherer.onlocalcandidate = function(evt) {
            if (pc.usingBundle && sdpMLineIndex > 0) {
              return;
            }
            var event = new Event("icecandidate");
            event.candidate = { sdpMid: mid, sdpMLineIndex };
            var cand = evt.candidate;
            var end = !cand || Object.keys(cand).length === 0;
            if (end) {
              if (iceGatherer.state === "new" || iceGatherer.state === "gathering") {
                iceGatherer.state = "completed";
              }
            } else {
              if (iceGatherer.state === "new") {
                iceGatherer.state = "gathering";
              }
              cand.component = 1;
              cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;
              var serializedCandidate = SDPUtils2.writeCandidate(cand);
              event.candidate = Object.assign(
                event.candidate,
                SDPUtils2.parseCandidate(serializedCandidate)
              );
              event.candidate.candidate = serializedCandidate;
              event.candidate.toJSON = function() {
                return {
                  candidate: event.candidate.candidate,
                  sdpMid: event.candidate.sdpMid,
                  sdpMLineIndex: event.candidate.sdpMLineIndex,
                  usernameFragment: event.candidate.usernameFragment
                };
              };
            }
            var sections = SDPUtils2.getMediaSections(pc._localDescription.sdp);
            if (!end) {
              sections[event.candidate.sdpMLineIndex] += "a=" + event.candidate.candidate + "\r\n";
            } else {
              sections[event.candidate.sdpMLineIndex] += "a=end-of-candidates\r\n";
            }
            pc._localDescription.sdp = SDPUtils2.getDescription(pc._localDescription.sdp) + sections.join("");
            var complete = pc.transceivers.every(function(transceiver) {
              return transceiver.iceGatherer && transceiver.iceGatherer.state === "completed";
            });
            if (pc.iceGatheringState !== "gathering") {
              pc.iceGatheringState = "gathering";
              pc._emitGatheringStateChange();
            }
            if (!end) {
              pc._dispatchEvent("icecandidate", event);
            }
            if (complete) {
              pc._dispatchEvent("icecandidate", new Event("icecandidate"));
              pc.iceGatheringState = "complete";
              pc._emitGatheringStateChange();
            }
          };
          window2.setTimeout(function() {
            bufferedCandidateEvents.forEach(function(e) {
              iceGatherer.onlocalcandidate(e);
            });
          }, 0);
        };
        RTCPeerConnection2.prototype._createIceAndDtlsTransports = function() {
          var pc = this;
          var iceTransport = new window2.RTCIceTransport(null);
          iceTransport.onicestatechange = function() {
            pc._updateIceConnectionState();
            pc._updateConnectionState();
          };
          var dtlsTransport = new window2.RTCDtlsTransport(iceTransport);
          dtlsTransport.ondtlsstatechange = function() {
            pc._updateConnectionState();
          };
          dtlsTransport.onerror = function() {
            Object.defineProperty(
              dtlsTransport,
              "state",
              { value: "failed", writable: true }
            );
            pc._updateConnectionState();
          };
          return {
            iceTransport,
            dtlsTransport
          };
        };
        RTCPeerConnection2.prototype._disposeIceAndDtlsTransports = function(sdpMLineIndex) {
          var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
          if (iceGatherer) {
            delete iceGatherer.onlocalcandidate;
            delete this.transceivers[sdpMLineIndex].iceGatherer;
          }
          var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
          if (iceTransport) {
            delete iceTransport.onicestatechange;
            delete this.transceivers[sdpMLineIndex].iceTransport;
          }
          var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
          if (dtlsTransport) {
            delete dtlsTransport.ondtlsstatechange;
            delete dtlsTransport.onerror;
            delete this.transceivers[sdpMLineIndex].dtlsTransport;
          }
        };
        RTCPeerConnection2.prototype._transceive = function(transceiver, send, recv) {
          var params2 = getCommonCapabilities(
            transceiver.localCapabilities,
            transceiver.remoteCapabilities
          );
          if (send && transceiver.rtpSender) {
            params2.encodings = transceiver.sendEncodingParameters;
            params2.rtcp = {
              cname: SDPUtils2.localCName,
              compound: transceiver.rtcpParameters.compound
            };
            if (transceiver.recvEncodingParameters.length) {
              params2.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
            }
            transceiver.rtpSender.send(params2);
          }
          if (recv && transceiver.rtpReceiver && params2.codecs.length > 0) {
            if (transceiver.kind === "video" && transceiver.recvEncodingParameters && edgeVersion < 15019) {
              transceiver.recvEncodingParameters.forEach(function(p) {
                delete p.rtx;
              });
            }
            if (transceiver.recvEncodingParameters.length) {
              params2.encodings = transceiver.recvEncodingParameters;
            } else {
              params2.encodings = [{}];
            }
            params2.rtcp = {
              compound: transceiver.rtcpParameters.compound
            };
            if (transceiver.rtcpParameters.cname) {
              params2.rtcp.cname = transceiver.rtcpParameters.cname;
            }
            if (transceiver.sendEncodingParameters.length) {
              params2.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
            }
            transceiver.rtpReceiver.receive(params2);
          }
        };
        RTCPeerConnection2.prototype.setLocalDescription = function(description) {
          var pc = this;
          if (["offer", "answer"].indexOf(description.type) === -1) {
            return Promise.reject(makeError(
              "TypeError",
              'Unsupported type "' + description.type + '"'
            ));
          }
          if (!isActionAllowedInSignalingState(
            "setLocalDescription",
            description.type,
            pc.signalingState
          ) || pc._isClosed) {
            return Promise.reject(makeError(
              "InvalidStateError",
              "Can not set local " + description.type + " in state " + pc.signalingState
            ));
          }
          var sections;
          var sessionpart;
          if (description.type === "offer") {
            sections = SDPUtils2.splitSections(description.sdp);
            sessionpart = sections.shift();
            sections.forEach(function(mediaSection, sdpMLineIndex) {
              var caps = SDPUtils2.parseRtpParameters(mediaSection);
              pc.transceivers[sdpMLineIndex].localCapabilities = caps;
            });
            pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
              pc._gather(transceiver.mid, sdpMLineIndex);
            });
          } else if (description.type === "answer") {
            sections = SDPUtils2.splitSections(pc._remoteDescription.sdp);
            sessionpart = sections.shift();
            var isIceLite = SDPUtils2.matchPrefix(
              sessionpart,
              "a=ice-lite"
            ).length > 0;
            sections.forEach(function(mediaSection, sdpMLineIndex) {
              var transceiver = pc.transceivers[sdpMLineIndex];
              var iceGatherer = transceiver.iceGatherer;
              var iceTransport = transceiver.iceTransport;
              var dtlsTransport = transceiver.dtlsTransport;
              var localCapabilities = transceiver.localCapabilities;
              var remoteCapabilities = transceiver.remoteCapabilities;
              var rejected = SDPUtils2.isRejected(mediaSection) && SDPUtils2.matchPrefix(mediaSection, "a=bundle-only").length === 0;
              if (!rejected && !transceiver.rejected) {
                var remoteIceParameters = SDPUtils2.getIceParameters(
                  mediaSection,
                  sessionpart
                );
                var remoteDtlsParameters = SDPUtils2.getDtlsParameters(
                  mediaSection,
                  sessionpart
                );
                if (isIceLite) {
                  remoteDtlsParameters.role = "server";
                }
                if (!pc.usingBundle || sdpMLineIndex === 0) {
                  pc._gather(transceiver.mid, sdpMLineIndex);
                  if (iceTransport.state === "new") {
                    iceTransport.start(
                      iceGatherer,
                      remoteIceParameters,
                      isIceLite ? "controlling" : "controlled"
                    );
                  }
                  if (dtlsTransport.state === "new") {
                    dtlsTransport.start(remoteDtlsParameters);
                  }
                }
                var params2 = getCommonCapabilities(
                  localCapabilities,
                  remoteCapabilities
                );
                pc._transceive(
                  transceiver,
                  params2.codecs.length > 0,
                  false
                );
              }
            });
          }
          pc._localDescription = {
            type: description.type,
            sdp: description.sdp
          };
          if (description.type === "offer") {
            pc._updateSignalingState("have-local-offer");
          } else {
            pc._updateSignalingState("stable");
          }
          return Promise.resolve();
        };
        RTCPeerConnection2.prototype.setRemoteDescription = function(description) {
          var pc = this;
          if (["offer", "answer"].indexOf(description.type) === -1) {
            return Promise.reject(makeError(
              "TypeError",
              'Unsupported type "' + description.type + '"'
            ));
          }
          if (!isActionAllowedInSignalingState(
            "setRemoteDescription",
            description.type,
            pc.signalingState
          ) || pc._isClosed) {
            return Promise.reject(makeError(
              "InvalidStateError",
              "Can not set remote " + description.type + " in state " + pc.signalingState
            ));
          }
          var streams = {};
          pc.remoteStreams.forEach(function(stream) {
            streams[stream.id] = stream;
          });
          var receiverList = [];
          var sections = SDPUtils2.splitSections(description.sdp);
          var sessionpart = sections.shift();
          var isIceLite = SDPUtils2.matchPrefix(
            sessionpart,
            "a=ice-lite"
          ).length > 0;
          var usingBundle = SDPUtils2.matchPrefix(
            sessionpart,
            "a=group:BUNDLE "
          ).length > 0;
          pc.usingBundle = usingBundle;
          var iceOptions = SDPUtils2.matchPrefix(
            sessionpart,
            "a=ice-options:"
          )[0];
          if (iceOptions) {
            pc.canTrickleIceCandidates = iceOptions.substr(14).split(" ").indexOf("trickle") >= 0;
          } else {
            pc.canTrickleIceCandidates = false;
          }
          sections.forEach(function(mediaSection, sdpMLineIndex) {
            var lines = SDPUtils2.splitLines(mediaSection);
            var kind = SDPUtils2.getKind(mediaSection);
            var rejected = SDPUtils2.isRejected(mediaSection) && SDPUtils2.matchPrefix(mediaSection, "a=bundle-only").length === 0;
            var protocol = lines[0].substr(2).split(" ")[2];
            var direction = SDPUtils2.getDirection(mediaSection, sessionpart);
            var remoteMsid = SDPUtils2.parseMsid(mediaSection);
            var mid = SDPUtils2.getMid(mediaSection) || SDPUtils2.generateIdentifier();
            if (rejected || kind === "application" && (protocol === "DTLS/SCTP" || protocol === "UDP/DTLS/SCTP")) {
              pc.transceivers[sdpMLineIndex] = {
                mid,
                kind,
                protocol,
                rejected: true
              };
              return;
            }
            if (!rejected && pc.transceivers[sdpMLineIndex] && pc.transceivers[sdpMLineIndex].rejected) {
              pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
            }
            var transceiver;
            var iceGatherer;
            var iceTransport;
            var dtlsTransport;
            var rtpReceiver;
            var sendEncodingParameters;
            var recvEncodingParameters;
            var localCapabilities;
            var track;
            var remoteCapabilities = SDPUtils2.parseRtpParameters(mediaSection);
            var remoteIceParameters;
            var remoteDtlsParameters;
            if (!rejected) {
              remoteIceParameters = SDPUtils2.getIceParameters(
                mediaSection,
                sessionpart
              );
              remoteDtlsParameters = SDPUtils2.getDtlsParameters(
                mediaSection,
                sessionpart
              );
              remoteDtlsParameters.role = "client";
            }
            recvEncodingParameters = SDPUtils2.parseRtpEncodingParameters(mediaSection);
            var rtcpParameters = SDPUtils2.parseRtcpParameters(mediaSection);
            var isComplete = SDPUtils2.matchPrefix(
              mediaSection,
              "a=end-of-candidates",
              sessionpart
            ).length > 0;
            var cands = SDPUtils2.matchPrefix(mediaSection, "a=candidate:").map(function(cand) {
              return SDPUtils2.parseCandidate(cand);
            }).filter(function(cand) {
              return cand.component === 1;
            });
            if ((description.type === "offer" || description.type === "answer") && !rejected && usingBundle && sdpMLineIndex > 0 && pc.transceivers[sdpMLineIndex]) {
              pc._disposeIceAndDtlsTransports(sdpMLineIndex);
              pc.transceivers[sdpMLineIndex].iceGatherer = pc.transceivers[0].iceGatherer;
              pc.transceivers[sdpMLineIndex].iceTransport = pc.transceivers[0].iceTransport;
              pc.transceivers[sdpMLineIndex].dtlsTransport = pc.transceivers[0].dtlsTransport;
              if (pc.transceivers[sdpMLineIndex].rtpSender) {
                pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
                  pc.transceivers[0].dtlsTransport
                );
              }
              if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
                pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
                  pc.transceivers[0].dtlsTransport
                );
              }
            }
            if (description.type === "offer" && !rejected) {
              transceiver = pc.transceivers[sdpMLineIndex] || pc._createTransceiver(kind);
              transceiver.mid = mid;
              if (!transceiver.iceGatherer) {
                transceiver.iceGatherer = pc._createIceGatherer(
                  sdpMLineIndex,
                  usingBundle
                );
              }
              if (cands.length && transceiver.iceTransport.state === "new") {
                if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
                  transceiver.iceTransport.setRemoteCandidates(cands);
                } else {
                  cands.forEach(function(candidate) {
                    maybeAddCandidate(transceiver.iceTransport, candidate);
                  });
                }
              }
              localCapabilities = window2.RTCRtpReceiver.getCapabilities(kind);
              if (edgeVersion < 15019) {
                localCapabilities.codecs = localCapabilities.codecs.filter(
                  function(codec) {
                    return codec.name !== "rtx";
                  }
                );
              }
              sendEncodingParameters = transceiver.sendEncodingParameters || [{
                ssrc: (2 * sdpMLineIndex + 2) * 1001
              }];
              var isNewTrack = false;
              if (direction === "sendrecv" || direction === "sendonly") {
                isNewTrack = !transceiver.rtpReceiver;
                rtpReceiver = transceiver.rtpReceiver || new window2.RTCRtpReceiver(transceiver.dtlsTransport, kind);
                if (isNewTrack) {
                  var stream;
                  track = rtpReceiver.track;
                  if (remoteMsid && remoteMsid.stream === "-") {
                  } else if (remoteMsid) {
                    if (!streams[remoteMsid.stream]) {
                      streams[remoteMsid.stream] = new window2.MediaStream();
                      Object.defineProperty(streams[remoteMsid.stream], "id", {
                        get: function() {
                          return remoteMsid.stream;
                        }
                      });
                    }
                    Object.defineProperty(track, "id", {
                      get: function() {
                        return remoteMsid.track;
                      }
                    });
                    stream = streams[remoteMsid.stream];
                  } else {
                    if (!streams.default) {
                      streams.default = new window2.MediaStream();
                    }
                    stream = streams.default;
                  }
                  if (stream) {
                    addTrackToStreamAndFireEvent(track, stream);
                    transceiver.associatedRemoteMediaStreams.push(stream);
                  }
                  receiverList.push([track, rtpReceiver, stream]);
                }
              } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
                transceiver.associatedRemoteMediaStreams.forEach(function(s) {
                  var nativeTrack = s.getTracks().find(function(t) {
                    return t.id === transceiver.rtpReceiver.track.id;
                  });
                  if (nativeTrack) {
                    removeTrackFromStreamAndFireEvent(nativeTrack, s);
                  }
                });
                transceiver.associatedRemoteMediaStreams = [];
              }
              transceiver.localCapabilities = localCapabilities;
              transceiver.remoteCapabilities = remoteCapabilities;
              transceiver.rtpReceiver = rtpReceiver;
              transceiver.rtcpParameters = rtcpParameters;
              transceiver.sendEncodingParameters = sendEncodingParameters;
              transceiver.recvEncodingParameters = recvEncodingParameters;
              pc._transceive(
                pc.transceivers[sdpMLineIndex],
                false,
                isNewTrack
              );
            } else if (description.type === "answer" && !rejected) {
              transceiver = pc.transceivers[sdpMLineIndex];
              iceGatherer = transceiver.iceGatherer;
              iceTransport = transceiver.iceTransport;
              dtlsTransport = transceiver.dtlsTransport;
              rtpReceiver = transceiver.rtpReceiver;
              sendEncodingParameters = transceiver.sendEncodingParameters;
              localCapabilities = transceiver.localCapabilities;
              pc.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters;
              pc.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities;
              pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;
              if (cands.length && iceTransport.state === "new") {
                if ((isIceLite || isComplete) && (!usingBundle || sdpMLineIndex === 0)) {
                  iceTransport.setRemoteCandidates(cands);
                } else {
                  cands.forEach(function(candidate) {
                    maybeAddCandidate(transceiver.iceTransport, candidate);
                  });
                }
              }
              if (!usingBundle || sdpMLineIndex === 0) {
                if (iceTransport.state === "new") {
                  iceTransport.start(
                    iceGatherer,
                    remoteIceParameters,
                    "controlling"
                  );
                }
                if (dtlsTransport.state === "new") {
                  dtlsTransport.start(remoteDtlsParameters);
                }
              }
              var commonCapabilities = getCommonCapabilities(
                transceiver.localCapabilities,
                transceiver.remoteCapabilities
              );
              var hasRtx = commonCapabilities.codecs.filter(function(c) {
                return c.name.toLowerCase() === "rtx";
              }).length;
              if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
                delete transceiver.sendEncodingParameters[0].rtx;
              }
              pc._transceive(
                transceiver,
                direction === "sendrecv" || direction === "recvonly",
                direction === "sendrecv" || direction === "sendonly"
              );
              if (rtpReceiver && (direction === "sendrecv" || direction === "sendonly")) {
                track = rtpReceiver.track;
                if (remoteMsid) {
                  if (!streams[remoteMsid.stream]) {
                    streams[remoteMsid.stream] = new window2.MediaStream();
                  }
                  addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
                  receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
                } else {
                  if (!streams.default) {
                    streams.default = new window2.MediaStream();
                  }
                  addTrackToStreamAndFireEvent(track, streams.default);
                  receiverList.push([track, rtpReceiver, streams.default]);
                }
              } else {
                delete transceiver.rtpReceiver;
              }
            }
          });
          if (pc._dtlsRole === void 0) {
            pc._dtlsRole = description.type === "offer" ? "active" : "passive";
          }
          pc._remoteDescription = {
            type: description.type,
            sdp: description.sdp
          };
          if (description.type === "offer") {
            pc._updateSignalingState("have-remote-offer");
          } else {
            pc._updateSignalingState("stable");
          }
          Object.keys(streams).forEach(function(sid) {
            var stream = streams[sid];
            if (stream.getTracks().length) {
              if (pc.remoteStreams.indexOf(stream) === -1) {
                pc.remoteStreams.push(stream);
                var event = new Event("addstream");
                event.stream = stream;
                window2.setTimeout(function() {
                  pc._dispatchEvent("addstream", event);
                });
              }
              receiverList.forEach(function(item) {
                var track = item[0];
                var receiver = item[1];
                if (stream.id !== item[2].id) {
                  return;
                }
                fireAddTrack(pc, track, receiver, [stream]);
              });
            }
          });
          receiverList.forEach(function(item) {
            if (item[2]) {
              return;
            }
            fireAddTrack(pc, item[0], item[1], []);
          });
          window2.setTimeout(function() {
            if (!(pc && pc.transceivers)) {
              return;
            }
            pc.transceivers.forEach(function(transceiver) {
              if (transceiver.iceTransport && transceiver.iceTransport.state === "new" && transceiver.iceTransport.getRemoteCandidates().length > 0) {
                console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification");
                transceiver.iceTransport.addRemoteCandidate({});
              }
            });
          }, 4e3);
          return Promise.resolve();
        };
        RTCPeerConnection2.prototype.close = function() {
          this.transceivers.forEach(function(transceiver) {
            if (transceiver.iceTransport) {
              transceiver.iceTransport.stop();
            }
            if (transceiver.dtlsTransport) {
              transceiver.dtlsTransport.stop();
            }
            if (transceiver.rtpSender) {
              transceiver.rtpSender.stop();
            }
            if (transceiver.rtpReceiver) {
              transceiver.rtpReceiver.stop();
            }
          });
          this._isClosed = true;
          this._updateSignalingState("closed");
        };
        RTCPeerConnection2.prototype._updateSignalingState = function(newState) {
          this.signalingState = newState;
          var event = new Event("signalingstatechange");
          this._dispatchEvent("signalingstatechange", event);
        };
        RTCPeerConnection2.prototype._maybeFireNegotiationNeeded = function() {
          var pc = this;
          if (this.signalingState !== "stable" || this.needNegotiation === true) {
            return;
          }
          this.needNegotiation = true;
          window2.setTimeout(function() {
            if (pc.needNegotiation) {
              pc.needNegotiation = false;
              var event = new Event("negotiationneeded");
              pc._dispatchEvent("negotiationneeded", event);
            }
          }, 0);
        };
        RTCPeerConnection2.prototype._updateIceConnectionState = function() {
          var newState;
          var states = {
            "new": 0,
            closed: 0,
            checking: 0,
            connected: 0,
            completed: 0,
            disconnected: 0,
            failed: 0
          };
          this.transceivers.forEach(function(transceiver) {
            if (transceiver.iceTransport && !transceiver.rejected) {
              states[transceiver.iceTransport.state]++;
            }
          });
          newState = "new";
          if (states.failed > 0) {
            newState = "failed";
          } else if (states.checking > 0) {
            newState = "checking";
          } else if (states.disconnected > 0) {
            newState = "disconnected";
          } else if (states.new > 0) {
            newState = "new";
          } else if (states.connected > 0) {
            newState = "connected";
          } else if (states.completed > 0) {
            newState = "completed";
          }
          if (newState !== this.iceConnectionState) {
            this.iceConnectionState = newState;
            var event = new Event("iceconnectionstatechange");
            this._dispatchEvent("iceconnectionstatechange", event);
          }
        };
        RTCPeerConnection2.prototype._updateConnectionState = function() {
          var newState;
          var states = {
            "new": 0,
            closed: 0,
            connecting: 0,
            connected: 0,
            completed: 0,
            disconnected: 0,
            failed: 0
          };
          this.transceivers.forEach(function(transceiver) {
            if (transceiver.iceTransport && transceiver.dtlsTransport && !transceiver.rejected) {
              states[transceiver.iceTransport.state]++;
              states[transceiver.dtlsTransport.state]++;
            }
          });
          states.connected += states.completed;
          newState = "new";
          if (states.failed > 0) {
            newState = "failed";
          } else if (states.connecting > 0) {
            newState = "connecting";
          } else if (states.disconnected > 0) {
            newState = "disconnected";
          } else if (states.new > 0) {
            newState = "new";
          } else if (states.connected > 0) {
            newState = "connected";
          }
          if (newState !== this.connectionState) {
            this.connectionState = newState;
            var event = new Event("connectionstatechange");
            this._dispatchEvent("connectionstatechange", event);
          }
        };
        RTCPeerConnection2.prototype.createOffer = function() {
          var pc = this;
          if (pc._isClosed) {
            return Promise.reject(makeError(
              "InvalidStateError",
              "Can not call createOffer after close"
            ));
          }
          var numAudioTracks = pc.transceivers.filter(function(t) {
            return t.kind === "audio";
          }).length;
          var numVideoTracks = pc.transceivers.filter(function(t) {
            return t.kind === "video";
          }).length;
          var offerOptions = arguments[0];
          if (offerOptions) {
            if (offerOptions.mandatory || offerOptions.optional) {
              throw new TypeError(
                "Legacy mandatory/optional constraints not supported."
              );
            }
            if (offerOptions.offerToReceiveAudio !== void 0) {
              if (offerOptions.offerToReceiveAudio === true) {
                numAudioTracks = 1;
              } else if (offerOptions.offerToReceiveAudio === false) {
                numAudioTracks = 0;
              } else {
                numAudioTracks = offerOptions.offerToReceiveAudio;
              }
            }
            if (offerOptions.offerToReceiveVideo !== void 0) {
              if (offerOptions.offerToReceiveVideo === true) {
                numVideoTracks = 1;
              } else if (offerOptions.offerToReceiveVideo === false) {
                numVideoTracks = 0;
              } else {
                numVideoTracks = offerOptions.offerToReceiveVideo;
              }
            }
          }
          pc.transceivers.forEach(function(transceiver) {
            if (transceiver.kind === "audio") {
              numAudioTracks--;
              if (numAudioTracks < 0) {
                transceiver.wantReceive = false;
              }
            } else if (transceiver.kind === "video") {
              numVideoTracks--;
              if (numVideoTracks < 0) {
                transceiver.wantReceive = false;
              }
            }
          });
          while (numAudioTracks > 0 || numVideoTracks > 0) {
            if (numAudioTracks > 0) {
              pc._createTransceiver("audio");
              numAudioTracks--;
            }
            if (numVideoTracks > 0) {
              pc._createTransceiver("video");
              numVideoTracks--;
            }
          }
          var sdp = SDPUtils2.writeSessionBoilerplate(
            pc._sdpSessionId,
            pc._sdpSessionVersion++
          );
          pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
            var track = transceiver.track;
            var kind = transceiver.kind;
            var mid = transceiver.mid || SDPUtils2.generateIdentifier();
            transceiver.mid = mid;
            if (!transceiver.iceGatherer) {
              transceiver.iceGatherer = pc._createIceGatherer(
                sdpMLineIndex,
                pc.usingBundle
              );
            }
            var localCapabilities = window2.RTCRtpSender.getCapabilities(kind);
            if (edgeVersion < 15019) {
              localCapabilities.codecs = localCapabilities.codecs.filter(
                function(codec) {
                  return codec.name !== "rtx";
                }
              );
            }
            localCapabilities.codecs.forEach(function(codec) {
              if (codec.name === "H264" && codec.parameters["level-asymmetry-allowed"] === void 0) {
                codec.parameters["level-asymmetry-allowed"] = "1";
              }
              if (transceiver.remoteCapabilities && transceiver.remoteCapabilities.codecs) {
                transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
                  if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() && codec.clockRate === remoteCodec.clockRate) {
                    codec.preferredPayloadType = remoteCodec.payloadType;
                  }
                });
              }
            });
            localCapabilities.headerExtensions.forEach(function(hdrExt) {
              var remoteExtensions = transceiver.remoteCapabilities && transceiver.remoteCapabilities.headerExtensions || [];
              remoteExtensions.forEach(function(rHdrExt) {
                if (hdrExt.uri === rHdrExt.uri) {
                  hdrExt.id = rHdrExt.id;
                }
              });
            });
            var sendEncodingParameters = transceiver.sendEncodingParameters || [{
              ssrc: (2 * sdpMLineIndex + 1) * 1001
            }];
            if (track) {
              if (edgeVersion >= 15019 && kind === "video" && !sendEncodingParameters[0].rtx) {
                sendEncodingParameters[0].rtx = {
                  ssrc: sendEncodingParameters[0].ssrc + 1
                };
              }
            }
            if (transceiver.wantReceive) {
              transceiver.rtpReceiver = new window2.RTCRtpReceiver(
                transceiver.dtlsTransport,
                kind
              );
            }
            transceiver.localCapabilities = localCapabilities;
            transceiver.sendEncodingParameters = sendEncodingParameters;
          });
          if (pc._config.bundlePolicy !== "max-compat") {
            sdp += "a=group:BUNDLE " + pc.transceivers.map(function(t) {
              return t.mid;
            }).join(" ") + "\r\n";
          }
          sdp += "a=ice-options:trickle\r\n";
          pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
            sdp += writeMediaSection(
              transceiver,
              transceiver.localCapabilities,
              "offer",
              transceiver.stream,
              pc._dtlsRole
            );
            sdp += "a=rtcp-rsize\r\n";
            if (transceiver.iceGatherer && pc.iceGatheringState !== "new" && (sdpMLineIndex === 0 || !pc.usingBundle)) {
              transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
                cand.component = 1;
                sdp += "a=" + SDPUtils2.writeCandidate(cand) + "\r\n";
              });
              if (transceiver.iceGatherer.state === "completed") {
                sdp += "a=end-of-candidates\r\n";
              }
            }
          });
          var desc = new window2.RTCSessionDescription({
            type: "offer",
            sdp
          });
          return Promise.resolve(desc);
        };
        RTCPeerConnection2.prototype.createAnswer = function() {
          var pc = this;
          if (pc._isClosed) {
            return Promise.reject(makeError(
              "InvalidStateError",
              "Can not call createAnswer after close"
            ));
          }
          if (!(pc.signalingState === "have-remote-offer" || pc.signalingState === "have-local-pranswer")) {
            return Promise.reject(makeError(
              "InvalidStateError",
              "Can not call createAnswer in signalingState " + pc.signalingState
            ));
          }
          var sdp = SDPUtils2.writeSessionBoilerplate(
            pc._sdpSessionId,
            pc._sdpSessionVersion++
          );
          if (pc.usingBundle) {
            sdp += "a=group:BUNDLE " + pc.transceivers.map(function(t) {
              return t.mid;
            }).join(" ") + "\r\n";
          }
          sdp += "a=ice-options:trickle\r\n";
          var mediaSectionsInOffer = SDPUtils2.getMediaSections(
            pc._remoteDescription.sdp
          ).length;
          pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
            if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
              return;
            }
            if (transceiver.rejected) {
              if (transceiver.kind === "application") {
                if (transceiver.protocol === "DTLS/SCTP") {
                  sdp += "m=application 0 DTLS/SCTP 5000\r\n";
                } else {
                  sdp += "m=application 0 " + transceiver.protocol + " webrtc-datachannel\r\n";
                }
              } else if (transceiver.kind === "audio") {
                sdp += "m=audio 0 UDP/TLS/RTP/SAVPF 0\r\na=rtpmap:0 PCMU/8000\r\n";
              } else if (transceiver.kind === "video") {
                sdp += "m=video 0 UDP/TLS/RTP/SAVPF 120\r\na=rtpmap:120 VP8/90000\r\n";
              }
              sdp += "c=IN IP4 0.0.0.0\r\na=inactive\r\na=mid:" + transceiver.mid + "\r\n";
              return;
            }
            if (transceiver.stream) {
              var localTrack;
              if (transceiver.kind === "audio") {
                localTrack = transceiver.stream.getAudioTracks()[0];
              } else if (transceiver.kind === "video") {
                localTrack = transceiver.stream.getVideoTracks()[0];
              }
              if (localTrack) {
                if (edgeVersion >= 15019 && transceiver.kind === "video" && !transceiver.sendEncodingParameters[0].rtx) {
                  transceiver.sendEncodingParameters[0].rtx = {
                    ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
                  };
                }
              }
            }
            var commonCapabilities = getCommonCapabilities(
              transceiver.localCapabilities,
              transceiver.remoteCapabilities
            );
            var hasRtx = commonCapabilities.codecs.filter(function(c) {
              return c.name.toLowerCase() === "rtx";
            }).length;
            if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
              delete transceiver.sendEncodingParameters[0].rtx;
            }
            sdp += writeMediaSection(
              transceiver,
              commonCapabilities,
              "answer",
              transceiver.stream,
              pc._dtlsRole
            );
            if (transceiver.rtcpParameters && transceiver.rtcpParameters.reducedSize) {
              sdp += "a=rtcp-rsize\r\n";
            }
          });
          var desc = new window2.RTCSessionDescription({
            type: "answer",
            sdp
          });
          return Promise.resolve(desc);
        };
        RTCPeerConnection2.prototype.addIceCandidate = function(candidate) {
          var pc = this;
          var sections;
          if (candidate && !(candidate.sdpMLineIndex !== void 0 || candidate.sdpMid)) {
            return Promise.reject(new TypeError("sdpMLineIndex or sdpMid required"));
          }
          return new Promise(function(resolve, reject) {
            if (!pc._remoteDescription) {
              return reject(makeError(
                "InvalidStateError",
                "Can not add ICE candidate without a remote description"
              ));
            } else if (!candidate || candidate.candidate === "") {
              for (var j = 0; j < pc.transceivers.length; j++) {
                if (pc.transceivers[j].rejected) {
                  continue;
                }
                pc.transceivers[j].iceTransport.addRemoteCandidate({});
                sections = SDPUtils2.getMediaSections(pc._remoteDescription.sdp);
                sections[j] += "a=end-of-candidates\r\n";
                pc._remoteDescription.sdp = SDPUtils2.getDescription(pc._remoteDescription.sdp) + sections.join("");
                if (pc.usingBundle) {
                  break;
                }
              }
            } else {
              var sdpMLineIndex = candidate.sdpMLineIndex;
              if (candidate.sdpMid) {
                for (var i = 0; i < pc.transceivers.length; i++) {
                  if (pc.transceivers[i].mid === candidate.sdpMid) {
                    sdpMLineIndex = i;
                    break;
                  }
                }
              }
              var transceiver = pc.transceivers[sdpMLineIndex];
              if (transceiver) {
                if (transceiver.rejected) {
                  return resolve();
                }
                var cand = Object.keys(candidate.candidate).length > 0 ? SDPUtils2.parseCandidate(candidate.candidate) : {};
                if (cand.protocol === "tcp" && (cand.port === 0 || cand.port === 9)) {
                  return resolve();
                }
                if (cand.component && cand.component !== 1) {
                  return resolve();
                }
                if (sdpMLineIndex === 0 || sdpMLineIndex > 0 && transceiver.iceTransport !== pc.transceivers[0].iceTransport) {
                  if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
                    return reject(makeError(
                      "OperationError",
                      "Can not add ICE candidate"
                    ));
                  }
                }
                var candidateString = candidate.candidate.trim();
                if (candidateString.indexOf("a=") === 0) {
                  candidateString = candidateString.substr(2);
                }
                sections = SDPUtils2.getMediaSections(pc._remoteDescription.sdp);
                sections[sdpMLineIndex] += "a=" + (cand.type ? candidateString : "end-of-candidates") + "\r\n";
                pc._remoteDescription.sdp = SDPUtils2.getDescription(pc._remoteDescription.sdp) + sections.join("");
              } else {
                return reject(makeError(
                  "OperationError",
                  "Can not add ICE candidate"
                ));
              }
            }
            resolve();
          });
        };
        RTCPeerConnection2.prototype.getStats = function(selector) {
          if (selector && selector instanceof window2.MediaStreamTrack) {
            var senderOrReceiver = null;
            this.transceivers.forEach(function(transceiver) {
              if (transceiver.rtpSender && transceiver.rtpSender.track === selector) {
                senderOrReceiver = transceiver.rtpSender;
              } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track === selector) {
                senderOrReceiver = transceiver.rtpReceiver;
              }
            });
            if (!senderOrReceiver) {
              throw makeError("InvalidAccessError", "Invalid selector.");
            }
            return senderOrReceiver.getStats();
          }
          var promises = [];
          this.transceivers.forEach(function(transceiver) {
            [
              "rtpSender",
              "rtpReceiver",
              "iceGatherer",
              "iceTransport",
              "dtlsTransport"
            ].forEach(function(method) {
              if (transceiver[method]) {
                promises.push(transceiver[method].getStats());
              }
            });
          });
          return Promise.all(promises).then(function(allStats) {
            var results = /* @__PURE__ */ new Map();
            allStats.forEach(function(stats) {
              stats.forEach(function(stat) {
                results.set(stat.id, stat);
              });
            });
            return results;
          });
        };
        var ortcObjects = [
          "RTCRtpSender",
          "RTCRtpReceiver",
          "RTCIceGatherer",
          "RTCIceTransport",
          "RTCDtlsTransport"
        ];
        ortcObjects.forEach(function(ortcObjectName) {
          var obj = window2[ortcObjectName];
          if (obj && obj.prototype && obj.prototype.getStats) {
            var nativeGetstats = obj.prototype.getStats;
            obj.prototype.getStats = function() {
              return nativeGetstats.apply(this).then(function(nativeStats) {
                var mapStats = /* @__PURE__ */ new Map();
                Object.keys(nativeStats).forEach(function(id2) {
                  nativeStats[id2].type = fixStatsType(nativeStats[id2]);
                  mapStats.set(id2, nativeStats[id2]);
                });
                return mapStats;
              });
            };
          }
        });
        var methods = ["createOffer", "createAnswer"];
        methods.forEach(function(method) {
          var nativeMethod = RTCPeerConnection2.prototype[method];
          RTCPeerConnection2.prototype[method] = function() {
            var args = arguments;
            if (typeof args[0] === "function" || typeof args[1] === "function") {
              return nativeMethod.apply(this, [arguments[2]]).then(function(description) {
                if (typeof args[0] === "function") {
                  args[0].apply(null, [description]);
                }
              }, function(error) {
                if (typeof args[1] === "function") {
                  args[1].apply(null, [error]);
                }
              });
            }
            return nativeMethod.apply(this, arguments);
          };
        });
        methods = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"];
        methods.forEach(function(method) {
          var nativeMethod = RTCPeerConnection2.prototype[method];
          RTCPeerConnection2.prototype[method] = function() {
            var args = arguments;
            if (typeof args[1] === "function" || typeof args[2] === "function") {
              return nativeMethod.apply(this, arguments).then(function() {
                if (typeof args[1] === "function") {
                  args[1].apply(null);
                }
              }, function(error) {
                if (typeof args[2] === "function") {
                  args[2].apply(null, [error]);
                }
              });
            }
            return nativeMethod.apply(this, arguments);
          };
        });
        ["getStats"].forEach(function(method) {
          var nativeMethod = RTCPeerConnection2.prototype[method];
          RTCPeerConnection2.prototype[method] = function() {
            var args = arguments;
            if (typeof args[1] === "function") {
              return nativeMethod.apply(this, arguments).then(function() {
                if (typeof args[1] === "function") {
                  args[1].apply(null);
                }
              });
            }
            return nativeMethod.apply(this, arguments);
          };
        });
        return RTCPeerConnection2;
      };
    }
  });

  // node_modules/p5/lib/p5.min.js
  var require_p5_min = __commonJS({
    "node_modules/p5/lib/p5.min.js"(exports, module) {
      !function(e) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).p5 = e();
      }(function() {
        var s, e, t;
        return function o(n, s2, i) {
          function a(t2, e3) {
            if (!s2[t2]) {
              if (!n[t2]) {
                var r = "function" == typeof __require && __require;
                if (!e3 && r)
                  return r(t2, true);
                if (l)
                  return l(t2, true);
                throw (e3 = new Error("Cannot find module '" + t2 + "'")).code = "MODULE_NOT_FOUND", e3;
              }
              r = s2[t2] = { exports: {} }, n[t2][0].call(r.exports, function(e4) {
                return a(n[t2][1][e4] || e4);
              }, r, r.exports, o, n, s2, i);
            }
            return s2[t2].exports;
          }
          for (var l = "function" == typeof __require && __require, e2 = 0; e2 < i.length; e2++)
            a(i[e2]);
          return a;
        }({ 1: [function(e2, t2, r) {
          "use strict";
          r.byteLength = function(e3) {
            var e3 = c(e3), t3 = e3[0], e3 = e3[1];
            return 3 * (t3 + e3) / 4 - e3;
          }, r.toByteArray = function(e3) {
            var t3, r2, o2 = c(e3), n2 = o2[0], o2 = o2[1], s3 = new u(function(e4, t4) {
              return 3 * (e4 + t4) / 4 - t4;
            }(n2, o2)), i = 0, a2 = 0 < o2 ? n2 - 4 : n2;
            for (r2 = 0; r2 < a2; r2 += 4)
              t3 = l[e3.charCodeAt(r2)] << 18 | l[e3.charCodeAt(r2 + 1)] << 12 | l[e3.charCodeAt(r2 + 2)] << 6 | l[e3.charCodeAt(r2 + 3)], s3[i++] = t3 >> 16 & 255, s3[i++] = t3 >> 8 & 255, s3[i++] = 255 & t3;
            2 === o2 && (t3 = l[e3.charCodeAt(r2)] << 2 | l[e3.charCodeAt(r2 + 1)] >> 4, s3[i++] = 255 & t3);
            1 === o2 && (t3 = l[e3.charCodeAt(r2)] << 10 | l[e3.charCodeAt(r2 + 1)] << 4 | l[e3.charCodeAt(r2 + 2)] >> 2, s3[i++] = t3 >> 8 & 255, s3[i++] = 255 & t3);
            return s3;
          }, r.fromByteArray = function(e3) {
            for (var t3, r2 = e3.length, o2 = r2 % 3, n2 = [], s3 = 0, i = r2 - o2; s3 < i; s3 += 16383)
              n2.push(function(e4, t4, r3) {
                for (var o3, n3 = [], s4 = t4; s4 < r3; s4 += 3)
                  o3 = (e4[s4] << 16 & 16711680) + (e4[s4 + 1] << 8 & 65280) + (255 & e4[s4 + 2]), n3.push(function(e5) {
                    return a[e5 >> 18 & 63] + a[e5 >> 12 & 63] + a[e5 >> 6 & 63] + a[63 & e5];
                  }(o3));
                return n3.join("");
              }(e3, s3, i < s3 + 16383 ? i : s3 + 16383));
            1 == o2 ? (t3 = e3[r2 - 1], n2.push(a[t3 >> 2] + a[t3 << 4 & 63] + "==")) : 2 == o2 && (t3 = (e3[r2 - 2] << 8) + e3[r2 - 1], n2.push(a[t3 >> 10] + a[t3 >> 4 & 63] + a[t3 << 2 & 63] + "="));
            return n2.join("");
          };
          for (var a = [], l = [], u = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = 0, s2 = o.length; n < s2; ++n)
            a[n] = o[n], l[o.charCodeAt(n)] = n;
          function c(e3) {
            var t3 = e3.length;
            if (0 < t3 % 4)
              throw new Error("Invalid string. Length must be a multiple of 4");
            e3 = e3.indexOf("="), t3 = (e3 = -1 === e3 ? t3 : e3) === t3 ? 0 : 4 - e3 % 4;
            return [e3, t3];
          }
          l["-".charCodeAt(0)] = 62, l["_".charCodeAt(0)] = 63;
        }, {}], 2: [function(e2, t2, r) {
        }, {}], 3: [function(e2, t2, r) {
          arguments[4][2][0].apply(r, arguments);
        }, { dup: 2 }], 4: [function(A, e2, P) {
          !function(d) {
            "use strict";
            var S = A("base64-js"), s2 = A("ieee754"), e3 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null, t2 = (P.Buffer = d, P.SlowBuffer = function(e4) {
              +e4 != e4 && (e4 = 0);
              return d.alloc(+e4);
            }, P.INSPECT_MAX_BYTES = 50, 2147483647);
            function l(e4) {
              if (t2 < e4)
                throw new RangeError('The value "' + e4 + '" is invalid for option "size"');
              e4 = new Uint8Array(e4);
              return Object.setPrototypeOf(e4, d.prototype), e4;
            }
            function d(e4, t3, r2) {
              if ("number" != typeof e4)
                return o(e4, t3, r2);
              if ("string" == typeof t3)
                throw new TypeError('The "string" argument must be of type string. Received type number');
              return i(e4);
            }
            function o(e4, t3, r2) {
              if ("string" == typeof e4) {
                var o2 = e4, n2 = t3;
                if (d.isEncoding(n2 = "string" == typeof n2 && "" !== n2 ? n2 : "utf8"))
                  return s3 = 0 | f(o2, n2), i2 = l(s3), i2 = (o2 = i2.write(o2, n2)) !== s3 ? i2.slice(0, o2) : i2;
                throw new TypeError("Unknown encoding: " + n2);
              }
              if (ArrayBuffer.isView(e4))
                return u(e4);
              if (null != e4) {
                if (O(e4, ArrayBuffer) || e4 && O(e4.buffer, ArrayBuffer)) {
                  var s3 = e4, o2 = t3, i2 = r2;
                  if (o2 < 0 || s3.byteLength < o2)
                    throw new RangeError('"offset" is outside of buffer bounds');
                  if (s3.byteLength < o2 + (i2 || 0))
                    throw new RangeError('"length" is outside of buffer bounds');
                  return s3 = void 0 === o2 && void 0 === i2 ? new Uint8Array(s3) : void 0 === i2 ? new Uint8Array(s3, o2) : new Uint8Array(s3, o2, i2), Object.setPrototypeOf(s3, d.prototype), s3;
                }
                if ("number" == typeof e4)
                  throw new TypeError('The "value" argument must not be of type number. Received type number');
                n2 = e4.valueOf && e4.valueOf();
                if (null != n2 && n2 !== e4)
                  return d.from(n2, t3, r2);
                var a2 = function(e5) {
                  {
                    var t4, r3;
                    if (d.isBuffer(e5))
                      return t4 = 0 | c(e5.length), 0 !== (r3 = l(t4)).length && e5.copy(r3, 0, 0, t4), r3;
                  }
                  if (void 0 !== e5.length)
                    return "number" != typeof e5.length || L(e5.length) ? l(0) : u(e5);
                  if ("Buffer" === e5.type && Array.isArray(e5.data))
                    return u(e5.data);
                }(e4);
                if (a2)
                  return a2;
                if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e4[Symbol.toPrimitive])
                  return d.from(e4[Symbol.toPrimitive]("string"), t3, r2);
              }
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e4);
            }
            function n(e4) {
              if ("number" != typeof e4)
                throw new TypeError('"size" argument must be of type number');
              if (e4 < 0)
                throw new RangeError('The value "' + e4 + '" is invalid for option "size"');
            }
            function i(e4) {
              return n(e4), l(e4 < 0 ? 0 : 0 | c(e4));
            }
            function u(e4) {
              for (var t3 = e4.length < 0 ? 0 : 0 | c(e4.length), r2 = l(t3), o2 = 0; o2 < t3; o2 += 1)
                r2[o2] = 255 & e4[o2];
              return r2;
            }
            function c(e4) {
              if (t2 <= e4)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + t2.toString(16) + " bytes");
              return 0 | e4;
            }
            function f(e4, t3) {
              if (d.isBuffer(e4))
                return e4.length;
              if (ArrayBuffer.isView(e4) || O(e4, ArrayBuffer))
                return e4.byteLength;
              if ("string" != typeof e4)
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e4);
              var r2 = e4.length, o2 = 2 < arguments.length && true === arguments[2];
              if (!o2 && 0 === r2)
                return 0;
              for (var n2 = false; ; )
                switch (t3) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return r2;
                  case "utf8":
                  case "utf-8":
                    return E(e4).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * r2;
                  case "hex":
                    return r2 >>> 1;
                  case "base64":
                    return T(e4).length;
                  default:
                    if (n2)
                      return o2 ? -1 : E(e4).length;
                    t3 = ("" + t3).toLowerCase(), n2 = true;
                }
            }
            function r(e4, t3, r2) {
              var o2, n2 = false;
              if ((t3 = void 0 === t3 || t3 < 0 ? 0 : t3) > this.length)
                return "";
              if ((r2 = void 0 === r2 || r2 > this.length ? this.length : r2) <= 0)
                return "";
              if ((r2 >>>= 0) <= (t3 >>>= 0))
                return "";
              for (e4 = e4 || "utf8"; ; )
                switch (e4) {
                  case "hex":
                    var s3 = this, i2 = t3, a2 = r2, l2 = s3.length;
                    (!a2 || a2 < 0 || l2 < a2) && (a2 = l2);
                    for (var u2 = "", c2 = i2 = !i2 || i2 < 0 ? 0 : i2; c2 < a2; ++c2)
                      u2 += k[s3[c2]];
                    return u2;
                  case "utf8":
                  case "utf-8":
                    return M(this, t3, r2);
                  case "ascii":
                    var d2 = this, l2 = t3, f2 = r2, h2 = "";
                    f2 = Math.min(d2.length, f2);
                    for (var p2 = l2; p2 < f2; ++p2)
                      h2 += String.fromCharCode(127 & d2[p2]);
                    return h2;
                  case "latin1":
                  case "binary":
                    var m2 = this, i2 = t3, y2 = r2, g2 = "";
                    y2 = Math.min(m2.length, y2);
                    for (var v2 = i2; v2 < y2; ++v2)
                      g2 += String.fromCharCode(m2[v2]);
                    return g2;
                  case "base64":
                    return b2 = this, o2 = r2, 0 === (j2 = t3) && o2 === b2.length ? S.fromByteArray(b2) : S.fromByteArray(b2.slice(j2, o2));
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    for (var b2 = t3, j2 = r2, _2 = this.slice(b2, j2), x2 = "", w2 = 0; w2 < _2.length; w2 += 2)
                      x2 += String.fromCharCode(_2[w2] + 256 * _2[w2 + 1]);
                    return x2;
                  default:
                    if (n2)
                      throw new TypeError("Unknown encoding: " + e4);
                    e4 = (e4 + "").toLowerCase(), n2 = true;
                }
            }
            function a(e4, t3, r2) {
              var o2 = e4[t3];
              e4[t3] = e4[r2], e4[r2] = o2;
            }
            function h(e4, t3, r2, o2, n2) {
              if (0 === e4.length)
                return -1;
              if ("string" == typeof r2 ? (o2 = r2, r2 = 0) : 2147483647 < r2 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), (r2 = (r2 = L(r2 = +r2) ? n2 ? 0 : e4.length - 1 : r2) < 0 ? e4.length + r2 : r2) >= e4.length) {
                if (n2)
                  return -1;
                r2 = e4.length - 1;
              } else if (r2 < 0) {
                if (!n2)
                  return -1;
                r2 = 0;
              }
              if ("string" == typeof t3 && (t3 = d.from(t3, o2)), d.isBuffer(t3))
                return 0 === t3.length ? -1 : p(e4, t3, r2, o2, n2);
              if ("number" == typeof t3)
                return t3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? (n2 ? Uint8Array.prototype.indexOf : Uint8Array.prototype.lastIndexOf).call(e4, t3, r2) : p(e4, [t3], r2, o2, n2);
              throw new TypeError("val must be string, number or Buffer");
            }
            function p(e4, t3, r2, o2, n2) {
              var s3 = 1, i2 = e4.length, a2 = t3.length;
              if (void 0 !== o2 && ("ucs2" === (o2 = String(o2).toLowerCase()) || "ucs-2" === o2 || "utf16le" === o2 || "utf-16le" === o2)) {
                if (e4.length < 2 || t3.length < 2)
                  return -1;
                i2 /= s3 = 2, a2 /= 2, r2 /= 2;
              }
              function l2(e5, t4) {
                return 1 === s3 ? e5[t4] : e5.readUInt16BE(t4 * s3);
              }
              if (n2)
                for (var u2 = -1, c2 = r2; c2 < i2; c2++)
                  if (l2(e4, c2) === l2(t3, -1 === u2 ? 0 : c2 - u2)) {
                    if (c2 - (u2 = -1 === u2 ? c2 : u2) + 1 === a2)
                      return u2 * s3;
                  } else
                    -1 !== u2 && (c2 -= c2 - u2), u2 = -1;
              else
                for (c2 = r2 = i2 < r2 + a2 ? i2 - a2 : r2; 0 <= c2; c2--) {
                  for (var d2 = true, f2 = 0; f2 < a2; f2++)
                    if (l2(e4, c2 + f2) !== l2(t3, f2)) {
                      d2 = false;
                      break;
                    }
                  if (d2)
                    return c2;
                }
              return -1;
            }
            function y(e4, t3, r2, o2) {
              return C(function(e5) {
                for (var t4 = [], r3 = 0; r3 < e5.length; ++r3)
                  t4.push(255 & e5.charCodeAt(r3));
                return t4;
              }(t3), e4, r2, o2);
            }
            function g(e4, t3, r2, o2) {
              return C(function(e5, t4) {
                for (var r3, o3, n2 = [], s3 = 0; s3 < e5.length && !((t4 -= 2) < 0); ++s3)
                  o3 = e5.charCodeAt(s3), r3 = o3 >> 8, o3 = o3 % 256, n2.push(o3), n2.push(r3);
                return n2;
              }(t3, e4.length - r2), e4, r2, o2);
            }
            function M(e4, t3, r2) {
              r2 = Math.min(e4.length, r2);
              for (var o2 = [], n2 = t3; n2 < r2; ) {
                var s3, i2, a2, l2, u2 = e4[n2], c2 = null, d2 = 239 < u2 ? 4 : 223 < u2 ? 3 : 191 < u2 ? 2 : 1;
                if (n2 + d2 <= r2)
                  switch (d2) {
                    case 1:
                      u2 < 128 && (c2 = u2);
                      break;
                    case 2:
                      128 == (192 & (s3 = e4[n2 + 1])) && 127 < (l2 = (31 & u2) << 6 | 63 & s3) && (c2 = l2);
                      break;
                    case 3:
                      s3 = e4[n2 + 1], i2 = e4[n2 + 2], 128 == (192 & s3) && 128 == (192 & i2) && 2047 < (l2 = (15 & u2) << 12 | (63 & s3) << 6 | 63 & i2) && (l2 < 55296 || 57343 < l2) && (c2 = l2);
                      break;
                    case 4:
                      s3 = e4[n2 + 1], i2 = e4[n2 + 2], a2 = e4[n2 + 3], 128 == (192 & s3) && 128 == (192 & i2) && 128 == (192 & a2) && 65535 < (l2 = (15 & u2) << 18 | (63 & s3) << 12 | (63 & i2) << 6 | 63 & a2) && l2 < 1114112 && (c2 = l2);
                  }
                null === c2 ? (c2 = 65533, d2 = 1) : 65535 < c2 && (c2 -= 65536, o2.push(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), o2.push(c2), n2 += d2;
              }
              var f2 = o2, h2 = f2.length;
              if (h2 <= v)
                return String.fromCharCode.apply(String, f2);
              for (var p2 = "", m2 = 0; m2 < h2; )
                p2 += String.fromCharCode.apply(String, f2.slice(m2, m2 += v));
              return p2;
            }
            P.kMaxLength = t2, (d.TYPED_ARRAY_SUPPORT = function() {
              try {
                var e4 = new Uint8Array(1), t3 = { foo: function() {
                  return 42;
                } };
                return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e4, t3), 42 === e4.foo();
              } catch (e5) {
                return false;
              }
            }()) || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(d.prototype, "parent", { enumerable: true, get: function() {
              if (d.isBuffer(this))
                return this.buffer;
            } }), Object.defineProperty(d.prototype, "offset", { enumerable: true, get: function() {
              if (d.isBuffer(this))
                return this.byteOffset;
            } }), "undefined" != typeof Symbol && null != Symbol.species && d[Symbol.species] === d && Object.defineProperty(d, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), d.poolSize = 8192, d.from = o, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array), d.alloc = function(e4, t3, r2) {
              return t3 = t3, r2 = r2, n(e4 = e4), !(e4 <= 0) && void 0 !== t3 ? "string" == typeof r2 ? l(e4).fill(t3, r2) : l(e4).fill(t3) : l(e4);
            }, d.allocUnsafe = i, d.allocUnsafeSlow = i, d.isBuffer = function(e4) {
              return null != e4 && true === e4._isBuffer && e4 !== d.prototype;
            }, d.compare = function(e4, t3) {
              if (O(e4, Uint8Array) && (e4 = d.from(e4, e4.offset, e4.byteLength)), O(t3, Uint8Array) && (t3 = d.from(t3, t3.offset, t3.byteLength)), !d.isBuffer(e4) || !d.isBuffer(t3))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              if (e4 === t3)
                return 0;
              for (var r2 = e4.length, o2 = t3.length, n2 = 0, s3 = Math.min(r2, o2); n2 < s3; ++n2)
                if (e4[n2] !== t3[n2]) {
                  r2 = e4[n2], o2 = t3[n2];
                  break;
                }
              return r2 < o2 ? -1 : o2 < r2 ? 1 : 0;
            }, d.isEncoding = function(e4) {
              switch (String(e4).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            }, d.concat = function(e4, t3) {
              if (!Array.isArray(e4))
                throw new TypeError('"list" argument must be an Array of Buffers');
              if (0 === e4.length)
                return d.alloc(0);
              if (void 0 === t3)
                for (n2 = t3 = 0; n2 < e4.length; ++n2)
                  t3 += e4[n2].length;
              for (var r2 = d.allocUnsafe(t3), o2 = 0, n2 = 0; n2 < e4.length; ++n2) {
                var s3 = e4[n2];
                if (O(s3, Uint8Array) && (s3 = d.from(s3)), !d.isBuffer(s3))
                  throw new TypeError('"list" argument must be an Array of Buffers');
                s3.copy(r2, o2), o2 += s3.length;
              }
              return r2;
            }, d.byteLength = f, d.prototype._isBuffer = true, d.prototype.swap16 = function() {
              var e4 = this.length;
              if (e4 % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (var t3 = 0; t3 < e4; t3 += 2)
                a(this, t3, t3 + 1);
              return this;
            }, d.prototype.swap32 = function() {
              var e4 = this.length;
              if (e4 % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (var t3 = 0; t3 < e4; t3 += 4)
                a(this, t3, t3 + 3), a(this, t3 + 1, t3 + 2);
              return this;
            }, d.prototype.swap64 = function() {
              var e4 = this.length;
              if (e4 % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (var t3 = 0; t3 < e4; t3 += 8)
                a(this, t3, t3 + 7), a(this, t3 + 1, t3 + 6), a(this, t3 + 2, t3 + 5), a(this, t3 + 3, t3 + 4);
              return this;
            }, d.prototype.toLocaleString = d.prototype.toString = function() {
              var e4 = this.length;
              return 0 === e4 ? "" : 0 === arguments.length ? M(this, 0, e4) : r.apply(this, arguments);
            }, d.prototype.equals = function(e4) {
              if (d.isBuffer(e4))
                return this === e4 || 0 === d.compare(this, e4);
              throw new TypeError("Argument must be a Buffer");
            }, d.prototype.inspect = function() {
              var e4 = "", t3 = P.INSPECT_MAX_BYTES, e4 = this.toString("hex", 0, t3).replace(/(.{2})/g, "$1 ").trim();
              return this.length > t3 && (e4 += " ... "), "<Buffer " + e4 + ">";
            }, e3 && (d.prototype[e3] = d.prototype.inspect), d.prototype.compare = function(e4, t3, r2, o2, n2) {
              if (O(e4, Uint8Array) && (e4 = d.from(e4, e4.offset, e4.byteLength)), !d.isBuffer(e4))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e4);
              if (void 0 === r2 && (r2 = e4 ? e4.length : 0), void 0 === o2 && (o2 = 0), void 0 === n2 && (n2 = this.length), (t3 = void 0 === t3 ? 0 : t3) < 0 || r2 > e4.length || o2 < 0 || n2 > this.length)
                throw new RangeError("out of range index");
              if (n2 <= o2 && r2 <= t3)
                return 0;
              if (n2 <= o2)
                return -1;
              if (r2 <= t3)
                return 1;
              if (this === e4)
                return 0;
              for (var s3 = (n2 >>>= 0) - (o2 >>>= 0), i2 = (r2 >>>= 0) - (t3 >>>= 0), a2 = Math.min(s3, i2), l2 = this.slice(o2, n2), u2 = e4.slice(t3, r2), c2 = 0; c2 < a2; ++c2)
                if (l2[c2] !== u2[c2]) {
                  s3 = l2[c2], i2 = u2[c2];
                  break;
                }
              return s3 < i2 ? -1 : i2 < s3 ? 1 : 0;
            }, d.prototype.includes = function(e4, t3, r2) {
              return -1 !== this.indexOf(e4, t3, r2);
            }, d.prototype.indexOf = function(e4, t3, r2) {
              return h(this, e4, t3, r2, true);
            }, d.prototype.lastIndexOf = function(e4, t3, r2) {
              return h(this, e4, t3, r2, false);
            }, d.prototype.write = function(e4, t3, r2, o2) {
              if (void 0 === t3)
                o2 = "utf8", r2 = this.length, t3 = 0;
              else if (void 0 === r2 && "string" == typeof t3)
                o2 = t3, r2 = this.length, t3 = 0;
              else {
                if (!isFinite(t3))
                  throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t3 >>>= 0, isFinite(r2) ? (r2 >>>= 0, void 0 === o2 && (o2 = "utf8")) : (o2 = r2, r2 = void 0);
              }
              var n2 = this.length - t3;
              if ((void 0 === r2 || n2 < r2) && (r2 = n2), 0 < e4.length && (r2 < 0 || t3 < 0) || t3 > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
              o2 = o2 || "utf8";
              for (var s3, i2, a2, l2 = false; ; )
                switch (o2) {
                  case "hex":
                    var u2 = this, c2 = e4, d2 = t3, f2 = r2, h2 = (d2 = Number(d2) || 0, u2.length - d2);
                    (!f2 || h2 < (f2 = Number(f2))) && (f2 = h2), (h2 = c2.length) / 2 < f2 && (f2 = h2 / 2);
                    for (var p2 = 0; p2 < f2; ++p2) {
                      var m2 = parseInt(c2.substr(2 * p2, 2), 16);
                      if (L(m2))
                        return p2;
                      u2[d2 + p2] = m2;
                    }
                    return p2;
                  case "utf8":
                  case "utf-8":
                    return h2 = t3, a2 = r2, C(E(e4, (i2 = this).length - h2), i2, h2, a2);
                  case "ascii":
                    return y(this, e4, t3, r2);
                  case "latin1":
                  case "binary":
                    return y(this, e4, t3, r2);
                  case "base64":
                    return i2 = this, a2 = t3, s3 = r2, C(T(e4), i2, a2, s3);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return g(this, e4, t3, r2);
                  default:
                    if (l2)
                      throw new TypeError("Unknown encoding: " + o2);
                    o2 = ("" + o2).toLowerCase(), l2 = true;
                }
            }, d.prototype.toJSON = function() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            var v = 4096;
            function m(e4, t3, r2) {
              if (e4 % 1 != 0 || e4 < 0)
                throw new RangeError("offset is not uint");
              if (r2 < e4 + t3)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function b(e4, t3, r2, o2, n2, s3) {
              if (!d.isBuffer(e4))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (n2 < t3 || t3 < s3)
                throw new RangeError('"value" argument is out of bounds');
              if (r2 + o2 > e4.length)
                throw new RangeError("Index out of range");
            }
            function j(e4, t3, r2, o2) {
              if (r2 + o2 > e4.length)
                throw new RangeError("Index out of range");
              if (r2 < 0)
                throw new RangeError("Index out of range");
            }
            function _(e4, t3, r2, o2, n2) {
              return t3 = +t3, r2 >>>= 0, n2 || j(e4, 0, r2, 4), s2.write(e4, t3, r2, o2, 23, 4), r2 + 4;
            }
            function x(e4, t3, r2, o2, n2) {
              return t3 = +t3, r2 >>>= 0, n2 || j(e4, 0, r2, 8), s2.write(e4, t3, r2, o2, 52, 8), r2 + 8;
            }
            d.prototype.slice = function(e4, t3) {
              var r2 = this.length, r2 = ((e4 = ~~e4) < 0 ? (e4 += r2) < 0 && (e4 = 0) : r2 < e4 && (e4 = r2), (t3 = void 0 === t3 ? r2 : ~~t3) < 0 ? (t3 += r2) < 0 && (t3 = 0) : r2 < t3 && (t3 = r2), t3 < e4 && (t3 = e4), this.subarray(e4, t3));
              return Object.setPrototypeOf(r2, d.prototype), r2;
            }, d.prototype.readUIntLE = function(e4, t3, r2) {
              e4 >>>= 0, t3 >>>= 0, r2 || m(e4, t3, this.length);
              for (var o2 = this[e4], n2 = 1, s3 = 0; ++s3 < t3 && (n2 *= 256); )
                o2 += this[e4 + s3] * n2;
              return o2;
            }, d.prototype.readUIntBE = function(e4, t3, r2) {
              e4 >>>= 0, t3 >>>= 0, r2 || m(e4, t3, this.length);
              for (var o2 = this[e4 + --t3], n2 = 1; 0 < t3 && (n2 *= 256); )
                o2 += this[e4 + --t3] * n2;
              return o2;
            }, d.prototype.readUInt8 = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 1, this.length), this[e4];
            }, d.prototype.readUInt16LE = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 2, this.length), this[e4] | this[e4 + 1] << 8;
            }, d.prototype.readUInt16BE = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 2, this.length), this[e4] << 8 | this[e4 + 1];
            }, d.prototype.readUInt32LE = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 4, this.length), (this[e4] | this[e4 + 1] << 8 | this[e4 + 2] << 16) + 16777216 * this[e4 + 3];
            }, d.prototype.readUInt32BE = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 4, this.length), 16777216 * this[e4] + (this[e4 + 1] << 16 | this[e4 + 2] << 8 | this[e4 + 3]);
            }, d.prototype.readIntLE = function(e4, t3, r2) {
              e4 >>>= 0, t3 >>>= 0, r2 || m(e4, t3, this.length);
              for (var o2 = this[e4], n2 = 1, s3 = 0; ++s3 < t3 && (n2 *= 256); )
                o2 += this[e4 + s3] * n2;
              return (n2 *= 128) <= o2 && (o2 -= Math.pow(2, 8 * t3)), o2;
            }, d.prototype.readIntBE = function(e4, t3, r2) {
              e4 >>>= 0, t3 >>>= 0, r2 || m(e4, t3, this.length);
              for (var o2 = t3, n2 = 1, s3 = this[e4 + --o2]; 0 < o2 && (n2 *= 256); )
                s3 += this[e4 + --o2] * n2;
              return (n2 *= 128) <= s3 && (s3 -= Math.pow(2, 8 * t3)), s3;
            }, d.prototype.readInt8 = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 1, this.length), 128 & this[e4] ? -1 * (255 - this[e4] + 1) : this[e4];
            }, d.prototype.readInt16LE = function(e4, t3) {
              e4 >>>= 0, t3 || m(e4, 2, this.length);
              t3 = this[e4] | this[e4 + 1] << 8;
              return 32768 & t3 ? 4294901760 | t3 : t3;
            }, d.prototype.readInt16BE = function(e4, t3) {
              e4 >>>= 0, t3 || m(e4, 2, this.length);
              t3 = this[e4 + 1] | this[e4] << 8;
              return 32768 & t3 ? 4294901760 | t3 : t3;
            }, d.prototype.readInt32LE = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 4, this.length), this[e4] | this[e4 + 1] << 8 | this[e4 + 2] << 16 | this[e4 + 3] << 24;
            }, d.prototype.readInt32BE = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 4, this.length), this[e4] << 24 | this[e4 + 1] << 16 | this[e4 + 2] << 8 | this[e4 + 3];
            }, d.prototype.readFloatLE = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 4, this.length), s2.read(this, e4, true, 23, 4);
            }, d.prototype.readFloatBE = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 4, this.length), s2.read(this, e4, false, 23, 4);
            }, d.prototype.readDoubleLE = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 8, this.length), s2.read(this, e4, true, 52, 8);
            }, d.prototype.readDoubleBE = function(e4, t3) {
              return e4 >>>= 0, t3 || m(e4, 8, this.length), s2.read(this, e4, false, 52, 8);
            }, d.prototype.writeUIntLE = function(e4, t3, r2, o2) {
              e4 = +e4, t3 >>>= 0, r2 >>>= 0, o2 || b(this, e4, t3, r2, Math.pow(2, 8 * r2) - 1, 0);
              var n2 = 1, s3 = 0;
              for (this[t3] = 255 & e4; ++s3 < r2 && (n2 *= 256); )
                this[t3 + s3] = e4 / n2 & 255;
              return t3 + r2;
            }, d.prototype.writeUIntBE = function(e4, t3, r2, o2) {
              e4 = +e4, t3 >>>= 0, r2 >>>= 0, o2 || b(this, e4, t3, r2, Math.pow(2, 8 * r2) - 1, 0);
              var n2 = r2 - 1, s3 = 1;
              for (this[t3 + n2] = 255 & e4; 0 <= --n2 && (s3 *= 256); )
                this[t3 + n2] = e4 / s3 & 255;
              return t3 + r2;
            }, d.prototype.writeUInt8 = function(e4, t3, r2) {
              return e4 = +e4, t3 >>>= 0, r2 || b(this, e4, t3, 1, 255, 0), this[t3] = 255 & e4, t3 + 1;
            }, d.prototype.writeUInt16LE = function(e4, t3, r2) {
              return e4 = +e4, t3 >>>= 0, r2 || b(this, e4, t3, 2, 65535, 0), this[t3] = 255 & e4, this[t3 + 1] = e4 >>> 8, t3 + 2;
            }, d.prototype.writeUInt16BE = function(e4, t3, r2) {
              return e4 = +e4, t3 >>>= 0, r2 || b(this, e4, t3, 2, 65535, 0), this[t3] = e4 >>> 8, this[t3 + 1] = 255 & e4, t3 + 2;
            }, d.prototype.writeUInt32LE = function(e4, t3, r2) {
              return e4 = +e4, t3 >>>= 0, r2 || b(this, e4, t3, 4, 4294967295, 0), this[t3 + 3] = e4 >>> 24, this[t3 + 2] = e4 >>> 16, this[t3 + 1] = e4 >>> 8, this[t3] = 255 & e4, t3 + 4;
            }, d.prototype.writeUInt32BE = function(e4, t3, r2) {
              return e4 = +e4, t3 >>>= 0, r2 || b(this, e4, t3, 4, 4294967295, 0), this[t3] = e4 >>> 24, this[t3 + 1] = e4 >>> 16, this[t3 + 2] = e4 >>> 8, this[t3 + 3] = 255 & e4, t3 + 4;
            }, d.prototype.writeIntLE = function(e4, t3, r2, o2) {
              e4 = +e4, t3 >>>= 0, o2 || b(this, e4, t3, r2, (o2 = Math.pow(2, 8 * r2 - 1)) - 1, -o2);
              var n2 = 0, s3 = 1, i2 = 0;
              for (this[t3] = 255 & e4; ++n2 < r2 && (s3 *= 256); )
                e4 < 0 && 0 === i2 && 0 !== this[t3 + n2 - 1] && (i2 = 1), this[t3 + n2] = (e4 / s3 >> 0) - i2 & 255;
              return t3 + r2;
            }, d.prototype.writeIntBE = function(e4, t3, r2, o2) {
              e4 = +e4, t3 >>>= 0, o2 || b(this, e4, t3, r2, (o2 = Math.pow(2, 8 * r2 - 1)) - 1, -o2);
              var n2 = r2 - 1, s3 = 1, i2 = 0;
              for (this[t3 + n2] = 255 & e4; 0 <= --n2 && (s3 *= 256); )
                e4 < 0 && 0 === i2 && 0 !== this[t3 + n2 + 1] && (i2 = 1), this[t3 + n2] = (e4 / s3 >> 0) - i2 & 255;
              return t3 + r2;
            }, d.prototype.writeInt8 = function(e4, t3, r2) {
              return e4 = +e4, t3 >>>= 0, r2 || b(this, e4, t3, 1, 127, -128), this[t3] = 255 & (e4 = e4 < 0 ? 255 + e4 + 1 : e4), t3 + 1;
            }, d.prototype.writeInt16LE = function(e4, t3, r2) {
              return e4 = +e4, t3 >>>= 0, r2 || b(this, e4, t3, 2, 32767, -32768), this[t3] = 255 & e4, this[t3 + 1] = e4 >>> 8, t3 + 2;
            }, d.prototype.writeInt16BE = function(e4, t3, r2) {
              return e4 = +e4, t3 >>>= 0, r2 || b(this, e4, t3, 2, 32767, -32768), this[t3] = e4 >>> 8, this[t3 + 1] = 255 & e4, t3 + 2;
            }, d.prototype.writeInt32LE = function(e4, t3, r2) {
              return e4 = +e4, t3 >>>= 0, r2 || b(this, e4, t3, 4, 2147483647, -2147483648), this[t3] = 255 & e4, this[t3 + 1] = e4 >>> 8, this[t3 + 2] = e4 >>> 16, this[t3 + 3] = e4 >>> 24, t3 + 4;
            }, d.prototype.writeInt32BE = function(e4, t3, r2) {
              return e4 = +e4, t3 >>>= 0, r2 || b(this, e4, t3, 4, 2147483647, -2147483648), this[t3] = (e4 = e4 < 0 ? 4294967295 + e4 + 1 : e4) >>> 24, this[t3 + 1] = e4 >>> 16, this[t3 + 2] = e4 >>> 8, this[t3 + 3] = 255 & e4, t3 + 4;
            }, d.prototype.writeFloatLE = function(e4, t3, r2) {
              return _(this, e4, t3, true, r2);
            }, d.prototype.writeFloatBE = function(e4, t3, r2) {
              return _(this, e4, t3, false, r2);
            }, d.prototype.writeDoubleLE = function(e4, t3, r2) {
              return x(this, e4, t3, true, r2);
            }, d.prototype.writeDoubleBE = function(e4, t3, r2) {
              return x(this, e4, t3, false, r2);
            }, d.prototype.copy = function(e4, t3, r2, o2) {
              if (!d.isBuffer(e4))
                throw new TypeError("argument should be a Buffer");
              if (r2 = r2 || 0, o2 || 0 === o2 || (o2 = this.length), t3 >= e4.length && (t3 = e4.length), (o2 = 0 < o2 && o2 < r2 ? r2 : o2) === r2)
                return 0;
              if (0 === e4.length || 0 === this.length)
                return 0;
              if ((t3 = t3 || 0) < 0)
                throw new RangeError("targetStart out of bounds");
              if (r2 < 0 || r2 >= this.length)
                throw new RangeError("Index out of range");
              if (o2 < 0)
                throw new RangeError("sourceEnd out of bounds");
              o2 > this.length && (o2 = this.length);
              var n2 = (o2 = e4.length - t3 < o2 - r2 ? e4.length - t3 + r2 : o2) - r2;
              if (this === e4 && "function" == typeof Uint8Array.prototype.copyWithin)
                this.copyWithin(t3, r2, o2);
              else if (this === e4 && r2 < t3 && t3 < o2)
                for (var s3 = n2 - 1; 0 <= s3; --s3)
                  e4[s3 + t3] = this[s3 + r2];
              else
                Uint8Array.prototype.set.call(e4, this.subarray(r2, o2), t3);
              return n2;
            }, d.prototype.fill = function(e4, t3, r2, o2) {
              if ("string" == typeof e4) {
                if ("string" == typeof t3 ? (o2 = t3, t3 = 0, r2 = this.length) : "string" == typeof r2 && (o2 = r2, r2 = this.length), void 0 !== o2 && "string" != typeof o2)
                  throw new TypeError("encoding must be a string");
                if ("string" == typeof o2 && !d.isEncoding(o2))
                  throw new TypeError("Unknown encoding: " + o2);
                var n2;
                1 === e4.length && (n2 = e4.charCodeAt(0), ("utf8" === o2 && n2 < 128 || "latin1" === o2) && (e4 = n2));
              } else
                "number" == typeof e4 ? e4 &= 255 : "boolean" == typeof e4 && (e4 = Number(e4));
              if (t3 < 0 || this.length < t3 || this.length < r2)
                throw new RangeError("Out of range index");
              var s3;
              if (!(r2 <= t3))
                if (t3 >>>= 0, r2 = void 0 === r2 ? this.length : r2 >>> 0, "number" == typeof (e4 = e4 || 0))
                  for (s3 = t3; s3 < r2; ++s3)
                    this[s3] = e4;
                else {
                  var i2 = d.isBuffer(e4) ? e4 : d.from(e4, o2), a2 = i2.length;
                  if (0 === a2)
                    throw new TypeError('The value "' + e4 + '" is invalid for argument "value"');
                  for (s3 = 0; s3 < r2 - t3; ++s3)
                    this[s3 + t3] = i2[s3 % a2];
                }
              return this;
            };
            var w = /[^+/0-9A-Za-z-_]/g;
            function E(e4, t3) {
              t3 = t3 || 1 / 0;
              for (var r2, o2 = e4.length, n2 = null, s3 = [], i2 = 0; i2 < o2; ++i2) {
                if (55295 < (r2 = e4.charCodeAt(i2)) && r2 < 57344) {
                  if (!n2) {
                    if (56319 < r2) {
                      -1 < (t3 -= 3) && s3.push(239, 191, 189);
                      continue;
                    }
                    if (i2 + 1 === o2) {
                      -1 < (t3 -= 3) && s3.push(239, 191, 189);
                      continue;
                    }
                    n2 = r2;
                    continue;
                  }
                  if (r2 < 56320) {
                    -1 < (t3 -= 3) && s3.push(239, 191, 189), n2 = r2;
                    continue;
                  }
                  r2 = 65536 + (n2 - 55296 << 10 | r2 - 56320);
                } else
                  n2 && -1 < (t3 -= 3) && s3.push(239, 191, 189);
                if (n2 = null, r2 < 128) {
                  if (--t3 < 0)
                    break;
                  s3.push(r2);
                } else if (r2 < 2048) {
                  if ((t3 -= 2) < 0)
                    break;
                  s3.push(r2 >> 6 | 192, 63 & r2 | 128);
                } else if (r2 < 65536) {
                  if ((t3 -= 3) < 0)
                    break;
                  s3.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
                } else {
                  if (!(r2 < 1114112))
                    throw new Error("Invalid code point");
                  if ((t3 -= 4) < 0)
                    break;
                  s3.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
                }
              }
              return s3;
            }
            function T(e4) {
              return S.toByteArray(function(e5) {
                if ((e5 = (e5 = e5.split("=")[0]).trim().replace(w, "")).length < 2)
                  return "";
                for (; e5.length % 4 != 0; )
                  e5 += "=";
                return e5;
              }(e4));
            }
            function C(e4, t3, r2, o2) {
              for (var n2 = 0; n2 < o2 && !(n2 + r2 >= t3.length || n2 >= e4.length); ++n2)
                t3[n2 + r2] = e4[n2];
              return n2;
            }
            function O(e4, t3) {
              return e4 instanceof t3 || null != e4 && null != e4.constructor && null != e4.constructor.name && e4.constructor.name === t3.name;
            }
            function L(e4) {
              return e4 != e4;
            }
            var k = function() {
              for (var e4 = "0123456789abcdef", t3 = new Array(256), r2 = 0; r2 < 16; ++r2)
                for (var o2 = 16 * r2, n2 = 0; n2 < 16; ++n2)
                  t3[o2 + n2] = e4[r2] + e4[n2];
              return t3;
            }();
          }.call(this, A("buffer").Buffer);
        }, { "base64-js": 1, buffer: 4, ieee754: 238 }], 5: [function(e2, t2, r) {
          t2.exports = function(e3) {
            if ("function" != typeof e3)
              throw TypeError(String(e3) + " is not a function");
            return e3;
          };
        }, {}], 6: [function(e2, t2, r) {
          var o = e2("../internals/is-object");
          t2.exports = function(e3) {
            if (o(e3) || null === e3)
              return e3;
            throw TypeError("Can't set " + String(e3) + " as a prototype");
          };
        }, { "../internals/is-object": 74 }], 7: [function(e2, t2, r) {
          var o = e2("../internals/well-known-symbol"), n = e2("../internals/object-create"), e2 = e2("../internals/object-define-property"), s2 = o("unscopables"), i = Array.prototype;
          null == i[s2] && e2.f(i, s2, { configurable: true, value: n(null) }), t2.exports = function(e3) {
            i[s2][e3] = true;
          };
        }, { "../internals/object-create": 90, "../internals/object-define-property": 92, "../internals/well-known-symbol": 146 }], 8: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/string-multibyte").charAt;
          t2.exports = function(e3, t3, r2) {
            return t3 + (r2 ? o(e3, t3).length : 1);
          };
        }, { "../internals/string-multibyte": 123 }], 9: [function(e2, t2, r) {
          t2.exports = function(e3, t3, r2) {
            if (e3 instanceof t3)
              return e3;
            throw TypeError("Incorrect " + (r2 ? r2 + " " : "") + "invocation");
          };
        }, {}], 10: [function(e2, t2, r) {
          var o = e2("../internals/is-object");
          t2.exports = function(e3) {
            if (o(e3))
              return e3;
            throw TypeError(String(e3) + " is not an object");
          };
        }, { "../internals/is-object": 74 }], 11: [function(e2, t2, r) {
          t2.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView;
        }, {}], 12: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return l(e3) && u(E, c(e3));
          }
          var n, s2 = e2("../internals/array-buffer-native"), i = e2("../internals/descriptors"), a = e2("../internals/global"), l = e2("../internals/is-object"), u = e2("../internals/has"), c = e2("../internals/classof"), d = e2("../internals/create-non-enumerable-property"), f = e2("../internals/redefine"), h = e2("../internals/object-define-property").f, p = e2("../internals/object-get-prototype-of"), m = e2("../internals/object-set-prototype-of"), y = e2("../internals/well-known-symbol"), e2 = e2("../internals/uid"), g = a.Int8Array, v = g && g.prototype, b = a.Uint8ClampedArray, b = b && b.prototype, j = g && p(g), _ = v && p(v), x = Object.prototype, w = x.isPrototypeOf, y = y("toStringTag"), S = e2("TYPED_ARRAY_TAG"), M = s2 && !!m && "Opera" !== c(a.opera), e2 = false, E = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 };
          for (n in E)
            a[n] || (M = false);
          if ((!M || "function" != typeof j || j === Function.prototype) && (j = function() {
            throw TypeError("Incorrect invocation");
          }, M))
            for (n in E)
              a[n] && m(a[n], j);
          if ((!M || !_ || _ === x) && (_ = j.prototype, M))
            for (n in E)
              a[n] && m(a[n].prototype, _);
          if (M && p(b) !== _ && m(b, _), i && !u(_, y))
            for (n in e2 = true, h(_, y, { get: function() {
              return l(this) ? this[S] : void 0;
            } }), E)
              a[n] && d(a[n], S, n);
          t2.exports = { NATIVE_ARRAY_BUFFER_VIEWS: M, TYPED_ARRAY_TAG: e2 && S, aTypedArray: function(e3) {
            if (o(e3))
              return e3;
            throw TypeError("Target is not a typed array");
          }, aTypedArrayConstructor: function(e3) {
            if (m) {
              if (w.call(j, e3))
                return e3;
            } else
              for (var t3 in E)
                if (u(E, n)) {
                  t3 = a[t3];
                  if (t3 && (e3 === t3 || w.call(t3, e3)))
                    return e3;
                }
            throw TypeError("Target is not a typed array constructor");
          }, exportTypedArrayMethod: function(e3, t3, r2) {
            if (i) {
              if (r2)
                for (var o2 in E) {
                  o2 = a[o2];
                  o2 && u(o2.prototype, e3) && delete o2.prototype[e3];
                }
              _[e3] && !r2 || f(_, e3, !r2 && M && v[e3] || t3);
            }
          }, exportTypedArrayStaticMethod: function(e3, t3, r2) {
            var o2, n2;
            if (i) {
              if (m) {
                if (r2)
                  for (o2 in E)
                    (n2 = a[o2]) && u(n2, e3) && delete n2[e3];
                if (j[e3] && !r2)
                  return;
                try {
                  return f(j, e3, !r2 && M && g[e3] || t3);
                } catch (e4) {
                }
              }
              for (o2 in E)
                !(n2 = a[o2]) || n2[e3] && !r2 || f(n2, e3, t3);
            }
          }, isView: function(e3) {
            e3 = c(e3);
            return "DataView" === e3 || u(E, e3);
          }, isTypedArray: o, TypedArray: j, TypedArrayPrototype: _ };
        }, { "../internals/array-buffer-native": 11, "../internals/classof": 29, "../internals/create-non-enumerable-property": 38, "../internals/descriptors": 43, "../internals/global": 59, "../internals/has": 60, "../internals/is-object": 74, "../internals/object-define-property": 92, "../internals/object-get-prototype-of": 97, "../internals/object-set-prototype-of": 101, "../internals/redefine": 108, "../internals/uid": 143, "../internals/well-known-symbol": 146 }], 13: [function(e2, t2, I) {
          "use strict";
          function r(e3) {
            return [255 & e3];
          }
          function o(e3) {
            return [255 & e3, e3 >> 8 & 255];
          }
          function n(e3) {
            return [255 & e3, e3 >> 8 & 255, e3 >> 16 & 255, e3 >> 24 & 255];
          }
          function s2(e3) {
            return e3[3] << 24 | e3[2] << 16 | e3[1] << 8 | e3[0];
          }
          function i(e3) {
            return L(e3, 23, 4);
          }
          function U(e3) {
            return L(e3, 52, 8);
          }
          function a(e3, t3) {
            H(e3[w], t3, { get: function() {
              return b(this)[t3];
            } });
          }
          function l(e3, t3, r2, o2) {
            if (r2 = m(r2), e3 = b(e3), r2 + t3 > e3.byteLength)
              throw O(S);
            var n2 = b(e3.buffer).bytes, r2 = r2 + e3.byteOffset, e3 = n2.slice(r2, r2 + t3);
            return o2 ? e3 : e3.reverse();
          }
          function u(e3, t3, r2, o2, n2, s3) {
            if (r2 = m(r2), e3 = b(e3), r2 + t3 > e3.byteLength)
              throw O(S);
            for (var i2 = b(e3.buffer).bytes, a2 = r2 + e3.byteOffset, l2 = o2(+n2), u2 = 0; u2 < t3; u2++)
              i2[a2 + u2] = l2[s3 ? u2 : t3 - u2 - 1];
          }
          var c = e2("../internals/global"), d = e2("../internals/descriptors"), N = e2("../internals/array-buffer-native"), F = e2("../internals/create-non-enumerable-property"), f = e2("../internals/redefine-all"), h = e2("../internals/fails"), p = e2("../internals/an-instance"), B = e2("../internals/to-integer"), G = e2("../internals/to-length"), m = e2("../internals/to-index"), y = e2("../internals/ieee754"), V = e2("../internals/object-get-prototype-of"), g = e2("../internals/object-set-prototype-of"), z = e2("../internals/object-get-own-property-names").f, H = e2("../internals/object-define-property").f, W = e2("../internals/array-fill"), v = e2("../internals/set-to-string-tag"), e2 = e2("../internals/internal-state"), b = e2.get, j = e2.set, _ = "ArrayBuffer", x = "DataView", w = "prototype", S = "Wrong index", M = c[_], E = M, T = c[x], e2 = T && T[w], C = Object.prototype, O = c.RangeError, L = y.pack, k = y.unpack;
          if (N) {
            if (!h(function() {
              M(1);
            }) || !h(function() {
              new M(-1);
            }) || h(function() {
              return new M(), new M(1.5), new M(NaN), M.name != _;
            })) {
              for (var A, c = (E = function(e3) {
                return p(this, E), new M(m(e3));
              })[w] = M[w], P = z(M), R = 0; P.length > R; )
                (A = P[R++]) in E || F(E, A, M[A]);
              c.constructor = E;
            }
            g && V(e2) !== C && g(e2, C);
            var y = new T(new E(2)), D = e2.setInt8;
            y.setInt8(0, 2147483648), y.setInt8(1, 2147483649), !y.getInt8(0) && y.getInt8(1) || f(e2, { setInt8: function(e3, t3) {
              D.call(this, e3, t3 << 24 >> 24);
            }, setUint8: function(e3, t3) {
              D.call(this, e3, t3 << 24 >> 24);
            } }, { unsafe: true });
          } else
            E = function(e3) {
              p(this, E, _);
              e3 = m(e3);
              j(this, { bytes: W.call(new Array(e3), 0), byteLength: e3 }), d || (this.byteLength = e3);
            }, T = function(e3, t3, r2) {
              p(this, T, x), p(e3, E, x);
              var o2 = b(e3).byteLength, t3 = B(t3);
              if (t3 < 0 || o2 < t3)
                throw O("Wrong offset");
              if (o2 < t3 + (r2 = void 0 === r2 ? o2 - t3 : G(r2)))
                throw O("Wrong length");
              j(this, { buffer: e3, byteLength: r2, byteOffset: t3 }), d || (this.buffer = e3, this.byteLength = r2, this.byteOffset = t3);
            }, d && (a(E, "byteLength"), a(T, "buffer"), a(T, "byteLength"), a(T, "byteOffset")), f(T[w], { getInt8: function(e3) {
              return l(this, 1, e3)[0] << 24 >> 24;
            }, getUint8: function(e3) {
              return l(this, 1, e3)[0];
            }, getInt16: function(e3) {
              e3 = l(this, 2, e3, 1 < arguments.length ? arguments[1] : void 0);
              return (e3[1] << 8 | e3[0]) << 16 >> 16;
            }, getUint16: function(e3) {
              e3 = l(this, 2, e3, 1 < arguments.length ? arguments[1] : void 0);
              return e3[1] << 8 | e3[0];
            }, getInt32: function(e3) {
              return s2(l(this, 4, e3, 1 < arguments.length ? arguments[1] : void 0));
            }, getUint32: function(e3) {
              return s2(l(this, 4, e3, 1 < arguments.length ? arguments[1] : void 0)) >>> 0;
            }, getFloat32: function(e3) {
              return k(l(this, 4, e3, 1 < arguments.length ? arguments[1] : void 0), 23);
            }, getFloat64: function(e3) {
              return k(l(this, 8, e3, 1 < arguments.length ? arguments[1] : void 0), 52);
            }, setInt8: function(e3, t3) {
              u(this, 1, e3, r, t3);
            }, setUint8: function(e3, t3) {
              u(this, 1, e3, r, t3);
            }, setInt16: function(e3, t3) {
              u(this, 2, e3, o, t3, 2 < arguments.length ? arguments[2] : void 0);
            }, setUint16: function(e3, t3) {
              u(this, 2, e3, o, t3, 2 < arguments.length ? arguments[2] : void 0);
            }, setInt32: function(e3, t3) {
              u(this, 4, e3, n, t3, 2 < arguments.length ? arguments[2] : void 0);
            }, setUint32: function(e3, t3) {
              u(this, 4, e3, n, t3, 2 < arguments.length ? arguments[2] : void 0);
            }, setFloat32: function(e3, t3) {
              u(this, 4, e3, i, t3, 2 < arguments.length ? arguments[2] : void 0);
            }, setFloat64: function(e3, t3) {
              u(this, 8, e3, U, t3, 2 < arguments.length ? arguments[2] : void 0);
            } });
          v(E, _), v(T, x), t2.exports = { ArrayBuffer: E, DataView: T };
        }, { "../internals/an-instance": 9, "../internals/array-buffer-native": 11, "../internals/array-fill": 15, "../internals/create-non-enumerable-property": 38, "../internals/descriptors": 43, "../internals/fails": 51, "../internals/global": 59, "../internals/ieee754": 65, "../internals/internal-state": 70, "../internals/object-define-property": 92, "../internals/object-get-own-property-names": 95, "../internals/object-get-prototype-of": 97, "../internals/object-set-prototype-of": 101, "../internals/redefine-all": 107, "../internals/set-to-string-tag": 117, "../internals/to-index": 131, "../internals/to-integer": 133, "../internals/to-length": 134 }], 14: [function(e2, t2, r) {
          "use strict";
          var l = e2("../internals/to-object"), u = e2("../internals/to-absolute-index"), c = e2("../internals/to-length"), d = Math.min;
          t2.exports = [].copyWithin || function(e3, t3) {
            var r2 = l(this), o = c(r2.length), n = u(e3, o), s2 = u(t3, o), e3 = 2 < arguments.length ? arguments[2] : void 0, i = d((void 0 === e3 ? o : u(e3, o)) - s2, o - n), a = 1;
            for (s2 < n && n < s2 + i && (a = -1, s2 += i - 1, n += i - 1); 0 < i--; )
              s2 in r2 ? r2[n] = r2[s2] : delete r2[n], n += a, s2 += a;
            return r2;
          };
        }, { "../internals/to-absolute-index": 130, "../internals/to-length": 134, "../internals/to-object": 135 }], 15: [function(e2, t2, r) {
          "use strict";
          var i = e2("../internals/to-object"), a = e2("../internals/to-absolute-index"), l = e2("../internals/to-length");
          t2.exports = function(e3) {
            for (var t3 = i(this), r2 = l(t3.length), o = arguments.length, n = a(1 < o ? arguments[1] : void 0, r2), o = 2 < o ? arguments[2] : void 0, s2 = void 0 === o ? r2 : a(o, r2); n < s2; )
              t3[n++] = e3;
            return t3;
          };
        }, { "../internals/to-absolute-index": 130, "../internals/to-length": 134, "../internals/to-object": 135 }], 16: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-iteration").forEach, n = e2("../internals/array-method-is-strict"), e2 = e2("../internals/array-method-uses-to-length"), n = n("forEach"), e2 = e2("forEach");
          t2.exports = n && e2 ? [].forEach : function(e3) {
            return o(this, e3, 1 < arguments.length ? arguments[1] : void 0);
          };
        }, { "../internals/array-iteration": 19, "../internals/array-method-is-strict": 22, "../internals/array-method-uses-to-length": 23 }], 17: [function(e2, t2, r) {
          "use strict";
          var h = e2("../internals/function-bind-context"), p = e2("../internals/to-object"), m = e2("../internals/call-with-safe-iteration-closing"), y = e2("../internals/is-array-iterator-method"), g = e2("../internals/to-length"), v = e2("../internals/create-property"), b = e2("../internals/get-iterator-method");
          t2.exports = function(e3) {
            var t3, r2, o, n, s2, i, a = p(e3), e3 = "function" == typeof this ? this : Array, l = arguments.length, u = 1 < l ? arguments[1] : void 0, c = void 0 !== u, d = b(a), f = 0;
            if (c && (u = h(u, 2 < l ? arguments[2] : void 0, 2)), null == d || e3 == Array && y(d))
              for (r2 = new e3(t3 = g(a.length)); f < t3; f++)
                i = c ? u(a[f], f) : a[f], v(r2, f, i);
            else
              for (s2 = (n = d.call(a)).next, r2 = new e3(); !(o = s2.call(n)).done; f++)
                i = c ? m(n, u, [o.value, f], true) : o.value, v(r2, f, i);
            return r2.length = f, r2;
          };
        }, { "../internals/call-with-safe-iteration-closing": 26, "../internals/create-property": 40, "../internals/function-bind-context": 54, "../internals/get-iterator-method": 57, "../internals/is-array-iterator-method": 71, "../internals/to-length": 134, "../internals/to-object": 135 }], 18: [function(e2, t2, r) {
          function o(a) {
            return function(e3, t3, r2) {
              var o2, n = l(e3), s2 = u(n.length), i = c(r2, s2);
              if (a && t3 != t3) {
                for (; i < s2; )
                  if ((o2 = n[i++]) != o2)
                    return true;
              } else
                for (; i < s2; i++)
                  if ((a || i in n) && n[i] === t3)
                    return a || i || 0;
              return !a && -1;
            };
          }
          var l = e2("../internals/to-indexed-object"), u = e2("../internals/to-length"), c = e2("../internals/to-absolute-index");
          t2.exports = { includes: o(true), indexOf: o(false) };
        }, { "../internals/to-absolute-index": 130, "../internals/to-indexed-object": 132, "../internals/to-length": 134 }], 19: [function(e2, t2, r) {
          function o(f) {
            var h = 1 == f, p = 2 == f, m = 3 == f, y = 4 == f, g = 6 == f, v = 5 == f || g;
            return function(e3, t3, r2, o2) {
              for (var n, s2, i = _(e3), a = j(i), l = b(t3, r2, 3), u = x(a.length), c = 0, t3 = o2 || w, d = h ? t3(e3, u) : p ? t3(e3, 0) : void 0; c < u; c++)
                if ((v || c in a) && (s2 = l(n = a[c], c, i), f)) {
                  if (h)
                    d[c] = s2;
                  else if (s2)
                    switch (f) {
                      case 3:
                        return true;
                      case 5:
                        return n;
                      case 6:
                        return c;
                      case 2:
                        S.call(d, n);
                    }
                  else if (y)
                    return false;
                }
              return g ? -1 : m || y ? y : d;
            };
          }
          var b = e2("../internals/function-bind-context"), j = e2("../internals/indexed-object"), _ = e2("../internals/to-object"), x = e2("../internals/to-length"), w = e2("../internals/array-species-create"), S = [].push;
          t2.exports = { forEach: o(0), map: o(1), filter: o(2), some: o(3), every: o(4), find: o(5), findIndex: o(6) };
        }, { "../internals/array-species-create": 25, "../internals/function-bind-context": 54, "../internals/indexed-object": 66, "../internals/to-length": 134, "../internals/to-object": 135 }], 20: [function(e2, t2, r) {
          "use strict";
          var n = e2("../internals/to-indexed-object"), s2 = e2("../internals/to-integer"), i = e2("../internals/to-length"), o = e2("../internals/array-method-is-strict"), e2 = e2("../internals/array-method-uses-to-length"), a = Math.min, l = [].lastIndexOf, u = !!l && 1 / [1].lastIndexOf(1, -0) < 0, o = o("lastIndexOf"), e2 = e2("indexOf", { ACCESSORS: true, 1: 0 });
          t2.exports = u || !o || !e2 ? function(e3) {
            if (u)
              return l.apply(this, arguments) || 0;
            var t3 = n(this), r2 = i(t3.length), o2 = r2 - 1;
            for ((o2 = 1 < arguments.length ? a(o2, s2(arguments[1])) : o2) < 0 && (o2 = r2 + o2); 0 <= o2; o2--)
              if (o2 in t3 && t3[o2] === e3)
                return o2 || 0;
            return -1;
          } : l;
        }, { "../internals/array-method-is-strict": 22, "../internals/array-method-uses-to-length": 23, "../internals/to-indexed-object": 132, "../internals/to-integer": 133, "../internals/to-length": 134 }], 21: [function(e2, t2, r) {
          var o = e2("../internals/fails"), n = e2("../internals/well-known-symbol"), s2 = e2("../internals/engine-v8-version"), i = n("species");
          t2.exports = function(t3) {
            return 51 <= s2 || !o(function() {
              var e3 = [];
              return (e3.constructor = {})[i] = function() {
                return { foo: 1 };
              }, 1 !== e3[t3](Boolean).foo;
            });
          };
        }, { "../internals/engine-v8-version": 48, "../internals/fails": 51, "../internals/well-known-symbol": 146 }], 22: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/fails");
          t2.exports = function(e3, t3) {
            var r2 = [][e3];
            return !!r2 && o(function() {
              r2.call(null, t3 || function() {
                throw 1;
              }, 1);
            });
          };
        }, { "../internals/fails": 51 }], 23: [function(e2, t2, r) {
          function i(e3) {
            throw e3;
          }
          var a = e2("../internals/descriptors"), l = e2("../internals/fails"), u = e2("../internals/has"), c = Object.defineProperty, d = {};
          t2.exports = function(e3, t3) {
            var r2, o, n, s2;
            return u(d, e3) ? d[e3] : (r2 = [][e3], o = !!u(t3 = t3 || {}, "ACCESSORS") && t3.ACCESSORS, n = u(t3, 0) ? t3[0] : i, s2 = u(t3, 1) ? t3[1] : void 0, d[e3] = !!r2 && !l(function() {
              if (o && !a)
                return true;
              var e4 = { length: -1 };
              o ? c(e4, 1, { enumerable: true, get: i }) : e4[1] = 1, r2.call(e4, n, s2);
            }));
          };
        }, { "../internals/descriptors": 43, "../internals/fails": 51, "../internals/has": 60 }], 24: [function(e2, t2, r) {
          function o(u) {
            return function(e3, t3, r2, o2) {
              c(t3);
              var n = d(e3), s2 = f(n), i = h(n.length), a = u ? i - 1 : 0, l = u ? -1 : 1;
              if (r2 < 2)
                for (; ; ) {
                  if (a in s2) {
                    o2 = s2[a], a += l;
                    break;
                  }
                  if (a += l, u ? a < 0 : i <= a)
                    throw TypeError("Reduce of empty array with no initial value");
                }
              for (; u ? 0 <= a : a < i; a += l)
                a in s2 && (o2 = t3(o2, s2[a], a, n));
              return o2;
            };
          }
          var c = e2("../internals/a-function"), d = e2("../internals/to-object"), f = e2("../internals/indexed-object"), h = e2("../internals/to-length");
          t2.exports = { left: o(false), right: o(true) };
        }, { "../internals/a-function": 5, "../internals/indexed-object": 66, "../internals/to-length": 134, "../internals/to-object": 135 }], 25: [function(e2, t2, r) {
          var o = e2("../internals/is-object"), n = e2("../internals/is-array"), s2 = e2("../internals/well-known-symbol")("species");
          t2.exports = function(e3, t3) {
            var r2;
            return new (void 0 === (r2 = n(e3) && ("function" == typeof (r2 = e3.constructor) && (r2 === Array || n(r2.prototype)) || o(r2) && null === (r2 = r2[s2])) ? void 0 : r2) ? Array : r2)(0 === t3 ? 0 : t3);
          };
        }, { "../internals/is-array": 72, "../internals/is-object": 74, "../internals/well-known-symbol": 146 }], 26: [function(e2, t2, r) {
          var n = e2("../internals/an-object");
          t2.exports = function(t3, e3, r2, o) {
            try {
              return o ? e3(n(r2)[0], r2[1]) : e3(r2);
            } catch (e4) {
              o = t3.return;
              throw void 0 !== o && n(o.call(t3)), e4;
            }
          };
        }, { "../internals/an-object": 10 }], 27: [function(e2, t2, r) {
          var n = e2("../internals/well-known-symbol")("iterator"), s2 = false;
          try {
            var o = 0, i = { next: function() {
              return { done: !!o++ };
            }, return: function() {
              s2 = true;
            } };
            i[n] = function() {
              return this;
            }, Array.from(i, function() {
              throw 2;
            });
          } catch (e3) {
          }
          t2.exports = function(e3, t3) {
            if (!t3 && !s2)
              return false;
            var r2 = false;
            try {
              var o2 = {};
              o2[n] = function() {
                return { next: function() {
                  return { done: r2 = true };
                } };
              }, e3(o2);
            } catch (e4) {
            }
            return r2;
          };
        }, { "../internals/well-known-symbol": 146 }], 28: [function(e2, t2, r) {
          var o = {}.toString;
          t2.exports = function(e3) {
            return o.call(e3).slice(8, -1);
          };
        }, {}], 29: [function(e2, t2, r) {
          var o = e2("../internals/to-string-tag-support"), n = e2("../internals/classof-raw"), s2 = e2("../internals/well-known-symbol")("toStringTag"), i = "Arguments" == n(function() {
            return arguments;
          }());
          t2.exports = o ? n : function(e3) {
            var t3;
            return void 0 === e3 ? "Undefined" : null === e3 ? "Null" : "string" == typeof (t3 = function(e4, t4) {
              try {
                return e4[t4];
              } catch (e5) {
              }
            }(e3 = Object(e3), s2)) ? t3 : i ? n(e3) : "Object" == (t3 = n(e3)) && "function" == typeof e3.callee ? "Arguments" : t3;
          };
        }, { "../internals/classof-raw": 28, "../internals/to-string-tag-support": 139, "../internals/well-known-symbol": 146 }], 30: [function(e2, t2, r) {
          "use strict";
          var u = e2("../internals/object-define-property").f, c = e2("../internals/object-create"), d = e2("../internals/redefine-all"), f = e2("../internals/function-bind-context"), h = e2("../internals/an-instance"), p = e2("../internals/iterate"), i = e2("../internals/define-iterator"), a = e2("../internals/set-species"), m = e2("../internals/descriptors"), y = e2("../internals/internal-metadata").fastKey, e2 = e2("../internals/internal-state"), g = e2.set, v = e2.getterFor;
          t2.exports = { getConstructor: function(e3, r2, o, n) {
            function s2(e4, t3, r3) {
              var o2, n2 = l(e4), s3 = i2(e4, t3);
              return s3 ? s3.value = r3 : (n2.last = s3 = { index: o2 = y(t3, true), key: t3, value: r3, previous: t3 = n2.last, next: void 0, removed: false }, n2.first || (n2.first = s3), t3 && (t3.next = s3), m ? n2.size++ : e4.size++, "F" !== o2 && (n2.index[o2] = s3)), e4;
            }
            function i2(e4, t3) {
              var r3, e4 = l(e4), o2 = y(t3);
              if ("F" !== o2)
                return e4.index[o2];
              for (r3 = e4.first; r3; r3 = r3.next)
                if (r3.key == t3)
                  return r3;
            }
            var a2 = e3(function(e4, t3) {
              h(e4, a2, r2), g(e4, { type: r2, index: c(null), first: void 0, last: void 0, size: 0 }), m || (e4.size = 0), null != t3 && p(t3, e4[n], e4, o);
            }), l = v(r2);
            return d(a2.prototype, { clear: function() {
              for (var e4 = l(this), t3 = e4.index, r3 = e4.first; r3; )
                r3.removed = true, r3.previous && (r3.previous = r3.previous.next = void 0), delete t3[r3.index], r3 = r3.next;
              e4.first = e4.last = void 0, m ? e4.size = 0 : this.size = 0;
            }, delete: function(e4) {
              var t3, r3, o2 = l(this), e4 = i2(this, e4);
              return e4 && (t3 = e4.next, r3 = e4.previous, delete o2.index[e4.index], e4.removed = true, r3 && (r3.next = t3), t3 && (t3.previous = r3), o2.first == e4 && (o2.first = t3), o2.last == e4 && (o2.last = r3), m ? o2.size-- : this.size--), !!e4;
            }, forEach: function(e4) {
              for (var t3, r3 = l(this), o2 = f(e4, 1 < arguments.length ? arguments[1] : void 0, 3); t3 = t3 ? t3.next : r3.first; )
                for (o2(t3.value, t3.key, this); t3 && t3.removed; )
                  t3 = t3.previous;
            }, has: function(e4) {
              return !!i2(this, e4);
            } }), d(a2.prototype, o ? { get: function(e4) {
              e4 = i2(this, e4);
              return e4 && e4.value;
            }, set: function(e4, t3) {
              return s2(this, 0 === e4 ? 0 : e4, t3);
            } } : { add: function(e4) {
              return s2(this, e4 = 0 === e4 ? 0 : e4, e4);
            } }), m && u(a2.prototype, "size", { get: function() {
              return l(this).size;
            } }), a2;
          }, setStrong: function(e3, t3, r2) {
            var o = t3 + " Iterator", n = v(t3), s2 = v(o);
            i(e3, t3, function(e4, t4) {
              g(this, { type: o, target: e4, state: n(e4), kind: t4, last: void 0 });
            }, function() {
              for (var e4 = s2(this), t4 = e4.kind, r3 = e4.last; r3 && r3.removed; )
                r3 = r3.previous;
              return e4.target && (e4.last = r3 = r3 ? r3.next : e4.state.first) ? "keys" == t4 ? { value: r3.key, done: false } : "values" == t4 ? { value: r3.value, done: false } : { value: [r3.key, r3.value], done: false } : { value: e4.target = void 0, done: true };
            }, r2 ? "entries" : "values", !r2, true), a(t3);
          } };
        }, { "../internals/an-instance": 9, "../internals/define-iterator": 41, "../internals/descriptors": 43, "../internals/function-bind-context": 54, "../internals/internal-metadata": 69, "../internals/internal-state": 70, "../internals/iterate": 77, "../internals/object-create": 90, "../internals/object-define-property": 92, "../internals/redefine-all": 107, "../internals/set-species": 116 }], 31: [function(e2, t2, r) {
          "use strict";
          function l(e3) {
            return e3.frozen || (e3.frozen = new o());
          }
          function o() {
            this.entries = [];
          }
          function n(e3, t3) {
            return i(e3.entries, function(e4) {
              return e4[0] === t3;
            });
          }
          var u = e2("../internals/redefine-all"), c = e2("../internals/internal-metadata").getWeakData, d = e2("../internals/an-object"), f = e2("../internals/is-object"), h = e2("../internals/an-instance"), p = e2("../internals/iterate"), s2 = e2("../internals/array-iteration"), m = e2("../internals/has"), e2 = e2("../internals/internal-state"), y = e2.set, g = e2.getterFor, i = s2.find, a = s2.findIndex, v = 0;
          o.prototype = { get: function(e3) {
            e3 = n(this, e3);
            if (e3)
              return e3[1];
          }, has: function(e3) {
            return !!n(this, e3);
          }, set: function(e3, t3) {
            var r2 = n(this, e3);
            r2 ? r2[1] = t3 : this.entries.push([e3, t3]);
          }, delete: function(t3) {
            var e3 = a(this.entries, function(e4) {
              return e4[0] === t3;
            });
            return ~e3 && this.entries.splice(e3, 1), !!~e3;
          } }, t2.exports = { getConstructor: function(e3, r2, o2, n2) {
            function s3(e4, t3, r3) {
              var o3 = a2(e4), n3 = c(d(t3), true);
              return true === n3 ? l(o3).set(t3, r3) : n3[o3.id] = r3, e4;
            }
            var i2 = e3(function(e4, t3) {
              h(e4, i2, r2), y(e4, { type: r2, id: v++, frozen: void 0 }), null != t3 && p(t3, e4[n2], e4, o2);
            }), a2 = g(r2);
            return u(i2.prototype, { delete: function(e4) {
              var t3, r3 = a2(this);
              return !!f(e4) && (true === (t3 = c(e4)) ? l(r3).delete(e4) : t3 && m(t3, r3.id) && delete t3[r3.id]);
            }, has: function(e4) {
              var t3, r3 = a2(this);
              return !!f(e4) && (true === (t3 = c(e4)) ? l(r3).has(e4) : t3 && m(t3, r3.id));
            } }), u(i2.prototype, o2 ? { get: function(e4) {
              var t3, r3 = a2(this);
              if (f(e4))
                return true === (t3 = c(e4)) ? l(r3).get(e4) : t3 ? t3[r3.id] : void 0;
            }, set: function(e4, t3) {
              return s3(this, e4, t3);
            } } : { add: function(e4) {
              return s3(this, e4, true);
            } }), i2;
          } };
        }, { "../internals/an-instance": 9, "../internals/an-object": 10, "../internals/array-iteration": 19, "../internals/has": 60, "../internals/internal-metadata": 69, "../internals/internal-state": 70, "../internals/is-object": 74, "../internals/iterate": 77, "../internals/redefine-all": 107 }], 32: [function(e2, t2, r) {
          "use strict";
          var y = e2("../internals/export"), g = e2("../internals/global"), v = e2("../internals/is-forced"), b = e2("../internals/redefine"), j = e2("../internals/internal-metadata"), _ = e2("../internals/iterate"), x = e2("../internals/an-instance"), w = e2("../internals/is-object"), S = e2("../internals/fails"), M = e2("../internals/check-correctness-of-iteration"), E = e2("../internals/set-to-string-tag"), T = e2("../internals/inherit-if-required");
          t2.exports = function(r2, e3, t3) {
            function o(e4) {
              var r3 = h[e4];
              b(h, e4, "add" == e4 ? function(e5) {
                return r3.call(this, 0 === e5 ? 0 : e5), this;
              } : "delete" == e4 ? function(e5) {
                return !(c && !w(e5)) && r3.call(this, 0 === e5 ? 0 : e5);
              } : "get" == e4 ? function(e5) {
                return c && !w(e5) ? void 0 : r3.call(this, 0 === e5 ? 0 : e5);
              } : "has" == e4 ? function(e5) {
                return !(c && !w(e5)) && r3.call(this, 0 === e5 ? 0 : e5);
              } : function(e5, t4) {
                return r3.call(this, 0 === e5 ? 0 : e5, t4), this;
              });
            }
            var n, s2, i, a, l, u = -1 !== r2.indexOf("Map"), c = -1 !== r2.indexOf("Weak"), d = u ? "set" : "add", f = g[r2], h = f && f.prototype, p = f, m = {};
            return v(r2, "function" != typeof f || !(c || h.forEach && !S(function() {
              new f().entries().next();
            }))) ? (p = t3.getConstructor(e3, r2, u, d), j.REQUIRED = true) : v(r2, true) && (s2 = (n = new p())[d](c ? {} : -0, 1) != n, i = S(function() {
              n.has(1);
            }), a = M(function(e4) {
              new f(e4);
            }), l = !c && S(function() {
              for (var e4 = new f(), t4 = 5; t4--; )
                e4[d](t4, t4);
              return !e4.has(-0);
            }), a || (((p = e3(function(e4, t4) {
              x(e4, p, r2);
              e4 = T(new f(), e4, p);
              return null != t4 && _(t4, e4[d], e4, u), e4;
            })).prototype = h).constructor = p), (i || l) && (o("delete"), o("has"), u && o("get")), (l || s2) && o(d), c && h.clear && delete h.clear), m[r2] = p, y({ global: true, forced: p != f }, m), E(p, r2), c || t3.setStrong(p, r2, u), p;
          };
        }, { "../internals/an-instance": 9, "../internals/check-correctness-of-iteration": 27, "../internals/export": 50, "../internals/fails": 51, "../internals/global": 59, "../internals/inherit-if-required": 67, "../internals/internal-metadata": 69, "../internals/is-forced": 73, "../internals/is-object": 74, "../internals/iterate": 77, "../internals/redefine": 108, "../internals/set-to-string-tag": 117 }], 33: [function(e2, t2, r) {
          var a = e2("../internals/has"), l = e2("../internals/own-keys"), u = e2("../internals/object-get-own-property-descriptor"), c = e2("../internals/object-define-property");
          t2.exports = function(e3, t3) {
            for (var r2 = l(t3), o = c.f, n = u.f, s2 = 0; s2 < r2.length; s2++) {
              var i = r2[s2];
              a(e3, i) || o(e3, i, n(t3, i));
            }
          };
        }, { "../internals/has": 60, "../internals/object-define-property": 92, "../internals/object-get-own-property-descriptor": 93, "../internals/own-keys": 103 }], 34: [function(e2, t2, r) {
          var o = e2("../internals/well-known-symbol")("match");
          t2.exports = function(t3) {
            var r2 = /./;
            try {
              "/./"[t3](r2);
            } catch (e3) {
              try {
                return r2[o] = false, "/./"[t3](r2);
              } catch (e4) {
              }
            }
            return false;
          };
        }, { "../internals/well-known-symbol": 146 }], 35: [function(e2, t2, r) {
          e2 = e2("../internals/fails");
          t2.exports = !e2(function() {
            function e3() {
            }
            return e3.prototype.constructor = null, Object.getPrototypeOf(new e3()) !== e3.prototype;
          });
        }, { "../internals/fails": 51 }], 36: [function(e2, t2, r) {
          var s2 = e2("../internals/require-object-coercible"), i = /"/g;
          t2.exports = function(e3, t3, r2, o) {
            var e3 = String(s2(e3)), n = "<" + t3;
            return "" !== r2 && (n += " " + r2 + '="' + String(o).replace(i, "&quot;") + '"'), n + ">" + e3 + "</" + t3 + ">";
          };
        }, { "../internals/require-object-coercible": 113 }], 37: [function(e2, t2, r) {
          "use strict";
          function o() {
            return this;
          }
          var n = e2("../internals/iterators-core").IteratorPrototype, s2 = e2("../internals/object-create"), i = e2("../internals/create-property-descriptor"), a = e2("../internals/set-to-string-tag"), l = e2("../internals/iterators");
          t2.exports = function(e3, t3, r2) {
            t3 += " Iterator";
            return e3.prototype = s2(n, { next: i(1, r2) }), a(e3, t3, false, true), l[t3] = o, e3;
          };
        }, { "../internals/create-property-descriptor": 39, "../internals/iterators": 79, "../internals/iterators-core": 78, "../internals/object-create": 90, "../internals/set-to-string-tag": 117 }], 38: [function(e2, t2, r) {
          var o = e2("../internals/descriptors"), n = e2("../internals/object-define-property"), s2 = e2("../internals/create-property-descriptor");
          t2.exports = o ? function(e3, t3, r2) {
            return n.f(e3, t3, s2(1, r2));
          } : function(e3, t3, r2) {
            return e3[t3] = r2, e3;
          };
        }, { "../internals/create-property-descriptor": 39, "../internals/descriptors": 43, "../internals/object-define-property": 92 }], 39: [function(e2, t2, r) {
          t2.exports = function(e3, t3) {
            return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t3 };
          };
        }, {}], 40: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/to-primitive"), n = e2("../internals/object-define-property"), s2 = e2("../internals/create-property-descriptor");
          t2.exports = function(e3, t3, r2) {
            t3 = o(t3);
            t3 in e3 ? n.f(e3, t3, s2(0, r2)) : e3[t3] = r2;
          };
        }, { "../internals/create-property-descriptor": 39, "../internals/object-define-property": 92, "../internals/to-primitive": 138 }], 41: [function(e2, t2, r) {
          "use strict";
          function m() {
            return this;
          }
          var y = e2("../internals/export"), g = e2("../internals/create-iterator-constructor"), v = e2("../internals/object-get-prototype-of"), b = e2("../internals/object-set-prototype-of"), j = e2("../internals/set-to-string-tag"), _ = e2("../internals/create-non-enumerable-property"), x = e2("../internals/redefine"), o = e2("../internals/well-known-symbol"), w = e2("../internals/is-pure"), S = e2("../internals/iterators"), e2 = e2("../internals/iterators-core"), M = e2.IteratorPrototype, E = e2.BUGGY_SAFARI_ITERATORS, T = o("iterator"), C = "values", O = "entries";
          t2.exports = function(e3, t3, r2, o2, n, s2, i) {
            g(r2, t3, o2);
            function a(e4) {
              if (e4 === n && h)
                return h;
              if (!E && e4 in d)
                return d[e4];
              switch (e4) {
                case "keys":
                case C:
                case O:
                  return function() {
                    return new r2(this, e4);
                  };
              }
              return function() {
                return new r2(this);
              };
            }
            var l, u, o2 = t3 + " Iterator", c = false, d = e3.prototype, f = d[T] || d["@@iterator"] || n && d[n], h = !E && f || a(n), p = "Array" == t3 && d.entries || f;
            if (p && (p = v(p.call(new e3())), M !== Object.prototype && p.next && (w || v(p) === M || (b ? b(p, M) : "function" != typeof p[T] && _(p, T, m)), j(p, o2, true, true), w && (S[o2] = m))), n == C && f && f.name !== C && (c = true, h = function() {
              return f.call(this);
            }), w && !i || d[T] === h || _(d, T, h), S[t3] = h, n)
              if (l = { values: a(C), keys: s2 ? h : a("keys"), entries: a(O) }, i)
                for (u in l)
                  !E && !c && u in d || x(d, u, l[u]);
              else
                y({ target: t3, proto: true, forced: E || c }, l);
            return l;
          };
        }, { "../internals/create-iterator-constructor": 37, "../internals/create-non-enumerable-property": 38, "../internals/export": 50, "../internals/is-pure": 75, "../internals/iterators": 79, "../internals/iterators-core": 78, "../internals/object-get-prototype-of": 97, "../internals/object-set-prototype-of": 101, "../internals/redefine": 108, "../internals/set-to-string-tag": 117, "../internals/well-known-symbol": 146 }], 42: [function(e2, t2, r) {
          var o = e2("../internals/path"), n = e2("../internals/has"), s2 = e2("../internals/well-known-symbol-wrapped"), i = e2("../internals/object-define-property").f;
          t2.exports = function(e3) {
            var t3 = o.Symbol || (o.Symbol = {});
            n(t3, e3) || i(t3, e3, { value: s2.f(e3) });
          };
        }, { "../internals/has": 60, "../internals/object-define-property": 92, "../internals/path": 104, "../internals/well-known-symbol-wrapped": 145 }], 43: [function(e2, t2, r) {
          e2 = e2("../internals/fails");
          t2.exports = !e2(function() {
            return 7 != Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1];
          });
        }, { "../internals/fails": 51 }], 44: [function(e2, t2, r) {
          var o = e2("../internals/global"), e2 = e2("../internals/is-object"), n = o.document, s2 = e2(n) && e2(n.createElement);
          t2.exports = function(e3) {
            return s2 ? n.createElement(e3) : {};
          };
        }, { "../internals/global": 59, "../internals/is-object": 74 }], 45: [function(e2, t2, r) {
          t2.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
        }, {}], 46: [function(e2, t2, r) {
          e2 = e2("../internals/engine-user-agent");
          t2.exports = /(iphone|ipod|ipad).*applewebkit/i.test(e2);
        }, { "../internals/engine-user-agent": 47 }], 47: [function(e2, t2, r) {
          e2 = e2("../internals/get-built-in");
          t2.exports = e2("navigator", "userAgent") || "";
        }, { "../internals/get-built-in": 56 }], 48: [function(e2, t2, r) {
          var o, n, s2 = e2("../internals/global"), e2 = e2("../internals/engine-user-agent"), s2 = s2.process, s2 = s2 && s2.versions, s2 = s2 && s2.v8;
          s2 ? n = (o = s2.split("."))[0] + o[1] : e2 && (!(o = e2.match(/Edge\/(\d+)/)) || 74 <= o[1]) && (o = e2.match(/Chrome\/(\d+)/)) && (n = o[1]), t2.exports = n && +n;
        }, { "../internals/engine-user-agent": 47, "../internals/global": 59 }], 49: [function(e2, t2, r) {
          t2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
        }, {}], 50: [function(e2, t2, r) {
          var u = e2("../internals/global"), c = e2("../internals/object-get-own-property-descriptor").f, d = e2("../internals/create-non-enumerable-property"), f = e2("../internals/redefine"), h = e2("../internals/set-global"), p = e2("../internals/copy-constructor-properties"), m = e2("../internals/is-forced");
          t2.exports = function(e3, t3) {
            var r2, o, n, s2 = e3.target, i = e3.global, a = e3.stat, l = i ? u : a ? u[s2] || h(s2, {}) : (u[s2] || {}).prototype;
            if (l)
              for (r2 in t3) {
                if (o = t3[r2], n = e3.noTargetGet ? (n = c(l, r2)) && n.value : l[r2], !m(i ? r2 : s2 + (a ? "." : "#") + r2, e3.forced) && void 0 !== n) {
                  if (typeof o == typeof n)
                    continue;
                  p(o, n);
                }
                (e3.sham || n && n.sham) && d(o, "sham", true), f(l, r2, o, e3);
              }
          };
        }, { "../internals/copy-constructor-properties": 33, "../internals/create-non-enumerable-property": 38, "../internals/global": 59, "../internals/is-forced": 73, "../internals/object-get-own-property-descriptor": 93, "../internals/redefine": 108, "../internals/set-global": 115 }], 51: [function(e2, t2, r) {
          t2.exports = function(e3) {
            try {
              return !!e3();
            } catch (e4) {
              return true;
            }
          };
        }, {}], 52: [function(e2, t2, r) {
          "use strict";
          e2("../modules/es.regexp.exec");
          var u = e2("../internals/redefine"), c = e2("../internals/fails"), d = e2("../internals/well-known-symbol"), f = e2("../internals/regexp-exec"), h = e2("../internals/create-non-enumerable-property"), p = d("species"), m = !c(function() {
            var e3 = /./;
            return e3.exec = function() {
              var e4 = [];
              return e4.groups = { a: "7" }, e4;
            }, "7" !== "".replace(e3, "$<a>");
          }), y = "$0" === "a".replace(/./, "$0"), e2 = d("replace"), g = !!/./[e2] && "" === /./[e2]("a", "$0"), v = !c(function() {
            var e3 = /(?:)/, t3 = e3.exec, e3 = (e3.exec = function() {
              return t3.apply(this, arguments);
            }, "ab".split(e3));
            return 2 !== e3.length || "a" !== e3[0] || "b" !== e3[1];
          });
          t2.exports = function(r2, e3, t3, o) {
            var s2, n, i = d(r2), a = !c(function() {
              var e4 = {};
              return e4[i] = function() {
                return 7;
              }, 7 != ""[r2](e4);
            }), l = a && !c(function() {
              var e4 = false, t4 = /a/;
              return "split" === r2 && ((t4 = { constructor: {} }).constructor[p] = function() {
                return t4;
              }, t4.flags = "", t4[i] = /./[i]), t4.exec = function() {
                return e4 = true, null;
              }, t4[i](""), !e4;
            });
            a && l && ("replace" !== r2 || m && y && !g) && ("split" !== r2 || v) || (s2 = /./[i], t3 = (l = t3(i, ""[r2], function(e4, t4, r3, o2, n2) {
              return t4.exec === f ? a && !n2 ? { done: true, value: s2.call(t4, r3, o2) } : { done: true, value: e4.call(r3, t4, o2) } : { done: false };
            }, { REPLACE_KEEPS_$0: y, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: g }))[0], n = l[1], u(String.prototype, r2, t3), u(RegExp.prototype, i, 2 == e3 ? function(e4, t4) {
              return n.call(e4, this, t4);
            } : function(e4) {
              return n.call(e4, this);
            })), o && h(RegExp.prototype[i], "sham", true);
          };
        }, { "../internals/create-non-enumerable-property": 38, "../internals/fails": 51, "../internals/redefine": 108, "../internals/regexp-exec": 110, "../internals/well-known-symbol": 146, "../modules/es.regexp.exec": 181 }], 53: [function(e2, t2, r) {
          e2 = e2("../internals/fails");
          t2.exports = !e2(function() {
            return Object.isExtensible(Object.preventExtensions({}));
          });
        }, { "../internals/fails": 51 }], 54: [function(e2, t2, r) {
          var s2 = e2("../internals/a-function");
          t2.exports = function(o, n, e3) {
            if (s2(o), void 0 === n)
              return o;
            switch (e3) {
              case 0:
                return function() {
                  return o.call(n);
                };
              case 1:
                return function(e4) {
                  return o.call(n, e4);
                };
              case 2:
                return function(e4, t3) {
                  return o.call(n, e4, t3);
                };
              case 3:
                return function(e4, t3, r2) {
                  return o.call(n, e4, t3, r2);
                };
            }
            return function() {
              return o.apply(n, arguments);
            };
          };
        }, { "../internals/a-function": 5 }], 55: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/a-function"), n = e2("../internals/is-object"), c = [].slice, d = {};
          t2.exports = Function.bind || function(i) {
            var a = o(this), l = c.call(arguments, 1), u = function() {
              var e3 = l.concat(c.call(arguments));
              if (this instanceof u) {
                var t3 = a, r2 = e3.length, o2 = e3;
                if (!(r2 in d)) {
                  for (var n2 = [], s2 = 0; s2 < r2; s2++)
                    n2[s2] = "a[" + s2 + "]";
                  d[r2] = Function("C,a", "return new C(" + n2.join(",") + ")");
                }
                return d[r2](t3, o2);
              }
              return a.apply(i, e3);
            };
            return n(a.prototype) && (u.prototype = a.prototype), u;
          };
        }, { "../internals/a-function": 5, "../internals/is-object": 74 }], 56: [function(e2, t2, r) {
          function o(e3) {
            return "function" == typeof e3 ? e3 : void 0;
          }
          var n = e2("../internals/path"), s2 = e2("../internals/global");
          t2.exports = function(e3, t3) {
            return arguments.length < 2 ? o(n[e3]) || o(s2[e3]) : n[e3] && n[e3][t3] || s2[e3] && s2[e3][t3];
          };
        }, { "../internals/global": 59, "../internals/path": 104 }], 57: [function(e2, t2, r) {
          var o = e2("../internals/classof"), n = e2("../internals/iterators"), s2 = e2("../internals/well-known-symbol")("iterator");
          t2.exports = function(e3) {
            if (null != e3)
              return e3[s2] || e3["@@iterator"] || n[o(e3)];
          };
        }, { "../internals/classof": 29, "../internals/iterators": 79, "../internals/well-known-symbol": 146 }], 58: [function(e2, t2, r) {
          var o = e2("../internals/an-object"), n = e2("../internals/get-iterator-method");
          t2.exports = function(e3) {
            var t3 = n(e3);
            if ("function" != typeof t3)
              throw TypeError(String(e3) + " is not iterable");
            return o(t3.call(e3));
          };
        }, { "../internals/an-object": 10, "../internals/get-iterator-method": 57 }], 59: [function(e2, r, t2) {
          !function(e3) {
            function t3(e4) {
              return e4 && e4.Math == Math && e4;
            }
            r.exports = t3("object" == typeof globalThis && globalThis) || t3("object" == typeof window && window) || t3("object" == typeof self && self) || t3("object" == typeof e3 && e3) || Function("return this")();
          }.call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, {}], 60: [function(e2, t2, r) {
          var o = {}.hasOwnProperty;
          t2.exports = function(e3, t3) {
            return o.call(e3, t3);
          };
        }, {}], 61: [function(e2, t2, r) {
          t2.exports = {};
        }, {}], 62: [function(e2, t2, r) {
          var o = e2("../internals/global");
          t2.exports = function(e3, t3) {
            var r2 = o.console;
            r2 && r2.error && (1 === arguments.length ? r2.error(e3) : r2.error(e3, t3));
          };
        }, { "../internals/global": 59 }], 63: [function(e2, t2, r) {
          e2 = e2("../internals/get-built-in");
          t2.exports = e2("document", "documentElement");
        }, { "../internals/get-built-in": 56 }], 64: [function(e2, t2, r) {
          var o = e2("../internals/descriptors"), n = e2("../internals/fails"), s2 = e2("../internals/document-create-element");
          t2.exports = !o && !n(function() {
            return 7 != Object.defineProperty(s2("div"), "a", { get: function() {
              return 7;
            } }).a;
          });
        }, { "../internals/descriptors": 43, "../internals/document-create-element": 44, "../internals/fails": 51 }], 65: [function(e2, t2, r) {
          var f = Math.abs, h = Math.pow, p = Math.floor, m = Math.log, y = Math.LN2;
          t2.exports = { pack: function(e3, t3, r2) {
            var o, n, s2, i = new Array(r2), a = 8 * r2 - t3 - 1, r2 = (1 << a) - 1, l = r2 >> 1, u = 23 === t3 ? h(2, -24) - h(2, -77) : 0, c = e3 < 0 || 0 === e3 && 1 / e3 < 0 ? 1 : 0, d = 0;
            for ((e3 = f(e3)) != e3 || e3 === 1 / 0 ? (n = e3 != e3 ? 1 : 0, o = r2) : (o = p(m(e3) / y), e3 * (s2 = h(2, -o)) < 1 && (o--, s2 *= 2), 2 <= (e3 += 1 <= o + l ? u / s2 : u * h(2, 1 - l)) * s2 && (o++, s2 /= 2), r2 <= o + l ? (n = 0, o = r2) : 1 <= o + l ? (n = (e3 * s2 - 1) * h(2, t3), o += l) : (n = e3 * h(2, l - 1) * h(2, t3), o = 0)); 8 <= t3; i[d++] = 255 & n, n /= 256, t3 -= 8)
              ;
            for (o = o << t3 | n, a += t3; 0 < a; i[d++] = 255 & o, o /= 256, a -= 8)
              ;
            return i[--d] |= 128 * c, i;
          }, unpack: function(e3, t3) {
            var r2, o = e3.length, n = 8 * o - t3 - 1, s2 = (1 << n) - 1, i = s2 >> 1, a = n - 7, l = o - 1, n = e3[l--], u = 127 & n;
            for (n >>= 7; 0 < a; u = 256 * u + e3[l], l--, a -= 8)
              ;
            for (r2 = u & (1 << -a) - 1, u >>= -a, a += t3; 0 < a; r2 = 256 * r2 + e3[l], l--, a -= 8)
              ;
            if (0 === u)
              u = 1 - i;
            else {
              if (u === s2)
                return r2 ? NaN : n ? -1 / 0 : 1 / 0;
              r2 += h(2, t3), u -= i;
            }
            return (n ? -1 : 1) * r2 * h(2, u - t3);
          } };
        }, {}], 66: [function(e2, t2, r) {
          var o = e2("../internals/fails"), n = e2("../internals/classof-raw"), s2 = "".split;
          t2.exports = o(function() {
            return !Object("z").propertyIsEnumerable(0);
          }) ? function(e3) {
            return "String" == n(e3) ? s2.call(e3, "") : Object(e3);
          } : Object;
        }, { "../internals/classof-raw": 28, "../internals/fails": 51 }], 67: [function(e2, t2, r) {
          var o = e2("../internals/is-object"), n = e2("../internals/object-set-prototype-of");
          t2.exports = function(e3, t3, r2) {
            return n && "function" == typeof (t3 = t3.constructor) && t3 !== r2 && o(t3 = t3.prototype) && t3 !== r2.prototype && n(e3, t3), e3;
          };
        }, { "../internals/is-object": 74, "../internals/object-set-prototype-of": 101 }], 68: [function(e2, t2, r) {
          var e2 = e2("../internals/shared-store"), o = Function.toString;
          "function" != typeof e2.inspectSource && (e2.inspectSource = function(e3) {
            return o.call(e3);
          }), t2.exports = e2.inspectSource;
        }, { "../internals/shared-store": 119 }], 69: [function(e2, t2, r) {
          function o(e3) {
            a(e3, c, { value: { objectID: "O" + ++d, weakData: {} } });
          }
          var n = e2("../internals/hidden-keys"), s2 = e2("../internals/is-object"), i = e2("../internals/has"), a = e2("../internals/object-define-property").f, l = e2("../internals/uid"), u = e2("../internals/freezing"), c = l("meta"), d = 0, f = Object.isExtensible || function() {
            return true;
          }, h = t2.exports = { REQUIRED: false, fastKey: function(e3, t3) {
            if (!s2(e3))
              return "symbol" == typeof e3 ? e3 : ("string" == typeof e3 ? "S" : "P") + e3;
            if (!i(e3, c)) {
              if (!f(e3))
                return "F";
              if (!t3)
                return "E";
              o(e3);
            }
            return e3[c].objectID;
          }, getWeakData: function(e3, t3) {
            if (!i(e3, c)) {
              if (!f(e3))
                return true;
              if (!t3)
                return false;
              o(e3);
            }
            return e3[c].weakData;
          }, onFreeze: function(e3) {
            return u && h.REQUIRED && f(e3) && !i(e3, c) && o(e3), e3;
          } };
          n[c] = true;
        }, { "../internals/freezing": 53, "../internals/has": 60, "../internals/hidden-keys": 61, "../internals/is-object": 74, "../internals/object-define-property": 92, "../internals/uid": 143 }], 70: [function(e2, t2, r) {
          var o, n, s2, i, a, l, u, c, d = e2("../internals/native-weak-map"), f = e2("../internals/global"), h = e2("../internals/is-object"), p = e2("../internals/create-non-enumerable-property"), m = e2("../internals/has"), y = e2("../internals/shared-key"), e2 = e2("../internals/hidden-keys"), f = f.WeakMap;
          u = d ? (o = new f(), n = o.get, s2 = o.has, i = o.set, a = function(e3, t3) {
            return i.call(o, e3, t3), t3;
          }, l = function(e3) {
            return n.call(o, e3) || {};
          }, function(e3) {
            return s2.call(o, e3);
          }) : (e2[c = y("state")] = true, a = function(e3, t3) {
            return p(e3, c, t3), t3;
          }, l = function(e3) {
            return m(e3, c) ? e3[c] : {};
          }, function(e3) {
            return m(e3, c);
          }), t2.exports = { set: a, get: l, has: u, enforce: function(e3) {
            return u(e3) ? l(e3) : a(e3, {});
          }, getterFor: function(t3) {
            return function(e3) {
              if (h(e3) && (e3 = l(e3)).type === t3)
                return e3;
              throw TypeError("Incompatible receiver, " + t3 + " required");
            };
          } };
        }, { "../internals/create-non-enumerable-property": 38, "../internals/global": 59, "../internals/has": 60, "../internals/hidden-keys": 61, "../internals/is-object": 74, "../internals/native-weak-map": 85, "../internals/shared-key": 118 }], 71: [function(e2, t2, r) {
          var o = e2("../internals/well-known-symbol"), n = e2("../internals/iterators"), s2 = o("iterator"), i = Array.prototype;
          t2.exports = function(e3) {
            return void 0 !== e3 && (n.Array === e3 || i[s2] === e3);
          };
        }, { "../internals/iterators": 79, "../internals/well-known-symbol": 146 }], 72: [function(e2, t2, r) {
          var o = e2("../internals/classof-raw");
          t2.exports = Array.isArray || function(e3) {
            return "Array" == o(e3);
          };
        }, { "../internals/classof-raw": 28 }], 73: [function(e2, t2, r) {
          function o(e3, t3) {
            return (e3 = a[i(e3)]) == u || e3 != l && ("function" == typeof t3 ? n(t3) : !!t3);
          }
          var n = e2("../internals/fails"), s2 = /#|\.prototype\./, i = o.normalize = function(e3) {
            return String(e3).replace(s2, ".").toLowerCase();
          }, a = o.data = {}, l = o.NATIVE = "N", u = o.POLYFILL = "P";
          t2.exports = o;
        }, { "../internals/fails": 51 }], 74: [function(e2, t2, r) {
          t2.exports = function(e3) {
            return "object" == typeof e3 ? null !== e3 : "function" == typeof e3;
          };
        }, {}], 75: [function(e2, t2, r) {
          t2.exports = false;
        }, {}], 76: [function(e2, t2, r) {
          var o = e2("../internals/is-object"), n = e2("../internals/classof-raw"), s2 = e2("../internals/well-known-symbol")("match");
          t2.exports = function(e3) {
            var t3;
            return o(e3) && (void 0 !== (t3 = e3[s2]) ? !!t3 : "RegExp" == n(e3));
          };
        }, { "../internals/classof-raw": 28, "../internals/is-object": 74, "../internals/well-known-symbol": 146 }], 77: [function(e2, t2, r) {
          function f(e3, t3) {
            this.stopped = e3, this.result = t3;
          }
          var h = e2("../internals/an-object"), p = e2("../internals/is-array-iterator-method"), m = e2("../internals/to-length"), y = e2("../internals/function-bind-context"), g = e2("../internals/get-iterator-method"), v = e2("../internals/call-with-safe-iteration-closing");
          (t2.exports = function(e3, t3, r2, o, n) {
            var s2, i, a, l, u, c, d = y(t3, r2, o ? 2 : 1);
            if (n)
              s2 = e3;
            else {
              if ("function" != typeof (t3 = g(e3)))
                throw TypeError("Target is not iterable");
              if (p(t3)) {
                for (i = 0, a = m(e3.length); i < a; i++)
                  if ((l = o ? d(h(c = e3[i])[0], c[1]) : d(e3[i])) && l instanceof f)
                    return l;
                return new f(false);
              }
              s2 = t3.call(e3);
            }
            for (u = s2.next; !(c = u.call(s2)).done; )
              if ("object" == typeof (l = v(s2, d, c.value, o)) && l && l instanceof f)
                return l;
            return new f(false);
          }).stop = function(e3) {
            return new f(true, e3);
          };
        }, { "../internals/an-object": 10, "../internals/call-with-safe-iteration-closing": 26, "../internals/function-bind-context": 54, "../internals/get-iterator-method": 57, "../internals/is-array-iterator-method": 71, "../internals/to-length": 134 }], 78: [function(e2, t2, r) {
          "use strict";
          var o, n, s2 = e2("../internals/object-get-prototype-of"), i = e2("../internals/create-non-enumerable-property"), a = e2("../internals/has"), l = e2("../internals/well-known-symbol"), e2 = e2("../internals/is-pure"), l = l("iterator"), u = false;
          [].keys && ("next" in (n = [].keys()) ? (s2 = s2(s2(n))) !== Object.prototype && (o = s2) : u = true), null == o && (o = {}), e2 || a(o, l) || i(o, l, function() {
            return this;
          }), t2.exports = { IteratorPrototype: o, BUGGY_SAFARI_ITERATORS: u };
        }, { "../internals/create-non-enumerable-property": 38, "../internals/has": 60, "../internals/is-pure": 75, "../internals/object-get-prototype-of": 97, "../internals/well-known-symbol": 146 }], 79: [function(e2, t2, r) {
          t2.exports = {};
        }, {}], 80: [function(e2, t2, r) {
          t2.exports = Math.sign || function(e3) {
            return 0 == (e3 = +e3) || e3 != e3 ? e3 : e3 < 0 ? -1 : 1;
          };
        }, {}], 81: [function(e2, t2, r) {
          var o, n, s2, i, a, l, u, c, d = e2("../internals/global"), f = e2("../internals/object-get-own-property-descriptor").f, h = e2("../internals/classof-raw"), p = e2("../internals/task").set, e2 = e2("../internals/engine-is-ios"), m = d.MutationObserver || d.WebKitMutationObserver, y = d.process, g = d.Promise, v = "process" == h(y), h = f(d, "queueMicrotask"), f = h && h.value;
          f || (o = function() {
            var e3, t3;
            for (v && (e3 = y.domain) && e3.exit(); n; ) {
              t3 = n.fn, n = n.next;
              try {
                t3();
              } catch (e4) {
                throw n ? i() : s2 = void 0, e4;
              }
            }
            s2 = void 0, e3 && e3.enter();
          }, i = v ? function() {
            y.nextTick(o);
          } : m && !e2 ? (a = true, l = document.createTextNode(""), new m(o).observe(l, { characterData: true }), function() {
            l.data = a = !a;
          }) : g && g.resolve ? (u = g.resolve(void 0), c = u.then, function() {
            c.call(u, o);
          }) : function() {
            p.call(d, o);
          }), t2.exports = f || function(e3) {
            e3 = { fn: e3, next: void 0 };
            s2 && (s2.next = e3), n || (n = e3, i()), s2 = e3;
          };
        }, { "../internals/classof-raw": 28, "../internals/engine-is-ios": 46, "../internals/global": 59, "../internals/object-get-own-property-descriptor": 93, "../internals/task": 128 }], 82: [function(e2, t2, r) {
          e2 = e2("../internals/global");
          t2.exports = e2.Promise;
        }, { "../internals/global": 59 }], 83: [function(e2, t2, r) {
          e2 = e2("../internals/fails");
          t2.exports = !!Object.getOwnPropertySymbols && !e2(function() {
            return !String(Symbol());
          });
        }, { "../internals/fails": 51 }], 84: [function(e2, t2, r) {
          var o = e2("../internals/fails"), n = e2("../internals/well-known-symbol"), s2 = e2("../internals/is-pure"), i = n("iterator");
          t2.exports = !o(function() {
            var e3 = new URL("b?a=1&b=2&c=3", "http://a"), r2 = e3.searchParams, o2 = "";
            return e3.pathname = "c%20d", r2.forEach(function(e4, t3) {
              r2.delete("b"), o2 += t3 + e4;
            }), s2 && !e3.toJSON || !r2.sort || "http://a/c%20d?a=1&c=3" !== e3.href || "3" !== r2.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !r2[i] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://\u0442\u0435\u0441\u0442").host || "#%D0%B1" !== new URL("http://a#\u0431").hash || "a1c3" !== o2 || "x" !== new URL("http://x", void 0).host;
          });
        }, { "../internals/fails": 51, "../internals/is-pure": 75, "../internals/well-known-symbol": 146 }], 85: [function(e2, t2, r) {
          var o = e2("../internals/global"), e2 = e2("../internals/inspect-source"), o = o.WeakMap;
          t2.exports = "function" == typeof o && /native code/.test(e2(o));
        }, { "../internals/global": 59, "../internals/inspect-source": 68 }], 86: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            var r2, o2;
            this.promise = new e3(function(e4, t3) {
              if (void 0 !== r2 || void 0 !== o2)
                throw TypeError("Bad Promise constructor");
              r2 = e4, o2 = t3;
            }), this.resolve = n(r2), this.reject = n(o2);
          }
          var n = e2("../internals/a-function");
          t2.exports.f = function(e3) {
            return new o(e3);
          };
        }, { "../internals/a-function": 5 }], 87: [function(e2, t2, r) {
          var o = e2("../internals/is-regexp");
          t2.exports = function(e3) {
            if (o(e3))
              throw TypeError("The method doesn't accept regular expressions");
            return e3;
          };
        }, { "../internals/is-regexp": 76 }], 88: [function(e2, t2, r) {
          var o = e2("../internals/global").isFinite;
          t2.exports = Number.isFinite || function(e3) {
            return "number" == typeof e3 && o(e3);
          };
        }, { "../internals/global": 59 }], 89: [function(e2, t2, r) {
          "use strict";
          var f = e2("../internals/descriptors"), o = e2("../internals/fails"), h = e2("../internals/object-keys"), p = e2("../internals/object-get-own-property-symbols"), m = e2("../internals/object-property-is-enumerable"), y = e2("../internals/to-object"), g = e2("../internals/indexed-object"), n = Object.assign, s2 = Object.defineProperty;
          t2.exports = !n || o(function() {
            var e3, t3, r2, o2;
            return !(!f || 1 === n({ b: 1 }, n(s2({}, "a", { enumerable: true, get: function() {
              s2(this, "b", { value: 3, enumerable: false });
            } }), { b: 2 })).b) || (t3 = {}, o2 = "abcdefghijklmnopqrst", (e3 = {})[r2 = Symbol()] = 7, o2.split("").forEach(function(e4) {
              t3[e4] = e4;
            }), 7 != n({}, e3)[r2] || h(n({}, t3)).join("") != o2);
          }) ? function(e3, t3) {
            for (var r2 = y(e3), o2 = arguments.length, n2 = 1, s3 = p.f, i = m.f; n2 < o2; )
              for (var a, l = g(arguments[n2++]), u = s3 ? h(l).concat(s3(l)) : h(l), c = u.length, d = 0; d < c; )
                a = u[d++], f && !i.call(l, a) || (r2[a] = l[a]);
            return r2;
          } : n;
        }, { "../internals/descriptors": 43, "../internals/fails": 51, "../internals/indexed-object": 66, "../internals/object-get-own-property-symbols": 96, "../internals/object-keys": 99, "../internals/object-property-is-enumerable": 100, "../internals/to-object": 135 }], 90: [function(e2, t2, r) {
          function o() {
          }
          var n, s2 = e2("../internals/an-object"), i = e2("../internals/object-define-properties"), a = e2("../internals/enum-bug-keys"), l = e2("../internals/hidden-keys"), u = e2("../internals/html"), c = e2("../internals/document-create-element"), e2 = e2("../internals/shared-key"), d = "prototype", f = "script", h = e2("IE_PROTO"), p = function(e3) {
            return "<" + f + ">" + e3 + "</" + f + ">";
          }, m = function() {
            try {
              n = document.domain && new ActiveXObject("htmlfile");
            } catch (e4) {
            }
            m = n ? ((e3 = n).write(p("")), e3.close(), t3 = e3.parentWindow.Object, e3 = null, t3) : (e3 = c("iframe"), t3 = "java" + f + ":", e3.style.display = "none", u.appendChild(e3), e3.src = String(t3), (t3 = e3.contentWindow.document).open(), t3.write(p("document.F=Object")), t3.close(), t3.F);
            for (var e3, t3, r2 = a.length; r2--; )
              delete m[d][a[r2]];
            return m();
          };
          l[h] = true, t2.exports = Object.create || function(e3, t3) {
            var r2;
            return null !== e3 ? (o[d] = s2(e3), r2 = new o(), o[d] = null, r2[h] = e3) : r2 = m(), void 0 === t3 ? r2 : i(r2, t3);
          };
        }, { "../internals/an-object": 10, "../internals/document-create-element": 44, "../internals/enum-bug-keys": 49, "../internals/hidden-keys": 61, "../internals/html": 63, "../internals/object-define-properties": 91, "../internals/shared-key": 118 }], 91: [function(e2, t2, r) {
          var o = e2("../internals/descriptors"), i = e2("../internals/object-define-property"), a = e2("../internals/an-object"), l = e2("../internals/object-keys");
          t2.exports = o ? Object.defineProperties : function(e3, t3) {
            a(e3);
            for (var r2, o2 = l(t3), n = o2.length, s2 = 0; s2 < n; )
              i.f(e3, r2 = o2[s2++], t3[r2]);
            return e3;
          };
        }, { "../internals/an-object": 10, "../internals/descriptors": 43, "../internals/object-define-property": 92, "../internals/object-keys": 99 }], 92: [function(e2, t2, r) {
          var o = e2("../internals/descriptors"), n = e2("../internals/ie8-dom-define"), s2 = e2("../internals/an-object"), i = e2("../internals/to-primitive"), a = Object.defineProperty;
          r.f = o ? a : function(e3, t3, r2) {
            if (s2(e3), t3 = i(t3, true), s2(r2), n)
              try {
                return a(e3, t3, r2);
              } catch (e4) {
              }
            if ("get" in r2 || "set" in r2)
              throw TypeError("Accessors not supported");
            return "value" in r2 && (e3[t3] = r2.value), e3;
          };
        }, { "../internals/an-object": 10, "../internals/descriptors": 43, "../internals/ie8-dom-define": 64, "../internals/to-primitive": 138 }], 93: [function(e2, t2, r) {
          var o = e2("../internals/descriptors"), n = e2("../internals/object-property-is-enumerable"), s2 = e2("../internals/create-property-descriptor"), i = e2("../internals/to-indexed-object"), a = e2("../internals/to-primitive"), l = e2("../internals/has"), u = e2("../internals/ie8-dom-define"), c = Object.getOwnPropertyDescriptor;
          r.f = o ? c : function(e3, t3) {
            if (e3 = i(e3), t3 = a(t3, true), u)
              try {
                return c(e3, t3);
              } catch (e4) {
              }
            if (l(e3, t3))
              return s2(!n.f.call(e3, t3), e3[t3]);
          };
        }, { "../internals/create-property-descriptor": 39, "../internals/descriptors": 43, "../internals/has": 60, "../internals/ie8-dom-define": 64, "../internals/object-property-is-enumerable": 100, "../internals/to-indexed-object": 132, "../internals/to-primitive": 138 }], 94: [function(e2, t2, r) {
          var o = e2("../internals/to-indexed-object"), n = e2("../internals/object-get-own-property-names").f, s2 = {}.toString, i = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
          t2.exports.f = function(e3) {
            if (!i || "[object Window]" != s2.call(e3))
              return n(o(e3));
            try {
              return n(e3);
            } catch (e4) {
              return i.slice();
            }
          };
        }, { "../internals/object-get-own-property-names": 95, "../internals/to-indexed-object": 132 }], 95: [function(e2, t2, r) {
          var o = e2("../internals/object-keys-internal"), n = e2("../internals/enum-bug-keys").concat("length", "prototype");
          r.f = Object.getOwnPropertyNames || function(e3) {
            return o(e3, n);
          };
        }, { "../internals/enum-bug-keys": 49, "../internals/object-keys-internal": 98 }], 96: [function(e2, t2, r) {
          r.f = Object.getOwnPropertySymbols;
        }, {}], 97: [function(e2, t2, r) {
          var o = e2("../internals/has"), n = e2("../internals/to-object"), s2 = e2("../internals/shared-key"), e2 = e2("../internals/correct-prototype-getter"), i = s2("IE_PROTO"), a = Object.prototype;
          t2.exports = e2 ? Object.getPrototypeOf : function(e3) {
            return e3 = n(e3), o(e3, i) ? e3[i] : "function" == typeof e3.constructor && e3 instanceof e3.constructor ? e3.constructor.prototype : e3 instanceof Object ? a : null;
          };
        }, { "../internals/correct-prototype-getter": 35, "../internals/has": 60, "../internals/shared-key": 118, "../internals/to-object": 135 }], 98: [function(e2, t2, r) {
          var i = e2("../internals/has"), a = e2("../internals/to-indexed-object"), l = e2("../internals/array-includes").indexOf, u = e2("../internals/hidden-keys");
          t2.exports = function(e3, t3) {
            var r2, o = a(e3), n = 0, s2 = [];
            for (r2 in o)
              !i(u, r2) && i(o, r2) && s2.push(r2);
            for (; t3.length > n; )
              !i(o, r2 = t3[n++]) || ~l(s2, r2) || s2.push(r2);
            return s2;
          };
        }, { "../internals/array-includes": 18, "../internals/has": 60, "../internals/hidden-keys": 61, "../internals/to-indexed-object": 132 }], 99: [function(e2, t2, r) {
          var o = e2("../internals/object-keys-internal"), n = e2("../internals/enum-bug-keys");
          t2.exports = Object.keys || function(e3) {
            return o(e3, n);
          };
        }, { "../internals/enum-bug-keys": 49, "../internals/object-keys-internal": 98 }], 100: [function(e2, t2, r) {
          "use strict";
          var o = {}.propertyIsEnumerable, n = Object.getOwnPropertyDescriptor, s2 = n && !o.call({ 1: 2 }, 1);
          r.f = s2 ? function(e3) {
            e3 = n(this, e3);
            return !!e3 && e3.enumerable;
          } : o;
        }, {}], 101: [function(e2, t2, r) {
          var n = e2("../internals/an-object"), s2 = e2("../internals/a-possible-prototype");
          t2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var r2, o = false, e3 = {};
            try {
              (r2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(e3, []), o = e3 instanceof Array;
            } catch (e4) {
            }
            return function(e4, t3) {
              return n(e4), s2(t3), o ? r2.call(e4, t3) : e4.__proto__ = t3, e4;
            };
          }() : void 0);
        }, { "../internals/a-possible-prototype": 6, "../internals/an-object": 10 }], 102: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/to-string-tag-support"), n = e2("../internals/classof");
          t2.exports = o ? {}.toString : function() {
            return "[object " + n(this) + "]";
          };
        }, { "../internals/classof": 29, "../internals/to-string-tag-support": 139 }], 103: [function(e2, t2, r) {
          var o = e2("../internals/get-built-in"), n = e2("../internals/object-get-own-property-names"), s2 = e2("../internals/object-get-own-property-symbols"), i = e2("../internals/an-object");
          t2.exports = o("Reflect", "ownKeys") || function(e3) {
            var t3 = n.f(i(e3)), r2 = s2.f;
            return r2 ? t3.concat(r2(e3)) : t3;
          };
        }, { "../internals/an-object": 10, "../internals/get-built-in": 56, "../internals/object-get-own-property-names": 95, "../internals/object-get-own-property-symbols": 96 }], 104: [function(e2, t2, r) {
          e2 = e2("../internals/global");
          t2.exports = e2;
        }, { "../internals/global": 59 }], 105: [function(e2, t2, r) {
          t2.exports = function(e3) {
            try {
              return { error: false, value: e3() };
            } catch (e4) {
              return { error: true, value: e4 };
            }
          };
        }, {}], 106: [function(e2, t2, r) {
          var o = e2("../internals/an-object"), n = e2("../internals/is-object"), s2 = e2("../internals/new-promise-capability");
          t2.exports = function(e3, t3) {
            return o(e3), n(t3) && t3.constructor === e3 ? t3 : ((0, (e3 = s2.f(e3)).resolve)(t3), e3.promise);
          };
        }, { "../internals/an-object": 10, "../internals/is-object": 74, "../internals/new-promise-capability": 86 }], 107: [function(e2, t2, r) {
          var n = e2("../internals/redefine");
          t2.exports = function(e3, t3, r2) {
            for (var o in t3)
              n(e3, o, t3[o], r2);
            return e3;
          };
        }, { "../internals/redefine": 108 }], 108: [function(e2, t2, r) {
          var i = e2("../internals/global"), a = e2("../internals/create-non-enumerable-property"), l = e2("../internals/has"), u = e2("../internals/set-global"), o = e2("../internals/inspect-source"), e2 = e2("../internals/internal-state"), n = e2.get, c = e2.enforce, d = String(String).split("String");
          (t2.exports = function(e3, t3, r2, o2) {
            var n2 = !!o2 && !!o2.unsafe, s2 = !!o2 && !!o2.enumerable, o2 = !!o2 && !!o2.noTargetGet;
            "function" == typeof r2 && ("string" != typeof t3 || l(r2, "name") || a(r2, "name", t3), c(r2).source = d.join("string" == typeof t3 ? t3 : "")), e3 === i ? s2 ? e3[t3] = r2 : u(t3, r2) : (n2 ? !o2 && e3[t3] && (s2 = true) : delete e3[t3], s2 ? e3[t3] = r2 : a(e3, t3, r2));
          })(Function.prototype, "toString", function() {
            return "function" == typeof this && n(this).source || o(this);
          });
        }, { "../internals/create-non-enumerable-property": 38, "../internals/global": 59, "../internals/has": 60, "../internals/inspect-source": 68, "../internals/internal-state": 70, "../internals/set-global": 115 }], 109: [function(e2, t2, r) {
          var o = e2("./classof-raw"), n = e2("./regexp-exec");
          t2.exports = function(e3, t3) {
            var r2 = e3.exec;
            if ("function" == typeof r2) {
              r2 = r2.call(e3, t3);
              if ("object" != typeof r2)
                throw TypeError("RegExp exec method returned something other than an Object or null");
              return r2;
            }
            if ("RegExp" !== o(e3))
              throw TypeError("RegExp#exec called on incompatible receiver");
            return n.call(e3, t3);
          };
        }, { "./classof-raw": 28, "./regexp-exec": 110 }], 110: [function(e2, t2, r) {
          "use strict";
          var o, n, d = e2("./regexp-flags"), e2 = e2("./regexp-sticky-helpers"), f = RegExp.prototype.exec, h = String.prototype.replace, s2 = f, p = (o = /a/, n = /b*/g, f.call(o, "a"), f.call(n, "a"), 0 !== o.lastIndex || 0 !== n.lastIndex), m = e2.UNSUPPORTED_Y || e2.BROKEN_CARET, y = void 0 !== /()??/.exec("")[1];
          t2.exports = s2 = p || y || m ? function(e3) {
            var t3, r2, o2, n2, s3 = this, i = m && s3.sticky, a = d.call(s3), l = s3.source, u = 0, c = e3;
            return i && (-1 === (a = a.replace("y", "")).indexOf("g") && (a += "g"), c = String(e3).slice(s3.lastIndex), 0 < s3.lastIndex && (!s3.multiline || s3.multiline && "\n" !== e3[s3.lastIndex - 1]) && (l = "(?: " + l + ")", c = " " + c, u++), r2 = new RegExp("^(?:" + l + ")", a)), y && (r2 = new RegExp("^" + l + "$(?!\\s)", a)), p && (t3 = s3.lastIndex), o2 = f.call(i ? r2 : s3, c), i ? o2 ? (o2.input = o2.input.slice(u), o2[0] = o2[0].slice(u), o2.index = s3.lastIndex, s3.lastIndex += o2[0].length) : s3.lastIndex = 0 : p && o2 && (s3.lastIndex = s3.global ? o2.index + o2[0].length : t3), y && o2 && 1 < o2.length && h.call(o2[0], r2, function() {
              for (n2 = 1; n2 < arguments.length - 2; n2++)
                void 0 === arguments[n2] && (o2[n2] = void 0);
            }), o2;
          } : s2;
        }, { "./regexp-flags": 111, "./regexp-sticky-helpers": 112 }], 111: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/an-object");
          t2.exports = function() {
            var e3 = o(this), t3 = "";
            return e3.global && (t3 += "g"), e3.ignoreCase && (t3 += "i"), e3.multiline && (t3 += "m"), e3.dotAll && (t3 += "s"), e3.unicode && (t3 += "u"), e3.sticky && (t3 += "y"), t3;
          };
        }, { "../internals/an-object": 10 }], 112: [function(e2, t2, r) {
          "use strict";
          e2 = e2("./fails");
          function o(e3, t3) {
            return RegExp(e3, t3);
          }
          r.UNSUPPORTED_Y = e2(function() {
            var e3 = o("a", "y");
            return e3.lastIndex = 2, null != e3.exec("abcd");
          }), r.BROKEN_CARET = e2(function() {
            var e3 = o("^r", "gy");
            return e3.lastIndex = 2, null != e3.exec("str");
          });
        }, { "./fails": 51 }], 113: [function(e2, t2, r) {
          t2.exports = function(e3) {
            if (null == e3)
              throw TypeError("Can't call method on " + e3);
            return e3;
          };
        }, {}], 114: [function(e2, t2, r) {
          t2.exports = Object.is || function(e3, t3) {
            return e3 === t3 ? 0 !== e3 || 1 / e3 == 1 / t3 : e3 != e3 && t3 != t3;
          };
        }, {}], 115: [function(e2, t2, r) {
          var o = e2("../internals/global"), n = e2("../internals/create-non-enumerable-property");
          t2.exports = function(t3, r2) {
            try {
              n(o, t3, r2);
            } catch (e3) {
              o[t3] = r2;
            }
            return r2;
          };
        }, { "../internals/create-non-enumerable-property": 38, "../internals/global": 59 }], 116: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/get-built-in"), n = e2("../internals/object-define-property"), s2 = e2("../internals/well-known-symbol"), i = e2("../internals/descriptors"), a = s2("species");
          t2.exports = function(e3) {
            var e3 = o(e3), t3 = n.f;
            i && e3 && !e3[a] && t3(e3, a, { configurable: true, get: function() {
              return this;
            } });
          };
        }, { "../internals/descriptors": 43, "../internals/get-built-in": 56, "../internals/object-define-property": 92, "../internals/well-known-symbol": 146 }], 117: [function(e2, t2, r) {
          var o = e2("../internals/object-define-property").f, n = e2("../internals/has"), s2 = e2("../internals/well-known-symbol")("toStringTag");
          t2.exports = function(e3, t3, r2) {
            e3 && !n(e3 = r2 ? e3 : e3.prototype, s2) && o(e3, s2, { configurable: true, value: t3 });
          };
        }, { "../internals/has": 60, "../internals/object-define-property": 92, "../internals/well-known-symbol": 146 }], 118: [function(e2, t2, r) {
          var o = e2("../internals/shared"), n = e2("../internals/uid"), s2 = o("keys");
          t2.exports = function(e3) {
            return s2[e3] || (s2[e3] = n(e3));
          };
        }, { "../internals/shared": 120, "../internals/uid": 143 }], 119: [function(e2, t2, r) {
          var o = e2("../internals/global"), e2 = e2("../internals/set-global"), n = "__core-js_shared__", o = o[n] || e2(n, {});
          t2.exports = o;
        }, { "../internals/global": 59, "../internals/set-global": 115 }], 120: [function(e2, t2, r) {
          var o = e2("../internals/is-pure"), n = e2("../internals/shared-store");
          (t2.exports = function(e3, t3) {
            return n[e3] || (n[e3] = void 0 !== t3 ? t3 : {});
          })("versions", []).push({ version: "3.6.5", mode: o ? "pure" : "global", copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)" });
        }, { "../internals/is-pure": 75, "../internals/shared-store": 119 }], 121: [function(e2, t2, r) {
          var o = e2("../internals/an-object"), n = e2("../internals/a-function"), s2 = e2("../internals/well-known-symbol")("species");
          t2.exports = function(e3, t3) {
            var e3 = o(e3).constructor;
            return void 0 === e3 || null == (e3 = o(e3)[s2]) ? t3 : n(e3);
          };
        }, { "../internals/a-function": 5, "../internals/an-object": 10, "../internals/well-known-symbol": 146 }], 122: [function(e2, t2, r) {
          var o = e2("../internals/fails");
          t2.exports = function(t3) {
            return o(function() {
              var e3 = ""[t3]('"');
              return e3 !== e3.toLowerCase() || 3 < e3.split('"').length;
            });
          };
        }, { "../internals/fails": 51 }], 123: [function(e2, t2, r) {
          function o(n) {
            return function(e3, t3) {
              var r2, e3 = String(i(e3)), t3 = s2(t3), o2 = e3.length;
              return t3 < 0 || o2 <= t3 ? n ? "" : void 0 : (r2 = e3.charCodeAt(t3)) < 55296 || 56319 < r2 || t3 + 1 === o2 || (o2 = e3.charCodeAt(t3 + 1)) < 56320 || 57343 < o2 ? n ? e3.charAt(t3) : r2 : n ? e3.slice(t3, t3 + 2) : o2 - 56320 + (r2 - 55296 << 10) + 65536;
            };
          }
          var s2 = e2("../internals/to-integer"), i = e2("../internals/require-object-coercible");
          t2.exports = { codeAt: o(false), charAt: o(true) };
        }, { "../internals/require-object-coercible": 113, "../internals/to-integer": 133 }], 124: [function(e2, t2, r) {
          "use strict";
          function g(e3) {
            return e3 + 22 + 75 * (e3 < 26);
          }
          function s2(e3) {
            var t3, r2 = [], o = (e3 = function(e4) {
              for (var t4 = [], r3 = 0, o2 = e4.length; r3 < o2; ) {
                var n2, s4 = e4.charCodeAt(r3++);
                55296 <= s4 && s4 <= 56319 && r3 < o2 ? 56320 == (64512 & (n2 = e4.charCodeAt(r3++))) ? t4.push(((1023 & s4) << 10) + (1023 & n2) + 65536) : (t4.push(s4), r3--) : t4.push(s4);
              }
              return t4;
            }(e3)).length, n = 128, s3 = 0, i2 = 72;
            for (c = 0; c < e3.length; c++)
              (t3 = e3[c]) < 128 && r2.push(E(t3));
            var a2 = r2.length, l = a2;
            for (a2 && r2.push("-"); l < o; ) {
              for (var u = v, c = 0; c < e3.length; c++)
                n <= (t3 = e3[c]) && t3 < u && (u = t3);
              var d = l + 1;
              if (u - n > M((v - s3) / d))
                throw RangeError(w);
              for (s3 += (u - n) * d, n = u, c = 0; c < e3.length; c++) {
                if ((t3 = e3[c]) < n && ++s3 > v)
                  throw RangeError(w);
                if (t3 == n) {
                  for (var f = s3, h = b; ; h += b) {
                    var p = h <= i2 ? 1 : i2 + j <= h ? j : h - i2;
                    if (f < p)
                      break;
                    var m = f - p, y = b - p;
                    r2.push(E(g(p + m % y))), f = M(m / y);
                  }
                  r2.push(E(g(f))), i2 = function(e4, t4, r3) {
                    var o2 = 0;
                    for (e4 = r3 ? M(e4 / x) : e4 >> 1, e4 += M(e4 / t4); S * j >> 1 < e4; o2 += b)
                      e4 = M(e4 / S);
                    return M(o2 + (S + 1) * e4 / (e4 + _));
                  }(s3, d, l == a2), s3 = 0, ++l;
                }
              }
              ++s3, ++n;
            }
            return r2.join("");
          }
          var v = 2147483647, b = 36, j = 26, _ = 38, x = 700, i = /[^\0-\u007E]/, a = /[.\u3002\uFF0E\uFF61]/g, w = "Overflow: input needs wider integers to process", S = b - 1, M = Math.floor, E = String.fromCharCode;
          t2.exports = function(e3) {
            for (var t3, r2 = [], o = e3.toLowerCase().replace(a, ".").split("."), n = 0; n < o.length; n++)
              t3 = o[n], r2.push(i.test(t3) ? "xn--" + s2(t3) : t3);
            return r2.join(".");
          };
        }, {}], 125: [function(e2, t2, r) {
          "use strict";
          var n = e2("../internals/to-integer"), s2 = e2("../internals/require-object-coercible");
          t2.exports = "".repeat || function(e3) {
            var t3 = String(s2(this)), r2 = "", o = n(e3);
            if (o < 0 || o == 1 / 0)
              throw RangeError("Wrong number of repetitions");
            for (; 0 < o; (o >>>= 1) && (t3 += t3))
              1 & o && (r2 += t3);
            return r2;
          };
        }, { "../internals/require-object-coercible": 113, "../internals/to-integer": 133 }], 126: [function(e2, t2, r) {
          var o = e2("../internals/fails"), n = e2("../internals/whitespaces");
          t2.exports = function(e3) {
            return o(function() {
              return !!n[e3]() || "\u200B\x85\u180E" != "\u200B\x85\u180E"[e3]() || n[e3].name !== e3;
            });
          };
        }, { "../internals/fails": 51, "../internals/whitespaces": 147 }], 127: [function(e2, t2, r) {
          function o(t3) {
            return function(e3) {
              e3 = String(n(e3));
              return 1 & t3 && (e3 = e3.replace(s2, "")), e3 = 2 & t3 ? e3.replace(i, "") : e3;
            };
          }
          var n = e2("../internals/require-object-coercible"), e2 = "[" + e2("../internals/whitespaces") + "]", s2 = RegExp("^" + e2 + e2 + "*"), i = RegExp(e2 + e2 + "*$");
          t2.exports = { start: o(1), end: o(2), trim: o(3) };
        }, { "../internals/require-object-coercible": 113, "../internals/whitespaces": 147 }], 128: [function(e2, t2, r) {
          function o(e3) {
            return function() {
              x(e3);
            };
          }
          function n(e3) {
            x(e3.data);
          }
          function s2(e3) {
            a.postMessage(e3 + "", h.protocol + "//" + h.host);
          }
          var i, a = e2("../internals/global"), l = e2("../internals/fails"), u = e2("../internals/classof-raw"), c = e2("../internals/function-bind-context"), d = e2("../internals/html"), f = e2("../internals/document-create-element"), e2 = e2("../internals/engine-is-ios"), h = a.location, p = a.setImmediate, m = a.clearImmediate, y = a.process, g = a.MessageChannel, v = a.Dispatch, b = 0, j = {}, _ = "onreadystatechange", x = function(e3) {
            var t3;
            j.hasOwnProperty(e3) && (t3 = j[e3], delete j[e3], t3());
          };
          p && m || (p = function(e3) {
            for (var t3 = [], r2 = 1; r2 < arguments.length; )
              t3.push(arguments[r2++]);
            return j[++b] = function() {
              ("function" == typeof e3 ? e3 : Function(e3)).apply(void 0, t3);
            }, i(b), b;
          }, m = function(e3) {
            delete j[e3];
          }, "process" == u(y) ? i = function(e3) {
            y.nextTick(o(e3));
          } : v && v.now ? i = function(e3) {
            v.now(o(e3));
          } : g && !e2 ? (e2 = (u = new g()).port2, u.port1.onmessage = n, i = c(e2.postMessage, e2, 1)) : !a.addEventListener || "function" != typeof postMessage || a.importScripts || l(s2) || "file:" === h.protocol ? i = _ in f("script") ? function(e3) {
            d.appendChild(f("script"))[_] = function() {
              d.removeChild(this), x(e3);
            };
          } : function(e3) {
            setTimeout(o(e3), 0);
          } : (i = s2, a.addEventListener("message", n, false))), t2.exports = { set: p, clear: m };
        }, { "../internals/classof-raw": 28, "../internals/document-create-element": 44, "../internals/engine-is-ios": 46, "../internals/fails": 51, "../internals/function-bind-context": 54, "../internals/global": 59, "../internals/html": 63 }], 129: [function(e2, t2, r) {
          var o = e2("../internals/classof-raw");
          t2.exports = function(e3) {
            if ("number" != typeof e3 && "Number" != o(e3))
              throw TypeError("Incorrect invocation");
            return +e3;
          };
        }, { "../internals/classof-raw": 28 }], 130: [function(e2, t2, r) {
          var o = e2("../internals/to-integer"), n = Math.max, s2 = Math.min;
          t2.exports = function(e3, t3) {
            e3 = o(e3);
            return e3 < 0 ? n(e3 + t3, 0) : s2(e3, t3);
          };
        }, { "../internals/to-integer": 133 }], 131: [function(e2, t2, r) {
          var o = e2("../internals/to-integer"), n = e2("../internals/to-length");
          t2.exports = function(e3) {
            if (void 0 === e3)
              return 0;
            var e3 = o(e3), t3 = n(e3);
            if (e3 !== t3)
              throw RangeError("Wrong length or index");
            return t3;
          };
        }, { "../internals/to-integer": 133, "../internals/to-length": 134 }], 132: [function(e2, t2, r) {
          var o = e2("../internals/indexed-object"), n = e2("../internals/require-object-coercible");
          t2.exports = function(e3) {
            return o(n(e3));
          };
        }, { "../internals/indexed-object": 66, "../internals/require-object-coercible": 113 }], 133: [function(e2, t2, r) {
          var o = Math.ceil, n = Math.floor;
          t2.exports = function(e3) {
            return isNaN(e3 = +e3) ? 0 : (0 < e3 ? n : o)(e3);
          };
        }, {}], 134: [function(e2, t2, r) {
          var o = e2("../internals/to-integer"), n = Math.min;
          t2.exports = function(e3) {
            return 0 < e3 ? n(o(e3), 9007199254740991) : 0;
          };
        }, { "../internals/to-integer": 133 }], 135: [function(e2, t2, r) {
          var o = e2("../internals/require-object-coercible");
          t2.exports = function(e3) {
            return Object(o(e3));
          };
        }, { "../internals/require-object-coercible": 113 }], 136: [function(e2, t2, r) {
          var o = e2("../internals/to-positive-integer");
          t2.exports = function(e3, t3) {
            e3 = o(e3);
            if (e3 % t3)
              throw RangeError("Wrong offset");
            return e3;
          };
        }, { "../internals/to-positive-integer": 137 }], 137: [function(e2, t2, r) {
          var o = e2("../internals/to-integer");
          t2.exports = function(e3) {
            e3 = o(e3);
            if (e3 < 0)
              throw RangeError("The argument can't be less than 0");
            return e3;
          };
        }, { "../internals/to-integer": 133 }], 138: [function(e2, t2, r) {
          var n = e2("../internals/is-object");
          t2.exports = function(e3, t3) {
            if (!n(e3))
              return e3;
            var r2, o;
            if (t3 && "function" == typeof (r2 = e3.toString) && !n(o = r2.call(e3)) || "function" == typeof (r2 = e3.valueOf) && !n(o = r2.call(e3)) || !t3 && "function" == typeof (r2 = e3.toString) && !n(o = r2.call(e3)))
              return o;
            throw TypeError("Can't convert object to primitive value");
          };
        }, { "../internals/is-object": 74 }], 139: [function(e2, t2, r) {
          var o = {};
          o[e2("../internals/well-known-symbol")("toStringTag")] = "z", t2.exports = "[object z]" === String(o);
        }, { "../internals/well-known-symbol": 146 }], 140: [function(e2, t2, I) {
          "use strict";
          function h(e3, t3) {
            for (var r2 = 0, o2 = t3.length, n2 = new (Q(e3))(o2); r2 < o2; )
              n2[r2] = t3[r2++];
            return n2;
          }
          function r(e3, t3) {
            E(e3, t3, { get: function() {
              return M(this)[t3];
            } });
          }
          function p(e3) {
            return e3 instanceof C || "ArrayBuffer" == (e3 = B(e3)) || "SharedArrayBuffer" == e3;
          }
          function o(e3, t3) {
            return P(e3) && "symbol" != typeof t3 && t3 in e3 && String(+t3) == String(t3);
          }
          function n(e3, t3) {
            return o(e3, t3 = d(t3, true)) ? N(2, e3[t3]) : X(e3, t3);
          }
          function s2(e3, t3, r2) {
            return !(o(e3, t3 = d(t3, true)) && b(r2) && f(r2, "value")) || f(r2, "get") || f(r2, "set") || r2.configurable || f(r2, "writable") && !r2.writable || f(r2, "enumerable") && !r2.enumerable ? E(e3, t3, r2) : (e3[t3] = r2.value, e3);
          }
          var a = e2("../internals/export"), l = e2("../internals/global"), i = e2("../internals/descriptors"), U = e2("../internals/typed-array-constructors-require-wrappers"), u = e2("../internals/array-buffer-view-core"), c = e2("../internals/array-buffer"), m = e2("../internals/an-instance"), N = e2("../internals/create-property-descriptor"), y = e2("../internals/create-non-enumerable-property"), F = e2("../internals/to-length"), g = e2("../internals/to-index"), v = e2("../internals/to-offset"), d = e2("../internals/to-primitive"), f = e2("../internals/has"), B = e2("../internals/classof"), b = e2("../internals/is-object"), G = e2("../internals/object-create"), j = e2("../internals/object-set-prototype-of"), V = e2("../internals/object-get-own-property-names").f, _ = e2("../internals/typed-array-from"), z = e2("../internals/array-iteration").forEach, H = e2("../internals/set-species"), x = e2("../internals/object-define-property"), w = e2("../internals/object-get-own-property-descriptor"), S = e2("../internals/internal-state"), W = e2("../internals/inherit-if-required"), M = S.get, q = S.set, E = x.f, X = w.f, Y = Math.round, T = l.RangeError, C = c.ArrayBuffer, Z = c.DataView, O = u.NATIVE_ARRAY_BUFFER_VIEWS, L = u.TYPED_ARRAY_TAG, k = u.TypedArray, A = u.TypedArrayPrototype, Q = u.aTypedArrayConstructor, P = u.isTypedArray, R = "BYTES_PER_ELEMENT", D = "Wrong length";
          i ? (O || (w.f = n, x.f = s2, r(A, "buffer"), r(A, "byteOffset"), r(A, "byteLength"), r(A, "length")), a({ target: "Object", stat: true, forced: !O }, { getOwnPropertyDescriptor: n, defineProperty: s2 }), t2.exports = function(e3, t3, n2) {
            function u2(e4, o3) {
              E(e4, o3, { get: function() {
                var e5 = this, t4 = o3;
                return (e5 = M(e5)).view[r2](t4 * c2 + e5.byteOffset, true);
              }, set: function(e5) {
                var t4 = this, r3 = o3;
                t4 = M(t4), n2 && (e5 = (e5 = Y(e5)) < 0 ? 0 : 255 < e5 ? 255 : 255 & e5), t4.view[s3](r3 * c2 + t4.byteOffset, e5, true);
              }, enumerable: true });
            }
            var c2 = e3.match(/\d+$/)[0] / 8, d2 = e3 + (n2 ? "Clamped" : "") + "Array", r2 = "get" + e3, s3 = "set" + e3, i2 = l[d2], f2 = i2, e3 = f2 && f2.prototype, o2 = {};
            O ? U && (f2 = t3(function(e4, t4, r3, o3) {
              return m(e4, f2, d2), W(b(t4) ? p(t4) ? void 0 !== o3 ? new i2(t4, v(r3, c2), o3) : void 0 !== r3 ? new i2(t4, v(r3, c2)) : new i2(t4) : P(t4) ? h(f2, t4) : _.call(f2, t4) : new i2(g(t4)), e4, f2);
            }), j && j(f2, k), z(V(i2), function(e4) {
              e4 in f2 || y(f2, e4, i2[e4]);
            }), f2.prototype = e3) : (f2 = t3(function(e4, t4, r3, o3) {
              m(e4, f2, d2);
              var n3, s4, i3 = 0, a2 = 0;
              if (b(t4)) {
                if (!p(t4))
                  return P(t4) ? h(f2, t4) : _.call(f2, t4);
                var l2 = t4, a2 = v(r3, c2), r3 = t4.byteLength;
                if (void 0 === o3) {
                  if (r3 % c2)
                    throw T(D);
                  if ((n3 = r3 - a2) < 0)
                    throw T(D);
                } else if (r3 < (n3 = F(o3) * c2) + a2)
                  throw T(D);
                s4 = n3 / c2;
              } else
                s4 = g(t4), l2 = new C(n3 = s4 * c2);
              for (q(e4, { buffer: l2, byteOffset: a2, byteLength: n3, length: s4, view: new Z(l2) }); i3 < s4; )
                u2(e4, i3++);
            }), j && j(f2, k), e3 = f2.prototype = G(A)), e3.constructor !== f2 && y(e3, "constructor", f2), L && y(e3, L, d2), o2[d2] = f2, a({ global: true, forced: f2 != i2, sham: !O }, o2), R in f2 || y(f2, R, c2), R in e3 || y(e3, R, c2), H(d2);
          }) : t2.exports = function() {
          };
        }, { "../internals/an-instance": 9, "../internals/array-buffer": 13, "../internals/array-buffer-view-core": 12, "../internals/array-iteration": 19, "../internals/classof": 29, "../internals/create-non-enumerable-property": 38, "../internals/create-property-descriptor": 39, "../internals/descriptors": 43, "../internals/export": 50, "../internals/global": 59, "../internals/has": 60, "../internals/inherit-if-required": 67, "../internals/internal-state": 70, "../internals/is-object": 74, "../internals/object-create": 90, "../internals/object-define-property": 92, "../internals/object-get-own-property-descriptor": 93, "../internals/object-get-own-property-names": 95, "../internals/object-set-prototype-of": 101, "../internals/set-species": 116, "../internals/to-index": 131, "../internals/to-length": 134, "../internals/to-offset": 136, "../internals/to-primitive": 138, "../internals/typed-array-constructors-require-wrappers": 141, "../internals/typed-array-from": 142 }], 141: [function(e2, t2, r) {
          var o = e2("../internals/global"), n = e2("../internals/fails"), s2 = e2("../internals/check-correctness-of-iteration"), e2 = e2("../internals/array-buffer-view-core").NATIVE_ARRAY_BUFFER_VIEWS, i = o.ArrayBuffer, a = o.Int8Array;
          t2.exports = !e2 || !n(function() {
            a(1);
          }) || !n(function() {
            new a(-1);
          }) || !s2(function(e3) {
            new a(), new a(null), new a(1.5), new a(e3);
          }, true) || n(function() {
            return 1 !== new a(new i(2), 1, void 0).length;
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/check-correctness-of-iteration": 27, "../internals/fails": 51, "../internals/global": 59 }], 142: [function(e2, t2, r) {
          var f = e2("../internals/to-object"), h = e2("../internals/to-length"), p = e2("../internals/get-iterator-method"), m = e2("../internals/is-array-iterator-method"), y = e2("../internals/function-bind-context"), g = e2("../internals/array-buffer-view-core").aTypedArrayConstructor;
          t2.exports = function(e3) {
            var t3, r2, o, n, s2, i, a = f(e3), l = arguments.length, u = 1 < l ? arguments[1] : void 0, c = void 0 !== u, d = p(a);
            if (null != d && !m(d))
              for (i = (s2 = d.call(a)).next, a = []; !(n = i.call(s2)).done; )
                a.push(n.value);
            for (c && 2 < l && (u = y(u, arguments[2], 2)), r2 = h(a.length), o = new (g(this))(r2), t3 = 0; t3 < r2; t3++)
              o[t3] = c ? u(a[t3], t3) : a[t3];
            return o;
          };
        }, { "../internals/array-buffer-view-core": 12, "../internals/function-bind-context": 54, "../internals/get-iterator-method": 57, "../internals/is-array-iterator-method": 71, "../internals/to-length": 134, "../internals/to-object": 135 }], 143: [function(e2, t2, r) {
          var o = 0, n = Math.random();
          t2.exports = function(e3) {
            return "Symbol(" + String(void 0 === e3 ? "" : e3) + ")_" + (++o + n).toString(36);
          };
        }, {}], 144: [function(e2, t2, r) {
          e2 = e2("../internals/native-symbol");
          t2.exports = e2 && !Symbol.sham && "symbol" == typeof Symbol.iterator;
        }, { "../internals/native-symbol": 83 }], 145: [function(e2, t2, r) {
          e2 = e2("../internals/well-known-symbol");
          r.f = e2;
        }, { "../internals/well-known-symbol": 146 }], 146: [function(e2, t2, r) {
          var o = e2("../internals/global"), n = e2("../internals/shared"), s2 = e2("../internals/has"), i = e2("../internals/uid"), a = e2("../internals/native-symbol"), e2 = e2("../internals/use-symbol-as-uid"), l = n("wks"), u = o.Symbol, c = e2 ? u : u && u.withoutSetter || i;
          t2.exports = function(e3) {
            return s2(l, e3) || (a && s2(u, e3) ? l[e3] = u[e3] : l[e3] = c("Symbol." + e3)), l[e3];
          };
        }, { "../internals/global": 59, "../internals/has": 60, "../internals/native-symbol": 83, "../internals/shared": 120, "../internals/uid": 143, "../internals/use-symbol-as-uid": 144 }], 147: [function(e2, t2, r) {
          t2.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
        }, {}], 148: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/global"), s2 = e2("../internals/array-buffer"), e2 = e2("../internals/set-species"), i = "ArrayBuffer", s2 = s2[i];
          o({ global: true, forced: n[i] !== s2 }, { ArrayBuffer: s2 }), e2(i);
        }, { "../internals/array-buffer": 13, "../internals/export": 50, "../internals/global": 59, "../internals/set-species": 116 }], 149: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/fails"), d = e2("../internals/is-array"), f = e2("../internals/is-object"), h = e2("../internals/to-object"), p = e2("../internals/to-length"), m = e2("../internals/create-property"), y = e2("../internals/array-species-create"), s2 = e2("../internals/array-method-has-species-support"), i = e2("../internals/well-known-symbol"), e2 = e2("../internals/engine-v8-version"), g = i("isConcatSpreadable"), v = 9007199254740991, b = "Maximum allowed index exceeded", i = 51 <= e2 || !n(function() {
            var e3 = [];
            return e3[g] = false, e3.concat()[0] !== e3;
          }), e2 = s2("concat");
          o({ target: "Array", proto: true, forced: !i || !e2 }, { concat: function(e3) {
            for (var t3, r2, o2, n2, s3, i2 = h(this), a = y(i2, 0), l = 0, u = -1, c = arguments.length; u < c; u++)
              if (s3 = void 0, !f(n2 = o2 = -1 === u ? i2 : arguments[u]) || (void 0 !== (s3 = n2[g]) ? !s3 : !d(n2))) {
                if (v <= l)
                  throw TypeError(b);
                m(a, l++, o2);
              } else {
                if (r2 = p(o2.length), v < l + r2)
                  throw TypeError(b);
                for (t3 = 0; t3 < r2; t3++, l++)
                  t3 in o2 && m(a, l, o2[t3]);
              }
            return a.length = l, a;
          } });
        }, { "../internals/array-method-has-species-support": 21, "../internals/array-species-create": 25, "../internals/create-property": 40, "../internals/engine-v8-version": 48, "../internals/export": 50, "../internals/fails": 51, "../internals/is-array": 72, "../internals/is-object": 74, "../internals/to-length": 134, "../internals/to-object": 135, "../internals/well-known-symbol": 146 }], 150: [function(e2, t2, r) {
          var o = e2("../internals/export"), n = e2("../internals/array-copy-within"), e2 = e2("../internals/add-to-unscopables");
          o({ target: "Array", proto: true }, { copyWithin: n }), e2("copyWithin");
        }, { "../internals/add-to-unscopables": 7, "../internals/array-copy-within": 14, "../internals/export": 50 }], 151: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/array-iteration").every, s2 = e2("../internals/array-method-is-strict"), e2 = e2("../internals/array-method-uses-to-length"), s2 = s2("every"), e2 = e2("every");
          o({ target: "Array", proto: true, forced: !s2 || !e2 }, { every: function(e3) {
            return n(this, e3, 1 < arguments.length ? arguments[1] : void 0);
          } });
        }, { "../internals/array-iteration": 19, "../internals/array-method-is-strict": 22, "../internals/array-method-uses-to-length": 23, "../internals/export": 50 }], 152: [function(e2, t2, r) {
          var o = e2("../internals/export"), n = e2("../internals/array-fill"), e2 = e2("../internals/add-to-unscopables");
          o({ target: "Array", proto: true }, { fill: n }), e2("fill");
        }, { "../internals/add-to-unscopables": 7, "../internals/array-fill": 15, "../internals/export": 50 }], 153: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/array-iteration").filter, s2 = e2("../internals/array-method-has-species-support"), e2 = e2("../internals/array-method-uses-to-length"), s2 = s2("filter"), e2 = e2("filter");
          o({ target: "Array", proto: true, forced: !s2 || !e2 }, { filter: function(e3) {
            return n(this, e3, 1 < arguments.length ? arguments[1] : void 0);
          } });
        }, { "../internals/array-iteration": 19, "../internals/array-method-has-species-support": 21, "../internals/array-method-uses-to-length": 23, "../internals/export": 50 }], 154: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), e2 = e2("../internals/array-for-each");
          o({ target: "Array", proto: true, forced: [].forEach != e2 }, { forEach: e2 });
        }, { "../internals/array-for-each": 16, "../internals/export": 50 }], 155: [function(e2, t2, r) {
          var o = e2("../internals/export"), n = e2("../internals/array-from");
          o({ target: "Array", stat: true, forced: !e2("../internals/check-correctness-of-iteration")(function(e3) {
            Array.from(e3);
          }) }, { from: n });
        }, { "../internals/array-from": 17, "../internals/check-correctness-of-iteration": 27, "../internals/export": 50 }], 156: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/array-includes").includes, s2 = e2("../internals/add-to-unscopables");
          o({ target: "Array", proto: true, forced: !e2("../internals/array-method-uses-to-length")("indexOf", { ACCESSORS: true, 1: 0 }) }, { includes: function(e3) {
            return n(this, e3, 1 < arguments.length ? arguments[1] : void 0);
          } }), s2("includes");
        }, { "../internals/add-to-unscopables": 7, "../internals/array-includes": 18, "../internals/array-method-uses-to-length": 23, "../internals/export": 50 }], 157: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/array-includes").indexOf, s2 = e2("../internals/array-method-is-strict"), e2 = e2("../internals/array-method-uses-to-length"), i = [].indexOf, a = !!i && 1 / [1].indexOf(1, -0) < 0, s2 = s2("indexOf"), e2 = e2("indexOf", { ACCESSORS: true, 1: 0 });
          o({ target: "Array", proto: true, forced: a || !s2 || !e2 }, { indexOf: function(e3) {
            return a ? i.apply(this, arguments) || 0 : n(this, e3, 1 < arguments.length ? arguments[1] : void 0);
          } });
        }, { "../internals/array-includes": 18, "../internals/array-method-is-strict": 22, "../internals/array-method-uses-to-length": 23, "../internals/export": 50 }], 158: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/to-indexed-object"), n = e2("../internals/add-to-unscopables"), s2 = e2("../internals/iterators"), i = e2("../internals/internal-state"), e2 = e2("../internals/define-iterator"), a = "Array Iterator", l = i.set, u = i.getterFor(a);
          t2.exports = e2(Array, "Array", function(e3, t3) {
            l(this, { type: a, target: o(e3), index: 0, kind: t3 });
          }, function() {
            var e3 = u(this), t3 = e3.target, r2 = e3.kind, o2 = e3.index++;
            return !t3 || o2 >= t3.length ? { value: e3.target = void 0, done: true } : "keys" == r2 ? { value: o2, done: false } : "values" == r2 ? { value: t3[o2], done: false } : { value: [o2, t3[o2]], done: false };
          }, "values"), s2.Arguments = s2.Array, n("keys"), n("values"), n("entries");
        }, { "../internals/add-to-unscopables": 7, "../internals/define-iterator": 41, "../internals/internal-state": 70, "../internals/iterators": 79, "../internals/to-indexed-object": 132 }], 159: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/indexed-object"), s2 = e2("../internals/to-indexed-object"), e2 = e2("../internals/array-method-is-strict"), i = [].join, n = n != Object, e2 = e2("join", ",");
          o({ target: "Array", proto: true, forced: n || !e2 }, { join: function(e3) {
            return i.call(s2(this), void 0 === e3 ? "," : e3);
          } });
        }, { "../internals/array-method-is-strict": 22, "../internals/export": 50, "../internals/indexed-object": 66, "../internals/to-indexed-object": 132 }], 160: [function(e2, t2, r) {
          var o = e2("../internals/export"), e2 = e2("../internals/array-last-index-of");
          o({ target: "Array", proto: true, forced: e2 !== [].lastIndexOf }, { lastIndexOf: e2 });
        }, { "../internals/array-last-index-of": 20, "../internals/export": 50 }], 161: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/array-iteration").map, s2 = e2("../internals/array-method-has-species-support"), e2 = e2("../internals/array-method-uses-to-length"), s2 = s2("map"), e2 = e2("map");
          o({ target: "Array", proto: true, forced: !s2 || !e2 }, { map: function(e3) {
            return n(this, e3, 1 < arguments.length ? arguments[1] : void 0);
          } });
        }, { "../internals/array-iteration": 19, "../internals/array-method-has-species-support": 21, "../internals/array-method-uses-to-length": 23, "../internals/export": 50 }], 162: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), u = e2("../internals/is-object"), c = e2("../internals/is-array"), d = e2("../internals/to-absolute-index"), f = e2("../internals/to-length"), h = e2("../internals/to-indexed-object"), p = e2("../internals/create-property"), n = e2("../internals/well-known-symbol"), s2 = e2("../internals/array-method-has-species-support"), e2 = e2("../internals/array-method-uses-to-length"), s2 = s2("slice"), e2 = e2("slice", { ACCESSORS: true, 0: 0, 1: 2 }), m = n("species"), y = [].slice, g = Math.max;
          o({ target: "Array", proto: true, forced: !s2 || !e2 }, { slice: function(e3, t3) {
            var r2, o2, n2, s3 = h(this), i = f(s3.length), a = d(e3, i), l = d(void 0 === t3 ? i : t3, i);
            if (c(s3) && ((r2 = "function" == typeof (r2 = s3.constructor) && (r2 === Array || c(r2.prototype)) || u(r2) && null === (r2 = r2[m]) ? void 0 : r2) === Array || void 0 === r2))
              return y.call(s3, a, l);
            for (o2 = new (void 0 === r2 ? Array : r2)(g(l - a, 0)), n2 = 0; a < l; a++, n2++)
              a in s3 && p(o2, n2, s3[a]);
            return o2.length = n2, o2;
          } });
        }, { "../internals/array-method-has-species-support": 21, "../internals/array-method-uses-to-length": 23, "../internals/create-property": 40, "../internals/export": 50, "../internals/is-array": 72, "../internals/is-object": 74, "../internals/to-absolute-index": 130, "../internals/to-indexed-object": 132, "../internals/to-length": 134, "../internals/well-known-symbol": 146 }], 163: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/array-iteration").some, s2 = e2("../internals/array-method-is-strict"), e2 = e2("../internals/array-method-uses-to-length"), s2 = s2("some"), e2 = e2("some");
          o({ target: "Array", proto: true, forced: !s2 || !e2 }, { some: function(e3) {
            return n(this, e3, 1 < arguments.length ? arguments[1] : void 0);
          } });
        }, { "../internals/array-iteration": 19, "../internals/array-method-is-strict": 22, "../internals/array-method-uses-to-length": 23, "../internals/export": 50 }], 164: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), d = e2("../internals/to-absolute-index"), f = e2("../internals/to-integer"), h = e2("../internals/to-length"), p = e2("../internals/to-object"), m = e2("../internals/array-species-create"), y = e2("../internals/create-property"), n = e2("../internals/array-method-has-species-support"), e2 = e2("../internals/array-method-uses-to-length"), n = n("splice"), e2 = e2("splice", { ACCESSORS: true, 0: 0, 1: 2 }), g = Math.max, v = Math.min;
          o({ target: "Array", proto: true, forced: !n || !e2 }, { splice: function(e3, t3) {
            var r2, o2, n2, s2, i, a, l = p(this), u = h(l.length), c = d(e3, u), e3 = arguments.length;
            if (0 === e3 ? r2 = o2 = 0 : o2 = 1 === e3 ? (r2 = 0, u - c) : (r2 = e3 - 2, v(g(f(t3), 0), u - c)), 9007199254740991 < u + r2 - o2)
              throw TypeError("Maximum allowed length exceeded");
            for (n2 = m(l, o2), s2 = 0; s2 < o2; s2++)
              (i = c + s2) in l && y(n2, s2, l[i]);
            if (r2 < (n2.length = o2)) {
              for (s2 = c; s2 < u - o2; s2++)
                a = s2 + r2, (i = s2 + o2) in l ? l[a] = l[i] : delete l[a];
              for (s2 = u; u - o2 + r2 < s2; s2--)
                delete l[s2 - 1];
            } else if (o2 < r2)
              for (s2 = u - o2; c < s2; s2--)
                a = s2 + r2 - 1, (i = s2 + o2 - 1) in l ? l[a] = l[i] : delete l[a];
            for (s2 = 0; s2 < r2; s2++)
              l[s2 + c] = arguments[s2 + 2];
            return l.length = u - o2 + r2, n2;
          } });
        }, { "../internals/array-method-has-species-support": 21, "../internals/array-method-uses-to-length": 23, "../internals/array-species-create": 25, "../internals/create-property": 40, "../internals/export": 50, "../internals/to-absolute-index": 130, "../internals/to-integer": 133, "../internals/to-length": 134, "../internals/to-object": 135 }], 165: [function(e2, t2, r) {
          var o = e2("../internals/descriptors"), e2 = e2("../internals/object-define-property").f, n = Function.prototype, s2 = n.toString, i = /^\s*function ([^ (]*)/;
          !o || "name" in n || e2(n, "name", { configurable: true, get: function() {
            try {
              return s2.call(this).match(i)[1];
            } catch (e3) {
              return "";
            }
          } });
        }, { "../internals/descriptors": 43, "../internals/object-define-property": 92 }], 166: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/collection"), e2 = e2("../internals/collection-strong");
          t2.exports = o("Map", function(e3) {
            return function() {
              return e3(this, arguments.length ? arguments[0] : void 0);
            };
          }, e2);
        }, { "../internals/collection": 32, "../internals/collection-strong": 30 }], 167: [function(e2, t2, r) {
          var e2 = e2("../internals/export"), o = Math.hypot, l = Math.abs, u = Math.sqrt;
          e2({ target: "Math", stat: true, forced: !!o && o(1 / 0, NaN) !== 1 / 0 }, { hypot: function(e3, t3) {
            for (var r2, o2, n = 0, s2 = 0, i = arguments.length, a = 0; s2 < i; )
              a < (r2 = l(arguments[s2++])) ? (n = n * (o2 = a / r2) * o2 + 1, a = r2) : n += 0 < r2 ? (o2 = r2 / a) * o2 : r2;
            return a === 1 / 0 ? 1 / 0 : a * u(n);
          } });
        }, { "../internals/export": 50 }], 168: [function(e2, t2, r) {
          e2("../internals/export")({ target: "Math", stat: true }, { sign: e2("../internals/math-sign") });
        }, { "../internals/export": 50, "../internals/math-sign": 80 }], 169: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            var t3, r2, o2, n2, s3, i2, a2, l2 = d(e3, false);
            if ("string" == typeof l2 && 2 < l2.length) {
              if (43 === (e3 = (l2 = g(l2)).charCodeAt(0)) || 45 === e3) {
                if (88 === (t3 = l2.charCodeAt(2)) || 120 === t3)
                  return NaN;
              } else if (48 === e3) {
                switch (l2.charCodeAt(1)) {
                  case 66:
                  case 98:
                    r2 = 2, o2 = 49;
                    break;
                  case 79:
                  case 111:
                    r2 = 8, o2 = 55;
                    break;
                  default:
                    return +l2;
                }
                for (s3 = (n2 = l2.slice(2)).length, i2 = 0; i2 < s3; i2++)
                  if ((a2 = n2.charCodeAt(i2)) < 48 || o2 < a2)
                    return NaN;
                return parseInt(n2, r2);
              }
            }
            return +l2;
          }
          var n = e2("../internals/descriptors"), s2 = e2("../internals/global"), i = e2("../internals/is-forced"), a = e2("../internals/redefine"), l = e2("../internals/has"), u = e2("../internals/classof-raw"), c = e2("../internals/inherit-if-required"), d = e2("../internals/to-primitive"), f = e2("../internals/fails"), h = e2("../internals/object-create"), p = e2("../internals/object-get-own-property-names").f, m = e2("../internals/object-get-own-property-descriptor").f, y = e2("../internals/object-define-property").f, g = e2("../internals/string-trim").trim, v = "Number", b = s2[v], j = b.prototype, _ = u(h(j)) == v;
          if (i(v, !b(" 0o1") || !b("0b1") || b("+0x1"))) {
            for (var x, w = function(e3) {
              var e3 = arguments.length < 1 ? 0 : e3, t3 = this;
              return t3 instanceof w && (_ ? f(function() {
                j.valueOf.call(t3);
              }) : u(t3) != v) ? c(new b(o(e3)), t3, w) : o(e3);
            }, S = n ? p(b) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), M = 0; S.length > M; M++)
              l(b, x = S[M]) && !l(w, x) && y(w, x, m(b, x));
            (w.prototype = j).constructor = w, a(s2, v, w);
          }
        }, { "../internals/classof-raw": 28, "../internals/descriptors": 43, "../internals/fails": 51, "../internals/global": 59, "../internals/has": 60, "../internals/inherit-if-required": 67, "../internals/is-forced": 73, "../internals/object-create": 90, "../internals/object-define-property": 92, "../internals/object-get-own-property-descriptor": 93, "../internals/object-get-own-property-names": 95, "../internals/redefine": 108, "../internals/string-trim": 127, "../internals/to-primitive": 138 }], 170: [function(e2, t2, r) {
          e2("../internals/export")({ target: "Number", stat: true }, { isFinite: e2("../internals/number-is-finite") });
        }, { "../internals/export": 50, "../internals/number-is-finite": 88 }], 171: [function(e2, t2, r) {
          "use strict";
          function c(e3, t3, r2) {
            return 0 === t3 ? r2 : t3 % 2 == 1 ? c(e3, t3 - 1, r2 * e3) : c(e3 * e3, t3 / 2, r2);
          }
          var o = e2("../internals/export"), d = e2("../internals/to-integer"), f = e2("../internals/this-number-value"), h = e2("../internals/string-repeat"), e2 = e2("../internals/fails"), n = 1 .toFixed, p = Math.floor;
          o({ target: "Number", proto: true, forced: n && ("0.000" !== 8e-5 .toFixed(3) || "1" !== 0.9 .toFixed(0) || "1.25" !== 1.255 .toFixed(2) || "1000000000000000128" !== 1000000000000000100 .toFixed(0)) || !e2(function() {
            n.call({});
          }) }, { toFixed: function(e3) {
            function t3(e4, t4) {
              for (var r3 = -1, o3 = t4; ++r3 < 6; )
                o3 += e4 * a[r3], a[r3] = o3 % 1e7, o3 = p(o3 / 1e7);
            }
            function r2(e4) {
              for (var t4 = 6, r3 = 0; 0 <= --t4; )
                r3 += a[t4], a[t4] = p(r3 / e4), r3 = r3 % e4 * 1e7;
            }
            function o2() {
              for (var e4, t4 = 6, r3 = ""; 0 <= --t4; )
                "" === r3 && 0 !== t4 && 0 === a[t4] || (e4 = String(a[t4]), r3 = "" === r3 ? e4 : r3 + h.call("0", 7 - e4.length) + e4);
              return r3;
            }
            var n2, s2, i = f(this), e3 = d(e3), a = [0, 0, 0, 0, 0, 0], l = "", u = "0";
            if (e3 < 0 || 20 < e3)
              throw RangeError("Incorrect fraction digits");
            if (i != i)
              return "NaN";
            if (i <= -1e21 || 1e21 <= i)
              return String(i);
            if (i < 0 && (l = "-", i = -i), 1e-21 < i)
              if (i = (n2 = function(e4) {
                for (var t4 = 0, r3 = e4; 4096 <= r3; )
                  t4 += 12, r3 /= 4096;
                for (; 2 <= r3; )
                  t4 += 1, r3 /= 2;
                return t4;
              }(i * c(2, 69, 1)) - 69) < 0 ? i * c(2, -n2, 1) : i / c(2, n2, 1), i *= 4503599627370496, 0 < (n2 = 52 - n2)) {
                for (t3(0, i), s2 = e3; 7 <= s2; )
                  t3(1e7, 0), s2 -= 7;
                for (t3(c(10, s2, 1), 0), s2 = n2 - 1; 23 <= s2; )
                  r2(1 << 23), s2 -= 23;
                r2(1 << s2), t3(1, 1), r2(2), u = o2();
              } else
                t3(0, i), t3(1 << -n2, 0), u = o2() + h.call("0", e3);
            return u = 0 < e3 ? l + ((i = u.length) <= e3 ? "0." + h.call("0", e3 - i) + u : u.slice(0, i - e3) + "." + u.slice(i - e3)) : l + u;
          } });
        }, { "../internals/export": 50, "../internals/fails": 51, "../internals/string-repeat": 125, "../internals/this-number-value": 129, "../internals/to-integer": 133 }], 172: [function(e2, t2, r) {
          var o = e2("../internals/export"), e2 = e2("../internals/object-assign");
          o({ target: "Object", stat: true, forced: Object.assign !== e2 }, { assign: e2 });
        }, { "../internals/export": 50, "../internals/object-assign": 89 }], 173: [function(e2, t2, r) {
          var o = e2("../internals/export"), n = e2("../internals/fails"), s2 = e2("../internals/to-indexed-object"), i = e2("../internals/object-get-own-property-descriptor").f, e2 = e2("../internals/descriptors"), n = n(function() {
            i(1);
          });
          o({ target: "Object", stat: true, forced: !e2 || n, sham: !e2 }, { getOwnPropertyDescriptor: function(e3, t3) {
            return i(s2(e3), t3);
          } });
        }, { "../internals/descriptors": 43, "../internals/export": 50, "../internals/fails": 51, "../internals/object-get-own-property-descriptor": 93, "../internals/to-indexed-object": 132 }], 174: [function(e2, t2, r) {
          var o = e2("../internals/export"), n = e2("../internals/fails"), e2 = e2("../internals/object-get-own-property-names-external").f;
          o({ target: "Object", stat: true, forced: n(function() {
            return !Object.getOwnPropertyNames(1);
          }) }, { getOwnPropertyNames: e2 });
        }, { "../internals/export": 50, "../internals/fails": 51, "../internals/object-get-own-property-names-external": 94 }], 175: [function(e2, t2, r) {
          var o = e2("../internals/export"), n = e2("../internals/fails"), s2 = e2("../internals/to-object"), i = e2("../internals/object-get-prototype-of"), e2 = e2("../internals/correct-prototype-getter");
          o({ target: "Object", stat: true, forced: n(function() {
            i(1);
          }), sham: !e2 }, { getPrototypeOf: function(e3) {
            return i(s2(e3));
          } });
        }, { "../internals/correct-prototype-getter": 35, "../internals/export": 50, "../internals/fails": 51, "../internals/object-get-prototype-of": 97, "../internals/to-object": 135 }], 176: [function(e2, t2, r) {
          var o = e2("../internals/export"), n = e2("../internals/to-object"), s2 = e2("../internals/object-keys");
          o({ target: "Object", stat: true, forced: e2("../internals/fails")(function() {
            s2(1);
          }) }, { keys: function(e3) {
            return s2(n(e3));
          } });
        }, { "../internals/export": 50, "../internals/fails": 51, "../internals/object-keys": 99, "../internals/to-object": 135 }], 177: [function(e2, t2, r) {
          var o = e2("../internals/to-string-tag-support"), n = e2("../internals/redefine"), e2 = e2("../internals/object-to-string");
          o || n(Object.prototype, "toString", e2, { unsafe: true });
        }, { "../internals/object-to-string": 102, "../internals/redefine": 108, "../internals/to-string-tag-support": 139 }], 178: [function(e2, I, U) {
          "use strict";
          var r, t2, o, n, s2 = e2("../internals/export"), i = e2("../internals/is-pure"), g = e2("../internals/global"), a = e2("../internals/get-built-in"), l = e2("../internals/native-promise-constructor"), N = e2("../internals/redefine"), F = e2("../internals/redefine-all"), B = e2("../internals/set-to-string-tag"), G = e2("../internals/set-species"), V = e2("../internals/is-object"), c = e2("../internals/a-function"), z = e2("../internals/an-instance"), H = e2("../internals/classof-raw"), W = e2("../internals/inspect-source"), d = e2("../internals/iterate"), q = e2("../internals/check-correctness-of-iteration"), X = e2("../internals/species-constructor"), v = e2("../internals/task").set, u = e2("../internals/microtask"), f = e2("../internals/promise-resolve"), Y = e2("../internals/host-report-errors"), h = e2("../internals/new-promise-capability"), b = e2("../internals/perform"), p = e2("../internals/internal-state"), Z = e2("../internals/is-forced"), m = e2("../internals/well-known-symbol"), y = e2("../internals/engine-v8-version"), Q = m("species"), j = "Promise", _ = p.get, K = p.set, J = p.getterFor(j), x = l, w = g.TypeError, S = g.document, M = g.process, E = a("fetch"), T = h.f, $ = T, C = "process" == H(M), ee = !!(S && S.createEvent && g.dispatchEvent), O = "unhandledrejection", te = "rejectionhandled", L = 1, re = 2, k = 1, oe = 2, e2 = Z(j, function() {
            var e3, t3;
            if (!(W(x) !== String(x))) {
              if (66 === y)
                return true;
              if (!C && "function" != typeof PromiseRejectionEvent)
                return true;
            }
            return !(!i || x.prototype.finally) || !(51 <= y && /native code/.test(x)) && (t3 = function(e4) {
              e4(function() {
              }, function() {
              });
            }, ((e3 = x.resolve(1)).constructor = {})[Q] = t3, !(e3.then(function() {
            }) instanceof t3));
          }), m = e2 || !q(function(e3) {
            x.all(e3).catch(function() {
            });
          }), ne = function(e3) {
            var t3;
            return !(!V(e3) || "function" != typeof (t3 = e3.then)) && t3;
          }, A = function(h2, p2, m2) {
            var y2;
            p2.notified || (p2.notified = true, y2 = p2.reactions, u(function() {
              for (var r2, o2, e3 = p2.value, t3 = p2.state == L, n2 = 0; y2.length > n2; ) {
                var s3, i2, a2, l2 = y2[n2++], u2 = t3 ? l2.ok : l2.fail, c2 = l2.resolve, d2 = l2.reject, f2 = l2.domain;
                try {
                  u2 ? (t3 || (p2.rejection === oe && function(e4, t4) {
                    v.call(g, function() {
                      if (C)
                        M.emit("rejectionHandled", e4);
                      else
                        se(te, e4, t4.value);
                    });
                  }(h2, p2), p2.rejection = k), true === u2 ? s3 = e3 : (f2 && f2.enter(), s3 = u2(e3), f2 && (f2.exit(), a2 = true)), s3 === l2.promise ? d2(w("Promise-chain cycle")) : (i2 = ne(s3)) ? i2.call(s3, c2, d2) : c2(s3)) : d2(e3);
                } catch (e4) {
                  f2 && !a2 && f2.exit(), d2(e4);
                }
              }
              p2.reactions = [], p2.notified = false, m2 && !p2.rejection && (r2 = h2, o2 = p2, v.call(g, function() {
                var e4 = o2.value, t4 = ie(o2);
                if (t4 && (t4 = b(function() {
                  C ? M.emit("unhandledRejection", e4, r2) : se(O, r2, e4);
                }), o2.rejection = C || ie(o2) ? oe : k, t4.error))
                  throw t4.value;
              }));
            }));
          }, se = function(e3, t3, r2) {
            var o2;
            ee ? ((o2 = S.createEvent("Event")).promise = t3, o2.reason = r2, o2.initEvent(e3, false, true), g.dispatchEvent(o2)) : o2 = { promise: t3, reason: r2 }, (t3 = g["on" + e3]) ? t3(o2) : e3 === O && Y("Unhandled promise rejection", r2);
          }, ie = function(e3) {
            return e3.rejection !== k && !e3.parent;
          }, P = function(t3, r2, o2, n2) {
            return function(e3) {
              t3(r2, o2, e3, n2);
            };
          }, R = function(e3, t3, r2, o2) {
            t3.done || (t3.done = true, (t3 = o2 ? o2 : t3).value = r2, t3.state = re, A(e3, t3, true));
          }, D = function(r2, o2, e3, t3) {
            if (!o2.done) {
              o2.done = true, t3 && (o2 = t3);
              try {
                if (r2 === e3)
                  throw w("Promise can't be resolved itself");
                var n2 = ne(e3);
                n2 ? u(function() {
                  var t4 = { done: false };
                  try {
                    n2.call(e3, P(D, r2, t4, o2), P(R, r2, t4, o2));
                  } catch (e4) {
                    R(r2, t4, e4, o2);
                  }
                }) : (o2.value = e3, o2.state = L, A(r2, o2, false));
              } catch (e4) {
                R(r2, { done: false }, e4, o2);
              }
            }
          };
          e2 && (x = function(e3) {
            z(this, x, j), c(e3), r.call(this);
            var t3 = _(this);
            try {
              e3(P(D, this, t3), P(R, this, t3));
            } catch (e4) {
              R(this, t3, e4);
            }
          }, (r = function(e3) {
            K(this, { type: j, done: false, notified: false, parent: false, reactions: [], rejection: false, state: 0, value: void 0 });
          }).prototype = F(x.prototype, { then: function(e3, t3) {
            var r2 = J(this), o2 = T(X(this, x));
            return o2.ok = "function" != typeof e3 || e3, o2.fail = "function" == typeof t3 && t3, o2.domain = C ? M.domain : void 0, r2.parent = true, r2.reactions.push(o2), 0 != r2.state && A(this, r2, false), o2.promise;
          }, catch: function(e3) {
            return this.then(void 0, e3);
          } }), t2 = function() {
            var e3 = new r(), t3 = _(e3);
            this.promise = e3, this.resolve = P(D, e3, t3), this.reject = P(R, e3, t3);
          }, h.f = T = function(e3) {
            return e3 === x || e3 === o ? new t2() : $(e3);
          }, i || "function" != typeof l || (n = l.prototype.then, N(l.prototype, "then", function(e3, t3) {
            var r2 = this;
            return new x(function(e4, t4) {
              n.call(r2, e4, t4);
            }).then(e3, t3);
          }, { unsafe: true }), "function" == typeof E && s2({ global: true, enumerable: true, forced: true }, { fetch: function(e3) {
            return f(x, E.apply(g, arguments));
          } }))), s2({ global: true, wrap: true, forced: e2 }, { Promise: x }), B(x, j, false, true), G(j), o = a(j), s2({ target: j, stat: true, forced: e2 }, { reject: function(e3) {
            var t3 = T(this);
            return t3.reject.call(void 0, e3), t3.promise;
          } }), s2({ target: j, stat: true, forced: i || e2 }, { resolve: function(e3) {
            return f(i && this === o ? x : this, e3);
          } }), s2({ target: j, stat: true, forced: m }, { all: function(e3) {
            var a2 = this, t3 = T(a2), l2 = t3.resolve, u2 = t3.reject, r2 = b(function() {
              var o2 = c(a2.resolve), n2 = [], s3 = 0, i2 = 1;
              d(e3, function(e4) {
                var t4 = s3++, r3 = false;
                n2.push(void 0), i2++, o2.call(a2, e4).then(function(e5) {
                  r3 || (r3 = true, n2[t4] = e5, --i2 || l2(n2));
                }, u2);
              }), --i2 || l2(n2);
            });
            return r2.error && u2(r2.value), t3.promise;
          }, race: function(e3) {
            var r2 = this, o2 = T(r2), n2 = o2.reject, t3 = b(function() {
              var t4 = c(r2.resolve);
              d(e3, function(e4) {
                t4.call(r2, e4).then(o2.resolve, n2);
              });
            });
            return t3.error && n2(t3.value), o2.promise;
          } });
        }, { "../internals/a-function": 5, "../internals/an-instance": 9, "../internals/check-correctness-of-iteration": 27, "../internals/classof-raw": 28, "../internals/engine-v8-version": 48, "../internals/export": 50, "../internals/get-built-in": 56, "../internals/global": 59, "../internals/host-report-errors": 62, "../internals/inspect-source": 68, "../internals/internal-state": 70, "../internals/is-forced": 73, "../internals/is-object": 74, "../internals/is-pure": 75, "../internals/iterate": 77, "../internals/microtask": 81, "../internals/native-promise-constructor": 82, "../internals/new-promise-capability": 86, "../internals/perform": 105, "../internals/promise-resolve": 106, "../internals/redefine": 108, "../internals/redefine-all": 107, "../internals/set-species": 116, "../internals/set-to-string-tag": 117, "../internals/species-constructor": 121, "../internals/task": 128, "../internals/well-known-symbol": 146 }], 179: [function(e2, t2, r) {
          var o = e2("../internals/export"), n = e2("../internals/get-built-in"), s2 = e2("../internals/a-function"), i = e2("../internals/an-object"), a = e2("../internals/is-object"), l = e2("../internals/object-create"), u = e2("../internals/function-bind"), e2 = e2("../internals/fails"), c = n("Reflect", "construct"), d = e2(function() {
            function e3() {
            }
            return !(c(function() {
            }, [], e3) instanceof e3);
          }), f = !e2(function() {
            c(function() {
            });
          }), n = d || f;
          o({ target: "Reflect", stat: true, forced: n, sham: n }, { construct: function(e3, t3) {
            s2(e3), i(t3);
            var r2 = arguments.length < 3 ? e3 : s2(arguments[2]);
            if (f && !d)
              return c(e3, t3, r2);
            if (e3 == r2) {
              switch (t3.length) {
                case 0:
                  return new e3();
                case 1:
                  return new e3(t3[0]);
                case 2:
                  return new e3(t3[0], t3[1]);
                case 3:
                  return new e3(t3[0], t3[1], t3[2]);
                case 4:
                  return new e3(t3[0], t3[1], t3[2], t3[3]);
              }
              var o2 = [null];
              return o2.push.apply(o2, t3), new (u.apply(e3, o2))();
            }
            o2 = r2.prototype, r2 = l(a(o2) ? o2 : Object.prototype), o2 = Function.apply.call(e3, r2, t3);
            return a(o2) ? o2 : r2;
          } });
        }, { "../internals/a-function": 5, "../internals/an-object": 10, "../internals/export": 50, "../internals/fails": 51, "../internals/function-bind": 55, "../internals/get-built-in": 56, "../internals/is-object": 74, "../internals/object-create": 90 }], 180: [function(e2, t2, r) {
          var o = e2("../internals/descriptors"), n = e2("../internals/global"), s2 = e2("../internals/is-forced"), i = e2("../internals/inherit-if-required"), a = e2("../internals/object-define-property").f, l = e2("../internals/object-get-own-property-names").f, u = e2("../internals/is-regexp"), c = e2("../internals/regexp-flags"), d = e2("../internals/regexp-sticky-helpers"), f = e2("../internals/redefine"), h = e2("../internals/fails"), p = e2("../internals/internal-state").set, m = e2("../internals/set-species"), y = e2("../internals/well-known-symbol")("match"), g = n.RegExp, v = g.prototype, b = /a/g, j = /a/g, _ = new g(b) !== b, x = d.UNSUPPORTED_Y;
          if (o && s2("RegExp", !_ || x || h(function() {
            return j[y] = false, g(b) != b || g(j) == j || "/a/i" != g(b, "i");
          }))) {
            for (var w = function(e3, t3) {
              var r2, o2 = this instanceof w, n2 = u(e3), s3 = void 0 === t3;
              if (!o2 && n2 && e3.constructor === w && s3)
                return e3;
              _ ? n2 && !s3 && (e3 = e3.source) : e3 instanceof w && (s3 && (t3 = c.call(e3)), e3 = e3.source), x && (r2 = !!t3 && -1 < t3.indexOf("y")) && (t3 = t3.replace(/y/g, ""));
              n2 = i(_ ? new g(e3, t3) : g(e3, t3), o2 ? this : v, w);
              return x && r2 && p(n2, { sticky: r2 }), n2;
            }, S = l(g), M = 0; S.length > M; )
              !function(t3) {
                t3 in w || a(w, t3, { configurable: true, get: function() {
                  return g[t3];
                }, set: function(e3) {
                  g[t3] = e3;
                } });
              }(S[M++]);
            (v.constructor = w).prototype = v, f(n, "RegExp", w);
          }
          m("RegExp");
        }, { "../internals/descriptors": 43, "../internals/fails": 51, "../internals/global": 59, "../internals/inherit-if-required": 67, "../internals/internal-state": 70, "../internals/is-forced": 73, "../internals/is-regexp": 76, "../internals/object-define-property": 92, "../internals/object-get-own-property-names": 95, "../internals/redefine": 108, "../internals/regexp-flags": 111, "../internals/regexp-sticky-helpers": 112, "../internals/set-species": 116, "../internals/well-known-symbol": 146 }], 181: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), e2 = e2("../internals/regexp-exec");
          o({ target: "RegExp", proto: true, forced: /./.exec !== e2 }, { exec: e2 });
        }, { "../internals/export": 50, "../internals/regexp-exec": 110 }], 182: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/redefine"), n = e2("../internals/an-object"), s2 = e2("../internals/fails"), i = e2("../internals/regexp-flags"), e2 = "toString", a = RegExp.prototype, l = a[e2], s2 = s2(function() {
            return "/a/b" != l.call({ source: "a", flags: "b" });
          }), u = l.name != e2;
          (s2 || u) && o(RegExp.prototype, e2, function() {
            var e3 = n(this), t3 = String(e3.source), r2 = e3.flags;
            return "/" + t3 + "/" + String(void 0 === r2 && e3 instanceof RegExp && !("flags" in a) ? i.call(e3) : r2);
          }, { unsafe: true });
        }, { "../internals/an-object": 10, "../internals/fails": 51, "../internals/redefine": 108, "../internals/regexp-flags": 111 }], 183: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/collection"), e2 = e2("../internals/collection-strong");
          t2.exports = o("Set", function(e3) {
            return function() {
              return e3(this, arguments.length ? arguments[0] : void 0);
            };
          }, e2);
        }, { "../internals/collection": 32, "../internals/collection-strong": 30 }], 184: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/object-get-own-property-descriptor").f, s2 = e2("../internals/to-length"), i = e2("../internals/not-a-regexp"), a = e2("../internals/require-object-coercible"), l = e2("../internals/correct-is-regexp-logic"), e2 = e2("../internals/is-pure"), u = "".endsWith, c = Math.min, l = l("endsWith");
          o({ target: "String", proto: true, forced: !!(e2 || l || (!(o = n(String.prototype, "endsWith")) || o.writable)) && !l }, { endsWith: function(e3) {
            var t3 = String(a(this)), r2 = (i(e3), 1 < arguments.length ? arguments[1] : void 0), o2 = s2(t3.length), r2 = void 0 === r2 ? o2 : c(s2(r2), o2), o2 = String(e3);
            return u ? u.call(t3, o2, r2) : t3.slice(r2 - o2.length, r2) === o2;
          } });
        }, { "../internals/correct-is-regexp-logic": 34, "../internals/export": 50, "../internals/is-pure": 75, "../internals/not-a-regexp": 87, "../internals/object-get-own-property-descriptor": 93, "../internals/require-object-coercible": 113, "../internals/to-length": 134 }], 185: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/not-a-regexp"), s2 = e2("../internals/require-object-coercible");
          o({ target: "String", proto: true, forced: !e2("../internals/correct-is-regexp-logic")("includes") }, { includes: function(e3) {
            return !!~String(s2(this)).indexOf(n(e3), 1 < arguments.length ? arguments[1] : void 0);
          } });
        }, { "../internals/correct-is-regexp-logic": 34, "../internals/export": 50, "../internals/not-a-regexp": 87, "../internals/require-object-coercible": 113 }], 186: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/string-multibyte").charAt, n = e2("../internals/internal-state"), e2 = e2("../internals/define-iterator"), s2 = "String Iterator", i = n.set, a = n.getterFor(s2);
          e2(String, "String", function(e3) {
            i(this, { type: s2, string: String(e3), index: 0 });
          }, function() {
            var e3 = a(this), t3 = e3.string, r2 = e3.index;
            return r2 >= t3.length ? { value: void 0, done: true } : (t3 = o(t3, r2), e3.index += t3.length, { value: t3, done: false });
          });
        }, { "../internals/define-iterator": 41, "../internals/internal-state": 70, "../internals/string-multibyte": 123 }], 187: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/fix-regexp-well-known-symbol-logic"), c = e2("../internals/an-object"), d = e2("../internals/to-length"), n = e2("../internals/require-object-coercible"), f = e2("../internals/advance-string-index"), h = e2("../internals/regexp-exec-abstract");
          o("match", 1, function(o2, l, u) {
            return [function(e3) {
              var t3 = n(this), r2 = null == e3 ? void 0 : e3[o2];
              return void 0 !== r2 ? r2.call(e3, t3) : new RegExp(e3)[o2](String(t3));
            }, function(e3) {
              var t3 = u(l, e3, this);
              if (t3.done)
                return t3.value;
              var r2 = c(e3), o3 = String(this);
              if (!r2.global)
                return h(r2, o3);
              for (var n2 = r2.unicode, s2 = [], i = r2.lastIndex = 0; null !== (a = h(r2, o3)); ) {
                var a = String(a[0]);
                "" === (s2[i] = a) && (r2.lastIndex = f(o3, d(r2.lastIndex), n2)), i++;
              }
              return 0 === i ? null : s2;
            }];
          });
        }, { "../internals/advance-string-index": 8, "../internals/an-object": 10, "../internals/fix-regexp-well-known-symbol-logic": 52, "../internals/regexp-exec-abstract": 109, "../internals/require-object-coercible": 113, "../internals/to-length": 134 }], 188: [function(e2, t2, r) {
          e2("../internals/export")({ target: "String", proto: true }, { repeat: e2("../internals/string-repeat") });
        }, { "../internals/export": 50, "../internals/string-repeat": 125 }], 189: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/fix-regexp-well-known-symbol-logic"), M = e2("../internals/an-object"), E = e2("../internals/to-object"), T = e2("../internals/to-length"), C = e2("../internals/to-integer"), s2 = e2("../internals/require-object-coercible"), O = e2("../internals/advance-string-index"), L = e2("../internals/regexp-exec-abstract"), k = Math.max, A = Math.min, P = Math.floor, R = /\$([$&'`]|\d\d?|<[^>]*>)/g, D = /\$([$&'`]|\d\d?)/g;
          o("replace", 2, function(n, j, _, e3) {
            var x = e3.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, w = e3.REPLACE_KEEPS_$0, S = x ? "$" : "$0";
            return [function(e4, t3) {
              var r2 = s2(this), o2 = null == e4 ? void 0 : e4[n];
              return void 0 !== o2 ? o2.call(e4, r2, t3) : j.call(String(r2), e4, t3);
            }, function(e4, t3) {
              if (!x && w || "string" == typeof t3 && -1 === t3.indexOf(S)) {
                var r2 = _(j, e4, this, t3);
                if (r2.done)
                  return r2.value;
              }
              for (var o2, n2 = M(e4), s3 = String(this), i = "function" == typeof t3, a = (i || (t3 = String(t3)), n2.global), l = (a && (o2 = n2.unicode, n2.lastIndex = 0), []); null !== (h = L(n2, s3)) && (l.push(h), a); )
                "" === String(h[0]) && (n2.lastIndex = O(s3, T(n2.lastIndex), o2));
              for (var u, c = "", d = 0, f = 0; f < l.length; f++) {
                for (var h = l[f], p = String(h[0]), m = k(A(C(h.index), s3.length), 0), y = [], g = 1; g < h.length; g++)
                  y.push(void 0 === (u = h[g]) ? u : String(u));
                var v = h.groups, b = i ? (b = [p].concat(y, m, s3), void 0 !== v && b.push(v), String(t3.apply(void 0, b))) : function(s4, i2, a2, l2, u2, e5) {
                  var c2 = a2 + s4.length, d2 = l2.length, t4 = D;
                  void 0 !== u2 && (u2 = E(u2), t4 = R);
                  return j.call(e5, t4, function(e6, t5) {
                    var r3;
                    switch (t5.charAt(0)) {
                      case "$":
                        return "$";
                      case "&":
                        return s4;
                      case "`":
                        return i2.slice(0, a2);
                      case "'":
                        return i2.slice(c2);
                      case "<":
                        r3 = u2[t5.slice(1, -1)];
                        break;
                      default:
                        var o3, n3 = +t5;
                        if (0 == n3)
                          return e6;
                        if (d2 < n3)
                          return 0 !== (o3 = P(n3 / 10)) && o3 <= d2 ? void 0 === l2[o3 - 1] ? t5.charAt(1) : l2[o3 - 1] + t5.charAt(1) : e6;
                        r3 = l2[n3 - 1];
                    }
                    return void 0 === r3 ? "" : r3;
                  });
                }(p, s3, m, y, v, t3);
                d <= m && (c += s3.slice(d, m) + b, d = m + p.length);
              }
              return c + s3.slice(d);
            }];
          });
        }, { "../internals/advance-string-index": 8, "../internals/an-object": 10, "../internals/fix-regexp-well-known-symbol-logic": 52, "../internals/regexp-exec-abstract": 109, "../internals/require-object-coercible": 113, "../internals/to-integer": 133, "../internals/to-length": 134, "../internals/to-object": 135 }], 190: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/fix-regexp-well-known-symbol-logic"), i = e2("../internals/an-object"), a = e2("../internals/require-object-coercible"), l = e2("../internals/same-value"), u = e2("../internals/regexp-exec-abstract");
          o("search", 1, function(o2, n, s2) {
            return [function(e3) {
              var t3 = a(this), r2 = null == e3 ? void 0 : e3[o2];
              return void 0 !== r2 ? r2.call(e3, t3) : new RegExp(e3)[o2](String(t3));
            }, function(e3) {
              var t3, r2 = s2(n, e3, this);
              return r2.done ? r2.value : (r2 = i(e3), e3 = String(this), t3 = r2.lastIndex, l(t3, 0) || (r2.lastIndex = 0), e3 = u(r2, e3), l(r2.lastIndex, t3) || (r2.lastIndex = t3), null === e3 ? -1 : e3.index);
            }];
          });
        }, { "../internals/an-object": 10, "../internals/fix-regexp-well-known-symbol-logic": 52, "../internals/regexp-exec-abstract": 109, "../internals/require-object-coercible": 113, "../internals/same-value": 114 }], 191: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/fix-regexp-well-known-symbol-logic"), c = e2("../internals/is-regexp"), g = e2("../internals/an-object"), d = e2("../internals/require-object-coercible"), v = e2("../internals/species-constructor"), b = e2("../internals/advance-string-index"), j = e2("../internals/to-length"), _ = e2("../internals/regexp-exec-abstract"), f = e2("../internals/regexp-exec"), e2 = e2("../internals/fails"), h = [].push, x = Math.min, w = 4294967295, S = !e2(function() {
            return !RegExp(w, "y");
          });
          o("split", 2, function(n, p, m) {
            var y = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || 1 < ".".split(/()()/).length || "".split(/.?/).length ? function(e3, t3) {
              var r2 = String(d(this)), o2 = void 0 === t3 ? w : t3 >>> 0;
              if (0 == o2)
                return [];
              if (void 0 === e3)
                return [r2];
              if (!c(e3))
                return p.call(r2, e3, o2);
              for (var n2, s2, i, a = [], t3 = (e3.ignoreCase ? "i" : "") + (e3.multiline ? "m" : "") + (e3.unicode ? "u" : "") + (e3.sticky ? "y" : ""), l = 0, u = new RegExp(e3.source, t3 + "g"); (n2 = f.call(u, r2)) && !(l < (s2 = u.lastIndex) && (a.push(r2.slice(l, n2.index)), 1 < n2.length && n2.index < r2.length && h.apply(a, n2.slice(1)), i = n2[0].length, l = s2, a.length >= o2)); )
                u.lastIndex === n2.index && u.lastIndex++;
              return l === r2.length ? !i && u.test("") || a.push("") : a.push(r2.slice(l)), a.length > o2 ? a.slice(0, o2) : a;
            } : "0".split(void 0, 0).length ? function(e3, t3) {
              return void 0 === e3 && 0 === t3 ? [] : p.call(this, e3, t3);
            } : p;
            return [function(e3, t3) {
              var r2 = d(this), o2 = null == e3 ? void 0 : e3[n];
              return void 0 !== o2 ? o2.call(e3, r2, t3) : y.call(String(r2), e3, t3);
            }, function(e3, t3) {
              var r2 = m(y, e3, this, t3, y !== p);
              if (r2.done)
                return r2.value;
              var r2 = g(e3), o2 = String(this), e3 = v(r2, RegExp), n2 = r2.unicode, s2 = (r2.ignoreCase ? "i" : "") + (r2.multiline ? "m" : "") + (r2.unicode ? "u" : "") + (S ? "y" : "g"), i = new e3(S ? r2 : "^(?:" + r2.source + ")", s2), a = void 0 === t3 ? w : t3 >>> 0;
              if (0 == a)
                return [];
              if (0 === o2.length)
                return null === _(i, o2) ? [o2] : [];
              for (var l = 0, u = 0, c2 = []; u < o2.length; ) {
                i.lastIndex = S ? u : 0;
                var d2, f2 = _(i, S ? o2 : o2.slice(u));
                if (null === f2 || (d2 = x(j(i.lastIndex + (S ? 0 : u)), o2.length)) === l)
                  u = b(o2, u, n2);
                else {
                  if (c2.push(o2.slice(l, u)), c2.length === a)
                    return c2;
                  for (var h2 = 1; h2 <= f2.length - 1; h2++)
                    if (c2.push(f2[h2]), c2.length === a)
                      return c2;
                  u = l = d2;
                }
              }
              return c2.push(o2.slice(l)), c2;
            }];
          }, !S);
        }, { "../internals/advance-string-index": 8, "../internals/an-object": 10, "../internals/fails": 51, "../internals/fix-regexp-well-known-symbol-logic": 52, "../internals/is-regexp": 76, "../internals/regexp-exec": 110, "../internals/regexp-exec-abstract": 109, "../internals/require-object-coercible": 113, "../internals/species-constructor": 121, "../internals/to-length": 134 }], 192: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/create-html");
          o({ target: "String", proto: true, forced: e2("../internals/string-html-forced")("sub") }, { sub: function() {
            return n(this, "sub", "", "");
          } });
        }, { "../internals/create-html": 36, "../internals/export": 50, "../internals/string-html-forced": 122 }], 193: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/export"), n = e2("../internals/string-trim").trim;
          o({ target: "String", proto: true, forced: e2("../internals/string-trim-forced")("trim") }, { trim: function() {
            return n(this);
          } });
        }, { "../internals/export": 50, "../internals/string-trim": 127, "../internals/string-trim-forced": 126 }], 194: [function(e2, t2, r) {
          "use strict";
          var o, n, s2, i, a, l = e2("../internals/export"), u = e2("../internals/descriptors"), c = e2("../internals/global"), d = e2("../internals/has"), f = e2("../internals/is-object"), h = e2("../internals/object-define-property").f, e2 = e2("../internals/copy-constructor-properties"), p = c.Symbol;
          !u || "function" != typeof p || "description" in p.prototype && void 0 === p().description || (o = {}, e2(n = function() {
            var e3 = arguments.length < 1 || void 0 === arguments[0] ? void 0 : String(arguments[0]), t3 = this instanceof n ? new p(e3) : void 0 === e3 ? p() : p(e3);
            return "" === e3 && (o[t3] = true), t3;
          }, p), (c = n.prototype = p.prototype).constructor = n, s2 = c.toString, i = "Symbol(test)" == String(p("test")), a = /^Symbol\((.*)\)[^)]+$/, h(c, "description", { configurable: true, get: function() {
            var e3 = f(this) ? this.valueOf() : this, t3 = s2.call(e3);
            return d(o, e3) ? "" : "" === (e3 = i ? t3.slice(7, -1) : t3.replace(a, "$1")) ? void 0 : e3;
          } }), l({ global: true, forced: true }, { Symbol: n }));
        }, { "../internals/copy-constructor-properties": 33, "../internals/descriptors": 43, "../internals/export": 50, "../internals/global": 59, "../internals/has": 60, "../internals/is-object": 74, "../internals/object-define-property": 92 }], 195: [function(e2, t2, r) {
          e2("../internals/define-well-known-symbol")("iterator");
        }, { "../internals/define-well-known-symbol": 42 }], 196: [function(e2, I, U) {
          "use strict";
          function o(e3, t3) {
            var r2 = E[e3] = h(w[_]);
            return ie(r2, { type: j, tag: e3, description: t3 }), s2 || (r2.description = t3), r2;
          }
          function r(t3, e3) {
            u(t3);
            var r2 = c(e3), e3 = q(r2).concat(D(r2));
            return v(e3, function(e4) {
              s2 && !R.call(r2, e4) || P(t3, e4, r2[e4]);
            }), t3;
          }
          function t2(e3, t3) {
            var r2, e3 = c(e3), t3 = d(t3, true);
            if (e3 !== x || !l(E, t3) || l(T, t3))
              return !(r2 = le(e3, t3)) || !l(E, t3) || l(e3, b) && e3[b][t3] || (r2.enumerable = true), r2;
          }
          function N(e3) {
            var e3 = ue(c(e3)), t3 = [];
            return v(e3, function(e4) {
              l(E, e4) || l(ee, e4) || t3.push(e4);
            }), t3;
          }
          var n = e2("../internals/export"), F = e2("../internals/global"), B = e2("../internals/get-built-in"), G = e2("../internals/is-pure"), s2 = e2("../internals/descriptors"), i = e2("../internals/native-symbol"), V = e2("../internals/use-symbol-as-uid"), a = e2("../internals/fails"), l = e2("../internals/has"), z = e2("../internals/is-array"), H = e2("../internals/is-object"), u = e2("../internals/an-object"), W = e2("../internals/to-object"), c = e2("../internals/to-indexed-object"), d = e2("../internals/to-primitive"), f = e2("../internals/create-property-descriptor"), h = e2("../internals/object-create"), q = e2("../internals/object-keys"), X = e2("../internals/object-get-own-property-names"), Y = e2("../internals/object-get-own-property-names-external"), p = e2("../internals/object-get-own-property-symbols"), Z = e2("../internals/object-get-own-property-descriptor"), Q = e2("../internals/object-define-property"), K = e2("../internals/object-property-is-enumerable"), J = e2("../internals/create-non-enumerable-property"), m = e2("../internals/redefine"), y = e2("../internals/shared"), $ = e2("../internals/shared-key"), ee = e2("../internals/hidden-keys"), te = e2("../internals/uid"), re = e2("../internals/well-known-symbol"), oe = e2("../internals/well-known-symbol-wrapped"), ne = e2("../internals/define-well-known-symbol"), se = e2("../internals/set-to-string-tag"), g = e2("../internals/internal-state"), v = e2("../internals/array-iteration").forEach, b = $("hidden"), j = "Symbol", _ = "prototype", e2 = re("toPrimitive"), ie = g.set, ae = g.getterFor(j), x = Object[_], w = F.Symbol, S = B("JSON", "stringify"), le = Z.f, M = Q.f, ue = Y.f, ce = K.f, E = y("symbols"), T = y("op-symbols"), C = y("string-to-symbol-registry"), O = y("symbol-to-string-registry"), $ = y("wks"), g = F.QObject, L = !g || !g[_] || !g[_].findChild, k = s2 && a(function() {
            return 7 != h(M({}, "a", { get: function() {
              return M(this, "a", { value: 7 }).a;
            } })).a;
          }) ? function(e3, t3, r2) {
            var o2 = le(x, t3);
            o2 && delete x[t3], M(e3, t3, r2), o2 && e3 !== x && M(x, t3, o2);
          } : M, A = V ? function(e3) {
            return "symbol" == typeof e3;
          } : function(e3) {
            return Object(e3) instanceof w;
          }, P = function(e3, t3, r2) {
            e3 === x && P(T, t3, r2), u(e3);
            t3 = d(t3, true);
            return u(r2), (l(E, t3) ? (r2.enumerable ? (l(e3, b) && e3[b][t3] && (e3[b][t3] = false), r2 = h(r2, { enumerable: f(0, false) })) : (l(e3, b) || M(e3, b, f(1, {})), e3[b][t3] = true), k) : M)(e3, t3, r2);
          }, R = function(e3) {
            var e3 = d(e3, true), t3 = ce.call(this, e3);
            return !(this === x && l(E, e3) && !l(T, e3)) && (!(t3 || !l(this, e3) || !l(E, e3) || l(this, b) && this[b][e3]) || t3);
          }, D = function(e3) {
            var t3 = e3 === x, e3 = ue(t3 ? T : c(e3)), r2 = [];
            return v(e3, function(e4) {
              !l(E, e4) || t3 && !l(x, e4) || r2.push(E[e4]);
            }), r2;
          };
          i || (m((w = function() {
            if (this instanceof w)
              throw TypeError("Symbol is not a constructor");
            var e3 = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0, t3 = te(e3), r2 = function(e4) {
              this === x && r2.call(T, e4), l(this, b) && l(this[b], t3) && (this[b][t3] = false), k(this, t3, f(1, e4));
            };
            return s2 && L && k(x, t3, { configurable: true, set: r2 }), o(t3, e3);
          })[_], "toString", function() {
            return ae(this).tag;
          }), m(w, "withoutSetter", function(e3) {
            return o(te(e3), e3);
          }), K.f = R, Q.f = P, Z.f = t2, X.f = Y.f = N, p.f = D, oe.f = function(e3) {
            return o(re(e3), e3);
          }, s2 && (M(w[_], "description", { configurable: true, get: function() {
            return ae(this).description;
          } }), G || m(x, "propertyIsEnumerable", R, { unsafe: true }))), n({ global: true, wrap: true, forced: !i, sham: !i }, { Symbol: w }), v(q($), function(e3) {
            ne(e3);
          }), n({ target: j, stat: true, forced: !i }, { for: function(e3) {
            var t3, e3 = String(e3);
            return l(C, e3) ? C[e3] : (t3 = w(e3), C[e3] = t3, O[t3] = e3, t3);
          }, keyFor: function(e3) {
            if (!A(e3))
              throw TypeError(e3 + " is not a symbol");
            if (l(O, e3))
              return O[e3];
          }, useSetter: function() {
            L = true;
          }, useSimple: function() {
            L = false;
          } }), n({ target: "Object", stat: true, forced: !i, sham: !s2 }, { create: function(e3, t3) {
            return void 0 === t3 ? h(e3) : r(h(e3), t3);
          }, defineProperty: P, defineProperties: r, getOwnPropertyDescriptor: t2 }), n({ target: "Object", stat: true, forced: !i }, { getOwnPropertyNames: N, getOwnPropertySymbols: D }), n({ target: "Object", stat: true, forced: a(function() {
            p.f(1);
          }) }, { getOwnPropertySymbols: function(e3) {
            return p.f(W(e3));
          } }), S && n({ target: "JSON", stat: true, forced: !i || a(function() {
            var e3 = w();
            return "[null]" != S([e3]) || "{}" != S({ a: e3 }) || "{}" != S(Object(e3));
          }) }, { stringify: function(e3, t3, r2) {
            for (var o2, n2 = [e3], s3 = 1; s3 < arguments.length; )
              n2.push(arguments[s3++]);
            if ((H(o2 = t3) || void 0 !== e3) && !A(e3))
              return z(t3) || (t3 = function(e4, t4) {
                if ("function" == typeof o2 && (t4 = o2.call(this, e4, t4)), !A(t4))
                  return t4;
              }), n2[1] = t3, S.apply(null, n2);
          } }), w[_][e2] || J(w[_], e2, w[_].valueOf), se(w, j), ee[b] = true;
        }, { "../internals/an-object": 10, "../internals/array-iteration": 19, "../internals/create-non-enumerable-property": 38, "../internals/create-property-descriptor": 39, "../internals/define-well-known-symbol": 42, "../internals/descriptors": 43, "../internals/export": 50, "../internals/fails": 51, "../internals/get-built-in": 56, "../internals/global": 59, "../internals/has": 60, "../internals/hidden-keys": 61, "../internals/internal-state": 70, "../internals/is-array": 72, "../internals/is-object": 74, "../internals/is-pure": 75, "../internals/native-symbol": 83, "../internals/object-create": 90, "../internals/object-define-property": 92, "../internals/object-get-own-property-descriptor": 93, "../internals/object-get-own-property-names": 95, "../internals/object-get-own-property-names-external": 94, "../internals/object-get-own-property-symbols": 96, "../internals/object-keys": 99, "../internals/object-property-is-enumerable": 100, "../internals/redefine": 108, "../internals/set-to-string-tag": 117, "../internals/shared": 120, "../internals/shared-key": 118, "../internals/to-indexed-object": 132, "../internals/to-object": 135, "../internals/to-primitive": 138, "../internals/uid": 143, "../internals/use-symbol-as-uid": 144, "../internals/well-known-symbol": 146, "../internals/well-known-symbol-wrapped": 145 }], 197: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-copy-within"), s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("copyWithin", function(e3, t3) {
            return n.call(s2(this), e3, t3, 2 < arguments.length ? arguments[2] : void 0);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-copy-within": 14 }], 198: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-iteration").every, s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("every", function(e3) {
            return n(s2(this), e3, 1 < arguments.length ? arguments[1] : void 0);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-iteration": 19 }], 199: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-fill"), s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("fill", function(e3) {
            return n.apply(s2(this), arguments);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-fill": 15 }], 200: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), s2 = e2("../internals/array-iteration").filter, i = e2("../internals/species-constructor"), a = o.aTypedArray, l = o.aTypedArrayConstructor;
          (0, o.exportTypedArrayMethod)("filter", function(e3) {
            for (var t3 = s2(a(this), e3, 1 < arguments.length ? arguments[1] : void 0), e3 = i(this, this.constructor), r2 = 0, o2 = t3.length, n = new (l(e3))(o2); r2 < o2; )
              n[r2] = t3[r2++];
            return n;
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-iteration": 19, "../internals/species-constructor": 121 }], 201: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-iteration").findIndex, s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("findIndex", function(e3) {
            return n(s2(this), e3, 1 < arguments.length ? arguments[1] : void 0);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-iteration": 19 }], 202: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-iteration").find, s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("find", function(e3) {
            return n(s2(this), e3, 1 < arguments.length ? arguments[1] : void 0);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-iteration": 19 }], 203: [function(e2, t2, r) {
          e2("../internals/typed-array-constructor")("Float32", function(o) {
            return function(e3, t3, r2) {
              return o(this, e3, t3, r2);
            };
          });
        }, { "../internals/typed-array-constructor": 140 }], 204: [function(e2, t2, r) {
          e2("../internals/typed-array-constructor")("Float64", function(o) {
            return function(e3, t3, r2) {
              return o(this, e3, t3, r2);
            };
          });
        }, { "../internals/typed-array-constructor": 140 }], 205: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-iteration").forEach, s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("forEach", function(e3) {
            n(s2(this), e3, 1 < arguments.length ? arguments[1] : void 0);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-iteration": 19 }], 206: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-includes").includes, s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("includes", function(e3) {
            return n(s2(this), e3, 1 < arguments.length ? arguments[1] : void 0);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-includes": 18 }], 207: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-includes").indexOf, s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("indexOf", function(e3) {
            return n(s2(this), e3, 1 < arguments.length ? arguments[1] : void 0);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-includes": 18 }], 208: [function(e2, t2, r) {
          e2("../internals/typed-array-constructor")("Int16", function(o) {
            return function(e3, t3, r2) {
              return o(this, e3, t3, r2);
            };
          });
        }, { "../internals/typed-array-constructor": 140 }], 209: [function(e2, t2, r) {
          e2("../internals/typed-array-constructor")("Int32", function(o) {
            return function(e3, t3, r2) {
              return o(this, e3, t3, r2);
            };
          });
        }, { "../internals/typed-array-constructor": 140 }], 210: [function(e2, t2, r) {
          "use strict";
          function o() {
            return a.call(c(this));
          }
          var n = e2("../internals/global"), s2 = e2("../internals/array-buffer-view-core"), i = e2("../modules/es.array.iterator"), e2 = e2("../internals/well-known-symbol")("iterator"), n = n.Uint8Array, a = i.values, l = i.keys, u = i.entries, c = s2.aTypedArray, i = s2.exportTypedArrayMethod, s2 = n && n.prototype[e2], n = !!s2 && ("values" == s2.name || null == s2.name);
          i("entries", function() {
            return u.call(c(this));
          }), i("keys", function() {
            return l.call(c(this));
          }), i("values", o, !n), i(e2, o, !n);
        }, { "../internals/array-buffer-view-core": 12, "../internals/global": 59, "../internals/well-known-symbol": 146, "../modules/es.array.iterator": 158 }], 211: [function(e2, t2, r) {
          "use strict";
          var e2 = e2("../internals/array-buffer-view-core"), o = e2.aTypedArray, e2 = e2.exportTypedArrayMethod, n = [].join;
          e2("join", function(e3) {
            return n.apply(o(this), arguments);
          });
        }, { "../internals/array-buffer-view-core": 12 }], 212: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-last-index-of"), s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("lastIndexOf", function(e3) {
            return n.apply(s2(this), arguments);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-last-index-of": 20 }], 213: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-iteration").map, s2 = e2("../internals/species-constructor"), i = o.aTypedArray, a = o.aTypedArrayConstructor;
          (0, o.exportTypedArrayMethod)("map", function(e3) {
            return n(i(this), e3, 1 < arguments.length ? arguments[1] : void 0, function(e4, t3) {
              return new (a(s2(e4, e4.constructor)))(t3);
            });
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-iteration": 19, "../internals/species-constructor": 121 }], 214: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-reduce").right, s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("reduceRight", function(e3) {
            return n(s2(this), e3, arguments.length, 1 < arguments.length ? arguments[1] : void 0);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-reduce": 24 }], 215: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-reduce").left, s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("reduce", function(e3) {
            return n(s2(this), e3, arguments.length, 1 < arguments.length ? arguments[1] : void 0);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-reduce": 24 }], 216: [function(e2, t2, r) {
          "use strict";
          var e2 = e2("../internals/array-buffer-view-core"), n = e2.aTypedArray, e2 = e2.exportTypedArrayMethod, s2 = Math.floor;
          e2("reverse", function() {
            for (var e3, t3 = n(this).length, r2 = s2(t3 / 2), o = 0; o < r2; )
              e3 = this[o], this[o++] = this[--t3], this[t3] = e3;
            return this;
          });
        }, { "../internals/array-buffer-view-core": 12 }], 217: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), i = e2("../internals/to-length"), a = e2("../internals/to-offset"), l = e2("../internals/to-object"), e2 = e2("../internals/fails"), u = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("set", function(e3) {
            u(this);
            var t3 = a(1 < arguments.length ? arguments[1] : void 0, 1), r2 = this.length, o2 = l(e3), n = i(o2.length), s2 = 0;
            if (r2 < n + t3)
              throw RangeError("Wrong length");
            for (; s2 < n; )
              this[t3 + s2] = o2[s2++];
          }, e2(function() {
            new Int8Array(1).set({});
          }));
        }, { "../internals/array-buffer-view-core": 12, "../internals/fails": 51, "../internals/to-length": 134, "../internals/to-object": 135, "../internals/to-offset": 136 }], 218: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), i = e2("../internals/species-constructor"), e2 = e2("../internals/fails"), a = o.aTypedArray, l = o.aTypedArrayConstructor, o = o.exportTypedArrayMethod, u = [].slice;
          o("slice", function(e3, t3) {
            for (var r2 = u.call(a(this), e3, t3), e3 = i(this, this.constructor), o2 = 0, n = r2.length, s2 = new (l(e3))(n); o2 < n; )
              s2[o2] = r2[o2++];
            return s2;
          }, e2(function() {
            new Int8Array(1).slice();
          }));
        }, { "../internals/array-buffer-view-core": 12, "../internals/fails": 51, "../internals/species-constructor": 121 }], 219: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/array-iteration").some, s2 = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("some", function(e3) {
            return n(s2(this), e3, 1 < arguments.length ? arguments[1] : void 0);
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/array-iteration": 19 }], 220: [function(e2, t2, r) {
          "use strict";
          var e2 = e2("../internals/array-buffer-view-core"), o = e2.aTypedArray, e2 = e2.exportTypedArrayMethod, n = [].sort;
          e2("sort", function(e3) {
            return n.call(o(this), e3);
          });
        }, { "../internals/array-buffer-view-core": 12 }], 221: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core"), n = e2("../internals/to-length"), s2 = e2("../internals/to-absolute-index"), i = e2("../internals/species-constructor"), a = o.aTypedArray;
          (0, o.exportTypedArrayMethod)("subarray", function(e3, t3) {
            var r2 = a(this), o2 = r2.length, e3 = s2(e3, o2);
            return new (i(r2, r2.constructor))(r2.buffer, r2.byteOffset + e3 * r2.BYTES_PER_ELEMENT, n((void 0 === t3 ? o2 : s2(t3, o2)) - e3));
          });
        }, { "../internals/array-buffer-view-core": 12, "../internals/species-constructor": 121, "../internals/to-absolute-index": 130, "../internals/to-length": 134 }], 222: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/global"), n = e2("../internals/array-buffer-view-core"), e2 = e2("../internals/fails"), s2 = o.Int8Array, i = n.aTypedArray, o = n.exportTypedArrayMethod, a = [].toLocaleString, l = [].slice, u = !!s2 && e2(function() {
            a.call(new s2(1));
          });
          o("toLocaleString", function() {
            return a.apply(u ? l.call(i(this)) : i(this), arguments);
          }, e2(function() {
            return [1, 2].toLocaleString() != new s2([1, 2]).toLocaleString();
          }) || !e2(function() {
            s2.prototype.toLocaleString.call([1, 2]);
          }));
        }, { "../internals/array-buffer-view-core": 12, "../internals/fails": 51, "../internals/global": 59 }], 223: [function(e2, t2, r) {
          "use strict";
          var o = e2("../internals/array-buffer-view-core").exportTypedArrayMethod, n = e2("../internals/fails"), e2 = e2("../internals/global").Uint8Array, e2 = e2 && e2.prototype || {}, s2 = [].toString, i = [].join, n = (n(function() {
            s2.call({});
          }) && (s2 = function() {
            return i.call(this);
          }), e2.toString != s2);
          o("toString", s2, n);
        }, { "../internals/array-buffer-view-core": 12, "../internals/fails": 51, "../internals/global": 59 }], 224: [function(e2, t2, r) {
          e2("../internals/typed-array-constructor")("Uint16", function(o) {
            return function(e3, t3, r2) {
              return o(this, e3, t3, r2);
            };
          });
        }, { "../internals/typed-array-constructor": 140 }], 225: [function(e2, t2, r) {
          e2("../internals/typed-array-constructor")("Uint32", function(o) {
            return function(e3, t3, r2) {
              return o(this, e3, t3, r2);
            };
          });
        }, { "../internals/typed-array-constructor": 140 }], 226: [function(e2, t2, r) {
          e2("../internals/typed-array-constructor")("Uint8", function(o) {
            return function(e3, t3, r2) {
              return o(this, e3, t3, r2);
            };
          });
        }, { "../internals/typed-array-constructor": 140 }], 227: [function(e2, t2, r) {
          e2("../internals/typed-array-constructor")("Uint8", function(o) {
            return function(e3, t3, r2) {
              return o(this, e3, t3, r2);
            };
          }, true);
        }, { "../internals/typed-array-constructor": 140 }], 228: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return function() {
              return e3(this, arguments.length ? arguments[0] : void 0);
            };
          }
          var n, s2, i, a, l, u = e2("../internals/global"), c = e2("../internals/redefine-all"), d = e2("../internals/internal-metadata"), f = e2("../internals/collection"), h = e2("../internals/collection-weak"), p = e2("../internals/is-object"), m = e2("../internals/internal-state").enforce, e2 = e2("../internals/native-weak-map"), u = !u.ActiveXObject && "ActiveXObject" in u, y = Object.isExtensible, t2 = t2.exports = f("WeakMap", o, h);
          e2 && u && (n = h.getConstructor(o, "WeakMap", true), d.REQUIRED = true, f = t2.prototype, s2 = f.delete, i = f.has, a = f.get, l = f.set, c(f, { delete: function(e3) {
            var t3;
            return p(e3) && !y(e3) ? ((t3 = m(this)).frozen || (t3.frozen = new n()), s2.call(this, e3) || t3.frozen.delete(e3)) : s2.call(this, e3);
          }, has: function(e3) {
            var t3;
            return p(e3) && !y(e3) ? ((t3 = m(this)).frozen || (t3.frozen = new n()), i.call(this, e3) || t3.frozen.has(e3)) : i.call(this, e3);
          }, get: function(e3) {
            var t3;
            return !p(e3) || y(e3) || ((t3 = m(this)).frozen || (t3.frozen = new n()), i.call(this, e3)) ? a.call(this, e3) : t3.frozen.get(e3);
          }, set: function(e3, t3) {
            var r2;
            return !p(e3) || y(e3) || ((r2 = m(this)).frozen || (r2.frozen = new n()), i.call(this, e3)) ? l.call(this, e3, t3) : r2.frozen.set(e3, t3), this;
          } }));
        }, { "../internals/collection": 32, "../internals/collection-weak": 31, "../internals/global": 59, "../internals/internal-metadata": 69, "../internals/internal-state": 70, "../internals/is-object": 74, "../internals/native-weak-map": 85, "../internals/redefine-all": 107 }], 229: [function(e2, t2, r) {
          var o, n = e2("../internals/global"), s2 = e2("../internals/dom-iterables"), i = e2("../internals/array-for-each"), a = e2("../internals/create-non-enumerable-property");
          for (o in s2) {
            var l = n[o], l = l && l.prototype;
            if (l && l.forEach !== i)
              try {
                a(l, "forEach", i);
              } catch (e3) {
                l.forEach = i;
              }
          }
        }, { "../internals/array-for-each": 16, "../internals/create-non-enumerable-property": 38, "../internals/dom-iterables": 45, "../internals/global": 59 }], 230: [function(e2, t2, r) {
          var o, n = e2("../internals/global"), s2 = e2("../internals/dom-iterables"), i = e2("../modules/es.array.iterator"), a = e2("../internals/create-non-enumerable-property"), e2 = e2("../internals/well-known-symbol"), l = e2("iterator"), u = e2("toStringTag"), c = i.values;
          for (o in s2) {
            var d = n[o], f = d && d.prototype;
            if (f) {
              if (f[l] !== c)
                try {
                  a(f, l, c);
                } catch (e3) {
                  f[l] = c;
                }
              if (f[u] || a(f, u, o), s2[o]) {
                for (var h in i)
                  if (f[h] !== i[h])
                    try {
                      a(f, h, i[h]);
                    } catch (e3) {
                      f[h] = i[h];
                    }
              }
            }
          }
        }, { "../internals/create-non-enumerable-property": 38, "../internals/dom-iterables": 45, "../internals/global": 59, "../internals/well-known-symbol": 146, "../modules/es.array.iterator": 158 }], 231: [function(e2, t2, I) {
          "use strict";
          e2("../modules/es.array.iterator");
          function n(t3) {
            try {
              return decodeURIComponent(t3);
            } catch (e3) {
              return t3;
            }
          }
          function r(e3) {
            return B[e3];
          }
          function s2(e3) {
            return encodeURIComponent(e3).replace(F, r);
          }
          function c(e3) {
            this.entries.length = 0, R(this.entries, e3);
          }
          function u(e3, t3) {
            if (e3 < t3)
              throw TypeError("Not enough arguments");
          }
          function d() {
            y(this, d, C);
            var e3, t3, r2, o2, n2, s3, i2, a2, l2 = 0 < arguments.length ? arguments[0] : void 0, u2 = [];
            if (L(this, { type: C, entries: u2, updateURL: function() {
            }, updateSearchParams: c }), void 0 !== l2)
              if (_(l2))
                if ("function" == typeof (e3 = M(l2)))
                  for (r2 = (t3 = e3.call(l2)).next; !(o2 = r2.call(t3)).done; ) {
                    if ((s3 = (n2 = (o2 = S(j(o2.value))).next).call(o2)).done || (i2 = n2.call(o2)).done || !n2.call(o2).done)
                      throw TypeError("Expected sequence with length 2");
                    u2.push({ key: s3.value + "", value: i2.value + "" });
                  }
                else
                  for (a2 in l2)
                    g(l2, a2) && u2.push({ key: a2, value: l2[a2] + "" });
              else
                R(u2, "string" == typeof l2 ? "?" === l2.charAt(0) ? l2.slice(1) : l2 : l2 + "");
          }
          var o = e2("../internals/export"), i = e2("../internals/get-built-in"), a = e2("../internals/native-url"), l = e2("../internals/redefine"), f = e2("../internals/redefine-all"), h = e2("../internals/set-to-string-tag"), p = e2("../internals/create-iterator-constructor"), m = e2("../internals/internal-state"), y = e2("../internals/an-instance"), g = e2("../internals/has"), v = e2("../internals/function-bind-context"), b = e2("../internals/classof"), j = e2("../internals/an-object"), _ = e2("../internals/is-object"), x = e2("../internals/object-create"), w = e2("../internals/create-property-descriptor"), S = e2("../internals/get-iterator"), M = e2("../internals/get-iterator-method"), e2 = e2("../internals/well-known-symbol"), E = i("fetch"), T = i("Headers"), i = e2("iterator"), C = "URLSearchParams", O = C + "Iterator", L = m.set, k = m.getterFor(C), U = m.getterFor(O), N = /\+/g, A = Array(4), P = function(e3) {
            var t3, r2 = e3.replace(N, " "), o2 = 4;
            try {
              return decodeURIComponent(r2);
            } catch (e4) {
              for (; o2; )
                r2 = r2.replace((t3 = o2--, A[t3 - 1] || (A[t3 - 1] = RegExp("((?:%[\\da-f]{2}){" + t3 + "})", "gi"))), n);
              return r2;
            }
          }, F = /[!'()~]|%20/g, B = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, R = function(e3, t3) {
            if (t3)
              for (var r2, o2 = t3.split("&"), n2 = 0; n2 < o2.length; )
                (r2 = o2[n2++]).length && (r2 = r2.split("="), e3.push({ key: P(r2.shift()), value: P(r2.join("=")) }));
          }, D = p(function(e3, t3) {
            L(this, { type: O, iterator: S(k(e3).entries), kind: t3 });
          }, "Iterator", function() {
            var e3 = U(this), t3 = e3.kind, e3 = e3.iterator.next(), r2 = e3.value;
            return e3.done || (e3.value = "keys" === t3 ? r2.key : "values" === t3 ? r2.value : [r2.key, r2.value]), e3;
          }), e2 = d.prototype;
          f(e2, { append: function(e3, t3) {
            u(arguments.length, 2);
            var r2 = k(this);
            r2.entries.push({ key: e3 + "", value: t3 + "" }), r2.updateURL();
          }, delete: function(e3) {
            u(arguments.length, 1);
            for (var t3 = k(this), r2 = t3.entries, o2 = e3 + "", n2 = 0; n2 < r2.length; )
              r2[n2].key === o2 ? r2.splice(n2, 1) : n2++;
            t3.updateURL();
          }, get: function(e3) {
            u(arguments.length, 1);
            for (var t3 = k(this).entries, r2 = e3 + "", o2 = 0; o2 < t3.length; o2++)
              if (t3[o2].key === r2)
                return t3[o2].value;
            return null;
          }, getAll: function(e3) {
            u(arguments.length, 1);
            for (var t3 = k(this).entries, r2 = e3 + "", o2 = [], n2 = 0; n2 < t3.length; n2++)
              t3[n2].key === r2 && o2.push(t3[n2].value);
            return o2;
          }, has: function(e3) {
            u(arguments.length, 1);
            for (var t3 = k(this).entries, r2 = e3 + "", o2 = 0; o2 < t3.length; )
              if (t3[o2++].key === r2)
                return true;
            return false;
          }, set: function(e3, t3) {
            u(arguments.length, 1);
            for (var r2, o2 = k(this), n2 = o2.entries, s3 = false, i2 = e3 + "", a2 = t3 + "", l2 = 0; l2 < n2.length; l2++)
              (r2 = n2[l2]).key === i2 && (s3 ? n2.splice(l2--, 1) : (s3 = true, r2.value = a2));
            s3 || n2.push({ key: i2, value: a2 }), o2.updateURL();
          }, sort: function() {
            for (var e3, t3, r2 = k(this), o2 = r2.entries, n2 = o2.slice(), s3 = o2.length = 0; s3 < n2.length; s3++) {
              for (e3 = n2[s3], t3 = 0; t3 < s3; t3++)
                if (o2[t3].key > e3.key) {
                  o2.splice(t3, 0, e3);
                  break;
                }
              t3 === s3 && o2.push(e3);
            }
            r2.updateURL();
          }, forEach: function(e3) {
            for (var t3, r2 = k(this).entries, o2 = v(e3, 1 < arguments.length ? arguments[1] : void 0, 3), n2 = 0; n2 < r2.length; )
              o2((t3 = r2[n2++]).value, t3.key, this);
          }, keys: function() {
            return new D(this, "keys");
          }, values: function() {
            return new D(this, "values");
          }, entries: function() {
            return new D(this, "entries");
          } }, { enumerable: true }), l(e2, i, e2.entries), l(e2, "toString", function() {
            for (var e3, t3 = k(this).entries, r2 = [], o2 = 0; o2 < t3.length; )
              e3 = t3[o2++], r2.push(s2(e3.key) + "=" + s2(e3.value));
            return r2.join("&");
          }, { enumerable: true }), h(d, C), o({ global: true, forced: !a }, { URLSearchParams: d }), a || "function" != typeof E || "function" != typeof T || o({ global: true, enumerable: true, forced: true }, { fetch: function(e3) {
            var t3, r2, o2, e3 = [e3];
            return 1 < arguments.length && (_(t3 = arguments[1]) && (r2 = t3.body, b(r2) === C && ((o2 = t3.headers ? new T(t3.headers) : new T()).has("content-type") || o2.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"), t3 = x(t3, { body: w(0, String(r2)), headers: w(0, o2) }))), e3.push(t3)), E.apply(this, e3);
          } }), t2.exports = { URLSearchParams: d, getState: k };
        }, { "../internals/an-instance": 9, "../internals/an-object": 10, "../internals/classof": 29, "../internals/create-iterator-constructor": 37, "../internals/create-property-descriptor": 39, "../internals/export": 50, "../internals/function-bind-context": 54, "../internals/get-built-in": 56, "../internals/get-iterator": 58, "../internals/get-iterator-method": 57, "../internals/has": 60, "../internals/internal-state": 70, "../internals/is-object": 74, "../internals/native-url": 84, "../internals/object-create": 90, "../internals/redefine": 108, "../internals/redefine-all": 107, "../internals/set-to-string-tag": 117, "../internals/well-known-symbol": 146, "../modules/es.array.iterator": 158 }], 232: [function(e2, y, U) {
          "use strict";
          e2("../modules/es.string.iterator");
          function c(e3) {
            var t3, r2, o2, n2;
            if ("number" == typeof e3) {
              for (t3 = [], r2 = 0; r2 < 4; r2++)
                t3.unshift(e3 % 256), e3 = Y(e3 / 256);
              return t3.join(".");
            }
            if ("object" != typeof e3)
              return e3;
            for (t3 = "", o2 = le(e3), r2 = 0; r2 < 8; r2++)
              n2 && 0 === e3[r2] || (n2 = n2 && false, o2 === r2 ? (t3 += r2 ? ":" : "::", n2 = true) : (t3 += e3[r2].toString(16), r2 < 7 && (t3 += ":")));
            return "[" + t3 + "]";
          }
          function n(e3) {
            return !e3.host || e3.cannotBeABaseURL || "file" == e3.scheme;
          }
          function a(e3, t3, r2, o2) {
            var n2, s3, i2, a2 = r2 || me, l2 = 0, u2 = "", c2 = false, d2 = false, f2 = false;
            for (r2 || (e3.scheme = "", e3.username = "", e3.password = "", e3.host = null, e3.port = null, e3.path = [], e3.query = null, e3.fragment = null, e3.cannotBeABaseURL = false, t3 = t3.replace(ie, "")), t3 = t3.replace(ae, ""), n2 = b(t3); l2 <= n2.length; ) {
              switch (s3 = n2[l2], a2) {
                case me:
                  if (!s3 || !J.test(s3)) {
                    if (r2)
                      return j;
                    a2 = ge;
                    continue;
                  }
                  u2 += s3.toLowerCase(), a2 = ye;
                  break;
                case ye:
                  if (s3 && ($.test(s3) || "+" == s3 || "-" == s3 || "." == s3))
                    u2 += s3.toLowerCase();
                  else {
                    if (":" != s3) {
                      if (r2)
                        return j;
                      u2 = "", a2 = ge, l2 = 0;
                      continue;
                    }
                    if (r2 && (C(e3) != v(T, u2) || "file" == u2 && (O(e3) || null !== e3.port) || "file" == e3.scheme && !e3.host))
                      return;
                    if (e3.scheme = u2, r2)
                      return void (C(e3) && T[e3.scheme] == e3.port && (e3.port = null));
                    u2 = "", "file" == e3.scheme ? a2 = Ee : C(e3) && o2 && o2.scheme == e3.scheme ? a2 = ve : C(e3) ? a2 = xe : "/" == n2[l2 + 1] ? (a2 = be, l2++) : (e3.cannotBeABaseURL = true, e3.path.push(""), a2 = Oe);
                  }
                  break;
                case ge:
                  if (!o2 || o2.cannotBeABaseURL && "#" != s3)
                    return j;
                  if (o2.cannotBeABaseURL && "#" == s3) {
                    e3.scheme = o2.scheme, e3.path = o2.path.slice(), e3.query = o2.query, e3.fragment = "", e3.cannotBeABaseURL = true, a2 = I;
                    break;
                  }
                  a2 = "file" == o2.scheme ? Ee : je;
                  continue;
                case ve:
                  if ("/" != s3 || "/" != n2[l2 + 1]) {
                    a2 = je;
                    continue;
                  }
                  a2 = k, l2++;
                  break;
                case be:
                  if ("/" == s3) {
                    a2 = A;
                    break;
                  }
                  a2 = R;
                  continue;
                case je:
                  if (e3.scheme = o2.scheme, s3 == g)
                    e3.username = o2.username, e3.password = o2.password, e3.host = o2.host, e3.port = o2.port, e3.path = o2.path.slice(), e3.query = o2.query;
                  else if ("/" == s3 || "\\" == s3 && C(e3))
                    a2 = _e;
                  else if ("?" == s3)
                    e3.username = o2.username, e3.password = o2.password, e3.host = o2.host, e3.port = o2.port, e3.path = o2.path.slice(), e3.query = "", a2 = D;
                  else {
                    if ("#" != s3) {
                      e3.username = o2.username, e3.password = o2.password, e3.host = o2.host, e3.port = o2.port, e3.path = o2.path.slice(), e3.path.pop(), a2 = R;
                      continue;
                    }
                    e3.username = o2.username, e3.password = o2.password, e3.host = o2.host, e3.port = o2.port, e3.path = o2.path.slice(), e3.query = o2.query, e3.fragment = "", a2 = I;
                  }
                  break;
                case _e:
                  if (!C(e3) || "/" != s3 && "\\" != s3) {
                    if ("/" != s3) {
                      e3.username = o2.username, e3.password = o2.password, e3.host = o2.host, e3.port = o2.port, a2 = R;
                      continue;
                    }
                    a2 = A;
                  } else
                    a2 = k;
                  break;
                case xe:
                  if (a2 = k, "/" != s3 || "/" != u2.charAt(l2 + 1))
                    continue;
                  l2++;
                  break;
                case k:
                  if ("/" == s3 || "\\" == s3)
                    break;
                  a2 = A;
                  continue;
                case A:
                  if ("@" == s3) {
                    c2 && (u2 = "%40" + u2);
                    for (var c2 = true, h2 = b(u2), p2 = 0; p2 < h2.length; p2++) {
                      var m2 = h2[p2];
                      ":" != m2 || f2 ? (m2 = E(m2, M), f2 ? e3.password += m2 : e3.username += m2) : f2 = true;
                    }
                    u2 = "";
                  } else if (s3 == g || "/" == s3 || "?" == s3 || "#" == s3 || "\\" == s3 && C(e3)) {
                    if (c2 && "" == u2)
                      return Q;
                    l2 -= b(u2).length + 1, u2 = "", a2 = we;
                  } else
                    u2 += s3;
                  break;
                case we:
                case Se:
                  if (r2 && "file" == e3.scheme) {
                    a2 = Ce;
                    continue;
                  }
                  if (":" != s3 || d2) {
                    if (s3 == g || "/" == s3 || "?" == s3 || "#" == s3 || "\\" == s3 && C(e3)) {
                      if (C(e3) && "" == u2)
                        return _;
                      if (r2 && "" == u2 && (O(e3) || null !== e3.port))
                        return;
                      if (i2 = w(e3, u2))
                        return i2;
                      if (u2 = "", a2 = P, r2)
                        return;
                      continue;
                    }
                    "[" == s3 ? d2 = true : "]" == s3 && (d2 = false), u2 += s3;
                  } else {
                    if ("" == u2)
                      return _;
                    if (i2 = w(e3, u2))
                      return i2;
                    if (u2 = "", a2 = Me, r2 == Se)
                      return;
                  }
                  break;
                case Me:
                  if (!x.test(s3)) {
                    if (s3 == g || "/" == s3 || "?" == s3 || "#" == s3 || "\\" == s3 && C(e3) || r2) {
                      if ("" != u2) {
                        var y2 = parseInt(u2, 10);
                        if (65535 < y2)
                          return K;
                        e3.port = C(e3) && y2 === T[e3.scheme] ? null : y2, u2 = "";
                      }
                      if (r2)
                        return;
                      a2 = P;
                      continue;
                    }
                    return K;
                  }
                  u2 += s3;
                  break;
                case Ee:
                  if (e3.scheme = "file", "/" == s3 || "\\" == s3)
                    a2 = Te;
                  else {
                    if (!o2 || "file" != o2.scheme) {
                      a2 = R;
                      continue;
                    }
                    if (s3 == g)
                      e3.host = o2.host, e3.path = o2.path.slice(), e3.query = o2.query;
                    else if ("?" == s3)
                      e3.host = o2.host, e3.path = o2.path.slice(), e3.query = "", a2 = D;
                    else {
                      if ("#" != s3) {
                        de(n2.slice(l2).join("")) || (e3.host = o2.host, e3.path = o2.path.slice(), fe(e3)), a2 = R;
                        continue;
                      }
                      e3.host = o2.host, e3.path = o2.path.slice(), e3.query = o2.query, e3.fragment = "", a2 = I;
                    }
                  }
                  break;
                case Te:
                  if ("/" == s3 || "\\" == s3) {
                    a2 = Ce;
                    break;
                  }
                  o2 && "file" == o2.scheme && !de(n2.slice(l2).join("")) && (L(o2.path[0], true) ? e3.path.push(o2.path[0]) : e3.host = o2.host), a2 = R;
                  continue;
                case Ce:
                  if (s3 == g || "/" == s3 || "\\" == s3 || "?" == s3 || "#" == s3) {
                    if (!r2 && L(u2))
                      a2 = R;
                    else {
                      if ("" == u2) {
                        if (e3.host = "", r2)
                          return;
                      } else {
                        if (i2 = w(e3, u2))
                          return i2;
                        if ("localhost" == e3.host && (e3.host = ""), r2)
                          return;
                        u2 = "";
                      }
                      a2 = P;
                    }
                    continue;
                  }
                  u2 += s3;
                  break;
                case P:
                  if (C(e3)) {
                    if (a2 = R, "/" != s3 && "\\" != s3)
                      continue;
                  } else if (r2 || "?" != s3)
                    if (r2 || "#" != s3) {
                      if (s3 != g && (a2 = R, "/" != s3))
                        continue;
                    } else
                      e3.fragment = "", a2 = I;
                  else
                    e3.query = "", a2 = D;
                  break;
                case R:
                  if (s3 == g || "/" == s3 || "\\" == s3 && C(e3) || !r2 && ("?" == s3 || "#" == s3)) {
                    if (pe(u2) ? (fe(e3), "/" == s3 || "\\" == s3 && C(e3) || e3.path.push("")) : he(u2) ? "/" == s3 || "\\" == s3 && C(e3) || e3.path.push("") : ("file" == e3.scheme && !e3.path.length && L(u2) && (e3.host && (e3.host = ""), u2 = u2.charAt(0) + ":"), e3.path.push(u2)), u2 = "", "file" == e3.scheme && (s3 == g || "?" == s3 || "#" == s3))
                      for (; 1 < e3.path.length && "" === e3.path[0]; )
                        e3.path.shift();
                    "?" == s3 ? (e3.query = "", a2 = D) : "#" == s3 && (e3.fragment = "", a2 = I);
                  } else
                    u2 += E(s3, ce);
                  break;
                case Oe:
                  "?" == s3 ? (e3.query = "", a2 = D) : "#" == s3 ? (e3.fragment = "", a2 = I) : s3 != g && (e3.path[0] += E(s3, S));
                  break;
                case D:
                  r2 || "#" != s3 ? s3 != g && ("'" == s3 && C(e3) ? e3.query += "%27" : e3.query += "#" == s3 ? "%23" : E(s3, S)) : (e3.fragment = "", a2 = I);
                  break;
                case I:
                  s3 != g && (e3.fragment += E(s3, ue));
              }
              l2++;
            }
          }
          function l(e3) {
            var t3, r2, o2 = G(this, l, "URL"), n2 = 1 < arguments.length ? arguments[1] : void 0, e3 = String(e3), s3 = X(o2, { type: "URL" });
            if (void 0 !== n2) {
              if (n2 instanceof l)
                t3 = p(n2);
              else if (r2 = a(t3 = {}, String(n2)))
                throw TypeError(r2);
            }
            if (r2 = a(s3, e3, null, t3))
              throw TypeError(r2);
            var i2 = s3.searchParams = new q();
            (n2 = h(i2)).updateSearchParams(s3.query), n2.updateURL = function() {
              s3.query = String(i2) || null;
            }, u || (o2.href = m.call(o2), o2.origin = Le.call(o2), o2.protocol = ke.call(o2), o2.username = Ae.call(o2), o2.password = Pe.call(o2), o2.host = Re.call(o2), o2.hostname = De.call(o2), o2.port = Ie.call(o2), o2.pathname = Ue.call(o2), o2.search = Ne.call(o2), o2.searchParams = Fe.call(o2), o2.hash = Be.call(o2));
          }
          function t2(e3, t3) {
            return { get: e3, set: t3, configurable: true, enumerable: true };
          }
          var g, r, o, N = e2("../internals/export"), u = e2("../internals/descriptors"), F = e2("../internals/native-url"), s2 = e2("../internals/global"), B = e2("../internals/object-define-properties"), i = e2("../internals/redefine"), G = e2("../internals/an-instance"), v = e2("../internals/has"), d = e2("../internals/object-assign"), b = e2("../internals/array-from"), V = e2("../internals/string-multibyte").codeAt, z = e2("../internals/string-punycode-to-ascii"), H = e2("../internals/set-to-string-tag"), W = e2("../modules/web.url-search-params"), e2 = e2("../internals/internal-state"), f = s2.URL, q = W.URLSearchParams, h = W.getState, X = e2.set, p = e2.getterFor("URL"), Y = Math.floor, Z = Math.pow, Q = "Invalid authority", j = "Invalid scheme", _ = "Invalid host", K = "Invalid port", J = /[A-Za-z]/, $ = /[\d+-.A-Za-z]/, x = /\d/, ee = /^(0x|0X)/, te = /^[0-7]+$/, re = /^\d+$/, oe = /^[\dA-Fa-f]+$/, ne = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/, se = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/, ie = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g, ae = /[\u0009\u000A\u000D]/g, w = function(e3, t3) {
            var r2, o2, n2;
            if ("[" == t3.charAt(0))
              return "]" == t3.charAt(t3.length - 1) && (r2 = function(e4) {
                var t4 = [0, 0, 0, 0, 0, 0, 0, 0], r3 = 0, o3 = null, n3 = 0, s3, i2, a2, l2, u2, c2, d2, f2 = function() {
                  return e4.charAt(n3);
                };
                if (f2() == ":") {
                  if (e4.charAt(1) != ":")
                    return;
                  n3 += 2;
                  r3++;
                  o3 = r3;
                }
                while (f2()) {
                  if (r3 == 8)
                    return;
                  if (f2() == ":") {
                    if (o3 !== null)
                      return;
                    n3++;
                    r3++;
                    o3 = r3;
                    continue;
                  }
                  s3 = i2 = 0;
                  while (i2 < 4 && oe.test(f2())) {
                    s3 = s3 * 16 + parseInt(f2(), 16);
                    n3++;
                    i2++;
                  }
                  if (f2() == ".") {
                    if (i2 == 0)
                      return;
                    n3 -= i2;
                    if (r3 > 6)
                      return;
                    a2 = 0;
                    while (f2()) {
                      l2 = null;
                      if (a2 > 0)
                        if (f2() == "." && a2 < 4)
                          n3++;
                        else
                          return;
                      if (!x.test(f2()))
                        return;
                      while (x.test(f2())) {
                        u2 = parseInt(f2(), 10);
                        if (l2 === null)
                          l2 = u2;
                        else if (l2 == 0)
                          return;
                        else
                          l2 = l2 * 10 + u2;
                        if (l2 > 255)
                          return;
                        n3++;
                      }
                      t4[r3] = t4[r3] * 256 + l2;
                      a2++;
                      if (a2 == 2 || a2 == 4)
                        r3++;
                    }
                    if (a2 != 4)
                      return;
                    break;
                  } else if (f2() == ":") {
                    n3++;
                    if (!f2())
                      return;
                  } else if (f2())
                    return;
                  t4[r3++] = s3;
                }
                if (o3 !== null) {
                  c2 = r3 - o3;
                  r3 = 7;
                  while (r3 != 0 && c2 > 0) {
                    d2 = t4[r3];
                    t4[r3--] = t4[o3 + c2 - 1];
                    t4[o3 + --c2] = d2;
                  }
                } else if (r3 != 8)
                  return;
                return t4;
              }(t3.slice(1, -1))) ? void (e3.host = r2) : _;
            if (C(e3))
              return t3 = z(t3), ne.test(t3) || null === (r2 = function(e4) {
                var t4 = e4.split("."), r3, o3, n3, s3, i2, a2, l2;
                if (t4.length && t4[t4.length - 1] == "")
                  t4.pop();
                if ((r3 = t4.length) > 4)
                  return e4;
                for (o3 = [], n3 = 0; n3 < r3; n3++) {
                  s3 = t4[n3];
                  if (s3 == "")
                    return e4;
                  i2 = 10;
                  if (s3.length > 1 && s3.charAt(0) == "0") {
                    i2 = ee.test(s3) ? 16 : 8;
                    s3 = s3.slice(i2 == 8 ? 1 : 2);
                  }
                  if (s3 === "")
                    a2 = 0;
                  else {
                    if (!(i2 == 10 ? re : i2 == 8 ? te : oe).test(s3))
                      return e4;
                    a2 = parseInt(s3, i2);
                  }
                  o3.push(a2);
                }
                for (n3 = 0; n3 < r3; n3++) {
                  a2 = o3[n3];
                  if (n3 == r3 - 1) {
                    if (a2 >= Z(256, 5 - r3))
                      return null;
                  } else if (a2 > 255)
                    return null;
                }
                for (l2 = o3.pop(), n3 = 0; n3 < o3.length; n3++)
                  l2 += o3[n3] * Z(256, 3 - n3);
                return l2;
              }(t3)) ? _ : void (e3.host = r2);
            if (se.test(t3))
              return _;
            for (r2 = "", o2 = b(t3), n2 = 0; n2 < o2.length; n2++)
              r2 += E(o2[n2], S);
            e3.host = r2;
          }, le = function(e3) {
            for (var t3 = null, r2 = 1, o2 = null, n2 = 0, s3 = 0; s3 < 8; s3++)
              0 !== e3[s3] ? (r2 < n2 && (t3 = o2, r2 = n2), o2 = null, n2 = 0) : (null === o2 && (o2 = s3), ++n2);
            return r2 < n2 && (t3 = o2, r2 = n2), t3;
          }, S = {}, ue = d({}, S, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), ce = d({}, ue, { "#": 1, "?": 1, "{": 1, "}": 1 }), M = d({}, ce, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), E = function(e3, t3) {
            var r2 = V(e3, 0);
            return 32 < r2 && r2 < 127 && !v(t3, e3) ? e3 : encodeURIComponent(e3);
          }, T = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, C = function(e3) {
            return v(T, e3.scheme);
          }, O = function(e3) {
            return "" != e3.username || "" != e3.password;
          }, L = function(e3, t3) {
            return 2 == e3.length && J.test(e3.charAt(0)) && (":" == (e3 = e3.charAt(1)) || !t3 && "|" == e3);
          }, de = function(e3) {
            return 1 < e3.length && L(e3.slice(0, 2)) && (2 == e3.length || "/" === (e3 = e3.charAt(2)) || "\\" === e3 || "?" === e3 || "#" === e3);
          }, fe = function(e3) {
            var t3 = e3.path, r2 = t3.length;
            !r2 || "file" == e3.scheme && 1 == r2 && L(t3[0], true) || t3.pop();
          }, he = function(e3) {
            return "." === e3 || "%2e" === e3.toLowerCase();
          }, pe = function(e3) {
            return ".." === (e3 = e3.toLowerCase()) || "%2e." === e3 || ".%2e" === e3 || "%2e%2e" === e3;
          }, me = {}, ye = {}, ge = {}, ve = {}, be = {}, je = {}, _e = {}, xe = {}, k = {}, A = {}, we = {}, Se = {}, Me = {}, Ee = {}, Te = {}, Ce = {}, P = {}, R = {}, Oe = {}, D = {}, I = {}, s2 = l.prototype, m = function() {
            var e3 = p(this), t3 = e3.scheme, r2 = e3.username, o2 = e3.password, n2 = e3.host, s3 = e3.port, i2 = e3.path, a2 = e3.query, l2 = e3.fragment, u2 = t3 + ":";
            return null !== n2 ? (u2 += "//", O(e3) && (u2 += r2 + (o2 ? ":" + o2 : "") + "@"), u2 += c(n2), null !== s3 && (u2 += ":" + s3)) : "file" == t3 && (u2 += "//"), u2 += e3.cannotBeABaseURL ? i2[0] : i2.length ? "/" + i2.join("/") : "", null !== a2 && (u2 += "?" + a2), null !== l2 && (u2 += "#" + l2), u2;
          }, Le = function() {
            var e3 = p(this), t3 = e3.scheme, r2 = e3.port;
            if ("blob" == t3)
              try {
                return new URL(t3.path[0]).origin;
              } catch (e4) {
                return "null";
              }
            return "file" != t3 && C(e3) ? t3 + "://" + c(e3.host) + (null !== r2 ? ":" + r2 : "") : "null";
          }, ke = function() {
            return p(this).scheme + ":";
          }, Ae = function() {
            return p(this).username;
          }, Pe = function() {
            return p(this).password;
          }, Re = function() {
            var e3 = p(this), t3 = e3.host, e3 = e3.port;
            return null === t3 ? "" : null === e3 ? c(t3) : c(t3) + ":" + e3;
          }, De = function() {
            var e3 = p(this).host;
            return null === e3 ? "" : c(e3);
          }, Ie = function() {
            var e3 = p(this).port;
            return null === e3 ? "" : String(e3);
          }, Ue = function() {
            var e3 = p(this), t3 = e3.path;
            return e3.cannotBeABaseURL ? t3[0] : t3.length ? "/" + t3.join("/") : "";
          }, Ne = function() {
            var e3 = p(this).query;
            return e3 ? "?" + e3 : "";
          }, Fe = function() {
            return p(this).searchParams;
          }, Be = function() {
            var e3 = p(this).fragment;
            return e3 ? "#" + e3 : "";
          };
          u && B(s2, { href: t2(m, function(e3) {
            var t3 = p(this), e3 = String(e3), e3 = a(t3, e3);
            if (e3)
              throw TypeError(e3);
            h(t3.searchParams).updateSearchParams(t3.query);
          }), origin: t2(Le), protocol: t2(ke, function(e3) {
            var t3 = p(this);
            a(t3, String(e3) + ":", me);
          }), username: t2(Ae, function(e3) {
            var t3 = p(this), r2 = b(String(e3));
            if (!n(t3)) {
              t3.username = "";
              for (var o2 = 0; o2 < r2.length; o2++)
                t3.username += E(r2[o2], M);
            }
          }), password: t2(Pe, function(e3) {
            var t3 = p(this), r2 = b(String(e3));
            if (!n(t3)) {
              t3.password = "";
              for (var o2 = 0; o2 < r2.length; o2++)
                t3.password += E(r2[o2], M);
            }
          }), host: t2(Re, function(e3) {
            var t3 = p(this);
            t3.cannotBeABaseURL || a(t3, String(e3), we);
          }), hostname: t2(De, function(e3) {
            var t3 = p(this);
            t3.cannotBeABaseURL || a(t3, String(e3), Se);
          }), port: t2(Ie, function(e3) {
            var t3 = p(this);
            n(t3) || ("" == (e3 = String(e3)) ? t3.port = null : a(t3, e3, Me));
          }), pathname: t2(Ue, function(e3) {
            var t3 = p(this);
            t3.cannotBeABaseURL || (t3.path = [], a(t3, e3 + "", P));
          }), search: t2(Ne, function(e3) {
            var t3 = p(this);
            "" == (e3 = String(e3)) ? t3.query = null : ("?" == e3.charAt(0) && (e3 = e3.slice(1)), t3.query = "", a(t3, e3, D)), h(t3.searchParams).updateSearchParams(t3.query);
          }), searchParams: t2(Fe), hash: t2(Be, function(e3) {
            var t3 = p(this);
            "" == (e3 = String(e3)) ? t3.fragment = null : ("#" == e3.charAt(0) && (e3 = e3.slice(1)), t3.fragment = "", a(t3, e3, I));
          }) }), i(s2, "toJSON", function() {
            return m.call(this);
          }, { enumerable: true }), i(s2, "toString", function() {
            return m.call(this);
          }, { enumerable: true }), f && (r = f.createObjectURL, o = f.revokeObjectURL, r && i(l, "createObjectURL", function(e3) {
            return r.apply(f, arguments);
          }), o && i(l, "revokeObjectURL", function(e3) {
            return o.apply(f, arguments);
          })), H(l, "URL"), N({ global: true, forced: !F, sham: !u }, { URL: l });
        }, { "../internals/an-instance": 9, "../internals/array-from": 17, "../internals/descriptors": 43, "../internals/export": 50, "../internals/global": 59, "../internals/has": 60, "../internals/internal-state": 70, "../internals/native-url": 84, "../internals/object-assign": 89, "../internals/object-define-properties": 91, "../internals/redefine": 108, "../internals/set-to-string-tag": 117, "../internals/string-multibyte": 123, "../internals/string-punycode-to-ascii": 124, "../modules/es.string.iterator": 186, "../modules/web.url-search-params": 231 }], 233: [function(e2, t2, r) {
          "use strict";
          t2.exports = e2("./").polyfill();
        }, { "./": 234 }], 234: [function(V, r, o) {
          !function(B, G) {
            var e2, t2;
            e2 = this, t2 = function() {
              "use strict";
              function l(e4) {
                return "function" == typeof e4;
              }
              var r2 = Array.isArray || function(e4) {
                return "[object Array]" === Object.prototype.toString.call(e4);
              }, o2 = 0, t3 = void 0, n = void 0, i = function(e4, t4) {
                d[o2] = e4, d[o2 + 1] = t4, 2 === (o2 += 2) && (n ? n(f) : I());
              };
              var e3 = "undefined" != typeof window ? window : void 0, s2 = e3 || {}, s2 = s2.MutationObserver || s2.WebKitMutationObserver, a = "undefined" == typeof self && void 0 !== B && "[object process]" === {}.toString.call(B), u = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel;
              function c() {
                var e4 = setTimeout;
                return function() {
                  return e4(f, 1);
                };
              }
              var d = new Array(1e3);
              function f() {
                for (var e4 = 0; e4 < o2; e4 += 2)
                  (0, d[e4])(d[e4 + 1]), d[e4] = void 0, d[e4 + 1] = void 0;
                o2 = 0;
              }
              function h() {
                try {
                  var e4 = Function("return this")().require("vertx");
                  return void 0 !== (t3 = e4.runOnLoop || e4.runOnContext) ? function() {
                    t3(f);
                  } : c();
                } catch (e5) {
                  return c();
                }
              }
              var p, m, y, I = void 0;
              function g(e4, t4) {
                var r3, o3 = this, n2 = new this.constructor(j), s3 = (void 0 === n2[b] && A(n2), o3._state);
                return s3 ? (r3 = arguments[s3 - 1], i(function() {
                  return L(s3, n2, r3, o3._result);
                })) : C(o3, n2, e4, t4), n2;
              }
              function v(e4) {
                var t4;
                return e4 && "object" == typeof e4 && e4.constructor === this ? e4 : (M(t4 = new this(j), e4), t4);
              }
              var I = a ? function() {
                return B.nextTick(f);
              } : s2 ? (m = 0, a = new s2(f), y = document.createTextNode(""), a.observe(y, { characterData: true }), function() {
                y.data = m = ++m % 2;
              }) : u ? ((p = new MessageChannel()).port1.onmessage = f, function() {
                return p.port2.postMessage(0);
              }) : (void 0 === e3 && "function" == typeof V ? h : c)(), b = Math.random().toString(36).substring(2);
              function j() {
              }
              var _ = void 0, x = 1, w = 2;
              function U(e4, o3, n2) {
                i(function(t4) {
                  var r3 = false, e5 = function(e6, t5, r4, o4) {
                    try {
                      e6.call(t5, r4, o4);
                    } catch (e7) {
                      return e7;
                    }
                  }(n2, o3, function(e6) {
                    r3 || (r3 = true, (o3 !== e6 ? M : E)(t4, e6));
                  }, function(e6) {
                    r3 || (r3 = true, T(t4, e6));
                  }, t4._label);
                  !r3 && e5 && (r3 = true, T(t4, e5));
                }, e4);
              }
              function S(e4, t4, r3) {
                var o3, n2;
                t4.constructor === e4.constructor && r3 === g && t4.constructor.resolve === v ? (o3 = e4, (n2 = t4)._state === x ? E(o3, n2._result) : n2._state === w ? T(o3, n2._result) : C(n2, void 0, function(e5) {
                  return M(o3, e5);
                }, function(e5) {
                  return T(o3, e5);
                })) : void 0 !== r3 && l(r3) ? U(e4, t4, r3) : E(e4, t4);
              }
              function M(t4, e4) {
                if (t4 === e4)
                  T(t4, new TypeError("You cannot resolve a promise with itself"));
                else if (r3 = typeof e4, null === e4 || "object" != r3 && "function" != r3)
                  E(t4, e4);
                else {
                  r3 = void 0;
                  try {
                    r3 = e4.then;
                  } catch (e5) {
                    return void T(t4, e5);
                  }
                  S(t4, e4, r3);
                }
                var r3;
              }
              function N(e4) {
                e4._onerror && e4._onerror(e4._result), O(e4);
              }
              function E(e4, t4) {
                e4._state === _ && (e4._result = t4, e4._state = x, 0 !== e4._subscribers.length && i(O, e4));
              }
              function T(e4, t4) {
                e4._state === _ && (e4._state = w, e4._result = t4, i(N, e4));
              }
              function C(e4, t4, r3, o3) {
                var n2 = e4._subscribers, s3 = n2.length;
                e4._onerror = null, n2[s3] = t4, n2[s3 + x] = r3, n2[s3 + w] = o3, 0 === s3 && e4._state && i(O, e4);
              }
              function O(e4) {
                var t4 = e4._subscribers, r3 = e4._state;
                if (0 !== t4.length) {
                  for (var o3, n2 = void 0, s3 = e4._result, i2 = 0; i2 < t4.length; i2 += 3)
                    o3 = t4[i2], n2 = t4[i2 + r3], o3 ? L(r3, o3, n2, s3) : n2(s3);
                  e4._subscribers.length = 0;
                }
              }
              function L(e4, t4, r3, o3) {
                var n2 = l(r3), s3 = void 0, i2 = void 0, a2 = true;
                if (n2) {
                  try {
                    s3 = r3(o3);
                  } catch (e5) {
                    a2 = false, i2 = e5;
                  }
                  if (t4 === s3)
                    return void T(t4, new TypeError("A promises callback cannot return that same promise."));
                } else
                  s3 = o3;
                t4._state === _ && (n2 && a2 ? M(t4, s3) : false === a2 ? T(t4, i2) : e4 === x ? E(t4, s3) : e4 === w && T(t4, s3));
              }
              var k = 0;
              function A(e4) {
                e4[b] = k++, e4._state = void 0, e4._result = void 0, e4._subscribers = [];
              }
              P.prototype._enumerate = function(e4) {
                for (var t4 = 0; this._state === _ && t4 < e4.length; t4++)
                  this._eachEntry(e4[t4], t4);
              }, P.prototype._eachEntry = function(t4, e4) {
                var r3 = this._instanceConstructor, o3 = r3.resolve;
                if (o3 === v) {
                  var n2, s3 = void 0, i2 = void 0, a2 = false;
                  try {
                    s3 = t4.then;
                  } catch (e5) {
                    a2 = true, i2 = e5;
                  }
                  s3 === g && t4._state !== _ ? this._settledAt(t4._state, e4, t4._result) : "function" != typeof s3 ? (this._remaining--, this._result[e4] = t4) : r3 === R ? (n2 = new r3(j), a2 ? T(n2, i2) : S(n2, t4, s3), this._willSettleAt(n2, e4)) : this._willSettleAt(new r3(function(e5) {
                    return e5(t4);
                  }), e4);
                } else
                  this._willSettleAt(o3(t4), e4);
              }, P.prototype._settledAt = function(e4, t4, r3) {
                var o3 = this.promise;
                o3._state === _ && (this._remaining--, e4 === w ? T(o3, r3) : this._result[t4] = r3), 0 === this._remaining && E(o3, this._result);
              }, P.prototype._willSettleAt = function(e4, t4) {
                var r3 = this;
                C(e4, void 0, function(e5) {
                  return r3._settledAt(x, t4, e5);
                }, function(e5) {
                  return r3._settledAt(w, t4, e5);
                });
              };
              var F = P;
              function P(e4, t4) {
                this._instanceConstructor = e4, this.promise = new e4(j), this.promise[b] || A(this.promise), r2(t4) ? (this.length = t4.length, this._remaining = t4.length, this._result = new Array(this.length), 0 !== this.length && (this.length = this.length || 0, this._enumerate(t4), 0 !== this._remaining) || E(this.promise, this._result)) : T(this.promise, new Error("Array Methods must be provided an Array"));
              }
              D.prototype.catch = function(e4) {
                return this.then(null, e4);
              }, D.prototype.finally = function(t4) {
                var r3 = this.constructor;
                return l(t4) ? this.then(function(e4) {
                  return r3.resolve(t4()).then(function() {
                    return e4;
                  });
                }, function(e4) {
                  return r3.resolve(t4()).then(function() {
                    throw e4;
                  });
                }) : this.then(t4, t4);
              };
              var R = D;
              function D(e4) {
                if (this[b] = k++, this._result = this._state = void 0, this._subscribers = [], j !== e4) {
                  if ("function" != typeof e4)
                    throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
                  if (!(this instanceof D))
                    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                  var t4 = this;
                  try {
                    e4(function(e5) {
                      M(t4, e5);
                    }, function(e5) {
                      T(t4, e5);
                    });
                  } catch (e5) {
                    T(t4, e5);
                  }
                }
              }
              return R.prototype.then = g, R.all = function(e4) {
                return new F(this, e4).promise;
              }, R.race = function(n2) {
                var s3 = this;
                return r2(n2) ? new s3(function(e4, t4) {
                  for (var r3 = n2.length, o3 = 0; o3 < r3; o3++)
                    s3.resolve(n2[o3]).then(e4, t4);
                }) : new s3(function(e4, t4) {
                  return t4(new TypeError("You must pass an array to race."));
                });
              }, R.resolve = v, R.reject = function(e4) {
                var t4 = new this(j);
                return T(t4, e4), t4;
              }, R._setScheduler = function(e4) {
                n = e4;
              }, R._setAsap = function(e4) {
                i = e4;
              }, R._asap = i, R.polyfill = function() {
                var e4 = void 0;
                if (void 0 !== G)
                  e4 = G;
                else if ("undefined" != typeof self)
                  e4 = self;
                else
                  try {
                    e4 = Function("return this")();
                  } catch (e5) {
                    throw new Error("polyfill failed because global object is unavailable in this environment");
                  }
                var t4 = e4.Promise;
                if (t4) {
                  var r3 = null;
                  try {
                    r3 = Object.prototype.toString.call(t4.resolve());
                  } catch (e5) {
                  }
                  if ("[object Promise]" === r3 && !t4.cast)
                    return;
                }
                e4.Promise = R;
              }, R.Promise = R;
            }, "object" == typeof o && void 0 !== r ? r.exports = t2() : "function" == typeof s && s.amd ? s(t2) : e2.ES6Promise = t2();
          }.call(this, V("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, { _process: 243 }], 235: [function(e2, t2, r) {
          var o, n;
          o = this, n = function(e3, t3) {
            "use strict";
            var r2 = 5e3, o2 = "callback";
            function d(t4) {
              try {
                delete window[t4];
              } catch (e4) {
                window[t4] = void 0;
              }
            }
            function f(e4) {
              e4 = document.getElementById(e4);
              e4 && document.getElementsByTagName("head")[0].removeChild(e4);
            }
            t3.exports = function(s2) {
              var i = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], a = s2, l = i.timeout || r2, u = i.jsonpCallback || o2, c = void 0;
              return new Promise(function(t4, e4) {
                var r3 = i.jsonpCallbackFunction || "jsonp_" + Date.now() + "_" + Math.ceil(1e5 * Math.random()), o3 = u + "_" + r3, n2 = (window[r3] = function(e5) {
                  t4({ ok: true, json: function() {
                    return Promise.resolve(e5);
                  } }), c && clearTimeout(c), f(o3), d(r3);
                }, a += -1 === a.indexOf("?") ? "?" : "&", document.createElement("script"));
                n2.setAttribute("src", "" + a + u + "=" + r3), i.charset && n2.setAttribute("charset", i.charset), n2.id = o3, document.getElementsByTagName("head")[0].appendChild(n2), c = setTimeout(function() {
                  e4(new Error("JSONP request to " + s2 + " timed out")), d(r3), f(o3), window[r3] = function() {
                    d(r3);
                  };
                }, l), n2.onerror = function() {
                  e4(new Error("JSONP request to " + s2 + " failed")), d(r3), f(o3), c && clearTimeout(c);
                };
              });
            };
          }, "function" == typeof s && s.amd ? s(["exports", "module"], n) : void 0 !== r && void 0 !== t2 ? n(0, t2) : (n(n = { exports: {} }, n), o.fetchJsonp = n.exports);
        }, {}], 236: [function(e2, t2, r) {
          var o = function(a) {
            "use strict";
            var l, u, c, d, f, h, t3, p, m, o2, e3;
            if (!(void 0 === a || "undefined" != typeof navigator && /MSIE [1-9]\./.test(navigator.userAgent)))
              return e3 = a.document, l = function() {
                return a.URL || a.webkitURL || a;
              }, u = e3.createElementNS("http://www.w3.org/1999/xhtml", "a"), c = "download" in u, d = /constructor/i.test(a.HTMLElement) || a.safari, f = /CriOS\/[\d]+/.test(navigator.userAgent), h = function(e4) {
                (a.setImmediate || a.setTimeout)(function() {
                  throw e4;
                }, 0);
              }, t3 = 4e4, p = function(e4) {
                setTimeout(function() {
                  "string" == typeof e4 ? l().revokeObjectURL(e4) : e4.remove();
                }, t3);
              }, m = function(e4) {
                return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e4.type) ? new Blob([String.fromCharCode(65279), e4], { type: e4.type }) : e4;
              }, e3 = (o2 = function(e4, r2, t4) {
                t4 || (e4 = m(e4));
                var o3, n, s2 = this, t4 = "application/octet-stream" === e4.type, i = function() {
                  for (var e5 = s2, t5 = "writestart progress write writeend".split(" "), r3 = void 0, o4 = (t5 = [].concat(t5)).length; o4--; ) {
                    var n2 = e5["on" + t5[o4]];
                    if ("function" == typeof n2)
                      try {
                        n2.call(e5, r3 || e5);
                      } catch (e6) {
                        h(e6);
                      }
                  }
                };
                s2.readyState = s2.INIT, c ? (o3 = l().createObjectURL(e4), setTimeout(function() {
                  var e5, t5;
                  u.href = o3, u.download = r2, e5 = u, t5 = new MouseEvent("click"), e5.dispatchEvent(t5), i(), p(o3), s2.readyState = s2.DONE;
                })) : (f || t4 && d) && a.FileReader ? ((n = new FileReader()).onloadend = function() {
                  var e5 = f ? n.result : n.result.replace(/^data:[^;]*;/, "data:attachment/file;");
                  a.open(e5, "_blank") || (a.location.href = e5), e5 = void 0, s2.readyState = s2.DONE, i();
                }, n.readAsDataURL(e4), s2.readyState = s2.INIT) : (o3 = o3 || l().createObjectURL(e4), !t4 && a.open(o3, "_blank") || (a.location.href = o3), s2.readyState = s2.DONE, i(), p(o3));
              }).prototype, "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function(e4, t4, r2) {
                return t4 = t4 || e4.name || "download", r2 || (e4 = m(e4)), navigator.msSaveOrOpenBlob(e4, t4);
              } : (e3.abort = function() {
              }, e3.readyState = e3.INIT = 0, e3.WRITING = 1, e3.DONE = 2, e3.error = e3.onwritestart = e3.onprogress = e3.onwrite = e3.onabort = e3.onerror = e3.onwriteend = null, function(e4, t4, r2) {
                return new o2(e4, t4 || e4.name || "download", r2);
              });
          }("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);
          void 0 !== t2 && t2.exports ? t2.exports.saveAs = o : null != s && null !== s.amd && s("FileSaver.js", function() {
            return o;
          });
        }, {}], 237: [function(e2, t2, r) {
          var o, n = Object.defineProperty, s2 = (n(r, "__esModule", { value: true }), r), i = { GIFEncoder: () => f, applyPalette: () => function(e3, t3, r2 = "rgb565") {
            if (!e3 || !e3.buffer)
              throw new Error("quantize() expected RGBA Uint8Array data");
            if (!(e3 instanceof Uint8Array || e3 instanceof Uint8ClampedArray))
              throw new Error("quantize() expected RGBA Uint8Array data");
            if (256 < t3.length)
              throw new Error("applyPalette() only works with 256 colors or less");
            const o2 = new Uint32Array(e3.buffer), n2 = o2.length, s3 = "rgb444" === r2 ? 4096 : 65536, i2 = new Uint8Array(n2), a2 = new Array(s3);
            if ("rgba4444" === r2)
              for (let e4 = 0; e4 < n2; e4++) {
                var l2 = o2[e4], u2 = l2 >> 24 & 255, c2 = l2 >> 16 & 255, d2 = l2 >> 8 & 255, l2 = 255 & l2, f2 = k(l2, d2, c2, u2), f2 = f2 in a2 ? a2[f2] : a2[f2] = function(t4, r3, o3, n3, s4) {
                  let i3 = 0, a3 = 1e100;
                  for (let e5 = 0; e5 < s4.length; e5++) {
                    var l3, u3 = s4[e5], c3 = v(u3[3] - n3);
                    c3 > a3 || (l3 = u3[0], (c3 += v(l3 - t4)) > a3 || (l3 = u3[1], (c3 += v(l3 - r3)) > a3 || (l3 = u3[2], (c3 += v(l3 - o3)) > a3 || (a3 = c3, i3 = e5))));
                  }
                  return i3;
                }(l2, d2, c2, u2, t3);
                i2[e4] = f2;
              }
            else {
              const g = "rgb444" === r2 ? A : L;
              for (let e4 = 0; e4 < n2; e4++) {
                var h2 = o2[e4], p = h2 >> 16 & 255, m = h2 >> 8 & 255, h2 = 255 & h2, y = g(h2, m, p), y = y in a2 ? a2[y] : a2[y] = function(t4, r3, o3, n3) {
                  let s4 = 0, i3 = 1e100;
                  for (let e5 = 0; e5 < n3.length; e5++) {
                    var a3, l3 = n3[e5], u3 = v(l3[0] - t4);
                    u3 > i3 || (a3 = l3[1], (u3 += v(a3 - r3)) > i3 || (a3 = l3[2], (u3 += v(a3 - o3)) > i3 || (i3 = u3, s4 = e5)));
                  }
                  return s4;
                }(h2, m, p, t3);
                i2[e4] = y;
              }
            }
            return i2;
          }, default: () => h, nearestColor: () => function(e3, t3, r2 = u) {
            return e3[l(e3, t3, r2)];
          }, nearestColorIndex: () => l, nearestColorIndexWithDistance: () => d, prequantize: () => function(e3, { roundRGB: r2 = 5, roundAlpha: o2 = 10, oneBitAlpha: n2 = null } = {}) {
            const s3 = new Uint32Array(e3.buffer);
            for (let t3 = 0; t3 < s3.length; t3++) {
              var i2 = s3[t3];
              let e4 = i2 >> 24 & 255;
              var a2, l2 = i2 >> 16 & 255, u2 = i2 >> 8 & 255, i2 = 255 & i2;
              e4 = c(e4, o2), n2 && (a2 = "number" == typeof n2 ? n2 : 127, e4 = e4 <= a2 ? 0 : 255), i2 = c(i2, r2), u2 = c(u2, r2), l2 = c(l2, r2), s3[t3] = e4 << 24 | l2 << 16 | u2 << 8 | i2 << 0;
            }
          }, quantize: () => function(e3, t3, r2 = {}) {
            var { format: o2 = "rgb565", clearAlpha: n2 = true, clearAlphaColor: s3 = 0, clearAlphaThreshold: i2 = 0, oneBitAlpha: a2 = false } = r2;
            if (!e3 || !e3.buffer)
              throw new Error("quantize() expected RGBA Uint8Array data");
            if (!(e3 instanceof Uint8Array || e3 instanceof Uint8ClampedArray))
              throw new Error("quantize() expected RGBA Uint8Array data");
            e3 = new Uint32Array(e3.buffer);
            let l2 = false !== r2.useSqrt;
            const u2 = "rgba4444" === o2, c2 = function(r3, e4) {
              const t4 = "rgb444" === e4 ? 4096 : 65536, o3 = new Array(t4), n3 = r3.length;
              if ("rgba4444" === e4)
                for (let t5 = 0; t5 < n3; ++t5) {
                  var s4 = r3[t5], i3 = s4 >> 24 & 255, a3 = s4 >> 16 & 255, l3 = s4 >> 8 & 255, s4 = 255 & s4, u3 = k(s4, l3, a3, i3);
                  let e5 = u3 in o3 ? o3[u3] : o3[u3] = I();
                  e5.rc += s4, e5.gc += l3, e5.bc += a3, e5.ac += i3, e5.cnt++;
                }
              else if ("rgb444" === e4)
                for (let t5 = 0; t5 < n3; ++t5) {
                  var c3 = r3[t5], d3 = c3 >> 16 & 255, f3 = c3 >> 8 & 255, c3 = 255 & c3, h3 = A(c3, f3, d3);
                  let e5 = h3 in o3 ? o3[h3] : o3[h3] = I();
                  e5.rc += c3, e5.gc += f3, e5.bc += d3, e5.cnt++;
                }
              else
                for (let t5 = 0; t5 < n3; ++t5) {
                  var p2 = r3[t5], m2 = p2 >> 16 & 255, y2 = p2 >> 8 & 255, p2 = 255 & p2, g2 = L(p2, y2, m2);
                  let e5 = g2 in o3 ? o3[g2] : o3[g2] = I();
                  e5.rc += p2, e5.gc += y2, e5.bc += m2, e5.cnt++;
                }
              return o3;
            }(e3, o2), d2 = c2.length, f2 = d2 - 1, h2 = new Uint32Array(d2 + 1);
            for (var p = 0, m = 0; m < d2; ++m) {
              const O2 = c2[m];
              null != O2 && (E2 = 1 / O2.cnt, u2 && (O2.ac *= E2), O2.rc *= E2, O2.gc *= E2, O2.bc *= E2, c2[p++] = O2);
            }
            R(t3) / p < 0.022 && (l2 = false);
            for (var y, g, v2, m = 0; m < p - 1; ++m)
              c2[m].fw = m + 1, c2[m + 1].bk = m, l2 && (c2[m].cnt = Math.sqrt(c2[m].cnt));
            l2 && (c2[m].cnt = Math.sqrt(c2[m].cnt));
            for (m = 0; m < p; ++m) {
              D(c2, m, false);
              var b = c2[m].err;
              for (g = ++h2[0]; 1 < g && (v2 = g >> 1, !(c2[y = h2[v2]].err <= b)); g = v2)
                h2[g] = y;
              h2[g] = m;
            }
            var j, _ = p - t3;
            for (m = 0; m < _; ) {
              for (; ; ) {
                var x = h2[1];
                if ((j = c2[x]).tm >= j.mtm && c2[j.nn].mtm <= j.tm)
                  break;
                j.mtm == f2 ? x = h2[1] = h2[h2[0]--] : (D(c2, x, false), j.tm = m);
                b = c2[x].err;
                for (g = 1; (v2 = g + g) <= h2[0] && (v2 < h2[0] && c2[h2[v2]].err > c2[h2[v2 + 1]].err && v2++, !(b <= c2[y = h2[v2]].err)); g = v2)
                  h2[g] = y;
                h2[g] = x;
              }
              var w = c2[j.nn], S2 = j.cnt, M2 = w.cnt, E2 = 1 / (S2 + M2);
              u2 && (j.ac = E2 * (S2 * j.ac + M2 * w.ac)), j.rc = E2 * (S2 * j.rc + M2 * w.rc), j.gc = E2 * (S2 * j.gc + M2 * w.gc), j.bc = E2 * (S2 * j.bc + M2 * w.bc), j.cnt += w.cnt, j.mtm = ++m, c2[w.bk].fw = w.fw, c2[w.fw].bk = w.bk, w.mtm = f2;
            }
            let T2 = [];
            for (m = 0; ; 0) {
              let e4 = P(Math.round(c2[m].rc), 0, 255), t4 = P(Math.round(c2[m].gc), 0, 255), r3 = P(Math.round(c2[m].bc), 0, 255), o3 = 255;
              u2 && (o3 = P(Math.round(c2[m].ac), 0, 255), a2 && (C2 = "number" == typeof a2 ? a2 : 127, o3 = o3 <= C2 ? 0 : 255), n2 && o3 <= i2 && (e4 = t4 = r3 = s3, o3 = 0));
              var C2 = u2 ? [e4, t4, r3, o3] : [e4, t4, r3];
              if (function(t5, r4) {
                for (let e5 = 0; e5 < t5.length; e5++) {
                  var o4 = t5[e5], n3 = o4[0] === r4[0] && o4[1] === r4[1] && o4[2] === r4[2], o4 = !(4 <= o4.length && 4 <= r4.length) || o4[3] === r4[3];
                  if (n3 && o4)
                    return true;
                }
                return false;
              }(T2, C2) || T2.push(C2), 0 == (m = c2[m].fw))
                break;
            }
            return T2;
          }, snapColorsToPalette: () => function(r2, o2, e3 = 5) {
            if (r2.length && o2.length) {
              var n2 = r2.map((e4) => e4.slice(0, 3)), s3 = e3 * e3, i2 = r2[0].length;
              for (let t3 = 0; t3 < o2.length; t3++) {
                let e4 = o2[t3];
                e4 = e4.length < i2 ? [e4[0], e4[1], e4[2], 255] : e4.length > i2 ? e4.slice(0, 3) : e4.slice();
                var a2 = d(n2, e4.slice(0, 3), u), l2 = a2[0], a2 = a2[1];
                0 < a2 && a2 <= s3 && (r2[l2] = e4);
              }
            }
          } };
          for (o in i)
            n(s2, o, { get: i[o], enumerable: true });
          var a = { signature: "GIF", version: "89a", trailer: 59, extensionIntroducer: 33, applicationExtensionLabel: 255, graphicControlExtensionLabel: 249, imageSeparator: 44, signatureSize: 3, versionSize: 3, globalColorTableFlagMask: 128, colorResolutionMask: 112, sortFlagMask: 8, globalColorTableSizeMask: 7, applicationIdentifierSize: 8, applicationAuthCodeSize: 3, disposalMethodMask: 28, userInputFlagMask: 2, transparentColorFlagMask: 1, localColorTableFlagMask: 128, interlaceFlagMask: 64, idSortFlagMask: 32, localColorTableSizeMask: 7 };
          function T(e3 = 256) {
            let n2 = 0, s3 = new Uint8Array(e3);
            return { get buffer() {
              return s3.buffer;
            }, reset() {
              n2 = 0;
            }, bytesView() {
              return s3.subarray(0, n2);
            }, bytes() {
              return s3.slice(0, n2);
            }, writeByte(e4) {
              i2(n2 + 1), s3[n2] = e4, n2++;
            }, writeBytes(t3, r2 = 0, o2 = t3.length) {
              i2(n2 + o2);
              for (let e4 = 0; e4 < o2; e4++)
                s3[n2++] = t3[e4 + r2];
            }, writeBytesView(e4, t3 = 0, r2 = e4.byteLength) {
              i2(n2 + r2), s3.set(e4.subarray(t3, t3 + r2), n2), n2 += r2;
            } };
            function i2(e4) {
              var t3 = s3.length;
              if (!(e4 <= t3)) {
                e4 = Math.max(e4, t3 * (t3 < 1048576 ? 2 : 1.125) >>> 0), 0 != t3 && (e4 = Math.max(e4, 256));
                const r2 = s3;
                s3 = new Uint8Array(e4), 0 < n2 && s3.set(r2.subarray(0, n2), 0);
              }
            }
          }
          var C = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535];
          var S = function(e3, t3, r2, o2, n2 = T(512), s3 = new Uint8Array(256), i2 = new Int32Array(5003), a2 = new Int32Array(5003)) {
            var l2 = i2.length, o2 = Math.max(2, o2);
            s3.fill(0), a2.fill(0), i2.fill(-1);
            let u2 = 0, c2 = 0;
            var d2 = o2 + 1;
            const f2 = d2;
            let h2 = false, p = f2, m = (1 << p) - 1;
            var y = 1 << d2 - 1;
            const g = 1 + y;
            let v2 = 2 + y, b = 0, j = r2[0], _ = 0;
            for (let e4 = l2; e4 < 65536; e4 *= 2)
              ++_;
            _ = 8 - _, n2.writeByte(o2), E2(y);
            var x = r2.length;
            for (let t4 = 1; t4 < x; t4++)
              e: {
                var w = r2[t4], S2 = (w << 12) + j;
                let e4 = w << _ ^ j;
                if (i2[e4] === S2)
                  j = a2[e4];
                else {
                  for (var M2 = 0 === e4 ? 1 : l2 - e4; 0 <= i2[e4]; )
                    if ((e4 -= M2) < 0 && (e4 += l2), i2[e4] === S2) {
                      j = a2[e4];
                      break e;
                    }
                  E2(j), j = w, v2 < 4096 ? (a2[e4] = v2++, i2[e4] = S2) : (i2.fill(-1), v2 = 2 + y, h2 = true, E2(y));
                }
              }
            return E2(j), E2(g), n2.writeByte(0), n2.bytesView();
            function E2(e4) {
              for (u2 &= C[c2], 0 < c2 ? u2 |= e4 << c2 : u2 = e4, c2 += p; 8 <= c2; )
                s3[b++] = 255 & u2, 254 <= b && (n2.writeByte(b), n2.writeBytesView(s3, 0, b), b = 0), u2 >>= 8, c2 -= 8;
              if ((v2 > m || h2) && (h2 ? (p = f2, m = (1 << p) - 1, h2 = false) : (++p, m = 12 === p ? 1 << p : (1 << p) - 1)), e4 == g) {
                for (; 0 < c2; )
                  s3[b++] = 255 & u2, 254 <= b && (n2.writeByte(b), n2.writeBytesView(s3, 0, b), b = 0), u2 >>= 8, c2 -= 8;
                0 < b && (n2.writeByte(b), n2.writeBytesView(s3, 0, b), b = 0);
              }
            }
          };
          function L(e3, t3, r2) {
            return e3 << 8 & 63488 | t3 << 2 & 992 | r2 >> 3;
          }
          function k(e3, t3, r2, o2) {
            return e3 >> 4 | 240 & t3 | (240 & r2) << 4 | (240 & o2) << 8;
          }
          function A(e3, t3, r2) {
            return e3 >> 4 << 8 | 240 & t3 | r2 >> 4;
          }
          function P(e3, t3, r2) {
            return e3 < t3 ? t3 : r2 < e3 ? r2 : e3;
          }
          function R(e3) {
            return e3 * e3;
          }
          function D(e3, t3, r2) {
            var o2 = 0, n2 = 1e100;
            const s3 = e3[t3];
            for (var i2 = s3.cnt, a2 = s3.ac, l2 = s3.rc, u2 = s3.gc, c2 = s3.bc, d2 = s3.fw; 0 != d2; d2 = e3[d2].fw) {
              var f2, h2 = e3[d2], p = h2.cnt, p = i2 * p / (i2 + p);
              n2 <= p || (f2 = 0, r2 && n2 <= (f2 += p * R(h2.ac - a2)) || n2 <= (f2 += p * R(h2.rc - l2)) || n2 <= (f2 += p * R(h2.gc - u2)) || n2 <= (f2 += p * R(h2.bc - c2)) || (n2 = f2, o2 = d2));
            }
            s3.err = n2, s3.nn = o2;
          }
          function I() {
            return { ac: 0, rc: 0, gc: 0, bc: 0, cnt: 0, nn: 0, fw: 0, bk: 0, tm: 0, mtm: 0, err: 0 };
          }
          function u(e3, t3) {
            for (var r2 = 0, o2 = 0; o2 < e3.length; o2++) {
              var n2 = e3[o2] - t3[o2];
              r2 += n2 * n2;
            }
            return r2;
          }
          function c(e3, t3) {
            return 1 < t3 ? Math.round(e3 / t3) * t3 : e3;
          }
          function v(e3) {
            return e3 * e3;
          }
          function l(t3, r2, o2 = u) {
            let n2 = 1 / 0, s3 = -1;
            for (let e3 = 0; e3 < t3.length; e3++) {
              var i2 = o2(r2, t3[e3]);
              i2 < n2 && (n2 = i2, s3 = e3);
            }
            return s3;
          }
          function d(t3, r2, o2 = u) {
            let n2 = 1 / 0, s3 = -1;
            for (let e3 = 0; e3 < t3.length; e3++) {
              var i2 = o2(r2, t3[e3]);
              i2 < n2 && (n2 = i2, s3 = e3);
            }
            return [s3, n2];
          }
          function f(e3 = {}) {
            const { initialCapacity: t3 = 4096, auto: g = true } = e3, v2 = T(t3);
            const b = new Uint8Array(256), j = new Int32Array(5003), _ = new Int32Array(5003);
            let x = false;
            return { reset() {
              v2.reset(), x = false;
            }, finish() {
              v2.writeByte(a.trailer);
            }, bytes() {
              return v2.bytes();
            }, bytesView() {
              return v2.bytesView();
            }, get buffer() {
              return v2.buffer;
            }, get stream() {
              return v2;
            }, writeHeader: w, writeFrame(e4, t4, r2, o2 = {}) {
              var { transparent: n2 = false, transparentIndex: s3 = 0, delay: i2 = 0, palette: a2 = null, repeat: l2 = 0, colorDepth: u2 = 8, dispose: c2 = -1 } = o2;
              let d2 = false;
              if (g ? x || (d2 = true, w(), x = true) : d2 = Boolean(o2.first), t4 = Math.max(0, Math.floor(t4)), r2 = Math.max(0, Math.floor(r2)), d2) {
                if (!a2)
                  throw new Error("First frame must include a { palette } option");
                var [o2, f2, h2, p, m = 8] = [v2, t4, r2, a2, u2];
                p = U(p.length) - 1, m = 128 | m - 1 << 4 | p, E(o2, f2), E(o2, h2), o2.writeBytes([m, 0, 0]), M(v2, a2), 0 <= l2 && (p = v2, f2 = l2, p.writeByte(33), p.writeByte(255), p.writeByte(11), O(p, "NETSCAPE2.0"), p.writeByte(3), p.writeByte(1), E(p, f2), p.writeByte(0));
              }
              var y, h2 = Math.round(i2 / 10), o2 = v2, m = c2, l2 = h2, f2 = n2, p = s3, i2 = (o2.writeByte(33), o2.writeByte(249), o2.writeByte(4), p < 0 && (p = 0, f2 = false), f2 = f2 ? (y = 1, 2) : y = 0, 0 <= m && (f2 = 7 & m), f2 <<= 2, o2.writeByte(0 | f2 | y), E(o2, l2), o2.writeByte(p || 0), o2.writeByte(0), Boolean(a2) && !d2);
              c2 = v2, n2 = t4, s3 = r2, y = i2 ? a2 : null, c2.writeByte(44), E(c2, 0), E(c2, 0), E(c2, n2), E(c2, s3), y ? (n2 = U(y.length) - 1, c2.writeByte(128 | n2)) : c2.writeByte(0), i2 && M(v2, a2), [l2, o2, s3, n2, c2 = 8, i2, a2, e4] = [v2, e4, t4, r2, u2, b, j, _], S(s3, n2, o2, c2, l2, i2, a2, e4);
            } };
            function w() {
              O(v2, "GIF89a");
            }
          }
          function M(r2, o2) {
            var e3 = 1 << U(o2.length);
            for (let t3 = 0; t3 < e3; t3++) {
              let e4 = [0, 0, 0];
              t3 < o2.length && (e4 = o2[t3]), r2.writeByte(e4[0]), r2.writeByte(e4[1]), r2.writeByte(e4[2]);
            }
          }
          function E(e3, t3) {
            e3.writeByte(255 & t3), e3.writeByte(t3 >> 8 & 255);
          }
          function O(e3, t3) {
            for (var r2 = 0; r2 < t3.length; r2++)
              e3.writeByte(t3.charCodeAt(r2));
          }
          function U(e3) {
            return Math.max(Math.ceil(Math.log2(e3)), 1);
          }
          var h = f;
        }, {}], 238: [function(e2, t2, r) {
          r.read = function(e3, t3, r2, o, n) {
            var s2, i, a = 8 * n - o - 1, l = (1 << a) - 1, u = l >> 1, c = -7, d = r2 ? n - 1 : 0, f = r2 ? -1 : 1, n = e3[t3 + d];
            for (d += f, s2 = n & (1 << -c) - 1, n >>= -c, c += a; 0 < c; s2 = 256 * s2 + e3[t3 + d], d += f, c -= 8)
              ;
            for (i = s2 & (1 << -c) - 1, s2 >>= -c, c += o; 0 < c; i = 256 * i + e3[t3 + d], d += f, c -= 8)
              ;
            if (0 === s2)
              s2 = 1 - u;
            else {
              if (s2 === l)
                return i ? NaN : 1 / 0 * (n ? -1 : 1);
              i += Math.pow(2, o), s2 -= u;
            }
            return (n ? -1 : 1) * i * Math.pow(2, s2 - o);
          }, r.write = function(e3, t3, r2, o, n, s2) {
            var i, a, l = 8 * s2 - n - 1, u = (1 << l) - 1, c = u >> 1, d = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = o ? 0 : s2 - 1, h = o ? 1 : -1, s2 = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
            for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a = isNaN(t3) ? 1 : 0, i = u) : (i = Math.floor(Math.log(t3) / Math.LN2), t3 * (o = Math.pow(2, -i)) < 1 && (i--, o *= 2), 2 <= (t3 += 1 <= i + c ? d / o : d * Math.pow(2, 1 - c)) * o && (i++, o /= 2), u <= i + c ? (a = 0, i = u) : 1 <= i + c ? (a = (t3 * o - 1) * Math.pow(2, n), i += c) : (a = t3 * Math.pow(2, c - 1) * Math.pow(2, n), i = 0)); 8 <= n; e3[r2 + f] = 255 & a, f += h, a /= 256, n -= 8)
              ;
            for (i = i << n | a, l += n; 0 < l; e3[r2 + f] = 255 & i, f += h, i /= 256, l -= 8)
              ;
            e3[r2 + f - h] |= 128 * s2;
          };
        }, {}], 239: [function(o, e2, c) {
          "use strict";
          var t2;
          function y(e3, t3) {
            return e3.b === t3.b && e3.a === t3.a;
          }
          function g(e3, t3) {
            return e3.b < t3.b || e3.b === t3.b && e3.a <= t3.a;
          }
          function v(e3, t3, r2) {
            var o2 = t3.b - e3.b, n2 = r2.b - t3.b;
            return 0 < o2 + n2 ? o2 < n2 ? t3.a - e3.a + o2 / (o2 + n2) * (e3.a - r2.a) : t3.a - r2.a + n2 / (o2 + n2) * (r2.a - e3.a) : 0;
          }
          function b(e3, t3, r2) {
            var o2 = t3.b - e3.b, n2 = r2.b - t3.b;
            return 0 < o2 + n2 ? (t3.a - r2.a) * o2 + (t3.a - e3.a) * n2 : 0;
          }
          function j(e3, t3) {
            return e3.a < t3.a || e3.a === t3.a && e3.b <= t3.b;
          }
          function V(e3, t3, r2) {
            var o2 = t3.a - e3.a, n2 = r2.a - t3.a;
            return 0 < o2 + n2 ? o2 < n2 ? t3.b - e3.b + o2 / (o2 + n2) * (e3.b - r2.b) : t3.b - r2.b + n2 / (o2 + n2) * (r2.b - e3.b) : 0;
          }
          function z(e3, t3, r2) {
            var o2 = t3.a - e3.a, n2 = r2.a - t3.a;
            return 0 < o2 + n2 ? (t3.b - r2.b) * o2 + (t3.b - e3.b) * n2 : 0;
          }
          function _(e3, t3, r2, o2) {
            return (e3 = e3 < 0 ? 0 : e3) <= (r2 = r2 < 0 ? 0 : r2) ? 0 === r2 ? (t3 + o2) / 2 : t3 + e3 / (e3 + r2) * (o2 - t3) : o2 + r2 / (e3 + r2) * (t3 - o2);
          }
          function d(e3) {
            var t3 = s2(e3.b);
            return n(t3, e3.c), n(t3.b, e3.c), i(t3, e3.a), t3;
          }
          function x(e3, t3) {
            var r2 = false, o2 = false;
            e3 !== t3 && (t3.a !== e3.a && (o2 = true, E(t3.a, e3.a)), t3.d !== e3.d && (r2 = true, a(t3.d, e3.d)), M(t3, e3), o2 || (n(t3, e3.a), e3.a.c = e3), r2 || (i(t3, e3.d), e3.d.a = e3));
          }
          function m(e3) {
            var t3 = e3.b, r2 = false;
            e3.d !== e3.b.d && (r2 = true, a(e3.d, e3.b.d)), e3.c === e3 ? E(e3.a, null) : (e3.b.d.a = e3.b.e, e3.a.c = e3.c, M(e3, e3.b.e), r2 || i(e3, e3.d)), t3.c === t3 ? (E(t3.a, null), a(t3.d, null)) : (e3.d.a = t3.b.e, t3.a.c = t3.c, M(t3, t3.b.e)), H(e3);
          }
          function w(e3) {
            var t3 = s2(e3), r2 = t3.b;
            return M(t3, e3.e), t3.a = e3.b.a, n(r2, t3.a), t3.d = r2.d = e3.d, t3 = t3.b, M(e3.b, e3.b.b.e), M(e3.b, t3), e3.b.a = t3.a, t3.b.a.c = t3.b, t3.b.d = e3.b.d, t3.f = e3.f, t3.b.f = e3.b.f, t3;
          }
          function S(e3, t3) {
            var r2 = false, o2 = s2(e3), n2 = o2.b;
            return t3.d !== e3.d && (r2 = true, a(t3.d, e3.d)), M(o2, e3.e), M(n2, t3), o2.a = e3.b.a, n2.a = t3.a, o2.d = n2.d = e3.d, e3.d.a = n2, r2 || i(o2, e3.d), o2;
          }
          function s2(e3) {
            var t3 = new u(), r2 = new u(), o2 = e3.b.h;
            return (((r2.h = o2).b.h = t3).h = e3).b.h = r2, t3.b = r2, ((t3.c = t3).e = r2).b = t3, (r2.c = r2).e = t3;
          }
          function M(e3, t3) {
            var r2 = e3.c, o2 = t3.c;
            r2.b.e = t3, (o2.b.e = e3).c = o2, t3.c = r2;
          }
          function n(e3, t3) {
            var r2 = t3.f, o2 = new I(t3, r2);
            for (r2.e = o2, r2 = (t3.f = o2).c = e3; r2.a = o2, (r2 = r2.c) !== e3; )
              ;
          }
          function i(e3, t3) {
            var r2 = t3.d, o2 = new te(t3, r2);
            for (r2.b = o2, (t3.d = o2).a = e3, o2.c = t3.c, r2 = e3; r2.d = o2, (r2 = r2.e) !== e3; )
              ;
          }
          function H(e3) {
            var t3 = e3.h;
            e3 = e3.b.h, (t3.b.h = e3).b.h = t3;
          }
          function E(e3, t3) {
            for (var r2 = e3.c, o2 = r2; o2.a = t3, (o2 = o2.c) !== r2; )
              ;
            r2 = e3.f, ((o2 = e3.e).f = r2).e = o2;
          }
          function a(e3, t3) {
            for (var r2 = e3.a, o2 = r2; o2.d = t3, (o2 = o2.e) !== r2; )
              ;
            r2 = e3.d, ((o2 = e3.b).d = r2).b = o2;
          }
          function W(e3) {
            var t3 = 0;
            return Math.abs(e3[1]) > Math.abs(e3[0]) && (t3 = 1), t3 = Math.abs(e3[2]) > Math.abs(e3[t3]) ? 2 : t3;
          }
          function T(e3, t3) {
            e3.f += t3.f, e3.b.f += t3.b.f;
          }
          function f(e3, t3, r2) {
            return e3 = e3.a, t3 = t3.a, r2 = r2.a, t3.b.a === e3 ? r2.b.a === e3 ? g(t3.a, r2.a) ? b(r2.b.a, t3.a, r2.a) <= 0 : 0 <= b(t3.b.a, r2.a, t3.a) : b(r2.b.a, e3, r2.a) <= 0 : r2.b.a === e3 ? 0 <= b(t3.b.a, e3, t3.a) : (t3 = v(t3.b.a, e3, t3.a), (e3 = v(r2.b.a, e3, r2.a)) <= t3);
          }
          function C(e3) {
            e3.a.i = null;
            var t3 = e3.e;
            t3.a.c = t3.c, t3.c.a = t3.a, e3.e = null;
          }
          function O(e3, t3) {
            m(e3.a), e3.c = false, (e3.a = t3).i = e3;
          }
          function L(e3) {
            for (var t3 = e3.a.a; (e3 = G(e3)).a.a === t3; )
              ;
            return e3.c && (O(e3, t3 = S(B(e3).a.b, e3.a.e)), e3 = G(e3)), e3;
          }
          function q(e3, t3, r2) {
            var o2 = new F();
            return o2.a = r2, o2.e = p(e3.f, t3.e, o2), r2.i = o2;
          }
          function X(e3, t3) {
            switch (e3.s) {
              case 100130:
                return 0 != (1 & t3);
              case 100131:
                return 0 !== t3;
              case 100132:
                return 0 < t3;
              case 100133:
                return t3 < 0;
              case 100134:
                return 2 <= t3 || t3 <= -2;
            }
            return false;
          }
          function h(e3) {
            var t3 = e3.a, r2 = t3.d;
            r2.c = e3.d, r2.a = t3, C(e3);
          }
          function k(e3, t3, r2) {
            for (t3 = (e3 = t3).a; e3 !== r2; ) {
              e3.c = false;
              var o2 = B(e3), n2 = o2.a;
              if (n2.a !== t3.a) {
                if (!o2.c) {
                  h(e3);
                  break;
                }
                O(o2, n2 = S(t3.c.b, n2.b));
              }
              t3.c !== n2 && (x(n2.b.e, n2), x(t3, n2)), h(e3), t3 = o2.a, e3 = o2;
            }
            return t3;
          }
          function A(e3, t3, r2, o2, n2, s3) {
            for (var i2 = true; q(e3, t3, r2.b), (r2 = r2.c) !== o2; )
              ;
            for (null === n2 && (n2 = B(t3).a.b.c); (r2 = (o2 = B(t3)).a.b).a === n2.a; )
              r2.c !== n2 && (x(r2.b.e, r2), x(n2.b.e, r2)), o2.f = t3.f - r2.f, o2.d = X(e3, o2.f), t3.b = true, !i2 && R(e3, t3) && (T(r2, n2), C(t3), m(n2)), i2 = false, t3 = o2, n2 = r2;
            t3.b = true, s3 && K(e3, t3);
          }
          function Y(e3, t3, r2, o2, n2) {
            var s3 = [t3.g[0], t3.g[1], t3.g[2]];
            t3.d = null, t3.d = e3.o && e3.o(s3, r2, o2, e3.c) || null, null === t3.d && (n2 ? e3.n || (l(e3, 100156), e3.n = true) : t3.d = r2[0]);
          }
          function P(e3, t3, r2) {
            var o2 = [null, null, null, null];
            o2[0] = t3.a.d, o2[1] = r2.a.d, Y(e3, t3.a, o2, [0.5, 0.5, 0, 0], false), x(t3, r2);
          }
          function Z(e3, t3, r2, o2, n2) {
            var s3 = Math.abs(t3.b - e3.b) + Math.abs(t3.a - e3.a), i2 = Math.abs(r2.b - e3.b) + Math.abs(r2.a - e3.a), a2 = n2 + 1;
            o2[n2] = 0.5 * i2 / (s3 + i2), o2[a2] = 0.5 * s3 / (s3 + i2), e3.g[0] += o2[n2] * t3.g[0] + o2[a2] * r2.g[0], e3.g[1] += o2[n2] * t3.g[1] + o2[a2] * r2.g[1], e3.g[2] += o2[n2] * t3.g[2] + o2[a2] * r2.g[2];
          }
          function R(e3, t3) {
            var r2 = B(t3), o2 = t3.a, n2 = r2.a;
            if (g(o2.a, n2.a)) {
              if (0 < b(n2.b.a, o2.a, n2.a))
                return;
              if (y(o2.a, n2.a)) {
                if (o2.a !== n2.a) {
                  var r2 = e3.e, s3 = o2.a.h;
                  if (0 <= s3) {
                    var i2 = (r2 = r2.b).d, a2 = r2.e, l2 = r2.c, u2 = l2[s3];
                    i2[u2] = i2[r2.a], (l2[i2[u2]] = u2) <= --r2.a && (u2 <= 1 || g(a2[i2[u2 >> 1]], a2[i2[u2]]) ? N : ue)(r2, u2), a2[s3] = null, l2[s3] = r2.b, r2.b = s3;
                  } else
                    for (r2.c[-(s3 + 1)] = null; 0 < r2.a && null === r2.c[r2.d[r2.a - 1]]; )
                      --r2.a;
                  P(e3, n2.b.e, o2);
                }
              } else
                w(n2.b), x(o2, n2.b.e), t3.b = r2.b = true;
            } else {
              if (b(o2.b.a, n2.a, o2.a) < 0)
                return;
              G(t3).b = t3.b = true, w(o2.b), x(n2.b.e, o2);
            }
            return 1;
          }
          function Q(e3, t3) {
            var r2 = B(t3), o2 = t3.a, n2 = r2.a, s3 = o2.a, i2 = n2.a, a2 = o2.b.a, l2 = n2.b.a, u2 = new I();
            if (b(a2, e3.a, s3), b(l2, e3.a, i2), !(s3 === i2 || Math.min(s3.a, a2.a) > Math.max(i2.a, l2.a))) {
              if (g(s3, i2)) {
                if (0 < b(l2, s3, i2))
                  return;
              } else if (b(a2, i2, s3) < 0)
                return;
              var c2, d2, f2 = a2, h2 = s3, p2 = l2, m2 = i2;
              if (g(f2, h2) || (c2 = f2, f2 = h2, h2 = c2), g(p2, m2) || (c2 = p2, p2 = m2, m2 = c2), g(f2, p2) || (c2 = f2, f2 = p2, p2 = c2, c2 = h2, h2 = m2, m2 = c2), g(p2, h2) ? g(h2, m2) ? ((c2 = v(f2, p2, h2)) + (d2 = v(p2, h2, m2)) < 0 && (c2 = -c2, d2 = -d2), u2.b = _(c2, p2.b, d2, h2.b)) : ((c2 = b(f2, p2, h2)) + (d2 = -b(f2, m2, h2)) < 0 && (c2 = -c2, d2 = -d2), u2.b = _(c2, p2.b, d2, m2.b)) : u2.b = (p2.b + h2.b) / 2, j(f2, h2) || (c2 = f2, f2 = h2, h2 = c2), j(p2, m2) || (c2 = p2, p2 = m2, m2 = c2), j(f2, p2) || (c2 = f2, f2 = p2, p2 = c2, c2 = h2, h2 = m2, m2 = c2), j(p2, h2) ? j(h2, m2) ? ((c2 = V(f2, p2, h2)) + (d2 = V(p2, h2, m2)) < 0 && (c2 = -c2, d2 = -d2), u2.a = _(c2, p2.a, d2, h2.a)) : ((c2 = z(f2, p2, h2)) + (d2 = -z(f2, m2, h2)) < 0 && (c2 = -c2, d2 = -d2), u2.a = _(c2, p2.a, d2, m2.a)) : u2.a = (p2.a + h2.a) / 2, g(u2, e3.a) && (u2.b = e3.a.b, u2.a = e3.a.a), f2 = g(s3, i2) ? s3 : i2, g(f2, u2) && (u2.b = f2.b, u2.a = f2.a), y(u2, s3) || y(u2, i2))
                return R(e3, t3), 0;
              if (!y(a2, e3.a) && 0 <= b(a2, e3.a, u2) || !y(l2, e3.a) && b(l2, e3.a, u2) <= 0) {
                if (l2 === e3.a)
                  w(o2.b), x(n2.b, o2), o2 = B(t3 = L(t3)).a, k(e3, B(t3), r2), A(e3, t3, o2.b.e, o2, o2, true);
                else {
                  if (a2 !== e3.a)
                    return 0 <= b(a2, e3.a, u2) && (G(t3).b = t3.b = true, w(o2.b), o2.a.b = e3.a.b, o2.a.a = e3.a.a), void (b(l2, e3.a, u2) <= 0 && (t3.b = r2.b = true, w(n2.b), n2.a.b = e3.a.b, n2.a.a = e3.a.a));
                  for (w(n2.b), x(o2.e, n2.b.e), i2 = (s3 = r2 = t3).a.b.a; (s3 = G(s3)).a.b.a === i2; )
                    ;
                  s3 = B(t3 = s3).a.b.c, r2.a = n2.b.e, A(e3, t3, (n2 = k(e3, r2, null)).c, o2.b.c, s3, true);
                }
                return 1;
              }
              w(o2.b), w(n2.b), x(n2.b.e, o2), o2.a.b = u2.b, o2.a.a = u2.a, o2.a.h = ne(e3.e, o2.a), o2 = o2.a, n2 = [0, 0, 0, 0], u2 = [s3.d, a2.d, i2.d, l2.d], o2.g[0] = o2.g[1] = o2.g[2] = 0, Z(o2, s3, a2, n2, 0), Z(o2, i2, l2, n2, 2), Y(e3, o2, u2, n2, true), G(t3).b = t3.b = r2.b = true;
            }
          }
          function K(e3, t3) {
            for (var r2 = B(t3); ; ) {
              for (; r2.b; )
                r2 = B(t3 = r2);
              if (!t3.b && (null === (t3 = G(r2 = t3)) || !t3.b))
                break;
              t3.b = false;
              var o2 = t3.a, n2 = r2.a;
              if (s3 = o2.b.a !== n2.b.a)
                e: {
                  var s3, i2 = B(s3 = t3), a2 = s3.a, l2 = i2.a, u2 = void 0;
                  if (g(a2.b.a, l2.b.a)) {
                    if (b(a2.b.a, l2.b.a, a2.a) < 0) {
                      s3 = false;
                      break e;
                    }
                    G(s3).b = s3.b = true, u2 = w(a2), x(l2.b, u2), u2.d.c = s3.d;
                  } else {
                    if (0 < b(l2.b.a, a2.b.a, l2.a)) {
                      s3 = false;
                      break e;
                    }
                    s3.b = i2.b = true, u2 = w(l2), x(a2.e, l2.b), u2.b.d.c = s3.d;
                  }
                  s3 = true;
                }
              if (s3 && (r2.c ? (C(r2), m(n2), n2 = (r2 = B(t3)).a) : t3.c && (C(t3), m(o2), o2 = (t3 = G(r2)).a)), o2.a !== n2.a) {
                if (o2.b.a === n2.b.a || t3.c || r2.c || o2.b.a !== e3.a && n2.b.a !== e3.a)
                  R(e3, t3);
                else if (Q(e3, t3))
                  break;
              }
              o2.a === n2.a && o2.b.a === n2.b.a && (T(n2, o2), C(t3), m(o2), t3 = G(r2));
            }
          }
          function J(e3, t3) {
            var r2 = new F(), o2 = d(e3.b);
            o2.a.b = 4e150, o2.a.a = t3, o2.b.a.b = -4e150, o2.b.a.a = t3, e3.a = o2.b.a, r2.a = o2, r2.f = 0, r2.d = false, r2.c = false, r2.h = true, r2.b = false, o2 = p(o2 = e3.f, o2.a, r2), r2.e = o2;
          }
          function $(e3) {
            this.a = new ee(), this.b = e3, this.c = f;
          }
          function p(e3, t3, r2) {
            for (; null !== (t3 = t3.c).b && !e3.c(e3.b, t3.b, r2); )
              ;
            return e3 = new ee(r2, t3.a, t3), t3.a.c = e3, t3.a = e3;
          }
          function ee(e3, t3, r2) {
            this.b = e3 || null, this.a = t3 || this, this.c = r2 || this;
          }
          function r() {
            this.d = 0, this.p = this.b = this.q = null, this.j = [0, 0, 0], this.s = 100130, this.n = false, this.o = this.a = this.e = this.f = null, this.m = false, this.c = this.r = this.i = this.k = this.l = this.h = null;
          }
          function D(e3, t3) {
            if (e3.d !== t3)
              for (; e3.d !== t3; )
                if (e3.d < t3)
                  switch (e3.d) {
                    case 0:
                      l(e3, 100151), e3.u(null);
                      break;
                    case 1:
                      l(e3, 100152), e3.t();
                  }
                else
                  switch (e3.d) {
                    case 2:
                      l(e3, 100154), e3.v();
                      break;
                    case 1:
                      l(e3, 100153), e3.w();
                  }
          }
          function l(e3, t3) {
            e3.p && e3.p(t3, e3.c);
          }
          function te(e3, t3) {
            this.b = e3 || this, this.d = t3 || this, this.a = null, this.c = false;
          }
          function u() {
            (this.h = this).i = this.d = this.a = this.e = this.c = this.b = null, this.f = 0;
          }
          function re() {
            this.c = new I(), this.a = new te(), this.b = new u(), this.d = new u(), this.b.b = this.d, this.d.b = this.b;
          }
          function I(e3, t3) {
            this.e = e3 || this, this.f = t3 || this, this.d = this.c = null, this.g = [0, 0, 0], this.h = this.a = this.b = 0;
          }
          function oe() {
            this.c = [], this.d = null, this.a = 0, this.e = false, this.b = new ie();
          }
          function ne(e3, t3) {
            var r2, o2, n2;
            return e3.e ? (2 * (o2 = ++(r2 = e3.b).a) > r2.f && (r2.f *= 2, r2.c = ae(r2.c, r2.f + 1)), 0 === r2.b ? n2 = o2 : (n2 = r2.b, r2.b = r2.c[r2.b]), r2.e[n2] = t3, r2.c[n2] = o2, r2.d[o2] = n2, r2.h && ue(r2, o2), n2) : (r2 = e3.a++, e3.c[r2] = t3, -(r2 + 1));
          }
          function se(e3) {
            if (0 === e3.a)
              return le(e3.b);
            var t3 = e3.c[e3.d[e3.a - 1]];
            if (0 !== e3.b.a && g(U(e3.b), t3))
              return le(e3.b);
            for (; --e3.a, 0 < e3.a && null === e3.c[e3.d[e3.a - 1]]; )
              ;
            return t3;
          }
          function ie() {
            this.d = ae([0], 33), this.e = [null, null], this.c = [0, 0], this.a = 0, this.f = 32, this.b = 0, this.h = false, this.d[1] = 1;
          }
          function ae(e3, t3) {
            for (var r2 = Array(t3), o2 = 0; o2 < e3.length; o2++)
              r2[o2] = e3[o2];
            for (; o2 < t3; o2++)
              r2[o2] = 0;
            return r2;
          }
          function U(e3) {
            return e3.e[e3.d[1]];
          }
          function le(e3) {
            var t3 = e3.d, r2 = e3.e, o2 = e3.c, n2 = t3[1], s3 = r2[n2];
            return 0 < e3.a && (t3[1] = t3[e3.a], o2[t3[1]] = 1, r2[n2] = null, o2[n2] = e3.b, e3.b = n2, 0 < --e3.a && N(e3, 1)), s3;
          }
          function N(e3, t3) {
            for (var r2 = e3.d, o2 = e3.e, n2 = e3.c, s3 = t3, i2 = r2[s3]; ; ) {
              var a2 = s3 << 1, l2 = (a2 < e3.a && g(o2[r2[a2 + 1]], o2[r2[a2]]) && (a2 += 1), r2[a2]);
              if (a2 > e3.a || g(o2[i2], o2[l2])) {
                n2[r2[s3] = i2] = s3;
                break;
              }
              n2[r2[s3] = l2] = s3, s3 = a2;
            }
          }
          function ue(e3, t3) {
            for (var r2 = e3.d, o2 = e3.e, n2 = e3.c, s3 = t3, i2 = r2[s3]; ; ) {
              var a2 = s3 >> 1, l2 = r2[a2];
              if (0 == a2 || g(o2[l2], o2[i2])) {
                n2[r2[s3] = i2] = s3;
                break;
              }
              n2[r2[s3] = l2] = s3, s3 = a2;
            }
          }
          function F() {
            this.e = this.a = null, this.f = 0, this.c = this.b = this.h = this.d = false;
          }
          function B(e3) {
            return e3.e.c.b;
          }
          function G(e3) {
            return e3.e.a.b;
          }
          (t2 = r.prototype).x = function() {
            D(this, 0);
          }, t2.B = function(e3, t3) {
            switch (e3) {
              case 100142:
                return;
              case 100140:
                switch (t3) {
                  case 100130:
                  case 100131:
                  case 100132:
                  case 100133:
                  case 100134:
                    return void (this.s = t3);
                }
                break;
              case 100141:
                return void (this.m = !!t3);
              default:
                return void l(this, 100900);
            }
            l(this, 100901);
          }, t2.y = function(e3) {
            switch (e3) {
              case 100142:
                return 0;
              case 100140:
                return this.s;
              case 100141:
                return this.m;
              default:
                l(this, 100900);
            }
            return false;
          }, t2.A = function(e3, t3, r2) {
            this.j[0] = e3, this.j[1] = t3, this.j[2] = r2;
          }, t2.z = function(e3, t3) {
            var r2 = t3 || null;
            switch (e3) {
              case 100100:
              case 100106:
                this.h = r2;
                break;
              case 100104:
              case 100110:
                this.l = r2;
                break;
              case 100101:
              case 100107:
                this.k = r2;
                break;
              case 100102:
              case 100108:
                this.i = r2;
                break;
              case 100103:
              case 100109:
                this.p = r2;
                break;
              case 100105:
              case 100111:
                this.o = r2;
                break;
              case 100112:
                this.r = r2;
                break;
              default:
                l(this, 100900);
            }
          }, t2.C = function(e3, t3) {
            var r2 = false, o2 = [0, 0, 0];
            D(this, 2);
            for (var n2 = 0; n2 < 3; ++n2) {
              var s3 = e3[n2];
              s3 < -1e150 && (s3 = -1e150, r2 = true), 1e150 < s3 && (s3 = 1e150, r2 = true), o2[n2] = s3;
            }
            r2 && l(this, 100155), null === (r2 = this.q) ? x(r2 = d(this.b), r2.b) : (w(r2), r2 = r2.e), r2.a.d = t3, r2.a.g[0] = o2[0], r2.a.g[1] = o2[1], r2.a.g[2] = o2[2], r2.f = 1, r2.b.f = -1, this.q = r2;
          }, t2.u = function(e3) {
            D(this, 0), this.d = 1, this.b = new re(), this.c = e3;
          }, t2.t = function() {
            D(this, 1), this.d = 2, this.q = null;
          }, t2.v = function() {
            D(this, 2), this.d = 1;
          }, t2.w = function() {
            D(this, 1), this.d = 0;
            var e3, t3, r2 = this.j[0], o2 = this.j[1], n2 = this.j[2], s3 = false, i2 = [r2, o2, n2];
            if (0 === r2 && 0 === o2 && 0 === n2) {
              for (var o2 = [-2e150, -2e150, -2e150], a2 = [2e150, 2e150, 2e150], n2 = [], l2 = [], r2 = (s3 = this.b.c).e; r2 !== s3; r2 = r2.e)
                for (var u2 = 0; u2 < 3; ++u2) {
                  var c2 = r2.g[u2];
                  c2 < a2[u2] && (a2[u2] = c2, l2[u2] = r2), c2 > o2[u2] && (o2[u2] = c2, n2[u2] = r2);
                }
              if (o2[1] - a2[1] > o2[r2 = 0] - a2[0] && (r2 = 1), a2[r2 = o2[2] - a2[2] > o2[r2] - a2[r2] ? 2 : r2] >= o2[r2])
                i2[0] = 0, i2[1] = 0, i2[2] = 1;
              else {
                for (a2 = l2[r2], n2 = n2[r2], l2 = [o2 = 0, 0, 0], a2 = [a2.g[0] - n2.g[0], a2.g[1] - n2.g[1], a2.g[2] - n2.g[2]], u2 = [0, 0, 0], r2 = s3.e; r2 !== s3; r2 = r2.e)
                  u2[0] = r2.g[0] - n2.g[0], u2[1] = r2.g[1] - n2.g[1], u2[2] = r2.g[2] - n2.g[2], l2[0] = a2[1] * u2[2] - a2[2] * u2[1], l2[1] = a2[2] * u2[0] - a2[0] * u2[2], l2[2] = a2[0] * u2[1] - a2[1] * u2[0], o2 < (c2 = l2[0] * l2[0] + l2[1] * l2[1] + l2[2] * l2[2]) && (o2 = c2, i2[0] = l2[0], i2[1] = l2[1], i2[2] = l2[2]);
                o2 <= 0 && (i2[0] = i2[1] = i2[2] = 0, i2[W(a2)] = 1);
              }
              s3 = true;
            }
            for (l2 = W(i2), r2 = this.b.c, o2 = (l2 + 1) % 3, n2 = (l2 + 2) % 3, l2 = 0 < i2[l2] ? 1 : -1, i2 = r2.e; i2 !== r2; i2 = i2.e)
              i2.b = i2.g[o2], i2.a = l2 * i2.g[n2];
            if (s3) {
              for (i2 = 0, r2 = (s3 = this.b.a).b; r2 !== s3; r2 = r2.b)
                if (!((o2 = r2.a).f <= 0))
                  for (; i2 += (o2.a.b - o2.b.a.b) * (o2.a.a + o2.b.a.a), (o2 = o2.e) !== r2.a; )
                    ;
              if (i2 < 0)
                for (s3 = (i2 = this.b.c).e; s3 !== i2; s3 = s3.e)
                  s3.a = -s3.a;
            }
            for (this.n = false, i2 = this.b.b, r2 = i2.h; r2 !== i2; r2 = s3)
              s3 = r2.h, o2 = r2.e, y(r2.a, r2.b.a) && r2.e.e !== r2 && (P(this, o2, r2), m(r2), o2 = (r2 = o2).e), o2.e === r2 && (o2 !== r2 && (o2 !== s3 && o2 !== s3.b || (s3 = s3.h), m(o2)), r2 !== s3 && r2 !== s3.b || (s3 = s3.h), m(r2));
            for (this.e = i2 = new oe(), s3 = this.b.c, r2 = s3.e; r2 !== s3; r2 = r2.e)
              r2.h = ne(i2, r2);
            var d2 = i2;
            d2.d = [];
            for (var f2 = 0; f2 < d2.a; f2++)
              d2.d[f2] = f2;
            d2.d.sort(function(r3) {
              return function(e4, t4) {
                return g(r3[e4], r3[t4]) ? 1 : -1;
              };
            }(d2.c)), d2.e = true;
            for (var h2 = d2.b, p2 = h2.a; 1 <= p2; --p2)
              N(h2, p2);
            for (h2.h = true, this.f = new $(this), J(this, -4e150), J(this, 4e150); null !== (i2 = se(this.e)); ) {
              for (; ; ) {
                e:
                  if (0 === (r2 = this.e).a)
                    s3 = U(r2.b);
                  else if (s3 = r2.c[r2.d[r2.a - 1]], 0 !== r2.b.a && g(r2 = U(r2.b), s3)) {
                    s3 = r2;
                    break e;
                  }
                if (null === s3 || !y(s3, i2))
                  break;
                s3 = se(this.e), P(this, i2.c, s3.c);
              }
              !function e4(t4, r3) {
                for (var o3, n3 = (t4.a = r3).c; null === n3.i; )
                  if ((n3 = n3.c) === r3.c) {
                    var n3 = t4, s4 = r3;
                    (c3 = new F()).a = s4.c.b;
                    for (var i3 = (a3 = n3.f).a; null !== (i3 = i3.a).b && !a3.c(a3.b, c3, i3.b); )
                      ;
                    var a3, l3, u3 = B(a3 = i3.b), c3 = a3.a, i3 = u3.a;
                    return void (0 === b(c3.b.a, s4, c3.a) ? y((c3 = a3.a).a, s4) || y(c3.b.a, s4) || (w(c3.b), a3.c && (m(c3.c), a3.c = false), x(s4.c, c3), e4(n3, s4)) : (l3 = g(i3.b.a, c3.b.a) ? a3 : u3, u3 = void 0, a3.d || l3.c ? (u3 = l3 === a3 ? S(s4.c.b, c3.e) : S(i3.b.c.b, s4.c).b, l3.c ? O(l3, u3) : ((a3 = q(c3 = n3, a3, u3)).f = G(a3).f + a3.a.f, a3.d = X(c3, a3.f)), e4(n3, s4)) : A(n3, a3, s4.c, s4.c, null, true)));
                  }
                a3 = (c3 = B(n3 = L(n3.i))).a, (c3 = k(t4, c3, null)).c === a3 ? (c3 = (a3 = c3).c, i3 = B(n3), u3 = n3.a, l3 = i3.a, o3 = false, u3.b.a !== l3.b.a && Q(t4, n3), y(u3.a, t4.a) && (x(c3.b.e, u3), c3 = B(n3 = L(n3)).a, k(t4, B(n3), i3), o3 = true), y(l3.a, t4.a) && (x(a3, l3.b.e), a3 = k(t4, i3, null), o3 = true), o3 ? A(t4, n3, a3.c, c3, c3, true) : (s4 = g(l3.a, u3.a) ? l3.b.e : u3, A(t4, n3, s4 = S(a3.c.b, s4), s4.c, s4.c, false), s4.b.i.c = true, K(t4, n3))) : A(t4, n3, c3.c, a3, a3, true);
              }(this, i2);
            }
            for (this.a = this.f.a.a.b.a.a, i2 = 0; null !== (s3 = this.f.a.a.b); )
              s3.h || ++i2, C(s3);
            for (this.f = null, (i2 = this.e).b = null, i2.d = null, this.e = i2.c = null, i2 = this.b, r2 = i2.a.b; r2 !== i2.a; r2 = s3)
              s3 = r2.b, (r2 = r2.a).e.e === r2 && (T(r2.c, r2), m(r2));
            if (!this.n) {
              if (i2 = this.b, this.m)
                for (r2 = i2.b.h; r2 !== i2.b; r2 = s3)
                  s3 = r2.h, r2.b.d.c !== r2.d.c ? r2.f = r2.d.c ? 1 : -1 : m(r2);
              else
                for (r2 = i2.a.b; r2 !== i2.a; r2 = s3)
                  if (s3 = r2.b, r2.c) {
                    for (r2 = r2.a; g(r2.b.a, r2.a); r2 = r2.c.b)
                      ;
                    for (; g(r2.a, r2.b.a); r2 = r2.e)
                      ;
                    for (o2 = r2.c.b, n2 = void 0; r2.e !== o2; )
                      if (g(r2.b.a, o2.a)) {
                        for (; o2.e !== r2 && (g((t3 = o2.e).b.a, t3.a) || b(o2.a, o2.b.a, o2.e.b.a) <= 0); )
                          o2 = (n2 = S(o2.e, o2)).b;
                        o2 = o2.c.b;
                      } else {
                        for (; o2.e !== r2 && (g((e3 = r2.c.b).a, e3.b.a) || 0 <= b(r2.b.a, r2.a, r2.c.b.a)); )
                          r2 = (n2 = S(r2, r2.c.b)).b;
                        r2 = r2.e;
                      }
                    for (; o2.e.e !== r2; )
                      n2 = S(o2.e, o2), o2 = n2.b;
                  }
              if (this.h || this.i || this.k || this.l)
                if (this.m) {
                  for (s3 = (i2 = this.b).a.b; s3 !== i2.a; s3 = s3.b)
                    if (s3.c) {
                      for (this.h && this.h(2, this.c), r2 = s3.a; this.k && this.k(r2.a.d, this.c), (r2 = r2.e) !== s3.a; )
                        ;
                      this.i && this.i(this.c);
                    }
                } else {
                  for (i2 = this.b, s3 = !!this.l, r2 = false, o2 = -1, n2 = i2.a.d; n2 !== i2.a; n2 = n2.d)
                    if (n2.c)
                      for (r2 || (this.h && this.h(4, this.c), r2 = true), l2 = n2.a; s3 && (a2 = l2.b.d.c ? 0 : 1, o2 !== a2 && (o2 = a2, this.l && this.l(!!o2, this.c))), this.k && this.k(l2.a.d, this.c), (l2 = l2.e) !== n2.a; )
                        ;
                  r2 && this.i && this.i(this.c);
                }
              if (this.r) {
                for (i2 = this.b, r2 = i2.a.b; r2 !== i2.a; r2 = s3)
                  if (s3 = r2.b, !r2.c) {
                    for (n2 = (o2 = r2.a).e, l2 = void 0; n2 = (l2 = n2).e, (l2.d = null) === l2.b.d && (l2.c === l2 ? E(l2.a, null) : (l2.a.c = l2.c, M(l2, l2.b.e)), (a2 = l2.b).c === a2 ? E(a2.a, null) : (a2.a.c = a2.c, M(a2, a2.b.e)), H(l2)), l2 !== o2; )
                      ;
                    o2 = r2.d, ((r2 = r2.b).d = o2).b = r2;
                  }
                return this.r(this.b), void (this.c = this.b = null);
              }
            }
            this.b = this.c = null;
          }, this.libtess = { GluTesselator: r, windingRule: { GLU_TESS_WINDING_ODD: 100130, GLU_TESS_WINDING_NONZERO: 100131, GLU_TESS_WINDING_POSITIVE: 100132, GLU_TESS_WINDING_NEGATIVE: 100133, GLU_TESS_WINDING_ABS_GEQ_TWO: 100134 }, primitiveType: { GL_LINE_LOOP: 2, GL_TRIANGLES: 4, GL_TRIANGLE_STRIP: 5, GL_TRIANGLE_FAN: 6 }, errorType: { GLU_TESS_MISSING_BEGIN_POLYGON: 100151, GLU_TESS_MISSING_END_POLYGON: 100153, GLU_TESS_MISSING_BEGIN_CONTOUR: 100152, GLU_TESS_MISSING_END_CONTOUR: 100154, GLU_TESS_COORD_TOO_LARGE: 100155, GLU_TESS_NEED_COMBINE_CALLBACK: 100156 }, gluEnum: { GLU_TESS_MESH: 100112, GLU_TESS_TOLERANCE: 100142, GLU_TESS_WINDING_RULE: 100140, GLU_TESS_BOUNDARY_ONLY: 100141, GLU_INVALID_ENUM: 100900, GLU_INVALID_VALUE: 100901, GLU_TESS_BEGIN: 100100, GLU_TESS_VERTEX: 100101, GLU_TESS_END: 100102, GLU_TESS_ERROR: 100103, GLU_TESS_EDGE_FLAG: 100104, GLU_TESS_COMBINE: 100105, GLU_TESS_BEGIN_DATA: 100106, GLU_TESS_VERTEX_DATA: 100107, GLU_TESS_END_DATA: 100108, GLU_TESS_ERROR_DATA: 100109, GLU_TESS_EDGE_FLAG_DATA: 100110, GLU_TESS_COMBINE_DATA: 100111 } }, r.prototype.gluDeleteTess = r.prototype.x, r.prototype.gluTessProperty = r.prototype.B, r.prototype.gluGetTessProperty = r.prototype.y, r.prototype.gluTessNormal = r.prototype.A, r.prototype.gluTessCallback = r.prototype.z, r.prototype.gluTessVertex = r.prototype.C, r.prototype.gluTessBeginPolygon = r.prototype.u, r.prototype.gluTessBeginContour = r.prototype.t, r.prototype.gluTessEndContour = r.prototype.v, r.prototype.gluTessEndPolygon = r.prototype.w, void 0 !== e2 && (e2.exports = this.libtess);
        }, {}], 240: [function(e2, t2, r) {
          "use strict";
          function o(g, e3, t3, r2) {
            var v = 0, o2 = void 0 === (r2 = void 0 === r2 ? {} : r2).loop ? null : r2.loop, b = void 0 === r2.palette ? null : r2.palette;
            if (e3 <= 0 || t3 <= 0 || 65535 < e3 || 65535 < t3)
              throw new Error("Width/Height invalid.");
            function j(e4) {
              e4 = e4.length;
              if (e4 < 2 || 256 < e4 || e4 & e4 - 1)
                throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
              return e4;
            }
            g[v++] = 71, g[v++] = 73, g[v++] = 70, g[v++] = 56, g[v++] = 57, g[v++] = 97;
            var n = 0, s2 = 0;
            if (null !== b) {
              for (var i = j(b); i >>= 1; )
                ++n;
              if (i = 1 << n, --n, void 0 !== r2.background) {
                if (i <= (s2 = r2.background))
                  throw new Error("Background index out of range.");
                if (0 === s2)
                  throw new Error("Background index explicitly passed as 0.");
              }
            }
            if (g[v++] = 255 & e3, g[v++] = e3 >> 8 & 255, g[v++] = 255 & t3, g[v++] = t3 >> 8 & 255, g[v++] = (null !== b ? 128 : 0) | n, g[v++] = s2, g[v++] = 0, null !== b)
              for (var a = 0, l = b.length; a < l; ++a) {
                var u = b[a];
                g[v++] = u >> 16 & 255, g[v++] = u >> 8 & 255, g[v++] = 255 & u;
              }
            if (null !== o2) {
              if (o2 < 0 || 65535 < o2)
                throw new Error("Loop count invalid.");
              g[v++] = 33, g[v++] = 255, g[v++] = 11, g[v++] = 78, g[v++] = 69, g[v++] = 84, g[v++] = 83, g[v++] = 67, g[v++] = 65, g[v++] = 80, g[v++] = 69, g[v++] = 50, g[v++] = 46, g[v++] = 48, g[v++] = 3, g[v++] = 1, g[v++] = 255 & o2, g[v++] = o2 >> 8 & 255, g[v++] = 0;
            }
            var _ = false;
            this.addFrame = function(e4, t4, r3, o3, n2, s3) {
              if (true === _ && (--v, _ = false), s3 = void 0 === s3 ? {} : s3, e4 < 0 || t4 < 0 || 65535 < e4 || 65535 < t4)
                throw new Error("x/y invalid.");
              if (r3 <= 0 || o3 <= 0 || 65535 < r3 || 65535 < o3)
                throw new Error("Width/Height invalid.");
              if (n2.length < r3 * o3)
                throw new Error("Not enough pixels for the frame size.");
              var i2 = true, a2 = s3.palette;
              if (null == a2 && (i2 = false, a2 = b), null == a2)
                throw new Error("Must supply either a local or global palette.");
              for (var l2 = j(a2), u2 = 0; l2 >>= 1; )
                ++u2;
              var l2 = 1 << u2, c = void 0 === s3.delay ? 0 : s3.delay, d = void 0 === s3.disposal ? 0 : s3.disposal;
              if (d < 0 || 3 < d)
                throw new Error("Disposal out of range.");
              var f = false, h = 0;
              if (void 0 !== s3.transparent && null !== s3.transparent && (f = true, (h = s3.transparent) < 0 || l2 <= h))
                throw new Error("Transparent color index.");
              if (0 === d && !f && 0 === c || (g[v++] = 33, g[v++] = 249, g[v++] = 4, g[v++] = d << 2 | (true === f ? 1 : 0), g[v++] = 255 & c, g[v++] = c >> 8 & 255, g[v++] = h, g[v++] = 0), g[v++] = 44, g[v++] = 255 & e4, g[v++] = e4 >> 8 & 255, g[v++] = 255 & t4, g[v++] = t4 >> 8 & 255, g[v++] = 255 & r3, g[v++] = r3 >> 8 & 255, g[v++] = 255 & o3, g[v++] = o3 >> 8 & 255, g[v++] = true === i2 ? 128 | u2 - 1 : 0, true === i2)
                for (var p = 0, m = a2.length; p < m; ++p) {
                  var y = a2[p];
                  g[v++] = y >> 16 & 255, g[v++] = y >> 8 & 255, g[v++] = 255 & y;
                }
              return v = function(t5, r4, e5, o4) {
                t5[r4++] = e5;
                var n3 = r4++, s4 = 1 << e5, i3 = s4 - 1, a3 = 1 + s4, l3 = 1 + a3, u3 = e5 + 1, c2 = 0, d2 = 0;
                function f2(e6) {
                  for (; e6 <= c2; )
                    t5[r4++] = 255 & d2, d2 >>= 8, c2 -= 8, r4 === n3 + 256 && (t5[n3] = 255, n3 = r4++);
                }
                function h2(e6) {
                  d2 |= e6 << c2, c2 += u3, f2(8);
                }
                var p2 = o4[0] & i3, m2 = {};
                h2(s4);
                for (var y2 = 1, g2 = o4.length; y2 < g2; ++y2) {
                  var v2 = o4[y2] & i3, b2 = p2 << 8 | v2, j2 = m2[b2];
                  if (void 0 === j2) {
                    for (d2 |= p2 << c2, c2 += u3; 8 <= c2; )
                      t5[r4++] = 255 & d2, d2 >>= 8, c2 -= 8, r4 === n3 + 256 && (t5[n3] = 255, n3 = r4++);
                    4096 === l3 ? (h2(s4), l3 = 1 + a3, u3 = e5 + 1, m2 = {}) : (1 << u3 <= l3 && ++u3, m2[b2] = l3++), p2 = v2;
                  } else
                    p2 = j2;
                }
                h2(p2), h2(a3), f2(1), n3 + 1 === r4 ? t5[n3] = 0 : (t5[n3] = r4 - n3 - 1, t5[r4++] = 0);
                return r4;
              }(g, v, u2 < 2 ? 2 : u2, n2);
            }, this.end = function() {
              return false === _ && (g[v++] = 59, _ = true), v;
            }, this.getOutputBuffer = function() {
              return g;
            }, this.setOutputBuffer = function(e4) {
              g = e4;
            }, this.getOutputBufferPosition = function() {
              return v;
            }, this.setOutputBufferPosition = function(e4) {
              v = e4;
            };
          }
          function E(e3, t3, r2, o2) {
            for (var n = e3[t3++], s2 = 1 << n, i = 1 + s2, a = 1 + i, l = n + 1, u = (1 << l) - 1, c = 0, d = 0, f = 0, h = e3[t3++], p = new Int32Array(4096), m = null; ; ) {
              for (; c < 16 && 0 !== h; )
                d |= e3[t3++] << c, c += 8, 1 === h ? h = e3[t3++] : --h;
              if (c < l)
                break;
              var y = d & u;
              if (d >>= l, c -= l, y == s2)
                a = 1 + i, u = (1 << (l = n + 1)) - 1, m = null;
              else {
                if (y == i)
                  break;
                for (var g = y < a ? y : m, v = 0, b = g; s2 < b; )
                  b = p[b] >> 8, ++v;
                var j = b;
                if (o2 < f + v + (g !== y ? 1 : 0))
                  return void console.log("Warning, gif stream longer than expected.");
                r2[f++] = j;
                var _ = f += v;
                for (g !== y && (r2[f++] = j), b = g; v--; )
                  b = p[b], r2[--_] = 255 & b, b >>= 8;
                null !== m && a < 4096 && (p[a++] = m << 8 | j, u + 1 <= a && l < 12 && (++l, u = u << 1 | 1)), m = y;
              }
            }
            f !== o2 && console.log("Warning, gif stream shorter than expected.");
          }
          try {
            r.GifWriter = o, r.GifReader = function(b) {
              var e3 = 0;
              if (71 !== b[e3++] || 73 !== b[e3++] || 70 !== b[e3++] || 56 !== b[e3++] || 56 != (b[e3++] + 1 & 253) || 97 !== b[e3++])
                throw new Error("Invalid GIF 87a/89a header.");
              var j = b[e3++] | b[e3++] << 8, t3 = b[e3++] | b[e3++] << 8, r2 = b[e3++], o2 = 1 << 1 + (7 & r2), n = (b[e3++], b[e3++], null), s2 = null, i = (r2 >> 7 && (n = e3, e3 += 3 * (s2 = o2)), true), a = [], l = 0, u = null, c = 0, d = null;
              for (this.width = j, this.height = t3; i && e3 < b.length; )
                switch (b[e3++]) {
                  case 33:
                    switch (b[e3++]) {
                      case 255:
                        if (11 !== b[e3] || 78 == b[e3 + 1] && 69 == b[e3 + 2] && 84 == b[e3 + 3] && 83 == b[e3 + 4] && 67 == b[e3 + 5] && 65 == b[e3 + 6] && 80 == b[e3 + 7] && 69 == b[e3 + 8] && 50 == b[e3 + 9] && 46 == b[e3 + 10] && 48 == b[e3 + 11] && 3 == b[e3 + 12] && 1 == b[e3 + 13] && 0 == b[e3 + 16])
                          e3 += 14, d = b[e3++] | b[e3++] << 8, e3++;
                        else
                          for (e3 += 12; ; ) {
                            if (!(0 <= (h = b[e3++])))
                              throw Error("Invalid block size");
                            if (0 === h)
                              break;
                            e3 += h;
                          }
                        break;
                      case 249:
                        if (4 !== b[e3++] || 0 !== b[e3 + 4])
                          throw new Error("Invalid graphics extension block.");
                        var f = b[e3++], l = b[e3++] | b[e3++] << 8, u = b[e3++];
                        0 == (1 & f) && (u = null), c = f >> 2 & 7, e3++;
                        break;
                      case 254:
                        for (; ; ) {
                          if (!(0 <= (h = b[e3++])))
                            throw Error("Invalid block size");
                          if (0 === h)
                            break;
                          e3 += h;
                        }
                        break;
                      default:
                        throw new Error("Unknown graphic control label: 0x" + b[e3 - 1].toString(16));
                    }
                    break;
                  case 44:
                    var h, p = b[e3++] | b[e3++] << 8, m = b[e3++] | b[e3++] << 8, y = b[e3++] | b[e3++] << 8, g = b[e3++] | b[e3++] << 8, v = b[e3++], _ = v >> 6 & 1, x = 1 << 1 + (7 & v), w = n, S = s2, M = false, v = (v >> 7 && (M = true, w = e3, e3 += 3 * (S = x)), e3);
                    for (e3++; ; ) {
                      if (!(0 <= (h = b[e3++])))
                        throw Error("Invalid block size");
                      if (0 === h)
                        break;
                      e3 += h;
                    }
                    a.push({ x: p, y: m, width: y, height: g, has_local_palette: M, palette_offset: w, palette_size: S, data_offset: v, data_length: e3 - v, transparent_index: u, interlaced: !!_, delay: l, disposal: c });
                    break;
                  case 59:
                    i = false;
                    break;
                  default:
                    throw new Error("Unknown gif block: 0x" + b[e3 - 1].toString(16));
                }
              this.numFrames = function() {
                return a.length;
              }, this.loopCount = function() {
                return d;
              }, this.frameInfo = function(e4) {
                if (e4 < 0 || e4 >= a.length)
                  throw new Error("Frame index out of range.");
                return a[e4];
              }, this.decodeAndBlitFrameBGRA = function(e4, t4) {
                for (var e4 = this.frameInfo(e4), r3 = e4.width * e4.height, o3 = new Uint8Array(r3), n2 = (E(b, e4.data_offset, o3, r3), e4.palette_offset), s3 = e4.transparent_index, i2 = (null === s3 && (s3 = 256), e4.width), a2 = j - i2, l2 = i2, u2 = 4 * (e4.y * j + e4.x), c2 = 4 * ((e4.y + e4.height) * j + e4.x), d2 = u2, f2 = 4 * a2, h2 = (true === e4.interlaced && (f2 += 4 * j * 7), 8), p2 = 0, m2 = o3.length; p2 < m2; ++p2) {
                  var y2, g2, v2 = o3[p2];
                  0 === l2 && (l2 = i2, c2 <= (d2 += f2) && (f2 = 4 * a2 + 4 * j * (h2 - 1), d2 = u2 + (i2 + a2) * (h2 << 1), h2 >>= 1)), v2 === s3 ? d2 += 4 : (y2 = b[n2 + 3 * v2], g2 = b[n2 + 3 * v2 + 1], v2 = b[n2 + 3 * v2 + 2], t4[d2++] = v2, t4[d2++] = g2, t4[d2++] = y2, t4[d2++] = 255), --l2;
                }
              }, this.decodeAndBlitFrameRGBA = function(e4, t4) {
                for (var e4 = this.frameInfo(e4), r3 = e4.width * e4.height, o3 = new Uint8Array(r3), n2 = (E(b, e4.data_offset, o3, r3), e4.palette_offset), s3 = e4.transparent_index, i2 = (null === s3 && (s3 = 256), e4.width), a2 = j - i2, l2 = i2, u2 = 4 * (e4.y * j + e4.x), c2 = 4 * ((e4.y + e4.height) * j + e4.x), d2 = u2, f2 = 4 * a2, h2 = (true === e4.interlaced && (f2 += 4 * j * 7), 8), p2 = 0, m2 = o3.length; p2 < m2; ++p2) {
                  var y2, g2, v2 = o3[p2];
                  0 === l2 && (l2 = i2, c2 <= (d2 += f2) && (f2 = 4 * a2 + 4 * j * (h2 - 1), d2 = u2 + (i2 + a2) * (h2 << 1), h2 >>= 1)), v2 === s3 ? d2 += 4 : (y2 = b[n2 + 3 * v2], g2 = b[n2 + 3 * v2 + 1], v2 = b[n2 + 3 * v2 + 2], t4[d2++] = y2, t4[d2++] = g2, t4[d2++] = v2, t4[d2++] = 255), --l2;
                }
              };
            };
          } catch (e3) {
          }
        }, {}], 241: [function(Ar, r, o) {
          !function(kr) {
            var e2, t2;
            e2 = this, t2 = function(j) {
              "use strict";
              function I(e4) {
                if (null == this)
                  throw TypeError();
                var t4, r3 = String(this), o3 = r3.length, e4 = e4 ? Number(e4) : 0;
                if (!((e4 = e4 != e4 ? 0 : e4) < 0 || o3 <= e4))
                  return 55296 <= (t4 = r3.charCodeAt(e4)) && t4 <= 56319 && e4 + 1 < o3 && 56320 <= (o3 = r3.charCodeAt(e4 + 1)) && o3 <= 57343 ? 1024 * (t4 - 55296) + o3 - 56320 + 65536 : t4;
              }
              String.prototype.codePointAt || ((U = function() {
                try {
                  var e4 = {}, t4 = Object.defineProperty, r3 = t4(e4, e4, e4) && t4;
                } catch (e5) {
                }
                return r3;
              }()) ? U(String.prototype, "codePointAt", { value: I, configurable: true, writable: true }) : String.prototype.codePointAt = I);
              var U, N = 0, F = -3;
              function B() {
                this.table = new Uint16Array(16), this.trans = new Uint16Array(288);
              }
              function G(e4, t4) {
                this.source = e4, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = t4, this.destLen = 0, this.ltree = new B(), this.dtree = new B();
              }
              var V = new B(), z = new B(), H = new Uint8Array(30), W = new Uint16Array(30), q = new Uint8Array(30), X = new Uint16Array(30), Y = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Z = new B(), v = new Uint8Array(320);
              function Q(e4, t4, r3, o3) {
                for (var n2, s3 = 0; s3 < r3; ++s3)
                  e4[s3] = 0;
                for (s3 = 0; s3 < 30 - r3; ++s3)
                  e4[s3 + r3] = s3 / r3 | 0;
                for (n2 = o3, s3 = 0; s3 < 30; ++s3)
                  t4[s3] = n2, n2 += 1 << e4[s3];
              }
              var K = new Uint16Array(16);
              function J(e4, t4, r3, o3) {
                for (var n2, s3 = 0; s3 < 16; ++s3)
                  e4.table[s3] = 0;
                for (s3 = 0; s3 < o3; ++s3)
                  e4.table[t4[r3 + s3]]++;
                for (s3 = n2 = e4.table[0] = 0; s3 < 16; ++s3)
                  K[s3] = n2, n2 += e4.table[s3];
                for (s3 = 0; s3 < o3; ++s3)
                  t4[r3 + s3] && (e4.trans[K[t4[r3 + s3]]++] = s3);
              }
              function b(e4, t4, r3) {
                if (!t4)
                  return r3;
                for (; e4.bitcount < 24; )
                  e4.tag |= e4.source[e4.sourceIndex++] << e4.bitcount, e4.bitcount += 8;
                var o3 = e4.tag & 65535 >>> 16 - t4;
                return e4.tag >>>= t4, e4.bitcount -= t4, o3 + r3;
              }
              function $(e4, t4) {
                for (; e4.bitcount < 24; )
                  e4.tag |= e4.source[e4.sourceIndex++] << e4.bitcount, e4.bitcount += 8;
                for (var r3 = 0, o3 = 0, n2 = 0, s3 = e4.tag; o3 = 2 * o3 + (1 & s3), s3 >>>= 1, r3 += t4.table[++n2], 0 <= (o3 -= t4.table[n2]); )
                  ;
                return e4.tag = s3, e4.bitcount -= n2, t4.trans[r3 + o3];
              }
              function ee(e4, t4, r3) {
                for (; ; ) {
                  var o3 = $(e4, t4);
                  if (256 === o3)
                    return N;
                  if (o3 < 256)
                    e4.dest[e4.destLen++] = o3;
                  else
                    for (var n2, s3 = b(e4, H[o3 -= 257], W[o3]), o3 = $(e4, r3), i2 = n2 = e4.destLen - b(e4, q[o3], X[o3]); i2 < n2 + s3; ++i2)
                      e4.dest[e4.destLen++] = e4.dest[i2];
                }
              }
              for (var e3 = V, te = z, t3 = 0; t3 < 7; ++t3)
                e3.table[t3] = 0;
              for (e3.table[7] = 24, e3.table[8] = 152, e3.table[9] = 112, t3 = 0; t3 < 24; ++t3)
                e3.trans[t3] = 256 + t3;
              for (t3 = 0; t3 < 144; ++t3)
                e3.trans[24 + t3] = t3;
              for (t3 = 0; t3 < 8; ++t3)
                e3.trans[168 + t3] = 280 + t3;
              for (t3 = 0; t3 < 112; ++t3)
                e3.trans[176 + t3] = 144 + t3;
              for (t3 = 0; t3 < 5; ++t3)
                te.table[t3] = 0;
              for (te.table[5] = 32, t3 = 0; t3 < 32; ++t3)
                te.trans[t3] = t3;
              Q(H, W, 4, 3), Q(q, X, 2, 1), H[28] = 0, W[28] = 258;
              var re = function(e4, t4) {
                var r3, o3, n2, s3 = new G(e4, t4);
                do {
                  switch (n2 = void 0, (o3 = s3).bitcount-- || (o3.tag = o3.source[o3.sourceIndex++], o3.bitcount = 7), n2 = 1 & o3.tag, o3.tag >>>= 1, o3 = n2, b(s3, 2, 0)) {
                    case 0:
                      r3 = function(e5) {
                        for (var t5, r4; 8 < e5.bitcount; )
                          e5.sourceIndex--, e5.bitcount -= 8;
                        if ((t5 = 256 * e5.source[e5.sourceIndex + 1] + e5.source[e5.sourceIndex]) !== (65535 & ~(256 * e5.source[e5.sourceIndex + 3] + e5.source[e5.sourceIndex + 2])))
                          return F;
                        for (e5.sourceIndex += 4, r4 = t5; r4; --r4)
                          e5.dest[e5.destLen++] = e5.source[e5.sourceIndex++];
                        return e5.bitcount = 0, N;
                      }(s3);
                      break;
                    case 1:
                      r3 = ee(s3, V, z);
                      break;
                    case 2:
                      y2 = m2 = p2 = g2 = i2 = h2 = f2 = d2 = c2 = u2 = l2 = a2 = void 0;
                      for (var i2, a2 = s3, l2 = s3.ltree, u2 = s3.dtree, c2 = b(a2, 5, 257), d2 = b(a2, 5, 1), f2 = b(a2, 4, 4), h2 = 0; h2 < 19; ++h2)
                        v[h2] = 0;
                      for (h2 = 0; h2 < f2; ++h2) {
                        var p2 = b(a2, 3, 0);
                        v[Y[h2]] = p2;
                      }
                      for (J(Z, v, 0, 19), i2 = 0; i2 < c2 + d2; ) {
                        var m2 = $(a2, Z);
                        switch (m2) {
                          case 16:
                            for (var y2 = v[i2 - 1], g2 = b(a2, 2, 3); g2; --g2)
                              v[i2++] = y2;
                            break;
                          case 17:
                            for (g2 = b(a2, 3, 3); g2; --g2)
                              v[i2++] = 0;
                            break;
                          case 18:
                            for (g2 = b(a2, 7, 11); g2; --g2)
                              v[i2++] = 0;
                            break;
                          default:
                            v[i2++] = m2;
                        }
                      }
                      J(l2, v, 0, c2), J(u2, v, c2, d2), r3 = ee(s3, s3.ltree, s3.dtree);
                      break;
                    default:
                      r3 = F;
                  }
                  if (r3 !== N)
                    throw new Error("Data error");
                } while (!o3);
                return s3.destLen < s3.dest.length ? "function" == typeof s3.dest.slice ? s3.dest.slice(0, s3.destLen) : s3.dest.subarray(0, s3.destLen) : s3.dest;
              };
              function g(e4, t4, r3, o3, n2) {
                return Math.pow(1 - n2, 3) * e4 + 3 * Math.pow(1 - n2, 2) * n2 * t4 + 3 * (1 - n2) * Math.pow(n2, 2) * r3 + Math.pow(n2, 3) * o3;
              }
              function a() {
                this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN;
              }
              function f() {
                this.commands = [], this.fill = "black", this.stroke = null, this.strokeWidth = 1;
              }
              function oe(e4) {
                throw new Error(e4);
              }
              function ne(e4, t4) {
                e4 || oe(t4);
              }
              a.prototype.isEmpty = function() {
                return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
              }, a.prototype.addPoint = function(e4, t4) {
                "number" == typeof e4 && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e4, this.x2 = e4), e4 < this.x1 && (this.x1 = e4), e4 > this.x2 && (this.x2 = e4)), "number" == typeof t4 && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t4, this.y2 = t4), t4 < this.y1 && (this.y1 = t4), t4 > this.y2 && (this.y2 = t4));
              }, a.prototype.addX = function(e4) {
                this.addPoint(e4, null);
              }, a.prototype.addY = function(e4) {
                this.addPoint(null, e4);
              }, a.prototype.addBezier = function(e4, t4, r3, o3, n2, s3, i2, a2) {
                var l2 = [e4, t4], u2 = [r3, o3], c2 = [n2, s3], d2 = [i2, a2];
                this.addPoint(e4, t4), this.addPoint(i2, a2);
                for (var f2 = 0; f2 <= 1; f2++) {
                  var h2, p2 = 6 * l2[f2] - 12 * u2[f2] + 6 * c2[f2], m2 = -3 * l2[f2] + 9 * u2[f2] - 9 * c2[f2] + 3 * d2[f2], y2 = 3 * u2[f2] - 3 * l2[f2];
                  0 == m2 ? 0 == p2 || 0 < (h2 = -y2 / p2) && h2 < 1 && (0 === f2 && this.addX(g(l2[f2], u2[f2], c2[f2], d2[f2], h2)), 1 === f2 && this.addY(g(l2[f2], u2[f2], c2[f2], d2[f2], h2))) : (h2 = Math.pow(p2, 2) - 4 * y2 * m2) < 0 || (0 < (y2 = (-p2 + Math.sqrt(h2)) / (2 * m2)) && y2 < 1 && (0 === f2 && this.addX(g(l2[f2], u2[f2], c2[f2], d2[f2], y2)), 1 === f2 && this.addY(g(l2[f2], u2[f2], c2[f2], d2[f2], y2))), 0 < (y2 = (-p2 - Math.sqrt(h2)) / (2 * m2)) && y2 < 1 && (0 === f2 && this.addX(g(l2[f2], u2[f2], c2[f2], d2[f2], y2)), 1 === f2 && this.addY(g(l2[f2], u2[f2], c2[f2], d2[f2], y2))));
                }
              }, a.prototype.addQuad = function(e4, t4, r3, o3, n2, s3) {
                r3 = e4 + 2 / 3 * (r3 - e4), o3 = t4 + 2 / 3 * (o3 - t4);
                this.addBezier(e4, t4, r3, o3, r3 + 1 / 3 * (n2 - e4), o3 + 1 / 3 * (s3 - t4), n2, s3);
              }, f.prototype.moveTo = function(e4, t4) {
                this.commands.push({ type: "M", x: e4, y: t4 });
              }, f.prototype.lineTo = function(e4, t4) {
                this.commands.push({ type: "L", x: e4, y: t4 });
              }, f.prototype.curveTo = f.prototype.bezierCurveTo = function(e4, t4, r3, o3, n2, s3) {
                this.commands.push({ type: "C", x1: e4, y1: t4, x2: r3, y2: o3, x: n2, y: s3 });
              }, f.prototype.quadTo = f.prototype.quadraticCurveTo = function(e4, t4, r3, o3) {
                this.commands.push({ type: "Q", x1: e4, y1: t4, x: r3, y: o3 });
              }, f.prototype.close = f.prototype.closePath = function() {
                this.commands.push({ type: "Z" });
              }, f.prototype.extend = function(e4) {
                var t4;
                if (e4.commands)
                  e4 = e4.commands;
                else if (e4 instanceof a)
                  return t4 = e4, this.moveTo(t4.x1, t4.y1), this.lineTo(t4.x2, t4.y1), this.lineTo(t4.x2, t4.y2), this.lineTo(t4.x1, t4.y2), void this.close();
                Array.prototype.push.apply(this.commands, e4);
              }, f.prototype.getBoundingBox = function() {
                for (var e4 = new a(), t4 = 0, r3 = 0, o3 = 0, n2 = 0, s3 = 0; s3 < this.commands.length; s3++) {
                  var i2 = this.commands[s3];
                  switch (i2.type) {
                    case "M":
                      e4.addPoint(i2.x, i2.y), t4 = o3 = i2.x, r3 = n2 = i2.y;
                      break;
                    case "L":
                      e4.addPoint(i2.x, i2.y), o3 = i2.x, n2 = i2.y;
                      break;
                    case "Q":
                      e4.addQuad(o3, n2, i2.x1, i2.y1, i2.x, i2.y), o3 = i2.x, n2 = i2.y;
                      break;
                    case "C":
                      e4.addBezier(o3, n2, i2.x1, i2.y1, i2.x2, i2.y2, i2.x, i2.y), o3 = i2.x, n2 = i2.y;
                      break;
                    case "Z":
                      o3 = t4, n2 = r3;
                      break;
                    default:
                      throw new Error("Unexpected path command " + i2.type);
                  }
                }
                return e4.isEmpty() && e4.addPoint(0, 0), e4;
              }, f.prototype.draw = function(e4) {
                e4.beginPath();
                for (var t4 = 0; t4 < this.commands.length; t4 += 1) {
                  var r3 = this.commands[t4];
                  "M" === r3.type ? e4.moveTo(r3.x, r3.y) : "L" === r3.type ? e4.lineTo(r3.x, r3.y) : "C" === r3.type ? e4.bezierCurveTo(r3.x1, r3.y1, r3.x2, r3.y2, r3.x, r3.y) : "Q" === r3.type ? e4.quadraticCurveTo(r3.x1, r3.y1, r3.x, r3.y) : "Z" === r3.type && e4.closePath();
                }
                this.fill && (e4.fillStyle = this.fill, e4.fill()), this.stroke && (e4.strokeStyle = this.stroke, e4.lineWidth = this.strokeWidth, e4.stroke());
              }, f.prototype.toPathData = function(n2) {
                function e4() {
                  for (var e5 = arguments, t5 = "", r4 = 0; r4 < arguments.length; r4 += 1) {
                    var o4 = e5[r4];
                    0 <= o4 && 0 < r4 && (t5 += " "), t5 += (o4 = o4, Math.round(o4) === o4 ? "" + Math.round(o4) : o4.toFixed(n2));
                  }
                  return t5;
                }
                n2 = void 0 !== n2 ? n2 : 2;
                for (var t4 = "", r3 = 0; r3 < this.commands.length; r3 += 1) {
                  var o3 = this.commands[r3];
                  "M" === o3.type ? t4 += "M" + e4(o3.x, o3.y) : "L" === o3.type ? t4 += "L" + e4(o3.x, o3.y) : "C" === o3.type ? t4 += "C" + e4(o3.x1, o3.y1, o3.x2, o3.y2, o3.x, o3.y) : "Q" === o3.type ? t4 += "Q" + e4(o3.x1, o3.y1, o3.x, o3.y) : "Z" === o3.type && (t4 += "Z");
                }
                return t4;
              }, f.prototype.toSVG = function(e4) {
                var t4 = (t4 = '<path d="') + this.toPathData(e4) + '"';
                return this.fill && "black" !== this.fill && (null === this.fill ? t4 += ' fill="none"' : t4 += ' fill="' + this.fill + '"'), this.stroke && (t4 += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), t4 += "/>";
              }, f.prototype.toDOMElement = function(e4) {
                var e4 = this.toPathData(e4), t4 = document.createElementNS("http://www.w3.org/2000/svg", "path");
                return t4.setAttribute("d", e4), t4;
              };
              var P = { fail: oe, argument: ne, assert: ne }, m = {}, w = {}, l = {};
              function r2(e4) {
                return function() {
                  return e4;
                };
              }
              w.BYTE = function(e4) {
                return P.argument(0 <= e4 && e4 <= 255, "Byte value should be between 0 and 255."), [e4];
              }, l.BYTE = r2(1), w.CHAR = function(e4) {
                return [e4.charCodeAt(0)];
              }, l.CHAR = r2(1), w.CHARARRAY = function(e4) {
                for (var t4 = [], r3 = 0; r3 < e4.length; r3 += 1)
                  t4[r3] = e4.charCodeAt(r3);
                return t4;
              }, l.CHARARRAY = function(e4) {
                return e4.length;
              }, w.USHORT = function(e4) {
                return [e4 >> 8 & 255, 255 & e4];
              }, l.USHORT = r2(2), w.SHORT = function(e4) {
                return [(e4 = 32768 <= e4 ? -(65536 - e4) : e4) >> 8 & 255, 255 & e4];
              }, l.SHORT = r2(2), w.UINT24 = function(e4) {
                return [e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
              }, l.UINT24 = r2(3), w.ULONG = function(e4) {
                return [e4 >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
              }, l.ULONG = r2(4), w.LONG = function(e4) {
                return [(e4 = 2147483648 <= e4 ? -(4294967296 - e4) : e4) >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
              }, l.LONG = r2(4), w.FIXED = w.ULONG, l.FIXED = l.ULONG, w.FWORD = w.SHORT, l.FWORD = l.SHORT, w.UFWORD = w.USHORT, l.UFWORD = l.USHORT, w.LONGDATETIME = function(e4) {
                return [0, 0, 0, 0, e4 >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
              }, l.LONGDATETIME = r2(8), w.TAG = function(e4) {
                return P.argument(4 === e4.length, "Tag should be exactly 4 ASCII characters."), [e4.charCodeAt(0), e4.charCodeAt(1), e4.charCodeAt(2), e4.charCodeAt(3)];
              }, l.TAG = r2(4), w.Card8 = w.BYTE, l.Card8 = l.BYTE, w.Card16 = w.USHORT, l.Card16 = l.USHORT, w.OffSize = w.BYTE, l.OffSize = l.BYTE, w.SID = w.USHORT, l.SID = l.USHORT, w.NUMBER = function(e4) {
                return -107 <= e4 && e4 <= 107 ? [e4 + 139] : 108 <= e4 && e4 <= 1131 ? [247 + ((e4 -= 108) >> 8), 255 & e4] : -1131 <= e4 && e4 <= -108 ? [251 + ((e4 = -e4 - 108) >> 8), 255 & e4] : -32768 <= e4 && e4 <= 32767 ? w.NUMBER16(e4) : w.NUMBER32(e4);
              }, l.NUMBER = function(e4) {
                return w.NUMBER(e4).length;
              }, w.NUMBER16 = function(e4) {
                return [28, e4 >> 8 & 255, 255 & e4];
              }, l.NUMBER16 = r2(3), w.NUMBER32 = function(e4) {
                return [29, e4 >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
              }, l.NUMBER32 = r2(5), w.REAL = function(e4) {
                for (var t4 = e4.toString(), r3 = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(t4), o3 = (r3 && (r3 = parseFloat("1e" + ((r3[2] ? +r3[2] : 0) + r3[1].length)), t4 = (Math.round(e4 * r3) / r3).toString()), ""), n2 = 0, s3 = t4.length; n2 < s3; n2 += 1) {
                  var i2 = t4[n2];
                  o3 += "e" === i2 ? "-" === t4[++n2] ? "c" : "b" : "." === i2 ? "a" : "-" === i2 ? "e" : i2;
                }
                for (var a2 = [30], l2 = 0, u2 = (o3 += 1 & o3.length ? "f" : "ff").length; l2 < u2; l2 += 2)
                  a2.push(parseInt(o3.substr(l2, 2), 16));
                return a2;
              }, l.REAL = function(e4) {
                return w.REAL(e4).length;
              }, w.NAME = w.CHARARRAY, l.NAME = l.CHARARRAY, w.STRING = w.CHARARRAY, l.STRING = l.CHARARRAY, m.UTF8 = function(e4, t4, r3) {
                for (var o3 = [], n2 = r3, s3 = 0; s3 < n2; s3++, t4 += 1)
                  o3[s3] = e4.getUint8(t4);
                return String.fromCharCode.apply(null, o3);
              }, m.UTF16 = function(e4, t4, r3) {
                for (var o3 = [], n2 = r3 / 2, s3 = 0; s3 < n2; s3++, t4 += 2)
                  o3[s3] = e4.getUint16(t4);
                return String.fromCharCode.apply(null, o3);
              }, w.UTF16 = function(e4) {
                for (var t4 = [], r3 = 0; r3 < e4.length; r3 += 1) {
                  var o3 = e4.charCodeAt(r3);
                  t4[t4.length] = o3 >> 8 & 255, t4[t4.length] = 255 & o3;
                }
                return t4;
              }, l.UTF16 = function(e4) {
                return 2 * e4.length;
              };
              var se, ie = { "x-mac-croatian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7", "x-mac-cyrillic": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E", "x-mac-gaelic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83", "x-mac-greek": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD", "x-mac-icelandic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-inuit": "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026\xA0\u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142", "x-mac-ce": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7", macintosh: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-romanian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-turkish": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7" }, ae = (m.MACSTRING = function(e4, t4, r3, o3) {
                var n2 = ie[o3];
                if (void 0 !== n2) {
                  for (var s3 = "", i2 = 0; i2 < r3; i2++) {
                    var a2 = e4.getUint8(t4 + i2);
                    s3 += a2 <= 127 ? String.fromCharCode(a2) : n2[127 & a2];
                  }
                  return s3;
                }
              }, "function" == typeof WeakMap && /* @__PURE__ */ new WeakMap());
              function le(e4) {
                return -128 <= e4 && e4 <= 127;
              }
              w.MACSTRING = function(e4, t4) {
                var r3 = function(e5) {
                  if (!se)
                    for (var t5 in se = {}, ie)
                      se[t5] = new String(t5);
                  var r4 = se[e5];
                  if (void 0 !== r4) {
                    if (ae) {
                      var o4 = ae.get(r4);
                      if (void 0 !== o4)
                        return o4;
                    }
                    var n3 = ie[e5];
                    if (void 0 !== n3) {
                      for (var s4 = {}, i2 = 0; i2 < n3.length; i2++)
                        s4[n3.charCodeAt(i2)] = i2 + 128;
                      return ae && ae.set(r4, s4), s4;
                    }
                  }
                }(t4);
                if (void 0 !== r3) {
                  for (var o3 = [], n2 = 0; n2 < e4.length; n2++) {
                    var s3 = e4.charCodeAt(n2);
                    if (128 <= s3 && void 0 === (s3 = r3[s3]))
                      return;
                    o3[n2] = s3;
                  }
                  return o3;
                }
              }, l.MACSTRING = function(e4, t4) {
                e4 = w.MACSTRING(e4, t4);
                return void 0 !== e4 ? e4.length : 0;
              }, w.VARDELTAS = function(e4) {
                for (var t4 = 0, r3 = []; t4 < e4.length; )
                  var o3 = e4[t4], t4 = (0 === o3 ? function(e5, t5, r4) {
                    for (var o4 = 0, n2 = e5.length; t5 < n2 && o4 < 64 && 0 === e5[t5]; )
                      ++t5, ++o4;
                    return r4.push(128 | o4 - 1), t5;
                  } : -128 <= o3 && o3 <= 127 ? function(e5, t5, r4) {
                    for (var o4 = 0, n2 = e5.length, s3 = t5; s3 < n2 && o4 < 64; ) {
                      var i2 = e5[s3];
                      if (!le(i2))
                        break;
                      if (0 === i2 && s3 + 1 < n2 && 0 === e5[s3 + 1])
                        break;
                      ++s3, ++o4;
                    }
                    r4.push(o4 - 1);
                    for (var a2 = t5; a2 < s3; ++a2)
                      r4.push(e5[a2] + 256 & 255);
                    return s3;
                  } : function(e5, t5, r4) {
                    for (var o4 = 0, n2 = e5.length, s3 = t5; s3 < n2 && o4 < 64; ) {
                      var i2 = e5[s3];
                      if (0 === i2)
                        break;
                      if (le(i2) && s3 + 1 < n2 && le(e5[s3 + 1]))
                        break;
                      ++s3, ++o4;
                    }
                    r4.push(64 | o4 - 1);
                    for (var a2 = t5; a2 < s3; ++a2) {
                      var l2 = e5[a2];
                      r4.push(l2 + 65536 >> 8 & 255, l2 + 256 & 255);
                    }
                    return s3;
                  })(e4, t4, r3);
                return r3;
              }, w.INDEX = function(e4) {
                for (var t4 = 1, r3 = [t4], o3 = [], n2 = 0; n2 < e4.length; n2 += 1) {
                  var s3 = w.OBJECT(e4[n2]);
                  Array.prototype.push.apply(o3, s3), t4 += s3.length, r3.push(t4);
                }
                if (0 === o3.length)
                  return [0, 0];
                for (var i2 = [], a2 = 1 + Math.floor(Math.log(t4) / Math.log(2)) / 8 | 0, l2 = [void 0, w.BYTE, w.USHORT, w.UINT24, w.ULONG][a2], u2 = 0; u2 < r3.length; u2 += 1) {
                  var c2 = l2(r3[u2]);
                  Array.prototype.push.apply(i2, c2);
                }
                return Array.prototype.concat(w.Card16(e4.length), w.OffSize(a2), i2, o3);
              }, l.INDEX = function(e4) {
                return w.INDEX(e4).length;
              }, w.DICT = function(e4) {
                for (var t4 = [], r3 = Object.keys(e4), o3 = r3.length, n2 = 0; n2 < o3; n2 += 1) {
                  var s3 = parseInt(r3[n2], 0), i2 = e4[s3];
                  t4 = (t4 = t4.concat(w.OPERAND(i2.value, i2.type))).concat(w.OPERATOR(s3));
                }
                return t4;
              }, l.DICT = function(e4) {
                return w.DICT(e4).length;
              }, w.OPERATOR = function(e4) {
                return e4 < 1200 ? [e4] : [12, e4 - 1200];
              }, w.OPERAND = function(e4, t4) {
                var r3 = [];
                if (Array.isArray(t4))
                  for (var o3 = 0; o3 < t4.length; o3 += 1)
                    P.argument(e4.length === t4.length, "Not enough arguments given for type" + t4), r3 = r3.concat(w.OPERAND(e4[o3], t4[o3]));
                else if ("SID" === t4)
                  r3 = r3.concat(w.NUMBER(e4));
                else if ("offset" === t4)
                  r3 = r3.concat(w.NUMBER32(e4));
                else if ("number" === t4)
                  r3 = r3.concat(w.NUMBER(e4));
                else {
                  if ("real" !== t4)
                    throw new Error("Unknown operand type " + t4);
                  r3 = r3.concat(w.REAL(e4));
                }
                return r3;
              }, w.OP = w.BYTE, l.OP = l.BYTE;
              var ue = "function" == typeof WeakMap && /* @__PURE__ */ new WeakMap();
              function n(e4, t4, r3) {
                for (var o3 = 0; o3 < t4.length; o3 += 1) {
                  var n2 = t4[o3];
                  this[n2.name] = n2.value;
                }
                if (this.tableName = e4, this.fields = t4, r3)
                  for (var s3 = Object.keys(r3), i2 = 0; i2 < s3.length; i2 += 1) {
                    var a2 = s3[i2], l2 = r3[a2];
                    void 0 !== this[a2] && (this[a2] = l2);
                  }
              }
              function ce(e4, t4, r3) {
                void 0 === r3 && (r3 = t4.length);
                var o3 = new Array(t4.length + 1);
                o3[0] = { name: e4 + "Count", type: "USHORT", value: r3 };
                for (var n2 = 0; n2 < t4.length; n2++)
                  o3[n2 + 1] = { name: e4 + n2, type: "USHORT", value: t4[n2] };
                return o3;
              }
              function de(e4, t4, r3) {
                var o3 = t4.length, n2 = new Array(o3 + 1);
                n2[0] = { name: e4 + "Count", type: "USHORT", value: o3 };
                for (var s3 = 0; s3 < o3; s3++)
                  n2[s3 + 1] = { name: e4 + s3, type: "TABLE", value: r3(t4[s3], s3) };
                return n2;
              }
              function fe(e4, t4, r3) {
                var o3 = t4.length, n2 = [];
                n2[0] = { name: e4 + "Count", type: "USHORT", value: o3 };
                for (var s3 = 0; s3 < o3; s3++)
                  n2 = n2.concat(r3(t4[s3], s3));
                return n2;
              }
              function he(e4) {
                1 === e4.format ? n.call(this, "coverageTable", [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(ce("glyph", e4.glyphs))) : P.assert(false, "Can't create coverage table format 2 yet.");
              }
              function pe(e4) {
                n.call(this, "scriptListTable", fe("scriptRecord", e4, function(e5, t4) {
                  var r3 = e5.script, o3 = r3.defaultLangSys;
                  return P.assert(!!o3, "Unable to write GSUB: script " + e5.tag + " has no default language system."), [{ name: "scriptTag" + t4, type: "TAG", value: e5.tag }, { name: "script" + t4, type: "TABLE", value: new n("scriptTable", [{ name: "defaultLangSys", type: "TABLE", value: new n("defaultLangSys", [{ name: "lookupOrder", type: "USHORT", value: 0 }, { name: "reqFeatureIndex", type: "USHORT", value: o3.reqFeatureIndex }].concat(ce("featureIndex", o3.featureIndexes))) }].concat(fe("langSys", r3.langSysRecords, function(e6, t5) {
                    var r4 = e6.langSys;
                    return [{ name: "langSysTag" + t5, type: "TAG", value: e6.tag }, { name: "langSys" + t5, type: "TABLE", value: new n("langSys", [{ name: "lookupOrder", type: "USHORT", value: 0 }, { name: "reqFeatureIndex", type: "USHORT", value: r4.reqFeatureIndex }].concat(ce("featureIndex", r4.featureIndexes))) }];
                  }))) }];
                }));
              }
              function me(e4) {
                n.call(this, "featureListTable", fe("featureRecord", e4, function(e5, t4) {
                  var r3 = e5.feature;
                  return [{ name: "featureTag" + t4, type: "TAG", value: e5.tag }, { name: "feature" + t4, type: "TABLE", value: new n("featureTable", [{ name: "featureParams", type: "USHORT", value: r3.featureParams }].concat(ce("lookupListIndex", r3.lookupListIndexes))) }];
                }));
              }
              function ye(e4, r3) {
                n.call(this, "lookupListTable", de("lookup", e4, function(e5) {
                  var t4 = r3[e5.lookupType];
                  return P.assert(!!t4, "Unable to write GSUB lookup type " + e5.lookupType + " tables."), new n("lookupTable", [{ name: "lookupType", type: "USHORT", value: e5.lookupType }, { name: "lookupFlag", type: "USHORT", value: e5.lookupFlag }].concat(de("subtable", e5.subtables, t4)));
                }));
              }
              w.CHARSTRING = function(e4) {
                if (ue) {
                  var t4 = ue.get(e4);
                  if (void 0 !== t4)
                    return t4;
                }
                for (var r3 = [], o3 = e4.length, n2 = 0; n2 < o3; n2 += 1)
                  var s3 = e4[n2], r3 = r3.concat(w[s3.type](s3.value));
                return ue && ue.set(e4, r3), r3;
              }, l.CHARSTRING = function(e4) {
                return w.CHARSTRING(e4).length;
              }, w.OBJECT = function(e4) {
                var t4 = w[e4.type];
                return P.argument(void 0 !== t4, "No encoding function for type " + e4.type), t4(e4.value);
              }, l.OBJECT = function(e4) {
                var t4 = l[e4.type];
                return P.argument(void 0 !== t4, "No sizeOf function for type " + e4.type), t4(e4.value);
              }, w.TABLE = function(e4) {
                for (var t4 = [], r3 = e4.fields.length, o3 = [], n2 = [], s3 = 0; s3 < r3; s3 += 1) {
                  var i2 = e4.fields[s3], a2 = w[i2.type], l2 = (P.argument(void 0 !== a2, "No encoding function for field type " + i2.type + " (" + i2.name + ")"), e4[i2.name]), a2 = a2(l2 = void 0 === l2 ? i2.value : l2);
                  "TABLE" === i2.type ? (n2.push(t4.length), t4 = t4.concat([0, 0]), o3.push(a2)) : t4 = t4.concat(a2);
                }
                for (var u2 = 0; u2 < o3.length; u2 += 1) {
                  var c2 = n2[u2], d2 = t4.length;
                  P.argument(d2 < 65536, "Table " + e4.tableName + " too big."), t4[c2] = d2 >> 8, t4[c2 + 1] = 255 & d2, t4 = t4.concat(o3[u2]);
                }
                return t4;
              }, l.TABLE = function(e4) {
                for (var t4 = 0, r3 = e4.fields.length, o3 = 0; o3 < r3; o3 += 1) {
                  var n2 = e4.fields[o3], s3 = l[n2.type], i2 = (P.argument(void 0 !== s3, "No sizeOf function for field type " + n2.type + " (" + n2.name + ")"), e4[n2.name]);
                  t4 += s3(i2 = void 0 === i2 ? n2.value : i2), "TABLE" === n2.type && (t4 += 2);
                }
                return t4;
              }, w.RECORD = w.TABLE, l.RECORD = l.TABLE, w.LITERAL = function(e4) {
                return e4;
              }, l.LITERAL = function(e4) {
                return e4.length;
              }, n.prototype.encode = function() {
                return w.TABLE(this);
              }, n.prototype.sizeOf = function() {
                return l.TABLE(this);
              };
              var S = { Table: n, Record: n, Coverage: (he.prototype = Object.create(n.prototype)).constructor = he, ScriptList: (pe.prototype = Object.create(n.prototype)).constructor = pe, FeatureList: (me.prototype = Object.create(n.prototype)).constructor = me, LookupList: (ye.prototype = Object.create(n.prototype)).constructor = ye, ushortList: ce, tableList: de, recordList: fe };
              function ge(e4, t4) {
                return e4.getUint8(t4);
              }
              function ve(e4, t4) {
                return e4.getUint16(t4, false);
              }
              function be(e4, t4) {
                return e4.getUint32(t4, false);
              }
              function je(e4, t4) {
                return e4.getInt16(t4, false) + e4.getUint16(t4 + 2, false) / 65535;
              }
              var _e = { byte: 1, uShort: 2, short: 2, uLong: 4, fixed: 4, longDateTime: 8, tag: 4 };
              function u(e4, t4) {
                this.data = e4, this.offset = t4, this.relativeOffset = 0;
              }
              u.prototype.parseByte = function() {
                var e4 = this.data.getUint8(this.offset + this.relativeOffset);
                return this.relativeOffset += 1, e4;
              }, u.prototype.parseChar = function() {
                var e4 = this.data.getInt8(this.offset + this.relativeOffset);
                return this.relativeOffset += 1, e4;
              }, u.prototype.parseCard8 = u.prototype.parseByte, u.prototype.parseCard16 = u.prototype.parseUShort = function() {
                var e4 = this.data.getUint16(this.offset + this.relativeOffset);
                return this.relativeOffset += 2, e4;
              }, u.prototype.parseSID = u.prototype.parseUShort, u.prototype.parseOffset16 = u.prototype.parseUShort, u.prototype.parseShort = function() {
                var e4 = this.data.getInt16(this.offset + this.relativeOffset);
                return this.relativeOffset += 2, e4;
              }, u.prototype.parseF2Dot14 = function() {
                var e4 = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
                return this.relativeOffset += 2, e4;
              }, u.prototype.parseOffset32 = u.prototype.parseULong = function() {
                var e4 = be(this.data, this.offset + this.relativeOffset);
                return this.relativeOffset += 4, e4;
              }, u.prototype.parseFixed = function() {
                var e4 = je(this.data, this.offset + this.relativeOffset);
                return this.relativeOffset += 4, e4;
              }, u.prototype.parseString = function(e4) {
                var t4 = this.data, r3 = this.offset + this.relativeOffset, o3 = "";
                this.relativeOffset += e4;
                for (var n2 = 0; n2 < e4; n2++)
                  o3 += String.fromCharCode(t4.getUint8(r3 + n2));
                return o3;
              }, u.prototype.parseTag = function() {
                return this.parseString(4);
              }, u.prototype.parseLongDateTime = function() {
                var e4 = be(this.data, this.offset + this.relativeOffset + 4);
                return e4 -= 2082844800, this.relativeOffset += 8, e4;
              }, u.prototype.parseVersion = function(e4) {
                var t4 = ve(this.data, this.offset + this.relativeOffset), r3 = ve(this.data, this.offset + this.relativeOffset + 2);
                return this.relativeOffset += 4, t4 + r3 / (e4 = void 0 === e4 ? 4096 : e4) / 10;
              }, u.prototype.skip = function(e4, t4) {
                this.relativeOffset += _e[e4] * (t4 = void 0 === t4 ? 1 : t4);
              }, u.prototype.parseULongList = function(e4) {
                void 0 === e4 && (e4 = this.parseULong());
                for (var t4 = new Array(e4), r3 = this.data, o3 = this.offset + this.relativeOffset, n2 = 0; n2 < e4; n2++)
                  t4[n2] = r3.getUint32(o3), o3 += 4;
                return this.relativeOffset += 4 * e4, t4;
              }, u.prototype.parseOffset16List = u.prototype.parseUShortList = function(e4) {
                void 0 === e4 && (e4 = this.parseUShort());
                for (var t4 = new Array(e4), r3 = this.data, o3 = this.offset + this.relativeOffset, n2 = 0; n2 < e4; n2++)
                  t4[n2] = r3.getUint16(o3), o3 += 2;
                return this.relativeOffset += 2 * e4, t4;
              }, u.prototype.parseShortList = function(e4) {
                for (var t4 = new Array(e4), r3 = this.data, o3 = this.offset + this.relativeOffset, n2 = 0; n2 < e4; n2++)
                  t4[n2] = r3.getInt16(o3), o3 += 2;
                return this.relativeOffset += 2 * e4, t4;
              }, u.prototype.parseByteList = function(e4) {
                for (var t4 = new Array(e4), r3 = this.data, o3 = this.offset + this.relativeOffset, n2 = 0; n2 < e4; n2++)
                  t4[n2] = r3.getUint8(o3++);
                return this.relativeOffset += e4, t4;
              }, u.prototype.parseList = function(e4, t4) {
                t4 || (t4 = e4, e4 = this.parseUShort());
                for (var r3 = new Array(e4), o3 = 0; o3 < e4; o3++)
                  r3[o3] = t4.call(this);
                return r3;
              }, u.prototype.parseList32 = function(e4, t4) {
                t4 || (t4 = e4, e4 = this.parseULong());
                for (var r3 = new Array(e4), o3 = 0; o3 < e4; o3++)
                  r3[o3] = t4.call(this);
                return r3;
              }, u.prototype.parseRecordList = function(e4, t4) {
                t4 || (t4 = e4, e4 = this.parseUShort());
                for (var r3 = new Array(e4), o3 = Object.keys(t4), n2 = 0; n2 < e4; n2++) {
                  for (var s3 = {}, i2 = 0; i2 < o3.length; i2++) {
                    var a2 = o3[i2], l2 = t4[a2];
                    s3[a2] = l2.call(this);
                  }
                  r3[n2] = s3;
                }
                return r3;
              }, u.prototype.parseRecordList32 = function(e4, t4) {
                t4 || (t4 = e4, e4 = this.parseULong());
                for (var r3 = new Array(e4), o3 = Object.keys(t4), n2 = 0; n2 < e4; n2++) {
                  for (var s3 = {}, i2 = 0; i2 < o3.length; i2++) {
                    var a2 = o3[i2], l2 = t4[a2];
                    s3[a2] = l2.call(this);
                  }
                  r3[n2] = s3;
                }
                return r3;
              }, u.prototype.parseStruct = function(e4) {
                if ("function" == typeof e4)
                  return e4.call(this);
                for (var t4 = Object.keys(e4), r3 = {}, o3 = 0; o3 < t4.length; o3++) {
                  var n2 = t4[o3], s3 = e4[n2];
                  r3[n2] = s3.call(this);
                }
                return r3;
              }, u.prototype.parseValueRecord = function(e4) {
                var t4;
                if (0 !== (e4 = void 0 === e4 ? this.parseUShort() : e4))
                  return t4 = {}, 1 & e4 && (t4.xPlacement = this.parseShort()), 2 & e4 && (t4.yPlacement = this.parseShort()), 4 & e4 && (t4.xAdvance = this.parseShort()), 8 & e4 && (t4.yAdvance = this.parseShort()), 16 & e4 && (t4.xPlaDevice = void 0, this.parseShort()), 32 & e4 && (t4.yPlaDevice = void 0, this.parseShort()), 64 & e4 && (t4.xAdvDevice = void 0, this.parseShort()), 128 & e4 && (t4.yAdvDevice = void 0, this.parseShort()), t4;
              }, u.prototype.parseValueRecordList = function() {
                for (var e4 = this.parseUShort(), t4 = this.parseUShort(), r3 = new Array(t4), o3 = 0; o3 < t4; o3++)
                  r3[o3] = this.parseValueRecord(e4);
                return r3;
              }, u.prototype.parsePointer = function(e4) {
                var t4 = this.parseOffset16();
                if (0 < t4)
                  return new u(this.data, this.offset + t4).parseStruct(e4);
              }, u.prototype.parsePointer32 = function(e4) {
                var t4 = this.parseOffset32();
                if (0 < t4)
                  return new u(this.data, this.offset + t4).parseStruct(e4);
              }, u.prototype.parseListOfLists = function(e4) {
                for (var t4 = this.parseOffset16List(), r3 = t4.length, o3 = this.relativeOffset, n2 = new Array(r3), s3 = 0; s3 < r3; s3++) {
                  var i2 = t4[s3];
                  if (0 === i2)
                    n2[s3] = void 0;
                  else if (this.relativeOffset = i2, e4) {
                    for (var a2 = this.parseOffset16List(), l2 = new Array(a2.length), u2 = 0; u2 < a2.length; u2++)
                      this.relativeOffset = i2 + a2[u2], l2[u2] = e4.call(this);
                    n2[s3] = l2;
                  } else
                    n2[s3] = this.parseUShortList();
                }
                return this.relativeOffset = o3, n2;
              }, u.prototype.parseCoverage = function() {
                var e4 = this.offset + this.relativeOffset, t4 = this.parseUShort(), r3 = this.parseUShort();
                if (1 === t4)
                  return { format: 1, glyphs: this.parseUShortList(r3) };
                if (2 !== t4)
                  throw new Error("0x" + e4.toString(16) + ": Coverage format must be 1 or 2.");
                for (var o3 = new Array(r3), n2 = 0; n2 < r3; n2++)
                  o3[n2] = { start: this.parseUShort(), end: this.parseUShort(), index: this.parseUShort() };
                return { format: 2, ranges: o3 };
              }, u.prototype.parseClassDef = function() {
                var e4 = this.offset + this.relativeOffset, t4 = this.parseUShort();
                if (1 === t4)
                  return { format: 1, startGlyph: this.parseUShort(), classes: this.parseUShortList() };
                if (2 === t4)
                  return { format: 2, ranges: this.parseRecordList({ start: u.uShort, end: u.uShort, classId: u.uShort }) };
                throw new Error("0x" + e4.toString(16) + ": ClassDef format must be 1 or 2.");
              }, u.list = function(e4, t4) {
                return function() {
                  return this.parseList(e4, t4);
                };
              }, u.list32 = function(e4, t4) {
                return function() {
                  return this.parseList32(e4, t4);
                };
              }, u.recordList = function(e4, t4) {
                return function() {
                  return this.parseRecordList(e4, t4);
                };
              }, u.recordList32 = function(e4, t4) {
                return function() {
                  return this.parseRecordList32(e4, t4);
                };
              }, u.pointer = function(e4) {
                return function() {
                  return this.parsePointer(e4);
                };
              }, u.pointer32 = function(e4) {
                return function() {
                  return this.parsePointer32(e4);
                };
              }, u.tag = u.prototype.parseTag, u.byte = u.prototype.parseByte, u.uShort = u.offset16 = u.prototype.parseUShort, u.uShortList = u.prototype.parseUShortList, u.uLong = u.offset32 = u.prototype.parseULong, u.uLongList = u.prototype.parseULongList, u.struct = u.prototype.parseStruct, u.coverage = u.prototype.parseCoverage, u.classDef = u.prototype.parseClassDef;
              var xe = { reserved: u.uShort, reqFeatureIndex: u.uShort, featureIndexes: u.uShortList }, R = (u.prototype.parseScriptList = function() {
                return this.parsePointer(u.recordList({ tag: u.tag, script: u.pointer({ defaultLangSys: u.pointer(xe), langSysRecords: u.recordList({ tag: u.tag, langSys: u.pointer(xe) }) }) })) || [];
              }, u.prototype.parseFeatureList = function() {
                return this.parsePointer(u.recordList({ tag: u.tag, feature: u.pointer({ featureParams: u.offset16, lookupListIndexes: u.uShortList }) })) || [];
              }, u.prototype.parseLookupList = function(o3) {
                return this.parsePointer(u.list(u.pointer(function() {
                  var e4 = this.parseUShort(), t4 = (P.argument(1 <= e4 && e4 <= 9, "GPOS/GSUB lookup type " + e4 + " unknown."), this.parseUShort()), r3 = 16 & t4;
                  return { lookupType: e4, lookupFlag: t4, subtables: this.parseList(u.pointer(o3[e4])), markFilteringSet: r3 ? this.parseUShort() : void 0 };
                }))) || [];
              }, u.prototype.parseFeatureVariationsList = function() {
                return this.parsePointer32(function() {
                  var e4 = this.parseUShort(), t4 = this.parseUShort();
                  return P.argument(1 === e4 && t4 < 1, "GPOS/GSUB feature variations table unknown."), this.parseRecordList32({ conditionSetOffset: u.offset32, featureTableSubstitutionOffset: u.offset32 });
                }) || [];
              }, { getByte: ge, getCard8: ge, getUShort: ve, getCard16: ve, getShort: function(e4, t4) {
                return e4.getInt16(t4, false);
              }, getULong: be, getFixed: je, getTag: function(e4, t4) {
                for (var r3 = "", o3 = t4; o3 < t4 + 4; o3 += 1)
                  r3 += String.fromCharCode(e4.getInt8(o3));
                return r3;
              }, getOffset: function(e4, t4, r3) {
                for (var o3 = 0, n2 = 0; n2 < r3; n2 += 1)
                  o3 = (o3 <<= 8) + e4.getUint8(t4 + n2);
                return o3;
              }, getBytes: function(e4, t4, r3) {
                for (var o3 = [], n2 = t4; n2 < r3; n2 += 1)
                  o3.push(e4.getUint8(n2));
                return o3;
              }, bytesToString: function(e4) {
                for (var t4 = "", r3 = 0; r3 < e4.length; r3 += 1)
                  t4 += String.fromCharCode(e4[r3]);
                return t4;
              }, Parser: u });
              var we = { parse: function(e4, t4) {
                for (var r3 = {}, o3 = (r3.version = R.getUShort(e4, t4), P.argument(0 === r3.version, "cmap table version should be 0."), r3.numTables = R.getUShort(e4, t4 + 2), -1), n2 = r3.numTables - 1; 0 <= n2; --n2) {
                  var s3 = R.getUShort(e4, t4 + 4 + 8 * n2), i2 = R.getUShort(e4, t4 + 4 + 8 * n2 + 2);
                  if (3 === s3 && (0 === i2 || 1 === i2 || 10 === i2) || 0 === s3 && (0 === i2 || 1 === i2 || 2 === i2 || 3 === i2 || 4 === i2)) {
                    o3 = R.getULong(e4, t4 + 4 + 8 * n2 + 4);
                    break;
                  }
                }
                if (-1 === o3)
                  throw new Error("No valid cmap sub-tables found.");
                var a2 = new R.Parser(e4, t4 + o3);
                if (r3.format = a2.parseUShort(), 12 === r3.format) {
                  var l2, u2 = r3, c2 = a2;
                  c2.parseUShort(), u2.length = c2.parseULong(), u2.language = c2.parseULong(), u2.groupCount = l2 = c2.parseULong(), u2.glyphIndexMap = {};
                  for (var d2 = 0; d2 < l2; d2 += 1)
                    for (var f2 = c2.parseULong(), h2 = c2.parseULong(), p2 = c2.parseULong(), m2 = f2; m2 <= h2; m2 += 1)
                      u2.glyphIndexMap[m2] = p2, p2++;
                } else {
                  if (4 !== r3.format)
                    throw new Error("Only format 4 and 12 cmap tables are supported (found format " + r3.format + ").");
                  var y2 = r3, g2 = e4, v2 = t4, b2 = o3;
                  y2.length = a2.parseUShort(), y2.language = a2.parseUShort(), y2.segCount = j2 = a2.parseUShort() >> 1, a2.skip("uShort", 3), y2.glyphIndexMap = {};
                  for (var j2, _2 = new R.Parser(g2, v2 + b2 + 14), x2 = new R.Parser(g2, v2 + b2 + 16 + 2 * j2), w2 = new R.Parser(g2, v2 + b2 + 16 + 4 * j2), S2 = new R.Parser(g2, v2 + b2 + 16 + 6 * j2), M2 = v2 + b2 + 16 + 8 * j2, E2 = 0; E2 < j2 - 1; E2 += 1)
                    for (var T2 = void 0, C2 = _2.parseUShort(), O2 = x2.parseUShort(), L2 = w2.parseShort(), k2 = S2.parseUShort(), A2 = O2; A2 <= C2; A2 += 1)
                      0 !== k2 ? (M2 = (M2 = S2.offset + S2.relativeOffset - 2) + k2 + 2 * (A2 - O2), 0 !== (T2 = R.getUShort(g2, M2)) && (T2 = T2 + L2 & 65535)) : T2 = A2 + L2 & 65535, y2.glyphIndexMap[A2] = T2;
                }
                return r3;
              }, make: function(e4) {
                for (var t4 = true, r3 = e4.length - 1; 0 < r3; --r3)
                  if (65535 < e4.get(r3).unicode) {
                    console.log("Adding CMAP format 12 (needed!)"), t4 = false;
                    break;
                  }
                var o3, n2, s3 = [{ name: "version", type: "USHORT", value: 0 }, { name: "numTables", type: "USHORT", value: t4 ? 1 : 2 }, { name: "platformID", type: "USHORT", value: 3 }, { name: "encodingID", type: "USHORT", value: 1 }, { name: "offset", type: "ULONG", value: t4 ? 12 : 20 }], i2 = (s3 = (s3 = t4 ? s3 : s3.concat([{ name: "cmap12PlatformID", type: "USHORT", value: 3 }, { name: "cmap12EncodingID", type: "USHORT", value: 10 }, { name: "cmap12Offset", type: "ULONG", value: 0 }])).concat([{ name: "format", type: "USHORT", value: 4 }, { name: "cmap4Length", type: "USHORT", value: 0 }, { name: "language", type: "USHORT", value: 0 }, { name: "segCountX2", type: "USHORT", value: 0 }, { name: "searchRange", type: "USHORT", value: 0 }, { name: "entrySelector", type: "USHORT", value: 0 }, { name: "rangeShift", type: "USHORT", value: 0 }]), new S.Table("cmap", s3));
                for (i2.segments = [], r3 = 0; r3 < e4.length; r3 += 1) {
                  for (var a2 = e4.get(r3), l2 = 0; l2 < a2.unicodes.length; l2 += 1)
                    o3 = a2.unicodes[l2], n2 = r3, i2.segments.push({ end: o3, start: o3, delta: -(o3 - n2), offset: 0, glyphIndex: n2 });
                  i2.segments = i2.segments.sort(function(e5, t5) {
                    return e5.start - t5.start;
                  });
                }
                i2.segments.push({ end: 65535, start: 65535, delta: 1, offset: 0 });
                var u2 = i2.segments.length, c2 = 0, d2 = [], f2 = [], h2 = [], p2 = [], m2 = [], y2 = [];
                for (r3 = 0; r3 < u2; r3 += 1) {
                  var g2 = i2.segments[r3];
                  g2.end <= 65535 && g2.start <= 65535 ? (d2 = d2.concat({ name: "end_" + r3, type: "USHORT", value: g2.end }), f2 = f2.concat({ name: "start_" + r3, type: "USHORT", value: g2.start }), h2 = h2.concat({ name: "idDelta_" + r3, type: "SHORT", value: g2.delta }), p2 = p2.concat({ name: "idRangeOffset_" + r3, type: "USHORT", value: g2.offset }), void 0 !== g2.glyphId && (m2 = m2.concat({ name: "glyph_" + r3, type: "USHORT", value: g2.glyphId }))) : c2 += 1, t4 || void 0 === g2.glyphIndex || (y2 = (y2 = (y2 = y2.concat({ name: "cmap12Start_" + r3, type: "ULONG", value: g2.start })).concat({ name: "cmap12End_" + r3, type: "ULONG", value: g2.end })).concat({ name: "cmap12Glyph_" + r3, type: "ULONG", value: g2.glyphIndex }));
                }
                return i2.segCountX2 = 2 * (u2 - c2), i2.searchRange = 2 * Math.pow(2, Math.floor(Math.log(u2 - c2) / Math.log(2))), i2.entrySelector = Math.log(i2.searchRange / 2) / Math.log(2), i2.rangeShift = i2.segCountX2 - i2.searchRange, i2.fields = i2.fields.concat(d2), i2.fields.push({ name: "reservedPad", type: "USHORT", value: 0 }), i2.fields = i2.fields.concat(f2), i2.fields = i2.fields.concat(h2), i2.fields = i2.fields.concat(p2), i2.fields = i2.fields.concat(m2), i2.cmap4Length = 14 + 2 * d2.length + 2 + 2 * f2.length + 2 * h2.length + 2 * p2.length + 2 * m2.length, t4 || (s3 = 16 + 4 * y2.length, i2.cmap12Offset = 20 + i2.cmap4Length, i2.fields = i2.fields.concat([{ name: "cmap12Format", type: "USHORT", value: 12 }, { name: "cmap12Reserved", type: "USHORT", value: 0 }, { name: "cmap12Length", type: "ULONG", value: s3 }, { name: "cmap12Language", type: "ULONG", value: 0 }, { name: "cmap12nGroups", type: "ULONG", value: y2.length / 3 }]), i2.fields = i2.fields.concat(y2)), i2;
              } }, Se = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "266 ff", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"], Me = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"], Ee = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], c = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
              function Te(e4) {
                this.font = e4;
              }
              function Ce(e4) {
                this.cmap = e4;
              }
              function Oe(e4, t4) {
                this.encoding = e4, this.charset = t4;
              }
              function Le(e4) {
                switch (e4.version) {
                  case 1:
                    this.names = c.slice();
                    break;
                  case 2:
                    this.names = new Array(e4.numberOfGlyphs);
                    for (var t4 = 0; t4 < e4.numberOfGlyphs; t4++)
                      e4.glyphNameIndex[t4] < c.length ? this.names[t4] = c[e4.glyphNameIndex[t4]] : this.names[t4] = e4.names[e4.glyphNameIndex[t4] - c.length];
                    break;
                  case 2.5:
                    this.names = new Array(e4.numberOfGlyphs);
                    for (var r3 = 0; r3 < e4.numberOfGlyphs; r3++)
                      this.names[r3] = c[r3 + e4.glyphNameIndex[r3]];
                    break;
                  default:
                    this.names = [];
                }
              }
              Te.prototype.charToGlyphIndex = function(e4) {
                var t4 = e4.codePointAt(0), r3 = this.font.glyphs;
                if (r3) {
                  for (var o3 = 0; o3 < r3.length; o3 += 1)
                    for (var n2 = r3.get(o3), s3 = 0; s3 < n2.unicodes.length; s3 += 1)
                      if (n2.unicodes[s3] === t4)
                        return o3;
                }
                return null;
              }, Ce.prototype.charToGlyphIndex = function(e4) {
                return this.cmap.glyphIndexMap[e4.codePointAt(0)] || 0;
              }, Oe.prototype.charToGlyphIndex = function(e4) {
                e4 = e4.codePointAt(0), e4 = this.encoding[e4];
                return this.charset.indexOf(e4);
              }, Le.prototype.nameToGlyphIndex = function(e4) {
                return this.names.indexOf(e4);
              }, Le.prototype.glyphIndexToName = function(e4) {
                return this.names[e4];
              };
              var d = { line: function(e4, t4, r3, o3, n2) {
                e4.beginPath(), e4.moveTo(t4, r3), e4.lineTo(o3, n2), e4.stroke();
              } };
              function h(e4) {
                this.bindConstructorValues(e4);
              }
              function ke(t4, e4, r3) {
                Object.defineProperty(t4, e4, { get: function() {
                  return t4.path, t4[r3];
                }, set: function(e5) {
                  t4[r3] = e5;
                }, enumerable: true, configurable: true });
              }
              function Ae(e4, t4) {
                if (this.font = e4, this.glyphs = {}, Array.isArray(t4))
                  for (var r3 = 0; r3 < t4.length; r3++)
                    this.glyphs[r3] = t4[r3];
                this.length = t4 && t4.length || 0;
              }
              h.prototype.bindConstructorValues = function(e4) {
                var t4;
                this.index = e4.index || 0, this.name = e4.name || null, this.unicode = e4.unicode || void 0, this.unicodes = e4.unicodes || void 0 !== e4.unicode ? [e4.unicode] : [], e4.xMin && (this.xMin = e4.xMin), e4.yMin && (this.yMin = e4.yMin), e4.xMax && (this.xMax = e4.xMax), e4.yMax && (this.yMax = e4.yMax), e4.advanceWidth && (this.advanceWidth = e4.advanceWidth), Object.defineProperty(this, "path", (e4 = e4.path, t4 = e4 || new f(), { configurable: true, get: function() {
                  return t4 = "function" == typeof t4 ? t4() : t4;
                }, set: function(e5) {
                  t4 = e5;
                } }));
              }, h.prototype.addUnicode = function(e4) {
                0 === this.unicodes.length && (this.unicode = e4), this.unicodes.push(e4);
              }, h.prototype.getBoundingBox = function() {
                return this.path.getBoundingBox();
              }, h.prototype.getPath = function(e4, t4, r3, o3, n2) {
                e4 = void 0 !== e4 ? e4 : 0, t4 = void 0 !== t4 ? t4 : 0, r3 = void 0 !== r3 ? r3 : 72;
                for (var s3, i2, a2 = (o3 = o3 || {}).xScale, l2 = o3.yScale, u2 = ((s3 = o3.hinting && n2 && n2.hinting ? this.path && n2.hinting.exec(this, r3) : s3) ? (i2 = n2.hinting.getCommands(s3), e4 = Math.round(e4), t4 = Math.round(t4), a2 = l2 = 1) : (i2 = this.path.commands, o3 = 1 / this.path.unitsPerEm * r3, void 0 === a2 && (a2 = o3), void 0 === l2 && (l2 = o3)), new f()), c2 = 0; c2 < i2.length; c2 += 1) {
                  var d2 = i2[c2];
                  "M" === d2.type ? u2.moveTo(e4 + d2.x * a2, t4 + -d2.y * l2) : "L" === d2.type ? u2.lineTo(e4 + d2.x * a2, t4 + -d2.y * l2) : "Q" === d2.type ? u2.quadraticCurveTo(e4 + d2.x1 * a2, t4 + -d2.y1 * l2, e4 + d2.x * a2, t4 + -d2.y * l2) : "C" === d2.type ? u2.curveTo(e4 + d2.x1 * a2, t4 + -d2.y1 * l2, e4 + d2.x2 * a2, t4 + -d2.y2 * l2, e4 + d2.x * a2, t4 + -d2.y * l2) : "Z" === d2.type && u2.closePath();
                }
                return u2;
              }, h.prototype.getContours = function() {
                if (void 0 === this.points)
                  return [];
                for (var e4 = [], t4 = [], r3 = 0; r3 < this.points.length; r3 += 1) {
                  var o3 = this.points[r3];
                  t4.push(o3), o3.lastPointOfContour && (e4.push(t4), t4 = []);
                }
                return P.argument(0 === t4.length, "There are still points left in the current contour."), e4;
              }, h.prototype.getMetrics = function() {
                for (var e4 = this.path.commands, t4 = [], r3 = [], o3 = 0; o3 < e4.length; o3 += 1) {
                  var n2 = e4[o3];
                  "Z" !== n2.type && (t4.push(n2.x), r3.push(n2.y)), "Q" !== n2.type && "C" !== n2.type || (t4.push(n2.x1), r3.push(n2.y1)), "C" === n2.type && (t4.push(n2.x2), r3.push(n2.y2));
                }
                var s3 = { xMin: Math.min.apply(null, t4), yMin: Math.min.apply(null, r3), xMax: Math.max.apply(null, t4), yMax: Math.max.apply(null, r3), leftSideBearing: this.leftSideBearing };
                return isFinite(s3.xMin) || (s3.xMin = 0), isFinite(s3.xMax) || (s3.xMax = this.advanceWidth), isFinite(s3.yMin) || (s3.yMin = 0), isFinite(s3.yMax) || (s3.yMax = 0), s3.rightSideBearing = this.advanceWidth - s3.leftSideBearing - (s3.xMax - s3.xMin), s3;
              }, h.prototype.draw = function(e4, t4, r3, o3, n2) {
                this.getPath(t4, r3, o3, n2).draw(e4);
              }, h.prototype.drawPoints = function(i2, e4, t4, r3) {
                function o3(e5, t5, r4, o4) {
                  var n3 = 2 * Math.PI;
                  i2.beginPath();
                  for (var s4 = 0; s4 < e5.length; s4 += 1)
                    i2.moveTo(t5 + e5[s4].x * o4, r4 + e5[s4].y * o4), i2.arc(t5 + e5[s4].x * o4, r4 + e5[s4].y * o4, 2, 0, n3, false);
                  i2.closePath(), i2.fill();
                }
                e4 = void 0 !== e4 ? e4 : 0, t4 = void 0 !== t4 ? t4 : 0;
                for (var r3 = 1 / this.path.unitsPerEm * (r3 = void 0 !== r3 ? r3 : 24), n2 = [], s3 = [], a2 = this.path, l2 = 0; l2 < a2.commands.length; l2 += 1) {
                  var u2 = a2.commands[l2];
                  void 0 !== u2.x && n2.push({ x: u2.x, y: -u2.y }), void 0 !== u2.x1 && s3.push({ x: u2.x1, y: -u2.y1 }), void 0 !== u2.x2 && s3.push({ x: u2.x2, y: -u2.y2 });
                }
                i2.fillStyle = "blue", o3(n2, e4, t4, r3), i2.fillStyle = "red", o3(s3, e4, t4, r3);
              }, h.prototype.drawMetrics = function(e4, t4, r3, o3) {
                t4 = void 0 !== t4 ? t4 : 0, r3 = void 0 !== r3 ? r3 : 0, o3 = 1 / this.path.unitsPerEm * (o3 = void 0 !== o3 ? o3 : 24), e4.lineWidth = 1, e4.strokeStyle = "black", d.line(e4, t4, -1e4, t4, 1e4), d.line(e4, -1e4, r3, 1e4, r3);
                var n2 = this.xMin || 0, s3 = this.yMin || 0, i2 = this.xMax || 0, a2 = this.yMax || 0, l2 = this.advanceWidth || 0;
                e4.strokeStyle = "blue", d.line(e4, t4 + n2 * o3, -1e4, t4 + n2 * o3, 1e4), d.line(e4, t4 + i2 * o3, -1e4, t4 + i2 * o3, 1e4), d.line(e4, -1e4, r3 + -s3 * o3, 1e4, r3 + -s3 * o3), d.line(e4, -1e4, r3 + -a2 * o3, 1e4, r3 + -a2 * o3), e4.strokeStyle = "green", d.line(e4, t4 + l2 * o3, -1e4, t4 + l2 * o3, 1e4);
              }, Ae.prototype.get = function(e4) {
                return "function" == typeof this.glyphs[e4] && (this.glyphs[e4] = this.glyphs[e4]()), this.glyphs[e4];
              }, Ae.prototype.push = function(e4, t4) {
                this.glyphs[e4] = t4, this.length++;
              };
              var p = { GlyphSet: Ae, glyphLoader: function(e4, t4) {
                return new h({ index: t4, font: e4 });
              }, ttfGlyphLoader: function(r3, e4, o3, n2, s3, i2) {
                return function() {
                  var t4 = new h({ index: e4, font: r3 });
                  return t4.path = function() {
                    o3(t4, n2, s3);
                    var e5 = i2(r3.glyphs, t4);
                    return e5.unitsPerEm = r3.unitsPerEm, e5;
                  }, ke(t4, "xMin", "_xMin"), ke(t4, "xMax", "_xMax"), ke(t4, "yMin", "_yMin"), ke(t4, "yMax", "_yMax"), t4;
                };
              }, cffGlyphLoader: function(r3, e4, o3, n2) {
                return function() {
                  var t4 = new h({ index: e4, font: r3 });
                  return t4.path = function() {
                    var e5 = o3(r3, t4, n2);
                    return e5.unitsPerEm = r3.unitsPerEm, e5;
                  }, t4;
                };
              } };
              function Pe(e4) {
                e4 = e4.length < 1240 ? 107 : e4.length < 33900 ? 1131 : 32768;
                return e4;
              }
              function y(e4, t4, r3) {
                var o3, n2 = [], s3 = [], i2 = R.getCard16(e4, t4);
                if (0 !== i2) {
                  for (var a2 = R.getByte(e4, t4 + 2), l2 = t4 + (i2 + 1) * a2 + 2, u2 = t4 + 3, c2 = 0; c2 < i2 + 1; c2 += 1)
                    n2.push(R.getOffset(e4, u2, a2)), u2 += a2;
                  o3 = l2 + n2[i2];
                } else
                  o3 = t4 + 2;
                for (var d2 = 0; d2 < n2.length - 1; d2 += 1) {
                  var f2 = R.getBytes(e4, l2 + n2[d2], l2 + n2[d2 + 1]);
                  r3 && (f2 = r3(f2)), s3.push(f2);
                }
                return { objects: s3, startOffset: t4, endOffset: o3 };
              }
              function Re(e4, t4) {
                if (28 === t4)
                  return e4.parseByte() << 8 | e4.parseByte();
                if (29 === t4)
                  return e4.parseByte() << 24 | e4.parseByte() << 16 | e4.parseByte() << 8 | e4.parseByte();
                if (30 === t4) {
                  for (var r3 = e4, o3 = "", n2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"]; ; ) {
                    var s3 = r3.parseByte(), i2 = s3 >> 4, s3 = 15 & s3;
                    if (15 == i2)
                      break;
                    if (o3 += n2[i2], 15 == s3)
                      break;
                    o3 += n2[s3];
                  }
                  return parseFloat(o3);
                }
                if (32 <= t4 && t4 <= 246)
                  return t4 - 139;
                if (247 <= t4 && t4 <= 250)
                  return 256 * (t4 - 247) + e4.parseByte() + 108;
                if (251 <= t4 && t4 <= 254)
                  return 256 * -(t4 - 251) - e4.parseByte() - 108;
                throw new Error("Invalid b0 " + t4);
              }
              function De(e4, t4, r3) {
                var o3 = new R.Parser(e4, t4 = void 0 !== t4 ? t4 : 0), n2 = [], s3 = [];
                for (r3 = void 0 !== r3 ? r3 : e4.length; o3.relativeOffset < r3; ) {
                  var i2 = o3.parseByte();
                  i2 <= 21 ? (12 === i2 && (i2 = 1200 + o3.parseByte()), n2.push([i2, s3]), s3 = []) : s3.push(Re(o3, i2));
                }
                for (var a2 = n2, l2 = {}, u2 = 0; u2 < a2.length; u2 += 1) {
                  var c2 = a2[u2][0], d2 = a2[u2][1], f2 = void 0, f2 = 1 === d2.length ? d2[0] : d2;
                  if (l2.hasOwnProperty(c2) && !isNaN(l2[c2]))
                    throw new Error("Object " + l2 + " already has key " + c2);
                  l2[c2] = f2;
                }
                return l2;
              }
              function Ie(e4, t4) {
                return t4 = t4 <= 390 ? Se[t4] : e4[t4 - 391];
              }
              function Ue(e4, t4, r3) {
                for (var o3, n2 = {}, s3 = 0; s3 < t4.length; s3 += 1) {
                  var i2 = t4[s3];
                  if (Array.isArray(i2.type)) {
                    var a2 = [];
                    a2.length = i2.type.length;
                    for (var l2 = 0; l2 < i2.type.length; l2++)
                      void 0 === (o3 = void 0 !== e4[i2.op] ? e4[i2.op][l2] : void 0) && (o3 = void 0 !== i2.value && void 0 !== i2.value[l2] ? i2.value[l2] : null), "SID" === i2.type[l2] && (o3 = Ie(r3, o3)), a2[l2] = o3;
                    n2[i2.name] = a2;
                  } else
                    void 0 === (o3 = e4[i2.op]) && (o3 = void 0 !== i2.value ? i2.value : null), "SID" === i2.type && (o3 = Ie(r3, o3)), n2[i2.name] = o3;
                }
                return n2;
              }
              var Ne = [{ name: "version", op: 0, type: "SID" }, { name: "notice", op: 1, type: "SID" }, { name: "copyright", op: 1200, type: "SID" }, { name: "fullName", op: 2, type: "SID" }, { name: "familyName", op: 3, type: "SID" }, { name: "weight", op: 4, type: "SID" }, { name: "isFixedPitch", op: 1201, type: "number", value: 0 }, { name: "italicAngle", op: 1202, type: "number", value: 0 }, { name: "underlinePosition", op: 1203, type: "number", value: -100 }, { name: "underlineThickness", op: 1204, type: "number", value: 50 }, { name: "paintType", op: 1205, type: "number", value: 0 }, { name: "charstringType", op: 1206, type: "number", value: 2 }, { name: "fontMatrix", op: 1207, type: ["real", "real", "real", "real", "real", "real"], value: [1e-3, 0, 0, 1e-3, 0, 0] }, { name: "uniqueId", op: 13, type: "number" }, { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] }, { name: "strokeWidth", op: 1208, type: "number", value: 0 }, { name: "xuid", op: 14, type: [], value: null }, { name: "charset", op: 15, type: "offset", value: 0 }, { name: "encoding", op: 16, type: "offset", value: 0 }, { name: "charStrings", op: 17, type: "offset", value: 0 }, { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] }, { name: "ros", op: 1230, type: ["SID", "SID", "number"] }, { name: "cidFontVersion", op: 1231, type: "number", value: 0 }, { name: "cidFontRevision", op: 1232, type: "number", value: 0 }, { name: "cidFontType", op: 1233, type: "number", value: 0 }, { name: "cidCount", op: 1234, type: "number", value: 8720 }, { name: "uidBase", op: 1235, type: "number" }, { name: "fdArray", op: 1236, type: "offset" }, { name: "fdSelect", op: 1237, type: "offset" }, { name: "fontName", op: 1238, type: "SID" }], Fe = [{ name: "subrs", op: 19, type: "offset", value: 0 }, { name: "defaultWidthX", op: 20, type: "number", value: 0 }, { name: "nominalWidthX", op: 21, type: "number", value: 0 }];
              function Be(e4, t4, r3, o3) {
                return Ue(De(e4, t4, r3), Fe, o3);
              }
              function Ge(e4, t4, r3, o3) {
                for (var n2 = [], s3 = 0; s3 < r3.length; s3 += 1) {
                  var i2 = new DataView(new Uint8Array(r3[s3]).buffer), i2 = (a2 = o3, Ue(De(i2, 0, i2.byteLength), Ne, a2)), a2 = (i2._subrs = [], i2._subrsBias = 0, i2.private[0]), l2 = i2.private[1];
                  0 !== a2 && 0 !== l2 && (a2 = Be(e4, l2 + t4, a2, o3), i2._defaultWidthX = a2.defaultWidthX, i2._nominalWidthX = a2.nominalWidthX, 0 !== a2.subrs && (l2 = y(e4, l2 + a2.subrs + t4), i2._subrs = l2.objects, i2._subrsBias = Pe(i2._subrs)), i2._privateDict = a2), n2.push(i2);
                }
                return n2;
              }
              function Ve(y2, g2, e4) {
                var v2, b2, j2, _2, t4, x2, w2, r3, S2, M2 = new f(), E2 = [], T2 = 0, C2 = false, O2 = false, L2 = 0, k2 = 0, A2 = (S2 = (y2.isCIDFont ? (t4 = y2.tables.cff.topDict._fdSelect[g2.index], t4 = y2.tables.cff.topDict._fdArray[t4], x2 = t4._subrs, w2 = t4._subrsBias, r3 = t4._defaultWidthX, t4) : (x2 = y2.tables.cff.topDict._subrs, w2 = y2.tables.cff.topDict._subrsBias, r3 = y2.tables.cff.topDict._defaultWidthX, y2.tables.cff.topDict))._nominalWidthX, r3);
                function P2(e5, t5) {
                  O2 && M2.closePath(), M2.moveTo(e5, t5), O2 = true;
                }
                function R2() {
                  E2.length % 2 == 0 || C2 || (A2 = E2.shift() + S2), T2 += E2.length >> 1, E2.length = 0, C2 = true;
                }
                return function e5(t5) {
                  for (var r4, o3, n2, s3, i2, a2, l2, u2, c2, d2, f2, h2, p2 = 0; p2 < t5.length; ) {
                    var m2 = t5[p2];
                    switch (p2 += 1, m2) {
                      case 1:
                      case 3:
                        R2();
                        break;
                      case 4:
                        1 < E2.length && !C2 && (A2 = E2.shift() + S2, C2 = true), k2 += E2.pop(), P2(L2, k2);
                        break;
                      case 5:
                        for (; 0 < E2.length; )
                          L2 += E2.shift(), k2 += E2.shift(), M2.lineTo(L2, k2);
                        break;
                      case 6:
                        for (; 0 < E2.length && (L2 += E2.shift(), M2.lineTo(L2, k2), 0 !== E2.length); )
                          k2 += E2.shift(), M2.lineTo(L2, k2);
                        break;
                      case 7:
                        for (; 0 < E2.length && (k2 += E2.shift(), M2.lineTo(L2, k2), 0 !== E2.length); )
                          L2 += E2.shift(), M2.lineTo(L2, k2);
                        break;
                      case 8:
                        for (; 0 < E2.length; )
                          v2 = L2 + E2.shift(), b2 = k2 + E2.shift(), j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), L2 = j2 + E2.shift(), k2 = _2 + E2.shift(), M2.curveTo(v2, b2, j2, _2, L2, k2);
                        break;
                      case 10:
                        i2 = E2.pop() + w2, (a2 = x2[i2]) && e5(a2);
                        break;
                      case 11:
                        return;
                      case 12:
                        switch (m2 = t5[p2], p2 += 1, m2) {
                          case 35:
                            v2 = L2 + E2.shift(), b2 = k2 + E2.shift(), j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), l2 = j2 + E2.shift(), u2 = _2 + E2.shift(), c2 = l2 + E2.shift(), d2 = u2 + E2.shift(), f2 = c2 + E2.shift(), h2 = d2 + E2.shift(), L2 = f2 + E2.shift(), k2 = h2 + E2.shift(), E2.shift(), M2.curveTo(v2, b2, j2, _2, l2, u2), M2.curveTo(c2, d2, f2, h2, L2, k2);
                            break;
                          case 34:
                            v2 = L2 + E2.shift(), b2 = k2, j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), l2 = j2 + E2.shift(), u2 = _2, c2 = l2 + E2.shift(), d2 = _2, f2 = c2 + E2.shift(), h2 = k2, L2 = f2 + E2.shift(), M2.curveTo(v2, b2, j2, _2, l2, u2), M2.curveTo(c2, d2, f2, h2, L2, k2);
                            break;
                          case 36:
                            v2 = L2 + E2.shift(), b2 = k2 + E2.shift(), j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), l2 = j2 + E2.shift(), u2 = _2, c2 = l2 + E2.shift(), d2 = _2, f2 = c2 + E2.shift(), h2 = d2 + E2.shift(), L2 = f2 + E2.shift(), M2.curveTo(v2, b2, j2, _2, l2, u2), M2.curveTo(c2, d2, f2, h2, L2, k2);
                            break;
                          case 37:
                            v2 = L2 + E2.shift(), b2 = k2 + E2.shift(), j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), l2 = j2 + E2.shift(), u2 = _2 + E2.shift(), c2 = l2 + E2.shift(), d2 = u2 + E2.shift(), f2 = c2 + E2.shift(), h2 = d2 + E2.shift(), Math.abs(f2 - L2) > Math.abs(h2 - k2) ? L2 = f2 + E2.shift() : k2 = h2 + E2.shift(), M2.curveTo(v2, b2, j2, _2, l2, u2), M2.curveTo(c2, d2, f2, h2, L2, k2);
                            break;
                          default:
                            console.log("Glyph " + g2.index + ": unknown operator 1200" + m2), E2.length = 0;
                        }
                        break;
                      case 14:
                        0 < E2.length && !C2 && (A2 = E2.shift() + S2, C2 = true), O2 && (M2.closePath(), O2 = false);
                        break;
                      case 18:
                        R2();
                        break;
                      case 19:
                      case 20:
                        R2(), p2 += T2 + 7 >> 3;
                        break;
                      case 21:
                        2 < E2.length && !C2 && (A2 = E2.shift() + S2, C2 = true), k2 += E2.pop(), P2(L2 += E2.pop(), k2);
                        break;
                      case 22:
                        1 < E2.length && !C2 && (A2 = E2.shift() + S2, C2 = true), P2(L2 += E2.pop(), k2);
                        break;
                      case 23:
                        R2();
                        break;
                      case 24:
                        for (; 2 < E2.length; )
                          v2 = L2 + E2.shift(), b2 = k2 + E2.shift(), j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), L2 = j2 + E2.shift(), k2 = _2 + E2.shift(), M2.curveTo(v2, b2, j2, _2, L2, k2);
                        L2 += E2.shift(), k2 += E2.shift(), M2.lineTo(L2, k2);
                        break;
                      case 25:
                        for (; 6 < E2.length; )
                          L2 += E2.shift(), k2 += E2.shift(), M2.lineTo(L2, k2);
                        v2 = L2 + E2.shift(), b2 = k2 + E2.shift(), j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), L2 = j2 + E2.shift(), k2 = _2 + E2.shift(), M2.curveTo(v2, b2, j2, _2, L2, k2);
                        break;
                      case 26:
                        for (E2.length % 2 && (L2 += E2.shift()); 0 < E2.length; )
                          v2 = L2, b2 = k2 + E2.shift(), j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), L2 = j2, k2 = _2 + E2.shift(), M2.curveTo(v2, b2, j2, _2, L2, k2);
                        break;
                      case 27:
                        for (E2.length % 2 && (k2 += E2.shift()); 0 < E2.length; )
                          v2 = L2 + E2.shift(), b2 = k2, j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), L2 = j2 + E2.shift(), k2 = _2, M2.curveTo(v2, b2, j2, _2, L2, k2);
                        break;
                      case 28:
                        r4 = t5[p2], o3 = t5[p2 + 1], E2.push((r4 << 24 | o3 << 16) >> 16), p2 += 2;
                        break;
                      case 29:
                        i2 = E2.pop() + y2.gsubrsBias, (a2 = y2.gsubrs[i2]) && e5(a2);
                        break;
                      case 30:
                        for (; 0 < E2.length && (v2 = L2, b2 = k2 + E2.shift(), j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), L2 = j2 + E2.shift(), k2 = _2 + (1 === E2.length ? E2.shift() : 0), M2.curveTo(v2, b2, j2, _2, L2, k2), 0 !== E2.length); )
                          v2 = L2 + E2.shift(), b2 = k2, j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), k2 = _2 + E2.shift(), L2 = j2 + (1 === E2.length ? E2.shift() : 0), M2.curveTo(v2, b2, j2, _2, L2, k2);
                        break;
                      case 31:
                        for (; 0 < E2.length && (v2 = L2 + E2.shift(), b2 = k2, j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), k2 = _2 + E2.shift(), L2 = j2 + (1 === E2.length ? E2.shift() : 0), M2.curveTo(v2, b2, j2, _2, L2, k2), 0 !== E2.length); )
                          v2 = L2, b2 = k2 + E2.shift(), j2 = v2 + E2.shift(), _2 = b2 + E2.shift(), L2 = j2 + E2.shift(), k2 = _2 + (1 === E2.length ? E2.shift() : 0), M2.curveTo(v2, b2, j2, _2, L2, k2);
                        break;
                      default:
                        m2 < 32 ? console.log("Glyph " + g2.index + ": unknown operator " + m2) : m2 < 247 ? E2.push(m2 - 139) : m2 < 251 ? (r4 = t5[p2], p2 += 1, E2.push(256 * (m2 - 247) + r4 + 108)) : m2 < 255 ? (r4 = t5[p2], p2 += 1, E2.push(256 * -(m2 - 251) - r4 - 108)) : (r4 = t5[p2], o3 = t5[p2 + 1], n2 = t5[p2 + 2], s3 = t5[p2 + 3], p2 += 4, E2.push((r4 << 24 | o3 << 16 | n2 << 8 | s3) / 65536));
                    }
                  }
                }(e4), g2.advanceWidth = A2, M2;
              }
              function ze(e4, t4) {
                var r3, o3 = Se.indexOf(e4);
                return 0 <= o3 && (r3 = o3), 0 <= (o3 = t4.indexOf(e4)) ? r3 = o3 + Se.length : (r3 = Se.length + t4.length, t4.push(e4)), r3;
              }
              function He(e4, t4, r3) {
                for (var o3 = {}, n2 = 0; n2 < e4.length; n2 += 1) {
                  var s3 = e4[n2], i2 = t4[s3.name];
                  void 0 === i2 || function e5(t5, r4) {
                    if (t5 === r4)
                      return 1;
                    if (Array.isArray(t5) && Array.isArray(r4) && t5.length === r4.length) {
                      for (var o4 = 0; o4 < t5.length; o4 += 1)
                        if (!e5(t5[o4], r4[o4]))
                          return;
                      return 1;
                    }
                  }(i2, s3.value) || ("SID" === s3.type && (i2 = ze(i2, r3)), o3[s3.op] = { name: s3.name, type: s3.type, value: i2 });
                }
                return o3;
              }
              function We(e4, t4) {
                var r3 = new S.Record("Top DICT", [{ name: "dict", type: "DICT", value: {} }]);
                return r3.dict = He(Ne, e4, t4), r3;
              }
              function qe(e4) {
                var t4 = new S.Record("Top DICT INDEX", [{ name: "topDicts", type: "INDEX", value: [] }]);
                return t4.topDicts = [{ name: "topDict_0", type: "TABLE", value: e4 }], t4;
              }
              function Xe(e4) {
                for (var t4 = new S.Record("CharStrings INDEX", [{ name: "charStrings", type: "INDEX", value: [] }]), r3 = 0; r3 < e4.length; r3 += 1) {
                  var o3 = e4.get(r3), n2 = function(e5) {
                    for (var t5 = [], r4 = e5.path, o4 = (t5.push({ name: "width", type: "NUMBER", value: e5.advanceWidth }), 0), n3 = 0, s3 = 0; s3 < r4.commands.length; s3 += 1) {
                      var i2, a2, l2, u2, c2 = void 0, d2 = void 0, f2 = r4.commands[s3];
                      "M" === (f2 = "Q" === f2.type ? { type: "C", x: f2.x, y: f2.y, x1: 1 / 3 * o4 + 2 / 3 * f2.x1, y1: 1 / 3 * n3 + 2 / 3 * f2.y1, x2: 1 / 3 * f2.x + 2 / 3 * f2.x1, y2: 1 / 3 * f2.y + 2 / 3 * f2.y1 } : f2).type ? (c2 = Math.round(f2.x - o4), d2 = Math.round(f2.y - n3), t5.push({ name: "dx", type: "NUMBER", value: c2 }), t5.push({ name: "dy", type: "NUMBER", value: d2 }), t5.push({ name: "rmoveto", type: "OP", value: 21 }), o4 = Math.round(f2.x), n3 = Math.round(f2.y)) : "L" === f2.type ? (c2 = Math.round(f2.x - o4), d2 = Math.round(f2.y - n3), t5.push({ name: "dx", type: "NUMBER", value: c2 }), t5.push({ name: "dy", type: "NUMBER", value: d2 }), t5.push({ name: "rlineto", type: "OP", value: 5 }), o4 = Math.round(f2.x), n3 = Math.round(f2.y)) : "C" === f2.type && (i2 = Math.round(f2.x1 - o4), a2 = Math.round(f2.y1 - n3), l2 = Math.round(f2.x2 - f2.x1), u2 = Math.round(f2.y2 - f2.y1), c2 = Math.round(f2.x - f2.x2), d2 = Math.round(f2.y - f2.y2), t5.push({ name: "dx1", type: "NUMBER", value: i2 }), t5.push({ name: "dy1", type: "NUMBER", value: a2 }), t5.push({ name: "dx2", type: "NUMBER", value: l2 }), t5.push({ name: "dy2", type: "NUMBER", value: u2 }), t5.push({ name: "dx", type: "NUMBER", value: c2 }), t5.push({ name: "dy", type: "NUMBER", value: d2 }), t5.push({ name: "rrcurveto", type: "OP", value: 8 }), o4 = Math.round(f2.x), n3 = Math.round(f2.y));
                    }
                    return t5.push({ name: "endchar", type: "OP", value: 14 }), t5;
                  }(o3);
                  t4.charStrings.push({ name: o3.name, type: "CHARSTRING", value: n2 });
                }
                return t4;
              }
              var Ye = { parse: function(e4, t4, r3) {
                r3.tables.cff = {}, o3 = e4, n2 = t4, (s3 = {}).formatMajor = R.getCard8(o3, n2), s3.formatMinor = R.getCard8(o3, n2 + 1), s3.size = R.getCard8(o3, n2 + 2), s3.offsetSize = R.getCard8(o3, n2 + 3), s3.startOffset = n2, s3.endOffset = n2 + 4;
                var o3 = y(e4, s3.endOffset, R.bytesToString), n2 = y(e4, o3.endOffset), s3 = y(e4, n2.endOffset, R.bytesToString), o3 = y(e4, s3.endOffset);
                if (r3.gsubrs = o3.objects, r3.gsubrsBias = Pe(r3.gsubrs), 1 !== (o3 = Ge(e4, t4, n2.objects, s3.objects)).length)
                  throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + o3.length);
                if (n2 = o3[0], (r3.tables.cff.topDict = n2)._privateDict && (r3.defaultWidthX = n2._privateDict.defaultWidthX, r3.nominalWidthX = n2._privateDict.nominalWidthX), void 0 !== n2.ros[0] && void 0 !== n2.ros[1] && (r3.isCIDFont = true), r3.isCIDFont) {
                  var o3 = n2.fdArray, i2 = n2.fdSelect;
                  if (0 === o3 || 0 === i2)
                    throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
                  o3 = Ge(e4, t4, y(e4, o3 += t4).objects, s3.objects);
                  n2._fdArray = o3, n2._fdSelect = function(e5, t5, r4, o4) {
                    var n3, s4 = [], i3 = new R.Parser(e5, t5);
                    if (0 === (e5 = i3.parseCard8()))
                      for (var a3 = 0; a3 < r4; a3++) {
                        if (o4 <= (n3 = i3.parseCard8()))
                          throw new Error("CFF table CID Font FDSelect has bad FD index value " + n3 + " (FD count " + o4 + ")");
                        s4.push(n3);
                      }
                    else {
                      if (3 !== e5)
                        throw new Error("CFF Table CID Font FDSelect table has unsupported format " + e5);
                      var l3, u3 = i3.parseCard16(), c2 = i3.parseCard16();
                      if (0 !== c2)
                        throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + c2);
                      for (var d2 = 0; d2 < u3; d2++) {
                        if (n3 = i3.parseCard8(), l3 = i3.parseCard16(), o4 <= n3)
                          throw new Error("CFF table CID Font FDSelect has bad FD index value " + n3 + " (FD count " + o4 + ")");
                        if (r4 < l3)
                          throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + l3);
                        for (; c2 < l3; c2++)
                          s4.push(n3);
                        c2 = l3;
                      }
                      if (l3 !== r4)
                        throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + l3);
                    }
                    return s4;
                  }(e4, i2 += t4, r3.numGlyphs, o3.length);
                }
                var i2 = t4 + n2.private[1], o3 = Be(e4, i2, n2.private[0], s3.objects), a2 = (r3.defaultWidthX = o3.defaultWidthX, r3.nominalWidthX = o3.nominalWidthX, 0 !== o3.subrs ? (i2 = y(e4, i2 + o3.subrs), r3.subrs = i2.objects, r3.subrsBias = Pe(r3.subrs)) : (r3.subrs = [], r3.subrsBias = 0), y(e4, t4 + n2.charStrings)), o3 = (r3.nGlyphs = a2.objects.length, function(e5, t5, r4, o4) {
                  var n3 = new R.Parser(e5, t5), s4 = (--r4, [".notdef"]);
                  if (0 === (e5 = n3.parseCard8()))
                    for (var i3 = 0; i3 < r4; i3 += 1)
                      a3 = n3.parseSID(), s4.push(Ie(o4, a3));
                  else if (1 === e5)
                    for (; s4.length <= r4; )
                      for (var a3 = n3.parseSID(), l3 = n3.parseCard8(), u3 = 0; u3 <= l3; u3 += 1)
                        s4.push(Ie(o4, a3)), a3 += 1;
                  else {
                    if (2 !== e5)
                      throw new Error("Unknown charset format " + e5);
                    for (; s4.length <= r4; ) {
                      a3 = n3.parseSID(), l3 = n3.parseCard16();
                      for (var c2 = 0; c2 <= l3; c2 += 1)
                        s4.push(Ie(o4, a3)), a3 += 1;
                    }
                  }
                  return s4;
                }(e4, t4 + n2.charset, r3.nGlyphs, s3.objects));
                0 === n2.encoding ? r3.cffEncoding = new Oe(Me, o3) : 1 === n2.encoding ? r3.cffEncoding = new Oe(Ee, o3) : r3.cffEncoding = function(e5, t5, r4) {
                  var o4 = {}, n3 = new R.Parser(e5, t5);
                  if (0 === (e5 = n3.parseCard8()))
                    for (var s4 = n3.parseCard8(), i3 = 0; i3 < s4; i3 += 1)
                      o4[l3 = n3.parseCard8()] = i3;
                  else {
                    if (1 !== e5)
                      throw new Error("Unknown encoding format " + e5);
                    for (var a3 = n3.parseCard8(), l3 = 1, u3 = 0; u3 < a3; u3 += 1)
                      for (var c2 = n3.parseCard8(), d2 = n3.parseCard8(), f2 = c2; f2 <= c2 + d2; f2 += 1)
                        o4[f2] = l3, l3 += 1;
                  }
                  return new Oe(o4, r4);
                }(e4, t4 + n2.encoding, o3), r3.encoding = r3.encoding || r3.cffEncoding, r3.glyphs = new p.GlyphSet(r3);
                for (var l2 = 0; l2 < r3.nGlyphs; l2 += 1) {
                  var u2 = a2.objects[l2];
                  r3.glyphs.push(l2, p.cffGlyphLoader(r3, l2, Ve, u2));
                }
              }, make: function(e4, t4) {
                for (var r3, o3 = new S.Table("CFF ", [{ name: "header", type: "RECORD" }, { name: "nameIndex", type: "RECORD" }, { name: "topDictIndex", type: "RECORD" }, { name: "stringIndex", type: "RECORD" }, { name: "globalSubrIndex", type: "RECORD" }, { name: "charsets", type: "RECORD" }, { name: "charStringsIndex", type: "RECORD" }, { name: "privateDict", type: "RECORD" }]), n2 = 1 / t4.unitsPerEm, n2 = { version: t4.version, fullName: t4.fullName, familyName: t4.familyName, weight: t4.weightName, fontBBox: t4.fontBBox || [0, 0, 0, 0], fontMatrix: [n2, 0, 0, n2, 0, 0], charset: 999, encoding: 0, charStrings: 999, private: [0, 999] }, s3 = [], i2 = 1; i2 < e4.length; i2 += 1)
                  r3 = e4.get(i2), s3.push(r3.name);
                var a2, l2, u2 = [], t4 = (o3.header = new S.Record("Header", [{ name: "major", type: "Card8", value: 1 }, { name: "minor", type: "Card8", value: 0 }, { name: "hdrSize", type: "Card8", value: 4 }, { name: "major", type: "Card8", value: 1 }]), o3.nameIndex = function(e5) {
                  var t5 = new S.Record("Name INDEX", [{ name: "names", type: "INDEX", value: [] }]);
                  t5.names = [];
                  for (var r4 = 0; r4 < e5.length; r4 += 1)
                    t5.names.push({ name: "name_" + r4, type: "NAME", value: e5[r4] });
                  return t5;
                }([t4.postScriptName]), We(n2, u2)), c2 = (o3.topDictIndex = qe(t4), o3.globalSubrIndex = new S.Record("Global Subr INDEX", [{ name: "subrs", type: "INDEX", value: [] }]), o3.charsets = function(e5, t5) {
                  for (var r4 = new S.Record("Charsets", [{ name: "format", type: "Card8", value: 0 }]), o4 = 0; o4 < e5.length; o4 += 1) {
                    var n3 = ze(e5[o4], t5);
                    r4.fields.push({ name: "glyph_" + o4, type: "SID", value: n3 });
                  }
                  return r4;
                }(s3, u2), o3.charStringsIndex = Xe(e4), o3.privateDict = (c2 = {}, a2 = u2, (l2 = new S.Record("Private DICT", [{ name: "dict", type: "DICT", value: {} }])).dict = He(Fe, c2, a2), l2), o3.stringIndex = function(e5) {
                  var t5 = new S.Record("String INDEX", [{ name: "strings", type: "INDEX", value: [] }]);
                  t5.strings = [];
                  for (var r4 = 0; r4 < e5.length; r4 += 1)
                    t5.strings.push({ name: "string_" + r4, type: "STRING", value: e5[r4] });
                  return t5;
                }(u2), o3.header.sizeOf() + o3.nameIndex.sizeOf() + o3.topDictIndex.sizeOf() + o3.stringIndex.sizeOf() + o3.globalSubrIndex.sizeOf());
                return n2.charset = c2, n2.encoding = 0, n2.charStrings = n2.charset + o3.charsets.sizeOf(), n2.private[1] = n2.charStrings + o3.charStringsIndex.sizeOf(), t4 = We(n2, u2), o3.topDictIndex = qe(t4), o3;
              } };
              var Ze = { parse: function(e4, t4) {
                var r3 = {}, e4 = new R.Parser(e4, t4);
                return r3.version = e4.parseVersion(), r3.fontRevision = Math.round(1e3 * e4.parseFixed()) / 1e3, r3.checkSumAdjustment = e4.parseULong(), r3.magicNumber = e4.parseULong(), P.argument(1594834165 === r3.magicNumber, "Font header has wrong magic number."), r3.flags = e4.parseUShort(), r3.unitsPerEm = e4.parseUShort(), r3.created = e4.parseLongDateTime(), r3.modified = e4.parseLongDateTime(), r3.xMin = e4.parseShort(), r3.yMin = e4.parseShort(), r3.xMax = e4.parseShort(), r3.yMax = e4.parseShort(), r3.macStyle = e4.parseUShort(), r3.lowestRecPPEM = e4.parseUShort(), r3.fontDirectionHint = e4.parseShort(), r3.indexToLocFormat = e4.parseShort(), r3.glyphDataFormat = e4.parseShort(), r3;
              }, make: function(e4) {
                var t4 = Math.round(new Date().getTime() / 1e3) + 2082844800, r3 = t4;
                return e4.createdTimestamp && (r3 = e4.createdTimestamp + 2082844800), new S.Table("head", [{ name: "version", type: "FIXED", value: 65536 }, { name: "fontRevision", type: "FIXED", value: 65536 }, { name: "checkSumAdjustment", type: "ULONG", value: 0 }, { name: "magicNumber", type: "ULONG", value: 1594834165 }, { name: "flags", type: "USHORT", value: 0 }, { name: "unitsPerEm", type: "USHORT", value: 1e3 }, { name: "created", type: "LONGDATETIME", value: r3 }, { name: "modified", type: "LONGDATETIME", value: t4 }, { name: "xMin", type: "SHORT", value: 0 }, { name: "yMin", type: "SHORT", value: 0 }, { name: "xMax", type: "SHORT", value: 0 }, { name: "yMax", type: "SHORT", value: 0 }, { name: "macStyle", type: "USHORT", value: 0 }, { name: "lowestRecPPEM", type: "USHORT", value: 0 }, { name: "fontDirectionHint", type: "SHORT", value: 2 }, { name: "indexToLocFormat", type: "SHORT", value: 0 }, { name: "glyphDataFormat", type: "SHORT", value: 0 }], e4);
              } };
              var Qe = { parse: function(e4, t4) {
                var r3 = {}, e4 = new R.Parser(e4, t4);
                return r3.version = e4.parseVersion(), r3.ascender = e4.parseShort(), r3.descender = e4.parseShort(), r3.lineGap = e4.parseShort(), r3.advanceWidthMax = e4.parseUShort(), r3.minLeftSideBearing = e4.parseShort(), r3.minRightSideBearing = e4.parseShort(), r3.xMaxExtent = e4.parseShort(), r3.caretSlopeRise = e4.parseShort(), r3.caretSlopeRun = e4.parseShort(), r3.caretOffset = e4.parseShort(), e4.relativeOffset += 8, r3.metricDataFormat = e4.parseShort(), r3.numberOfHMetrics = e4.parseUShort(), r3;
              }, make: function(e4) {
                return new S.Table("hhea", [{ name: "version", type: "FIXED", value: 65536 }, { name: "ascender", type: "FWORD", value: 0 }, { name: "descender", type: "FWORD", value: 0 }, { name: "lineGap", type: "FWORD", value: 0 }, { name: "advanceWidthMax", type: "UFWORD", value: 0 }, { name: "minLeftSideBearing", type: "FWORD", value: 0 }, { name: "minRightSideBearing", type: "FWORD", value: 0 }, { name: "xMaxExtent", type: "FWORD", value: 0 }, { name: "caretSlopeRise", type: "SHORT", value: 1 }, { name: "caretSlopeRun", type: "SHORT", value: 0 }, { name: "caretOffset", type: "SHORT", value: 0 }, { name: "reserved1", type: "SHORT", value: 0 }, { name: "reserved2", type: "SHORT", value: 0 }, { name: "reserved3", type: "SHORT", value: 0 }, { name: "reserved4", type: "SHORT", value: 0 }, { name: "metricDataFormat", type: "SHORT", value: 0 }, { name: "numberOfHMetrics", type: "USHORT", value: 0 }], e4);
              } };
              var Ke = { parse: function(e4, t4, r3, o3, n2) {
                for (var s3, i2, a2 = new R.Parser(e4, t4), l2 = 0; l2 < o3; l2 += 1) {
                  l2 < r3 && (s3 = a2.parseUShort(), i2 = a2.parseShort());
                  var u2 = n2.get(l2);
                  u2.advanceWidth = s3, u2.leftSideBearing = i2;
                }
              }, make: function(e4) {
                for (var t4 = new S.Table("hmtx", []), r3 = 0; r3 < e4.length; r3 += 1) {
                  var o3 = e4.get(r3), n2 = o3.advanceWidth || 0, o3 = o3.leftSideBearing || 0;
                  t4.fields.push({ name: "advanceWidth_" + r3, type: "USHORT", value: n2 }), t4.fields.push({ name: "leftSideBearing_" + r3, type: "SHORT", value: o3 });
                }
                return t4;
              } };
              var Je = { make: function(e4) {
                for (var t4 = new S.Table("ltag", [{ name: "version", type: "ULONG", value: 1 }, { name: "flags", type: "ULONG", value: 0 }, { name: "numTags", type: "ULONG", value: e4.length }]), r3 = "", o3 = 12 + 4 * e4.length, n2 = 0; n2 < e4.length; ++n2) {
                  var s3 = r3.indexOf(e4[n2]);
                  s3 < 0 && (s3 = r3.length, r3 += e4[n2]), t4.fields.push({ name: "offset " + n2, type: "USHORT", value: o3 + s3 }), t4.fields.push({ name: "length " + n2, type: "USHORT", value: e4[n2].length });
                }
                return t4.fields.push({ name: "stringPool", type: "CHARARRAY", value: r3 }), t4;
              }, parse: function(e4, t4) {
                for (var r3 = new R.Parser(e4, t4), o3 = r3.parseULong(), n2 = (P.argument(1 === o3, "Unsupported ltag table version."), r3.skip("uLong", 1), r3.parseULong()), s3 = [], i2 = 0; i2 < n2; i2++) {
                  for (var a2 = "", l2 = t4 + r3.parseUShort(), u2 = r3.parseUShort(), c2 = l2; c2 < l2 + u2; ++c2)
                    a2 += String.fromCharCode(e4.getInt8(c2));
                  s3.push(a2);
                }
                return s3;
              } };
              var $e = { parse: function(e4, t4) {
                var r3 = {}, e4 = new R.Parser(e4, t4);
                return r3.version = e4.parseVersion(), r3.numGlyphs = e4.parseUShort(), 1 === r3.version && (r3.maxPoints = e4.parseUShort(), r3.maxContours = e4.parseUShort(), r3.maxCompositePoints = e4.parseUShort(), r3.maxCompositeContours = e4.parseUShort(), r3.maxZones = e4.parseUShort(), r3.maxTwilightPoints = e4.parseUShort(), r3.maxStorage = e4.parseUShort(), r3.maxFunctionDefs = e4.parseUShort(), r3.maxInstructionDefs = e4.parseUShort(), r3.maxStackElements = e4.parseUShort(), r3.maxSizeOfInstructions = e4.parseUShort(), r3.maxComponentElements = e4.parseUShort(), r3.maxComponentDepth = e4.parseUShort()), r3;
              }, make: function(e4) {
                return new S.Table("maxp", [{ name: "version", type: "FIXED", value: 20480 }, { name: "numGlyphs", type: "USHORT", value: e4 }]);
              } }, et = ["copyright", "fontFamily", "fontSubfamily", "uniqueID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "manufacturerURL", "designerURL", "license", "licenseURL", "reserved", "preferredFamily", "preferredSubfamily", "compatibleFullName", "sampleText", "postScriptFindFontName", "wwsFamily", "wwsSubfamily"], tt = { 0: "en", 1: "fr", 2: "de", 3: "it", 4: "nl", 5: "sv", 6: "es", 7: "da", 8: "pt", 9: "no", 10: "he", 11: "ja", 12: "ar", 13: "fi", 14: "el", 15: "is", 16: "mt", 17: "tr", 18: "hr", 19: "zh-Hant", 20: "ur", 21: "hi", 22: "th", 23: "ko", 24: "lt", 25: "pl", 26: "hu", 27: "es", 28: "lv", 29: "se", 30: "fo", 31: "fa", 32: "ru", 33: "zh", 34: "nl-BE", 35: "ga", 36: "sq", 37: "ro", 38: "cz", 39: "sk", 40: "si", 41: "yi", 42: "sr", 43: "mk", 44: "bg", 45: "uk", 46: "be", 47: "uz", 48: "kk", 49: "az-Cyrl", 50: "az-Arab", 51: "hy", 52: "ka", 53: "mo", 54: "ky", 55: "tg", 56: "tk", 57: "mn-CN", 58: "mn", 59: "ps", 60: "ks", 61: "ku", 62: "sd", 63: "bo", 64: "ne", 65: "sa", 66: "mr", 67: "bn", 68: "as", 69: "gu", 70: "pa", 71: "or", 72: "ml", 73: "kn", 74: "ta", 75: "te", 76: "si", 77: "my", 78: "km", 79: "lo", 80: "vi", 81: "id", 82: "tl", 83: "ms", 84: "ms-Arab", 85: "am", 86: "ti", 87: "om", 88: "so", 89: "sw", 90: "rw", 91: "rn", 92: "ny", 93: "mg", 94: "eo", 128: "cy", 129: "eu", 130: "ca", 131: "la", 132: "qu", 133: "gn", 134: "ay", 135: "tt", 136: "ug", 137: "dz", 138: "jv", 139: "su", 140: "gl", 141: "af", 142: "br", 143: "iu", 144: "gd", 145: "gv", 146: "ga", 147: "to", 148: "el-polyton", 149: "kl", 150: "az", 151: "nn" }, rt = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 5, 11: 1, 12: 4, 13: 0, 14: 6, 15: 0, 16: 0, 17: 0, 18: 0, 19: 2, 20: 4, 21: 9, 22: 21, 23: 3, 24: 29, 25: 29, 26: 29, 27: 29, 28: 29, 29: 0, 30: 0, 31: 4, 32: 7, 33: 25, 34: 0, 35: 0, 36: 0, 37: 0, 38: 29, 39: 29, 40: 0, 41: 5, 42: 7, 43: 7, 44: 7, 45: 7, 46: 7, 47: 7, 48: 7, 49: 7, 50: 4, 51: 24, 52: 23, 53: 7, 54: 7, 55: 7, 56: 7, 57: 27, 58: 7, 59: 4, 60: 4, 61: 4, 62: 4, 63: 26, 64: 9, 65: 9, 66: 9, 67: 13, 68: 13, 69: 11, 70: 10, 71: 12, 72: 17, 73: 16, 74: 14, 75: 15, 76: 18, 77: 19, 78: 20, 79: 22, 80: 30, 81: 0, 82: 0, 83: 0, 84: 4, 85: 28, 86: 28, 87: 28, 88: 0, 89: 0, 90: 0, 91: 0, 92: 0, 93: 0, 94: 0, 128: 0, 129: 0, 130: 0, 131: 0, 132: 0, 133: 0, 134: 0, 135: 7, 136: 4, 137: 26, 138: 0, 139: 0, 140: 0, 141: 0, 142: 0, 143: 28, 144: 0, 145: 0, 146: 0, 147: 0, 148: 6, 149: 0, 150: 0, 151: 0 }, ot = { 1078: "af", 1052: "sq", 1156: "gsw", 1118: "am", 5121: "ar-DZ", 15361: "ar-BH", 3073: "ar", 2049: "ar-IQ", 11265: "ar-JO", 13313: "ar-KW", 12289: "ar-LB", 4097: "ar-LY", 6145: "ary", 8193: "ar-OM", 16385: "ar-QA", 1025: "ar-SA", 10241: "ar-SY", 7169: "aeb", 14337: "ar-AE", 9217: "ar-YE", 1067: "hy", 1101: "as", 2092: "az-Cyrl", 1068: "az", 1133: "ba", 1069: "eu", 1059: "be", 2117: "bn", 1093: "bn-IN", 8218: "bs-Cyrl", 5146: "bs", 1150: "br", 1026: "bg", 1027: "ca", 3076: "zh-HK", 5124: "zh-MO", 2052: "zh", 4100: "zh-SG", 1028: "zh-TW", 1155: "co", 1050: "hr", 4122: "hr-BA", 1029: "cs", 1030: "da", 1164: "prs", 1125: "dv", 2067: "nl-BE", 1043: "nl", 3081: "en-AU", 10249: "en-BZ", 4105: "en-CA", 9225: "en-029", 16393: "en-IN", 6153: "en-IE", 8201: "en-JM", 17417: "en-MY", 5129: "en-NZ", 13321: "en-PH", 18441: "en-SG", 7177: "en-ZA", 11273: "en-TT", 2057: "en-GB", 1033: "en", 12297: "en-ZW", 1061: "et", 1080: "fo", 1124: "fil", 1035: "fi", 2060: "fr-BE", 3084: "fr-CA", 1036: "fr", 5132: "fr-LU", 6156: "fr-MC", 4108: "fr-CH", 1122: "fy", 1110: "gl", 1079: "ka", 3079: "de-AT", 1031: "de", 5127: "de-LI", 4103: "de-LU", 2055: "de-CH", 1032: "el", 1135: "kl", 1095: "gu", 1128: "ha", 1037: "he", 1081: "hi", 1038: "hu", 1039: "is", 1136: "ig", 1057: "id", 1117: "iu", 2141: "iu-Latn", 2108: "ga", 1076: "xh", 1077: "zu", 1040: "it", 2064: "it-CH", 1041: "ja", 1099: "kn", 1087: "kk", 1107: "km", 1158: "quc", 1159: "rw", 1089: "sw", 1111: "kok", 1042: "ko", 1088: "ky", 1108: "lo", 1062: "lv", 1063: "lt", 2094: "dsb", 1134: "lb", 1071: "mk", 2110: "ms-BN", 1086: "ms", 1100: "ml", 1082: "mt", 1153: "mi", 1146: "arn", 1102: "mr", 1148: "moh", 1104: "mn", 2128: "mn-CN", 1121: "ne", 1044: "nb", 2068: "nn", 1154: "oc", 1096: "or", 1123: "ps", 1045: "pl", 1046: "pt", 2070: "pt-PT", 1094: "pa", 1131: "qu-BO", 2155: "qu-EC", 3179: "qu", 1048: "ro", 1047: "rm", 1049: "ru", 9275: "smn", 4155: "smj-NO", 5179: "smj", 3131: "se-FI", 1083: "se", 2107: "se-SE", 8251: "sms", 6203: "sma-NO", 7227: "sms", 1103: "sa", 7194: "sr-Cyrl-BA", 3098: "sr", 6170: "sr-Latn-BA", 2074: "sr-Latn", 1132: "nso", 1074: "tn", 1115: "si", 1051: "sk", 1060: "sl", 11274: "es-AR", 16394: "es-BO", 13322: "es-CL", 9226: "es-CO", 5130: "es-CR", 7178: "es-DO", 12298: "es-EC", 17418: "es-SV", 4106: "es-GT", 18442: "es-HN", 2058: "es-MX", 19466: "es-NI", 6154: "es-PA", 15370: "es-PY", 10250: "es-PE", 20490: "es-PR", 3082: "es", 1034: "es", 21514: "es-US", 14346: "es-UY", 8202: "es-VE", 2077: "sv-FI", 1053: "sv", 1114: "syr", 1064: "tg", 2143: "tzm", 1097: "ta", 1092: "tt", 1098: "te", 1054: "th", 1105: "bo", 1055: "tr", 1090: "tk", 1152: "ug", 1058: "uk", 1070: "hsb", 1056: "ur", 2115: "uz-Cyrl", 1091: "uz", 1066: "vi", 1106: "cy", 1160: "wo", 1157: "sah", 1144: "ii", 1130: "yo" };
              var nt = "utf-16", st = { 0: "macintosh", 1: "x-mac-japanese", 2: "x-mac-chinesetrad", 3: "x-mac-korean", 6: "x-mac-greek", 7: "x-mac-cyrillic", 9: "x-mac-devanagai", 10: "x-mac-gurmukhi", 11: "x-mac-gujarati", 12: "x-mac-oriya", 13: "x-mac-bengali", 14: "x-mac-tamil", 15: "x-mac-telugu", 16: "x-mac-kannada", 17: "x-mac-malayalam", 18: "x-mac-sinhalese", 19: "x-mac-burmese", 20: "x-mac-khmer", 21: "x-mac-thai", 22: "x-mac-lao", 23: "x-mac-georgian", 24: "x-mac-armenian", 25: "x-mac-chinesesimp", 26: "x-mac-tibetan", 27: "x-mac-mongolian", 28: "x-mac-ethiopic", 29: "x-mac-ce", 30: "x-mac-vietnamese", 31: "x-mac-extarabic" }, it = { 15: "x-mac-icelandic", 17: "x-mac-turkish", 18: "x-mac-croatian", 24: "x-mac-ce", 25: "x-mac-ce", 26: "x-mac-ce", 27: "x-mac-ce", 28: "x-mac-ce", 30: "x-mac-icelandic", 37: "x-mac-romanian", 38: "x-mac-ce", 39: "x-mac-ce", 40: "x-mac-ce", 143: "x-mac-inuit", 146: "x-mac-gaelic" };
              function at(e4, t4, r3) {
                switch (e4) {
                  case 0:
                    return nt;
                  case 1:
                    return it[r3] || st[t4];
                  case 3:
                    if (1 === t4 || 10 === t4)
                      return nt;
                }
              }
              function lt(e4) {
                var t4, r3 = {};
                for (t4 in e4)
                  r3[e4[t4]] = parseInt(t4);
                return r3;
              }
              function ut(e4, t4, r3, o3, n2, s3) {
                return new S.Record("NameRecord", [{ name: "platformID", type: "USHORT", value: e4 }, { name: "encodingID", type: "USHORT", value: t4 }, { name: "languageID", type: "USHORT", value: r3 }, { name: "nameID", type: "USHORT", value: o3 }, { name: "length", type: "USHORT", value: n2 }, { name: "offset", type: "USHORT", value: s3 }]);
              }
              function ct(e4, t4) {
                if ((r3 = function(e5, t5) {
                  var r4 = e5.length, o4 = t5.length - r4 + 1;
                  e:
                    for (var n3 = 0; n3 < o4; n3++)
                      for (; n3 < o4; n3++) {
                        for (var s3 = 0; s3 < r4; s3++)
                          if (t5[n3 + s3] !== e5[s3])
                            continue e;
                        return n3;
                      }
                  return -1;
                }(e4, t4)) < 0)
                  for (var r3 = t4.length, o3 = 0, n2 = e4.length; o3 < n2; ++o3)
                    t4.push(e4[o3]);
                return r3;
              }
              var dt = { parse: function(e4, t4, r3) {
                for (var o3 = {}, n2 = new R.Parser(e4, t4), t4 = n2.parseUShort(), s3 = n2.parseUShort(), i2 = n2.offset + n2.parseUShort(), a2 = 0; a2 < s3; a2++) {
                  var l2 = n2.parseUShort(), u2 = n2.parseUShort(), c2 = n2.parseUShort(), d2 = n2.parseUShort(), d2 = et[d2] || d2, f2 = n2.parseUShort(), h2 = n2.parseUShort(), p2 = function(e5, t5, r4) {
                    switch (e5) {
                      case 0:
                        if (65535 === t5)
                          return "und";
                        if (r4)
                          return r4[t5];
                        break;
                      case 1:
                        return tt[t5];
                      case 3:
                        return ot[t5];
                    }
                  }(l2, c2, r3), l2 = at(l2, u2, c2);
                  void 0 !== l2 && void 0 !== p2 && (u2 = void 0, (u2 = l2 === nt ? m.UTF16(e4, i2 + h2, f2) : m.MACSTRING(e4, i2 + h2, f2, l2)) && ((c2 = void 0 === (c2 = o3[d2]) ? o3[d2] = {} : c2)[p2] = u2));
                }
                return 1 === t4 && n2.parseUShort(), o3;
              }, make: function(e4, t4) {
                var r3, o3 = [], n2 = {}, s3 = lt(et);
                for (r3 in e4) {
                  var i2 = s3[r3];
                  if (void 0 === i2 && (i2 = r3), f2 = parseInt(i2), isNaN(f2))
                    throw new Error('Name table entry "' + r3 + '" does not exist, see nameTableNames for complete list.');
                  n2[f2] = e4[r3], o3.push(f2);
                }
                for (var a2 = lt(tt), l2 = lt(ot), u2 = [], c2 = [], d2 = 0; d2 < o3.length; d2++) {
                  var f2, h2, p2 = n2[f2 = o3[d2]];
                  for (h2 in p2) {
                    var m2 = p2[h2], y2 = 1, g2 = a2[h2], v2 = rt[g2], b2 = at(y2, v2, g2), b2 = w.MACSTRING(m2, b2), j2 = (void 0 === b2 && (y2 = 0, (g2 = t4.indexOf(h2)) < 0 && (g2 = t4.length, t4.push(h2)), v2 = 4, b2 = w.UTF16(m2)), ct(b2, c2)), y2 = (u2.push(ut(y2, v2, g2, f2, b2.length, j2)), l2[h2]);
                    void 0 !== y2 && (g2 = ct(v2 = w.UTF16(m2), c2), u2.push(ut(3, 1, y2, f2, v2.length, g2)));
                  }
                }
                u2.sort(function(e5, t5) {
                  return e5.platformID - t5.platformID || e5.encodingID - t5.encodingID || e5.languageID - t5.languageID || e5.nameID - t5.nameID;
                });
                for (var _2 = new S.Table("name", [{ name: "format", type: "USHORT", value: 0 }, { name: "count", type: "USHORT", value: u2.length }, { name: "stringOffset", type: "USHORT", value: 6 + 12 * u2.length }]), x2 = 0; x2 < u2.length; x2++)
                  _2.fields.push({ name: "record_" + x2, type: "RECORD", value: u2[x2] });
                return _2.fields.push({ name: "strings", type: "LITERAL", value: c2 }), _2;
              } }, ft = [{ begin: 0, end: 127 }, { begin: 128, end: 255 }, { begin: 256, end: 383 }, { begin: 384, end: 591 }, { begin: 592, end: 687 }, { begin: 688, end: 767 }, { begin: 768, end: 879 }, { begin: 880, end: 1023 }, { begin: 11392, end: 11519 }, { begin: 1024, end: 1279 }, { begin: 1328, end: 1423 }, { begin: 1424, end: 1535 }, { begin: 42240, end: 42559 }, { begin: 1536, end: 1791 }, { begin: 1984, end: 2047 }, { begin: 2304, end: 2431 }, { begin: 2432, end: 2559 }, { begin: 2560, end: 2687 }, { begin: 2688, end: 2815 }, { begin: 2816, end: 2943 }, { begin: 2944, end: 3071 }, { begin: 3072, end: 3199 }, { begin: 3200, end: 3327 }, { begin: 3328, end: 3455 }, { begin: 3584, end: 3711 }, { begin: 3712, end: 3839 }, { begin: 4256, end: 4351 }, { begin: 6912, end: 7039 }, { begin: 4352, end: 4607 }, { begin: 7680, end: 7935 }, { begin: 7936, end: 8191 }, { begin: 8192, end: 8303 }, { begin: 8304, end: 8351 }, { begin: 8352, end: 8399 }, { begin: 8400, end: 8447 }, { begin: 8448, end: 8527 }, { begin: 8528, end: 8591 }, { begin: 8592, end: 8703 }, { begin: 8704, end: 8959 }, { begin: 8960, end: 9215 }, { begin: 9216, end: 9279 }, { begin: 9280, end: 9311 }, { begin: 9312, end: 9471 }, { begin: 9472, end: 9599 }, { begin: 9600, end: 9631 }, { begin: 9632, end: 9727 }, { begin: 9728, end: 9983 }, { begin: 9984, end: 10175 }, { begin: 12288, end: 12351 }, { begin: 12352, end: 12447 }, { begin: 12448, end: 12543 }, { begin: 12544, end: 12591 }, { begin: 12592, end: 12687 }, { begin: 43072, end: 43135 }, { begin: 12800, end: 13055 }, { begin: 13056, end: 13311 }, { begin: 44032, end: 55215 }, { begin: 55296, end: 57343 }, { begin: 67840, end: 67871 }, { begin: 19968, end: 40959 }, { begin: 57344, end: 63743 }, { begin: 12736, end: 12783 }, { begin: 64256, end: 64335 }, { begin: 64336, end: 65023 }, { begin: 65056, end: 65071 }, { begin: 65040, end: 65055 }, { begin: 65104, end: 65135 }, { begin: 65136, end: 65279 }, { begin: 65280, end: 65519 }, { begin: 65520, end: 65535 }, { begin: 3840, end: 4095 }, { begin: 1792, end: 1871 }, { begin: 1920, end: 1983 }, { begin: 3456, end: 3583 }, { begin: 4096, end: 4255 }, { begin: 4608, end: 4991 }, { begin: 5024, end: 5119 }, { begin: 5120, end: 5759 }, { begin: 5760, end: 5791 }, { begin: 5792, end: 5887 }, { begin: 6016, end: 6143 }, { begin: 6144, end: 6319 }, { begin: 10240, end: 10495 }, { begin: 40960, end: 42127 }, { begin: 5888, end: 5919 }, { begin: 66304, end: 66351 }, { begin: 66352, end: 66383 }, { begin: 66560, end: 66639 }, { begin: 118784, end: 119039 }, { begin: 119808, end: 120831 }, { begin: 1044480, end: 1048573 }, { begin: 65024, end: 65039 }, { begin: 917504, end: 917631 }, { begin: 6400, end: 6479 }, { begin: 6480, end: 6527 }, { begin: 6528, end: 6623 }, { begin: 6656, end: 6687 }, { begin: 11264, end: 11359 }, { begin: 11568, end: 11647 }, { begin: 19904, end: 19967 }, { begin: 43008, end: 43055 }, { begin: 65536, end: 65663 }, { begin: 65856, end: 65935 }, { begin: 66432, end: 66463 }, { begin: 66464, end: 66527 }, { begin: 66640, end: 66687 }, { begin: 66688, end: 66735 }, { begin: 67584, end: 67647 }, { begin: 68096, end: 68191 }, { begin: 119552, end: 119647 }, { begin: 73728, end: 74751 }, { begin: 119648, end: 119679 }, { begin: 7040, end: 7103 }, { begin: 7168, end: 7247 }, { begin: 7248, end: 7295 }, { begin: 43136, end: 43231 }, { begin: 43264, end: 43311 }, { begin: 43312, end: 43359 }, { begin: 43520, end: 43615 }, { begin: 65936, end: 65999 }, { begin: 66e3, end: 66047 }, { begin: 66208, end: 66271 }, { begin: 127024, end: 127135 }];
              var ht = { parse: function(e4, t4) {
                var r3 = {}, o3 = new R.Parser(e4, t4);
                r3.version = o3.parseUShort(), r3.xAvgCharWidth = o3.parseShort(), r3.usWeightClass = o3.parseUShort(), r3.usWidthClass = o3.parseUShort(), r3.fsType = o3.parseUShort(), r3.ySubscriptXSize = o3.parseShort(), r3.ySubscriptYSize = o3.parseShort(), r3.ySubscriptXOffset = o3.parseShort(), r3.ySubscriptYOffset = o3.parseShort(), r3.ySuperscriptXSize = o3.parseShort(), r3.ySuperscriptYSize = o3.parseShort(), r3.ySuperscriptXOffset = o3.parseShort(), r3.ySuperscriptYOffset = o3.parseShort(), r3.yStrikeoutSize = o3.parseShort(), r3.yStrikeoutPosition = o3.parseShort(), r3.sFamilyClass = o3.parseShort(), r3.panose = [];
                for (var n2 = 0; n2 < 10; n2++)
                  r3.panose[n2] = o3.parseByte();
                return r3.ulUnicodeRange1 = o3.parseULong(), r3.ulUnicodeRange2 = o3.parseULong(), r3.ulUnicodeRange3 = o3.parseULong(), r3.ulUnicodeRange4 = o3.parseULong(), r3.achVendID = String.fromCharCode(o3.parseByte(), o3.parseByte(), o3.parseByte(), o3.parseByte()), r3.fsSelection = o3.parseUShort(), r3.usFirstCharIndex = o3.parseUShort(), r3.usLastCharIndex = o3.parseUShort(), r3.sTypoAscender = o3.parseShort(), r3.sTypoDescender = o3.parseShort(), r3.sTypoLineGap = o3.parseShort(), r3.usWinAscent = o3.parseUShort(), r3.usWinDescent = o3.parseUShort(), 1 <= r3.version && (r3.ulCodePageRange1 = o3.parseULong(), r3.ulCodePageRange2 = o3.parseULong()), 2 <= r3.version && (r3.sxHeight = o3.parseShort(), r3.sCapHeight = o3.parseShort(), r3.usDefaultChar = o3.parseUShort(), r3.usBreakChar = o3.parseUShort(), r3.usMaxContent = o3.parseUShort()), r3;
              }, make: function(e4) {
                return new S.Table("OS/2", [{ name: "version", type: "USHORT", value: 3 }, { name: "xAvgCharWidth", type: "SHORT", value: 0 }, { name: "usWeightClass", type: "USHORT", value: 0 }, { name: "usWidthClass", type: "USHORT", value: 0 }, { name: "fsType", type: "USHORT", value: 0 }, { name: "ySubscriptXSize", type: "SHORT", value: 650 }, { name: "ySubscriptYSize", type: "SHORT", value: 699 }, { name: "ySubscriptXOffset", type: "SHORT", value: 0 }, { name: "ySubscriptYOffset", type: "SHORT", value: 140 }, { name: "ySuperscriptXSize", type: "SHORT", value: 650 }, { name: "ySuperscriptYSize", type: "SHORT", value: 699 }, { name: "ySuperscriptXOffset", type: "SHORT", value: 0 }, { name: "ySuperscriptYOffset", type: "SHORT", value: 479 }, { name: "yStrikeoutSize", type: "SHORT", value: 49 }, { name: "yStrikeoutPosition", type: "SHORT", value: 258 }, { name: "sFamilyClass", type: "SHORT", value: 0 }, { name: "bFamilyType", type: "BYTE", value: 0 }, { name: "bSerifStyle", type: "BYTE", value: 0 }, { name: "bWeight", type: "BYTE", value: 0 }, { name: "bProportion", type: "BYTE", value: 0 }, { name: "bContrast", type: "BYTE", value: 0 }, { name: "bStrokeVariation", type: "BYTE", value: 0 }, { name: "bArmStyle", type: "BYTE", value: 0 }, { name: "bLetterform", type: "BYTE", value: 0 }, { name: "bMidline", type: "BYTE", value: 0 }, { name: "bXHeight", type: "BYTE", value: 0 }, { name: "ulUnicodeRange1", type: "ULONG", value: 0 }, { name: "ulUnicodeRange2", type: "ULONG", value: 0 }, { name: "ulUnicodeRange3", type: "ULONG", value: 0 }, { name: "ulUnicodeRange4", type: "ULONG", value: 0 }, { name: "achVendID", type: "CHARARRAY", value: "XXXX" }, { name: "fsSelection", type: "USHORT", value: 0 }, { name: "usFirstCharIndex", type: "USHORT", value: 0 }, { name: "usLastCharIndex", type: "USHORT", value: 0 }, { name: "sTypoAscender", type: "SHORT", value: 0 }, { name: "sTypoDescender", type: "SHORT", value: 0 }, { name: "sTypoLineGap", type: "SHORT", value: 0 }, { name: "usWinAscent", type: "USHORT", value: 0 }, { name: "usWinDescent", type: "USHORT", value: 0 }, { name: "ulCodePageRange1", type: "ULONG", value: 0 }, { name: "ulCodePageRange2", type: "ULONG", value: 0 }, { name: "sxHeight", type: "SHORT", value: 0 }, { name: "sCapHeight", type: "SHORT", value: 0 }, { name: "usDefaultChar", type: "USHORT", value: 0 }, { name: "usBreakChar", type: "USHORT", value: 0 }, { name: "usMaxContext", type: "USHORT", value: 0 }], e4);
              }, unicodeRanges: ft, getUnicodeRange: function(e4) {
                for (var t4 = 0; t4 < ft.length; t4 += 1) {
                  var r3 = ft[t4];
                  if (e4 >= r3.begin && e4 < r3.end)
                    return t4;
                }
                return -1;
              } };
              var pt = { parse: function(e4, t4) {
                var r3 = {}, o3 = new R.Parser(e4, t4);
                switch (r3.version = o3.parseVersion(), r3.italicAngle = o3.parseFixed(), r3.underlinePosition = o3.parseShort(), r3.underlineThickness = o3.parseShort(), r3.isFixedPitch = o3.parseULong(), r3.minMemType42 = o3.parseULong(), r3.maxMemType42 = o3.parseULong(), r3.minMemType1 = o3.parseULong(), r3.maxMemType1 = o3.parseULong(), r3.version) {
                  case 1:
                    r3.names = c.slice();
                    break;
                  case 2:
                    r3.numberOfGlyphs = o3.parseUShort(), r3.glyphNameIndex = new Array(r3.numberOfGlyphs);
                    for (var n2 = 0; n2 < r3.numberOfGlyphs; n2++)
                      r3.glyphNameIndex[n2] = o3.parseUShort();
                    r3.names = [];
                    for (var s3, i2 = 0; i2 < r3.numberOfGlyphs; i2++)
                      r3.glyphNameIndex[i2] >= c.length && (s3 = o3.parseChar(), r3.names.push(o3.parseString(s3)));
                    break;
                  case 2.5:
                    r3.numberOfGlyphs = o3.parseUShort(), r3.offset = new Array(r3.numberOfGlyphs);
                    for (var a2 = 0; a2 < r3.numberOfGlyphs; a2++)
                      r3.offset[a2] = o3.parseChar();
                }
                return r3;
              }, make: function() {
                return new S.Table("post", [{ name: "version", type: "FIXED", value: 196608 }, { name: "italicAngle", type: "FIXED", value: 0 }, { name: "underlinePosition", type: "FWORD", value: 0 }, { name: "underlineThickness", type: "FWORD", value: 0 }, { name: "isFixedPitch", type: "ULONG", value: 0 }, { name: "minMemType42", type: "ULONG", value: 0 }, { name: "maxMemType42", type: "ULONG", value: 0 }, { name: "minMemType1", type: "ULONG", value: 0 }, { name: "maxMemType1", type: "ULONG", value: 0 }]);
              } }, o2 = new Array(9), s2 = (o2[1] = function() {
                var e4 = this.offset + this.relativeOffset, t4 = this.parseUShort();
                return 1 === t4 ? { substFormat: 1, coverage: this.parsePointer(u.coverage), deltaGlyphId: this.parseUShort() } : 2 === t4 ? { substFormat: 2, coverage: this.parsePointer(u.coverage), substitute: this.parseOffset16List() } : void P.assert(false, "0x" + e4.toString(16) + ": lookup type 1 format must be 1 or 2.");
              }, o2[2] = function() {
                var e4 = this.parseUShort();
                return P.argument(1 === e4, "GSUB Multiple Substitution Subtable identifier-format must be 1"), { substFormat: e4, coverage: this.parsePointer(u.coverage), sequences: this.parseListOfLists() };
              }, o2[3] = function() {
                var e4 = this.parseUShort();
                return P.argument(1 === e4, "GSUB Alternate Substitution Subtable identifier-format must be 1"), { substFormat: e4, coverage: this.parsePointer(u.coverage), alternateSets: this.parseListOfLists() };
              }, o2[4] = function() {
                var e4 = this.parseUShort();
                return P.argument(1 === e4, "GSUB ligature table identifier-format must be 1"), { substFormat: e4, coverage: this.parsePointer(u.coverage), ligatureSets: this.parseListOfLists(function() {
                  return { ligGlyph: this.parseUShort(), components: this.parseUShortList(this.parseUShort() - 1) };
                }) };
              }, { sequenceIndex: u.uShort, lookupListIndex: u.uShort });
              o2[5] = function() {
                var e4, t4, r3 = this.offset + this.relativeOffset, o3 = this.parseUShort();
                return 1 === o3 ? { substFormat: o3, coverage: this.parsePointer(u.coverage), ruleSets: this.parseListOfLists(function() {
                  var e5 = this.parseUShort(), t5 = this.parseUShort();
                  return { input: this.parseUShortList(e5 - 1), lookupRecords: this.parseRecordList(t5, s2) };
                }) } : 2 === o3 ? { substFormat: o3, coverage: this.parsePointer(u.coverage), classDef: this.parsePointer(u.classDef), classSets: this.parseListOfLists(function() {
                  var e5 = this.parseUShort(), t5 = this.parseUShort();
                  return { classes: this.parseUShortList(e5 - 1), lookupRecords: this.parseRecordList(t5, s2) };
                }) } : 3 === o3 ? (e4 = this.parseUShort(), t4 = this.parseUShort(), { substFormat: o3, coverages: this.parseList(e4, u.pointer(u.coverage)), lookupRecords: this.parseRecordList(t4, s2) }) : void P.assert(false, "0x" + r3.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
              }, o2[6] = function() {
                var e4 = this.offset + this.relativeOffset, t4 = this.parseUShort();
                return 1 === t4 ? { substFormat: 1, coverage: this.parsePointer(u.coverage), chainRuleSets: this.parseListOfLists(function() {
                  return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(s2) };
                }) } : 2 === t4 ? { substFormat: 2, coverage: this.parsePointer(u.coverage), backtrackClassDef: this.parsePointer(u.classDef), inputClassDef: this.parsePointer(u.classDef), lookaheadClassDef: this.parsePointer(u.classDef), chainClassSet: this.parseListOfLists(function() {
                  return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(s2) };
                }) } : 3 === t4 ? { substFormat: 3, backtrackCoverage: this.parseList(u.pointer(u.coverage)), inputCoverage: this.parseList(u.pointer(u.coverage)), lookaheadCoverage: this.parseList(u.pointer(u.coverage)), lookupRecords: this.parseRecordList(s2) } : void P.assert(false, "0x" + e4.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
              }, o2[7] = function() {
                var e4 = this.parseUShort(), e4 = (P.argument(1 === e4, "GSUB Extension Substitution subtable identifier-format must be 1"), this.parseUShort()), t4 = new u(this.data, this.offset + this.parseULong());
                return { substFormat: 1, lookupType: e4, extension: o2[e4].call(t4) };
              }, o2[8] = function() {
                var e4 = this.parseUShort();
                return P.argument(1 === e4, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), { substFormat: e4, coverage: this.parsePointer(u.coverage), backtrackCoverage: this.parseList(u.pointer(u.coverage)), lookaheadCoverage: this.parseList(u.pointer(u.coverage)), substitutes: this.parseUShortList() };
              };
              var mt = new Array(9);
              mt[1] = function(e4) {
                return 1 === e4.substFormat ? new S.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new S.Coverage(e4.coverage) }, { name: "deltaGlyphID", type: "USHORT", value: e4.deltaGlyphId }]) : new S.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 2 }, { name: "coverage", type: "TABLE", value: new S.Coverage(e4.coverage) }].concat(S.ushortList("substitute", e4.substitute)));
              }, mt[3] = function(e4) {
                return P.assert(1 === e4.substFormat, "Lookup type 3 substFormat must be 1."), new S.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new S.Coverage(e4.coverage) }].concat(S.tableList("altSet", e4.alternateSets, function(e5) {
                  return new S.Table("alternateSetTable", S.ushortList("alternate", e5));
                })));
              }, mt[4] = function(e4) {
                return P.assert(1 === e4.substFormat, "Lookup type 4 substFormat must be 1."), new S.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new S.Coverage(e4.coverage) }].concat(S.tableList("ligSet", e4.ligatureSets, function(e5) {
                  return new S.Table("ligatureSetTable", S.tableList("ligature", e5, function(e6) {
                    return new S.Table("ligatureTable", [{ name: "ligGlyph", type: "USHORT", value: e6.ligGlyph }].concat(S.ushortList("component", e6.components, e6.components.length + 1)));
                  }));
                })));
              };
              var yt = { parse: function(e4, t4) {
                return t4 = (e4 = new u(e4, t4 = t4 || 0)).parseVersion(1), P.argument(1 === t4 || 1.1 === t4, "Unsupported GSUB table version."), 1 === t4 ? { version: t4, scripts: e4.parseScriptList(), features: e4.parseFeatureList(), lookups: e4.parseLookupList(o2) } : { version: t4, scripts: e4.parseScriptList(), features: e4.parseFeatureList(), lookups: e4.parseLookupList(o2), variations: e4.parseFeatureVariationsList() };
              }, make: function(e4) {
                return new S.Table("GSUB", [{ name: "version", type: "ULONG", value: 65536 }, { name: "scripts", type: "TABLE", value: new S.ScriptList(e4.scripts) }, { name: "features", type: "TABLE", value: new S.FeatureList(e4.features) }, { name: "lookups", type: "TABLE", value: new S.LookupList(e4.lookups, mt) }]);
              } };
              var gt = { parse: function(e4, t4) {
                for (var r3 = new R.Parser(e4, t4), o3 = r3.parseULong(), n2 = (P.argument(1 === o3, "Unsupported META table version."), r3.parseULong(), r3.parseULong(), r3.parseULong()), s3 = {}, i2 = 0; i2 < n2; i2++) {
                  var a2 = r3.parseTag(), l2 = r3.parseULong(), u2 = r3.parseULong(), l2 = m.UTF8(e4, t4 + l2, u2);
                  s3[a2] = l2;
                }
                return s3;
              }, make: function(e4) {
                var t4, r3 = Object.keys(e4).length, o3 = "", n2 = 16 + 12 * r3, s3 = new S.Table("meta", [{ name: "version", type: "ULONG", value: 1 }, { name: "flags", type: "ULONG", value: 0 }, { name: "offset", type: "ULONG", value: n2 }, { name: "numTags", type: "ULONG", value: r3 }]);
                for (t4 in e4) {
                  var i2 = o3.length;
                  o3 += e4[t4], s3.fields.push({ name: "tag " + t4, type: "TAG", value: t4 }), s3.fields.push({ name: "offset " + t4, type: "ULONG", value: n2 + i2 }), s3.fields.push({ name: "length " + t4, type: "ULONG", value: e4[t4].length });
                }
                return s3.fields.push({ name: "stringPool", type: "CHARARRAY", value: o3 }), s3;
              } };
              function vt(e4) {
                return Math.log(e4) / Math.log(2) | 0;
              }
              function bt(e4) {
                for (; e4.length % 4 != 0; )
                  e4.push(0);
                for (var t4 = 0, r3 = 0; r3 < e4.length; r3 += 4)
                  t4 += (e4[r3] << 24) + (e4[r3 + 1] << 16) + (e4[r3 + 2] << 8) + e4[r3 + 3];
                return t4 %= Math.pow(2, 32);
              }
              function jt(e4, t4, r3, o3) {
                return new S.Record("Table Record", [{ name: "tag", type: "TAG", value: void 0 !== e4 ? e4 : "" }, { name: "checkSum", type: "ULONG", value: void 0 !== t4 ? t4 : 0 }, { name: "offset", type: "ULONG", value: void 0 !== r3 ? r3 : 0 }, { name: "length", type: "ULONG", value: void 0 !== o3 ? o3 : 0 }]);
              }
              function _t(e4) {
                for (var t4 = new S.Table("sfnt", [{ name: "version", type: "TAG", value: "OTTO" }, { name: "numTables", type: "USHORT", value: 0 }, { name: "searchRange", type: "USHORT", value: 0 }, { name: "entrySelector", type: "USHORT", value: 0 }, { name: "rangeShift", type: "USHORT", value: 0 }]), r3 = (t4.tables = e4, t4.numTables = e4.length, Math.pow(2, vt(t4.numTables))), o3 = (t4.searchRange = 16 * r3, t4.entrySelector = vt(r3), t4.rangeShift = 16 * t4.numTables - t4.searchRange, []), n2 = [], s3 = t4.sizeOf() + jt().sizeOf() * t4.numTables; s3 % 4 != 0; )
                  s3 += 1, n2.push({ name: "padding", type: "BYTE", value: 0 });
                for (var i2 = 0; i2 < e4.length; i2 += 1) {
                  var a2 = e4[i2], l2 = (P.argument(4 === a2.tableName.length, "Table name" + a2.tableName + " is invalid."), a2.sizeOf()), u2 = jt(a2.tableName, bt(a2.encode()), s3, l2);
                  for (o3.push({ name: u2.tag + " Table Record", type: "RECORD", value: u2 }), n2.push({ name: a2.tableName + " table", type: "RECORD", value: a2 }), s3 += l2, P.argument(!isNaN(s3), "Something went wrong calculating the offset."); s3 % 4 != 0; )
                    s3 += 1, n2.push({ name: "padding", type: "BYTE", value: 0 });
                }
                return o3.sort(function(e5, t5) {
                  return e5.value.tag > t5.value.tag ? 1 : -1;
                }), t4.fields = t4.fields.concat(o3), t4.fields = t4.fields.concat(n2), t4;
              }
              function xt(e4, t4, r3) {
                for (var o3 = 0; o3 < t4.length; o3 += 1) {
                  var n2 = e4.charToGlyphIndex(t4[o3]);
                  if (0 < n2)
                    return e4.glyphs.get(n2).getMetrics();
                }
                return r3;
              }
              var wt = { make: _t, fontToTable: function(e4) {
                for (var t4, r3 = [], o3 = [], n2 = [], s3 = [], i2 = [], a2 = [], l2 = [], u2 = 0, c2 = 0, d2 = 0, f2 = 0, h2 = 0, p2 = 0; p2 < e4.glyphs.length; p2 += 1) {
                  var m2 = e4.glyphs.get(p2), y2 = 0 | m2.unicode;
                  if (isNaN(m2.advanceWidth))
                    throw new Error("Glyph " + m2.name + " (" + p2 + "): advanceWidth is not a number.");
                  (y2 < t4 || void 0 === t4) && 0 < y2 && (t4 = y2), u2 < y2 && (u2 = y2);
                  var y2 = ht.getUnicodeRange(y2);
                  if (y2 < 32)
                    c2 |= 1 << y2;
                  else if (y2 < 64)
                    d2 |= 1 << y2 - 32;
                  else if (y2 < 96)
                    f2 |= 1 << y2 - 64;
                  else {
                    if (!(y2 < 123))
                      throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
                    h2 |= 1 << y2 - 96;
                  }
                  ".notdef" !== m2.name && (y2 = m2.getMetrics(), r3.push(y2.xMin), o3.push(y2.yMin), n2.push(y2.xMax), s3.push(y2.yMax), a2.push(y2.leftSideBearing), l2.push(y2.rightSideBearing), i2.push(m2.advanceWidth));
                }
                var g2, v2 = { xMin: Math.min.apply(null, r3), yMin: Math.min.apply(null, o3), xMax: Math.max.apply(null, n2), yMax: Math.max.apply(null, s3), advanceWidthMax: Math.max.apply(null, i2), advanceWidthAvg: function(e5) {
                  for (var t5 = 0, r4 = 0; r4 < e5.length; r4 += 1)
                    t5 += e5[r4];
                  return t5 / e5.length;
                }(i2), minLeftSideBearing: Math.min.apply(null, a2), maxLeftSideBearing: Math.max.apply(null, a2), minRightSideBearing: Math.min.apply(null, l2) }, b2 = (v2.ascender = e4.ascender, v2.descender = e4.descender, Ze.make({ flags: 3, unitsPerEm: e4.unitsPerEm, xMin: v2.xMin, yMin: v2.yMin, xMax: v2.xMax, yMax: v2.yMax, lowestRecPPEM: 3, createdTimestamp: e4.createdTimestamp })), j2 = Qe.make({ ascender: v2.ascender, descender: v2.descender, advanceWidthMax: v2.advanceWidthMax, minLeftSideBearing: v2.minLeftSideBearing, minRightSideBearing: v2.minRightSideBearing, xMaxExtent: v2.maxLeftSideBearing + (v2.xMax - v2.xMin), numberOfHMetrics: e4.glyphs.length }), _2 = $e.make(e4.glyphs.length), x2 = ht.make({ xAvgCharWidth: Math.round(v2.advanceWidthAvg), usWeightClass: e4.tables.os2.usWeightClass, usWidthClass: e4.tables.os2.usWidthClass, usFirstCharIndex: t4, usLastCharIndex: u2, ulUnicodeRange1: c2, ulUnicodeRange2: d2, ulUnicodeRange3: f2, ulUnicodeRange4: h2, fsSelection: e4.tables.os2.fsSelection, sTypoAscender: v2.ascender, sTypoDescender: v2.descender, sTypoLineGap: 0, usWinAscent: v2.yMax, usWinDescent: Math.abs(v2.yMin), ulCodePageRange1: 1, sxHeight: xt(e4, "xyvw", { yMax: Math.round(v2.ascender / 2) }).yMax, sCapHeight: xt(e4, "HIKLEFJMNTZBDPRAGOQSUVWXY", v2).yMax, usDefaultChar: e4.hasChar(" ") ? 32 : 0, usBreakChar: e4.hasChar(" ") ? 32 : 0 }), w2 = Ke.make(e4.glyphs), S2 = we.make(e4.glyphs), M2 = e4.getEnglishName("fontFamily"), E2 = e4.getEnglishName("fontSubfamily"), T2 = M2 + " " + E2, C2 = (C2 = e4.getEnglishName("postScriptName")) || M2.replace(/\s/g, "") + "-" + E2, O2 = {};
                for (g2 in e4.names)
                  O2[g2] = e4.names[g2];
                O2.uniqueID || (O2.uniqueID = { en: e4.getEnglishName("manufacturer") + ":" + T2 }), O2.postScriptName || (O2.postScriptName = { en: C2 }), O2.preferredFamily || (O2.preferredFamily = e4.names.fontFamily), O2.preferredSubfamily || (O2.preferredSubfamily = e4.names.fontSubfamily);
                var L2 = [], k2 = dt.make(O2, L2), L2 = 0 < L2.length ? Je.make(L2) : void 0, A2 = pt.make(), T2 = Ye.make(e4.glyphs, { version: e4.getEnglishName("version"), fullName: T2, familyName: M2, weightName: E2, postScriptName: C2, unitsPerEm: e4.unitsPerEm, fontBBox: [0, v2.yMin, v2.ascender, v2.advanceWidthMax] }), M2 = e4.metas && 0 < Object.keys(e4.metas).length ? gt.make(e4.metas) : void 0, E2 = [b2, j2, _2, x2, k2, S2, A2, T2, w2];
                L2 && E2.push(L2), e4.tables.gsub && E2.push(yt.make(e4.tables.gsub)), M2 && E2.push(M2);
                for (var I2 = bt((C2 = _t(E2)).encode()), P2 = C2.fields, R2 = false, D2 = 0; D2 < P2.length; D2 += 1)
                  if ("head table" === P2[D2].name) {
                    P2[D2].value.checkSumAdjustment = 2981146554 - I2, R2 = true;
                    break;
                  }
                if (R2)
                  return C2;
                throw new Error("Could not find head table with checkSum to adjust.");
              }, computeCheckSum: bt };
              function St(e4, t4) {
                for (var r3 = 0, o3 = e4.length - 1; r3 <= o3; ) {
                  var n2 = r3 + o3 >>> 1, s3 = e4[n2].tag;
                  if (s3 === t4)
                    return n2;
                  s3 < t4 ? r3 = 1 + n2 : o3 = n2 - 1;
                }
                return -r3 - 1;
              }
              function Mt(e4, t4) {
                for (var r3 = 0, o3 = e4.length - 1; r3 <= o3; ) {
                  var n2 = r3 + o3 >>> 1, s3 = e4[n2];
                  if (s3 === t4)
                    return n2;
                  s3 < t4 ? r3 = 1 + n2 : o3 = n2 - 1;
                }
                return -r3 - 1;
              }
              function Et(e4, t4) {
                for (var r3 = 0, o3 = e4.length - 1; r3 <= o3; ) {
                  var n2, s3 = r3 + o3 >>> 1, i2 = (n2 = e4[s3]).start;
                  if (i2 === t4)
                    return n2;
                  i2 < t4 ? r3 = 1 + s3 : o3 = s3 - 1;
                }
                if (0 < r3)
                  return t4 > (n2 = e4[r3 - 1]).end ? 0 : n2;
              }
              function Tt(e4, t4) {
                this.font = e4, this.tableName = t4;
              }
              function Ct(e4) {
                Tt.call(this, e4, "gpos");
              }
              function i(e4) {
                Tt.call(this, e4, "gsub");
              }
              function Ot(e4, t4, r3) {
                for (var o3 = e4.subtables, n2 = 0; n2 < o3.length; n2++) {
                  var s3 = o3[n2];
                  if (s3.substFormat === t4)
                    return s3;
                }
                if (r3)
                  return o3.push(r3), r3;
              }
              function Lt(e4) {
                for (var t4 = new ArrayBuffer(e4.length), r3 = new Uint8Array(t4), o3 = 0; o3 < e4.length; ++o3)
                  r3[o3] = e4[o3];
                return t4;
              }
              function _(e4, t4) {
                if (!e4)
                  throw t4;
              }
              function kt(e4, t4, r3, o3, n2) {
                var s3 = 0 < (t4 & o3) ? (s3 = e4.parseByte(), r3 + (s3 = 0 == (t4 & n2) ? -s3 : s3)) : 0 < (t4 & n2) ? r3 : r3 + e4.parseShort();
                return s3;
              }
              function At(e4, t4, r3) {
                var o3, n2 = new R.Parser(t4, r3);
                if (e4.numberOfContours = n2.parseShort(), e4._xMin = n2.parseShort(), e4._yMin = n2.parseShort(), e4._xMax = n2.parseShort(), e4._yMax = n2.parseShort(), 0 < e4.numberOfContours) {
                  for (var s3 = e4.endPointIndices = [], i2 = 0; i2 < e4.numberOfContours; i2 += 1)
                    s3.push(n2.parseUShort());
                  e4.instructionLength = n2.parseUShort(), e4.instructions = [];
                  for (var a2 = 0; a2 < e4.instructionLength; a2 += 1)
                    e4.instructions.push(n2.parseByte());
                  for (var l2 = s3[s3.length - 1] + 1, u2 = [], c2 = 0; c2 < l2; c2 += 1)
                    if (o3 = n2.parseByte(), u2.push(o3), 0 < (8 & o3))
                      for (var d2 = n2.parseByte(), f2 = 0; f2 < d2; f2 += 1)
                        u2.push(o3), c2 += 1;
                  if (P.argument(u2.length === l2, "Bad flags."), 0 < s3.length) {
                    var h2, p2 = [];
                    if (0 < l2) {
                      for (var m2 = 0; m2 < l2; m2 += 1)
                        o3 = u2[m2], (h2 = {}).onCurve = !!(1 & o3), h2.lastPointOfContour = 0 <= s3.indexOf(m2), p2.push(h2);
                      for (var y2 = 0, g2 = 0; g2 < l2; g2 += 1)
                        o3 = u2[g2], (h2 = p2[g2]).x = kt(n2, o3, y2, 2, 16), y2 = h2.x;
                      for (var v2 = 0, b2 = 0; b2 < l2; b2 += 1)
                        o3 = u2[b2], (h2 = p2[b2]).y = kt(n2, o3, v2, 4, 32), v2 = h2.y;
                    }
                    e4.points = p2;
                  } else
                    e4.points = [];
                } else if (0 === e4.numberOfContours)
                  e4.points = [];
                else {
                  e4.isComposite = true, e4.points = [], e4.components = [];
                  for (var j2 = true; j2; ) {
                    u2 = n2.parseUShort();
                    var _2 = { glyphIndex: n2.parseUShort(), xScale: 1, scale01: 0, scale10: 0, yScale: 1, dx: 0, dy: 0 };
                    0 < (1 & u2) ? 0 < (2 & u2) ? (_2.dx = n2.parseShort(), _2.dy = n2.parseShort()) : _2.matchedPoints = [n2.parseUShort(), n2.parseUShort()] : 0 < (2 & u2) ? (_2.dx = n2.parseChar(), _2.dy = n2.parseChar()) : _2.matchedPoints = [n2.parseByte(), n2.parseByte()], 0 < (8 & u2) ? _2.xScale = _2.yScale = n2.parseF2Dot14() : 0 < (64 & u2) ? (_2.xScale = n2.parseF2Dot14(), _2.yScale = n2.parseF2Dot14()) : 0 < (128 & u2) && (_2.xScale = n2.parseF2Dot14(), _2.scale01 = n2.parseF2Dot14(), _2.scale10 = n2.parseF2Dot14(), _2.yScale = n2.parseF2Dot14()), e4.components.push(_2), j2 = !!(32 & u2);
                  }
                  if (256 & u2) {
                    e4.instructionLength = n2.parseUShort(), e4.instructions = [];
                    for (var x2 = 0; x2 < e4.instructionLength; x2 += 1)
                      e4.instructions.push(n2.parseByte());
                  }
                }
              }
              function Pt(e4, t4) {
                for (var r3 = [], o3 = 0; o3 < e4.length; o3 += 1) {
                  var n2 = e4[o3], n2 = { x: t4.xScale * n2.x + t4.scale01 * n2.y + t4.dx, y: t4.scale10 * n2.x + t4.yScale * n2.y + t4.dy, onCurve: n2.onCurve, lastPointOfContour: n2.lastPointOfContour };
                  r3.push(n2);
                }
                return r3;
              }
              function Rt(e4) {
                var t4 = new f();
                if (e4)
                  for (var r3 = function(e5) {
                    for (var t5 = [], r4 = [], o4 = 0; o4 < e5.length; o4 += 1) {
                      var n3 = e5[o4];
                      r4.push(n3), n3.lastPointOfContour && (t5.push(r4), r4 = []);
                    }
                    return P.argument(0 === r4.length, "There are still points left in the current contour."), t5;
                  }(e4), o3 = 0; o3 < r3.length; ++o3) {
                    var n2, s3 = r3[o3], i2 = s3[s3.length - 1], a2 = s3[0];
                    i2.onCurve ? t4.moveTo(i2.x, i2.y) : a2.onCurve ? t4.moveTo(a2.x, a2.y) : (n2 = { x: 0.5 * (i2.x + a2.x), y: 0.5 * (i2.y + a2.y) }, t4.moveTo(n2.x, n2.y));
                    for (var l2 = 0; l2 < s3.length; ++l2) {
                      var u2, c2 = i2, i2 = a2, a2 = s3[(l2 + 1) % s3.length];
                      i2.onCurve ? t4.lineTo(i2.x, i2.y) : (u2 = a2, c2.onCurve || (i2.x, c2.x, i2.y, c2.y), a2.onCurve || (u2 = { x: 0.5 * (i2.x + a2.x), y: 0.5 * (i2.y + a2.y) }), t4.quadraticCurveTo(i2.x, i2.y, u2.x, u2.y));
                    }
                    t4.closePath();
                  }
                return t4;
              }
              function Dt(e4, t4) {
                if (t4.isComposite)
                  for (var r3 = 0; r3 < t4.components.length; r3 += 1) {
                    var o3 = t4.components[r3], n2 = e4.get(o3.glyphIndex);
                    if (n2.getPath(), n2.points) {
                      var s3 = void 0;
                      if (void 0 === o3.matchedPoints)
                        s3 = Pt(n2.points, o3);
                      else {
                        if (o3.matchedPoints[0] > t4.points.length - 1 || o3.matchedPoints[1] > n2.points.length - 1)
                          throw Error("Matched points out of range in " + t4.name);
                        var i2 = t4.points[o3.matchedPoints[0]], a2 = n2.points[o3.matchedPoints[1]], o3 = { xScale: o3.xScale, scale01: o3.scale01, scale10: o3.scale10, yScale: o3.yScale, dx: 0, dy: 0 }, a2 = Pt([a2], o3)[0];
                        o3.dx = i2.x - a2.x, o3.dy = i2.y - a2.y, s3 = Pt(n2.points, o3);
                      }
                      t4.points = t4.points.concat(s3);
                    }
                  }
                return Rt(t4.points);
              }
              (Ct.prototype = Tt.prototype = { searchTag: St, binSearch: Mt, getTable: function(e4) {
                var t4 = this.font.tables[this.tableName];
                return t4 = !t4 && e4 ? this.font.tables[this.tableName] = this.createDefaultTable() : t4;
              }, getScriptNames: function() {
                var e4 = this.getTable();
                return e4 ? e4.scripts.map(function(e5) {
                  return e5.tag;
                }) : [];
              }, getDefaultScriptName: function() {
                var e4 = this.getTable();
                if (e4) {
                  for (var t4 = false, r3 = 0; r3 < e4.scripts.length; r3++) {
                    var o3 = e4.scripts[r3].tag;
                    if ("DFLT" === o3)
                      return o3;
                    "latn" === o3 && (t4 = true);
                  }
                  return t4 ? "latn" : void 0;
                }
              }, getScriptTable: function(e4, t4) {
                var r3, o3 = this.getTable(t4);
                if (o3)
                  return r3 = o3.scripts, 0 <= (o3 = St(o3.scripts, e4 = e4 || "DFLT")) ? r3[o3].script : t4 ? (r3.splice(-1 - o3, 0, t4 = { tag: e4, script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } }), t4.script) : void 0;
              }, getLangSysTable: function(e4, t4, r3) {
                var o3, e4 = this.getScriptTable(e4, r3);
                if (e4)
                  return t4 && "dflt" !== t4 && "DFLT" !== t4 ? 0 <= (o3 = St(e4.langSysRecords, t4)) ? e4.langSysRecords[o3].langSys : r3 ? (e4.langSysRecords.splice(-1 - o3, 0, r3 = { tag: t4, langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] } }), r3.langSys) : void 0 : e4.defaultLangSys;
              }, getFeatureTable: function(e4, t4, r3, o3) {
                e4 = this.getLangSysTable(e4, t4, o3);
                if (e4) {
                  for (var n2, s3 = e4.featureIndexes, i2 = this.font.tables[this.tableName].features, a2 = 0; a2 < s3.length; a2++)
                    if ((n2 = i2[s3[a2]]).tag === r3)
                      return n2.feature;
                  if (o3)
                    return t4 = i2.length, P.assert(0 === t4 || r3 >= i2[t4 - 1].tag, "Features must be added in alphabetical order."), i2.push(n2 = { tag: r3, feature: { params: 0, lookupListIndexes: [] } }), s3.push(t4), n2.feature;
                }
              }, getLookupTables: function(e4, t4, r3, o3, n2) {
                var e4 = this.getFeatureTable(e4, t4, r3, n2), s3 = [];
                if (e4) {
                  for (var i2, a2 = e4.lookupListIndexes, l2 = this.font.tables[this.tableName].lookups, u2 = 0; u2 < a2.length; u2++)
                    (i2 = l2[a2[u2]]).lookupType === o3 && s3.push(i2);
                  if (0 === s3.length && n2)
                    return t4 = l2.length, l2.push(i2 = { lookupType: o3, lookupFlag: 0, subtables: [], markFilteringSet: void 0 }), a2.push(t4), [i2];
                }
                return s3;
              }, getGlyphClass: function(e4, t4) {
                switch (e4.format) {
                  case 1:
                    return e4.startGlyph <= t4 && t4 < e4.startGlyph + e4.classes.length ? e4.classes[t4 - e4.startGlyph] : 0;
                  case 2:
                    var r3 = Et(e4.ranges, t4);
                    return r3 ? r3.classId : 0;
                }
              }, getCoverageIndex: function(e4, t4) {
                switch (e4.format) {
                  case 1:
                    var r3 = Mt(e4.glyphs, t4);
                    return 0 <= r3 ? r3 : -1;
                  case 2:
                    r3 = Et(e4.ranges, t4);
                    return r3 ? r3.index + t4 - r3.start : -1;
                }
              }, expandCoverage: function(e4) {
                if (1 === e4.format)
                  return e4.glyphs;
                for (var t4 = [], r3 = e4.ranges, o3 = 0; o3 < r3.length; o3++)
                  for (var n2 = r3[o3], s3 = n2.start, i2 = n2.end, a2 = s3; a2 <= i2; a2++)
                    t4.push(a2);
                return t4;
              } }).init = function() {
                var e4 = this.getDefaultScriptName();
                this.defaultKerningTables = this.getKerningTables(e4);
              }, Ct.prototype.getKerningValue = function(e4, t4, r3) {
                for (var o3 = 0; o3 < e4.length; o3++)
                  for (var n2 = e4[o3].subtables, s3 = 0; s3 < n2.length; s3++) {
                    var i2 = n2[s3], a2 = this.getCoverageIndex(i2.coverage, t4);
                    if (!(a2 < 0))
                      switch (i2.posFormat) {
                        case 1:
                          for (var l2 = i2.pairSets[a2], u2 = 0; u2 < l2.length; u2++) {
                            var c2 = l2[u2];
                            if (c2.secondGlyph === r3)
                              return c2.value1 && c2.value1.xAdvance || 0;
                          }
                          break;
                        case 2:
                          var d2 = this.getGlyphClass(i2.classDef1, t4), f2 = this.getGlyphClass(i2.classDef2, r3), d2 = i2.classRecords[d2][f2];
                          return d2.value1 && d2.value1.xAdvance || 0;
                      }
                  }
                return 0;
              }, Ct.prototype.getKerningTables = function(e4, t4) {
                if (this.font.tables.gpos)
                  return this.getLookupTables(e4, t4, "kern", 2);
              }, (i.prototype = Tt.prototype).createDefaultTable = function() {
                return { version: 1, scripts: [{ tag: "DFLT", script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } }], features: [], lookups: [] };
              }, i.prototype.getSingle = function(e4, t4, r3) {
                for (var o3 = [], n2 = this.getLookupTables(t4, r3, e4, 1), s3 = 0; s3 < n2.length; s3++)
                  for (var i2 = n2[s3].subtables, a2 = 0; a2 < i2.length; a2++) {
                    var l2 = i2[a2], u2 = this.expandCoverage(l2.coverage), c2 = void 0;
                    if (1 === l2.substFormat)
                      for (var d2 = l2.deltaGlyphId, c2 = 0; c2 < u2.length; c2++) {
                        var f2 = u2[c2];
                        o3.push({ sub: f2, by: f2 + d2 });
                      }
                    else {
                      var h2 = l2.substitute;
                      for (c2 = 0; c2 < u2.length; c2++)
                        o3.push({ sub: u2[c2], by: h2[c2] });
                    }
                  }
                return o3;
              }, i.prototype.getAlternates = function(e4, t4, r3) {
                for (var o3 = [], n2 = this.getLookupTables(t4, r3, e4, 3), s3 = 0; s3 < n2.length; s3++)
                  for (var i2 = n2[s3].subtables, a2 = 0; a2 < i2.length; a2++)
                    for (var l2 = i2[a2], u2 = this.expandCoverage(l2.coverage), c2 = l2.alternateSets, d2 = 0; d2 < u2.length; d2++)
                      o3.push({ sub: u2[d2], by: c2[d2] });
                return o3;
              }, i.prototype.getLigatures = function(e4, t4, r3) {
                for (var o3 = [], n2 = this.getLookupTables(t4, r3, e4, 4), s3 = 0; s3 < n2.length; s3++)
                  for (var i2 = n2[s3].subtables, a2 = 0; a2 < i2.length; a2++)
                    for (var l2 = i2[a2], u2 = this.expandCoverage(l2.coverage), c2 = l2.ligatureSets, d2 = 0; d2 < u2.length; d2++)
                      for (var f2 = u2[d2], h2 = c2[d2], p2 = 0; p2 < h2.length; p2++) {
                        var m2 = h2[p2];
                        o3.push({ sub: [f2].concat(m2.components), by: m2.ligGlyph });
                      }
                return o3;
              }, i.prototype.addSingle = function(e4, t4, r3, o3) {
                r3 = Ot(this.getLookupTables(r3, o3, e4, 1, true)[0], 2, { substFormat: 2, coverage: { format: 1, glyphs: [] }, substitute: [] }), P.assert(1 === r3.coverage.format, "Ligature: unable to modify coverage table format " + r3.coverage.format), o3 = t4.sub, e4 = this.binSearch(r3.coverage.glyphs, o3);
                e4 < 0 && (r3.coverage.glyphs.splice(e4 = -1 - e4, 0, o3), r3.substitute.splice(e4, 0, 0)), r3.substitute[e4] = t4.by;
              }, i.prototype.addAlternate = function(e4, t4, r3, o3) {
                r3 = Ot(this.getLookupTables(r3, o3, e4, 3, true)[0], 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, alternateSets: [] }), P.assert(1 === r3.coverage.format, "Ligature: unable to modify coverage table format " + r3.coverage.format), o3 = t4.sub, e4 = this.binSearch(r3.coverage.glyphs, o3);
                e4 < 0 && (r3.coverage.glyphs.splice(e4 = -1 - e4, 0, o3), r3.alternateSets.splice(e4, 0, 0)), r3.alternateSets[e4] = t4.by;
              }, i.prototype.addLigature = function(e4, t4, r3, o3) {
                var r3 = this.getLookupTables(r3, o3, e4, 4, true)[0], o3 = r3.subtables[0], e4 = (o3 || (r3.subtables[0] = o3 = { substFormat: 1, coverage: { format: 1, glyphs: [] }, ligatureSets: [] }), P.assert(1 === o3.coverage.format, "Ligature: unable to modify coverage table format " + o3.coverage.format), t4.sub[0]), n2 = t4.sub.slice(1), r3 = { ligGlyph: t4.by, components: n2 }, t4 = this.binSearch(o3.coverage.glyphs, e4);
                if (0 <= t4) {
                  for (var s3 = o3.ligatureSets[t4], i2 = 0; i2 < s3.length; i2++)
                    if (function(e5, t5) {
                      var r4 = e5.length;
                      if (r4 === t5.length) {
                        for (var o4 = 0; o4 < r4; o4++)
                          if (e5[o4] !== t5[o4])
                            return;
                        return 1;
                      }
                    }(s3[i2].components, n2))
                      return;
                  s3.push(r3);
                } else
                  o3.coverage.glyphs.splice(t4 = -1 - t4, 0, e4), o3.ligatureSets.splice(t4, 0, [r3]);
              }, i.prototype.getFeature = function(e4, t4, r3) {
                if (/ss\d\d/.test(e4))
                  return this.getSingle(e4, t4, r3);
                switch (e4) {
                  case "aalt":
                  case "salt":
                    return this.getSingle(e4, t4, r3).concat(this.getAlternates(e4, t4, r3));
                  case "dlig":
                  case "liga":
                  case "rlig":
                    return this.getLigatures(e4, t4, r3);
                }
              }, i.prototype.add = function(e4, t4, r3, o3) {
                if (/ss\d\d/.test(e4))
                  return this.addSingle(e4, t4, r3, o3);
                switch (e4) {
                  case "aalt":
                  case "salt":
                    return "number" == typeof t4.by ? this.addSingle(e4, t4, r3, o3) : this.addAlternate(e4, t4, r3, o3);
                  case "dlig":
                  case "liga":
                  case "rlig":
                    return this.addLigature(e4, t4, r3, o3);
                }
              };
              var It = { getPath: Rt, parse: function(e4, t4, r3, o3) {
                for (var n2 = new p.GlyphSet(o3), s3 = 0; s3 < r3.length - 1; s3 += 1) {
                  var i2 = r3[s3];
                  i2 !== r3[s3 + 1] ? n2.push(s3, p.ttfGlyphLoader(o3, s3, At, e4, t4 + i2, Dt)) : n2.push(s3, p.glyphLoader(o3, s3));
                }
                return n2;
              } };
              function Ut(e4) {
                this.font = e4, this.getCommands = function(e5) {
                  return It.getPath(e5).commands;
                }, this._fpgmState = this._prepState = void 0, this._errorState = 0;
              }
              function Nt(e4) {
                return e4;
              }
              function Ft(e4) {
                return Math.sign(e4) * Math.round(Math.abs(e4));
              }
              function Bt(e4) {
                return Math.sign(e4) * Math.round(Math.abs(2 * e4)) / 2;
              }
              function Gt(e4) {
                return Math.sign(e4) * (Math.round(Math.abs(e4) + 0.5) - 0.5);
              }
              function Vt(e4) {
                return Math.sign(e4) * Math.ceil(Math.abs(e4));
              }
              function zt(e4) {
                return Math.sign(e4) * Math.floor(Math.abs(e4));
              }
              function Ht(e4) {
                var t4 = this.srPeriod, r3 = this.srPhase, o3 = 1;
                return e4 < 0 && (e4 = -e4, o3 = -1), e4 += this.srThreshold - r3, e4 = Math.trunc(e4 / t4) * t4, (e4 += r3) < 0 ? r3 * o3 : e4 * o3;
              }
              var x = { x: 1, y: 0, axis: "x", distance: function(e4, t4, r3, o3) {
                return (r3 ? e4.xo : e4.x) - (o3 ? t4.xo : t4.x);
              }, interpolate: function(e4, t4, r3, o3) {
                var n2, s3, i2, a2, l2, u2, c2;
                if (!o3 || o3 === this)
                  return n2 = e4.xo - t4.xo, s3 = e4.xo - r3.xo, l2 = t4.x - t4.xo, u2 = r3.x - r3.xo, 0 === (c2 = (i2 = Math.abs(n2)) + (a2 = Math.abs(s3))) ? void (e4.x = e4.xo + (l2 + u2) / 2) : void (e4.x = e4.xo + (l2 * a2 + u2 * i2) / c2);
                n2 = o3.distance(e4, t4, true, true), s3 = o3.distance(e4, r3, true, true), l2 = o3.distance(t4, t4, false, true), u2 = o3.distance(r3, r3, false, true), 0 === (c2 = (i2 = Math.abs(n2)) + (a2 = Math.abs(s3))) ? x.setRelative(e4, e4, (l2 + u2) / 2, o3, true) : x.setRelative(e4, e4, (l2 * a2 + u2 * i2) / c2, o3, true);
              }, normalSlope: Number.NEGATIVE_INFINITY, setRelative: function(e4, t4, r3, o3, n2) {
                var s3, i2;
                o3 && o3 !== this ? (s3 = n2 ? t4.xo : t4.x, i2 = n2 ? t4.yo : t4.y, s3 += r3 * o3.x, i2 += r3 * o3.y, e4.x = s3 + (e4.y - i2) / o3.normalSlope) : e4.x = (n2 ? t4.xo : t4.x) + r3;
              }, slope: 0, touch: function(e4) {
                e4.xTouched = true;
              }, touched: function(e4) {
                return e4.xTouched;
              }, untouch: function(e4) {
                e4.xTouched = false;
              } }, M = { x: 0, y: 1, axis: "y", distance: function(e4, t4, r3, o3) {
                return (r3 ? e4.yo : e4.y) - (o3 ? t4.yo : t4.y);
              }, interpolate: function(e4, t4, r3, o3) {
                var n2, s3, i2, a2, l2, u2, c2;
                if (!o3 || o3 === this)
                  return n2 = e4.yo - t4.yo, s3 = e4.yo - r3.yo, l2 = t4.y - t4.yo, u2 = r3.y - r3.yo, 0 === (c2 = (i2 = Math.abs(n2)) + (a2 = Math.abs(s3))) ? void (e4.y = e4.yo + (l2 + u2) / 2) : void (e4.y = e4.yo + (l2 * a2 + u2 * i2) / c2);
                n2 = o3.distance(e4, t4, true, true), s3 = o3.distance(e4, r3, true, true), l2 = o3.distance(t4, t4, false, true), u2 = o3.distance(r3, r3, false, true), 0 === (c2 = (i2 = Math.abs(n2)) + (a2 = Math.abs(s3))) ? M.setRelative(e4, e4, (l2 + u2) / 2, o3, true) : M.setRelative(e4, e4, (l2 * a2 + u2 * i2) / c2, o3, true);
              }, normalSlope: 0, setRelative: function(e4, t4, r3, o3, n2) {
                var s3, i2;
                o3 && o3 !== this ? (s3 = n2 ? t4.xo : t4.x, i2 = n2 ? t4.yo : t4.y, s3 += r3 * o3.x, i2 += r3 * o3.y, e4.y = i2 + o3.normalSlope * (e4.x - s3)) : e4.y = (n2 ? t4.yo : t4.y) + r3;
              }, slope: Number.POSITIVE_INFINITY, touch: function(e4) {
                e4.yTouched = true;
              }, touched: function(e4) {
                return e4.yTouched;
              }, untouch: function(e4) {
                e4.yTouched = false;
              } };
              function Wt(e4, t4) {
                this.x = e4, this.y = t4, this.axis = void 0, this.slope = t4 / e4, this.normalSlope = -e4 / t4, Object.freeze(this);
              }
              function qt(e4, t4) {
                var r3 = Math.sqrt(e4 * e4 + t4 * t4);
                return t4 /= r3, 1 === (e4 /= r3) && 0 === t4 ? x : 0 === e4 && 1 === t4 ? M : new Wt(e4, t4);
              }
              function E(e4, t4, r3, o3) {
                this.x = this.xo = Math.round(64 * e4) / 64, this.y = this.yo = Math.round(64 * t4) / 64, this.lastPointOfContour = r3, this.onCurve = o3, this.prevPointOnContour = void 0, this.nextPointOnContour = void 0, this.xTouched = false, this.yTouched = false, Object.preventExtensions(this);
              }
              Object.freeze(x), Object.freeze(M), Wt.prototype.distance = function(e4, t4, r3, o3) {
                return this.x * x.distance(e4, t4, r3, o3) + this.y * M.distance(e4, t4, r3, o3);
              }, Wt.prototype.interpolate = function(e4, t4, r3, o3) {
                var n2 = o3.distance(e4, t4, true, true), s3 = o3.distance(e4, r3, true, true), t4 = o3.distance(t4, t4, false, true), r3 = o3.distance(r3, r3, false, true), n2 = Math.abs(n2), s3 = Math.abs(s3), i2 = n2 + s3;
                0 === i2 ? this.setRelative(e4, e4, (t4 + r3) / 2, o3, true) : this.setRelative(e4, e4, (t4 * s3 + r3 * n2) / i2, o3, true);
              }, Wt.prototype.setRelative = function(e4, t4, r3, o3, n2) {
                var s3 = n2 ? t4.xo : t4.x, n2 = n2 ? t4.yo : t4.y, t4 = s3 + r3 * (o3 = o3 || this).x, s3 = n2 + r3 * o3.y, n2 = o3.normalSlope, r3 = this.slope, o3 = e4.x, i2 = e4.y;
                e4.x = (r3 * o3 - n2 * t4 + s3 - i2) / (r3 - n2), e4.y = r3 * (e4.x - o3) + i2;
              }, Wt.prototype.touch = function(e4) {
                e4.xTouched = true, e4.yTouched = true;
              }, E.prototype.nextTouched = function(e4) {
                for (var t4 = this.nextPointOnContour; !e4.touched(t4) && t4 !== this; )
                  t4 = t4.nextPointOnContour;
                return t4;
              }, E.prototype.prevTouched = function(e4) {
                for (var t4 = this.prevPointOnContour; !e4.touched(t4) && t4 !== this; )
                  t4 = t4.prevPointOnContour;
                return t4;
              };
              var Xt = Object.freeze(new E(0, 0)), Yt = { cvCutIn: 17 / 16, deltaBase: 9, deltaShift: 0.125, loop: 1, minDis: 1, autoFlip: true };
              function T(e4, t4) {
                switch (this.env = e4, this.stack = [], this.prog = t4, e4) {
                  case "glyf":
                    this.zp0 = this.zp1 = this.zp2 = 1, this.rp0 = this.rp1 = this.rp2 = 0;
                  case "prep":
                    this.fv = this.pv = this.dpv = x, this.round = Ft;
                }
              }
              function Zt(e4) {
                for (var t4 = e4.tZone = new Array(e4.gZone.length), r3 = 0; r3 < t4.length; r3++)
                  t4[r3] = new E(0, 0);
              }
              function Qt(e4, t4) {
                var r3, o3 = e4.prog, n2 = e4.ip, s3 = 1;
                do {
                  if (88 === (r3 = o3[++n2]))
                    s3++;
                  else if (89 === r3)
                    s3--;
                  else if (64 === r3)
                    n2 += o3[n2 + 1] + 1;
                  else if (65 === r3)
                    n2 += 2 * o3[n2 + 1] + 1;
                  else if (176 <= r3 && r3 <= 183)
                    n2 += r3 - 176 + 1;
                  else if (184 <= r3 && r3 <= 191)
                    n2 += 2 * (r3 - 184 + 1);
                  else if (t4 && 1 === s3 && 27 === r3)
                    break;
                } while (0 < s3);
                e4.ip = n2;
              }
              function Kt(e4, t4) {
                j.DEBUG && console.log(t4.step, "SVTCA[" + e4.axis + "]"), t4.fv = t4.pv = t4.dpv = e4;
              }
              function Jt(e4, t4) {
                j.DEBUG && console.log(t4.step, "SPVTCA[" + e4.axis + "]"), t4.pv = t4.dpv = e4;
              }
              function $t(e4, t4) {
                j.DEBUG && console.log(t4.step, "SFVTCA[" + e4.axis + "]"), t4.fv = e4;
              }
              function er(e4, t4) {
                var r3, o3 = t4.stack, n2 = o3.pop(), o3 = o3.pop(), s3 = t4.z2[n2], i2 = t4.z1[o3];
                j.DEBUG && console.log("SPVTL[" + e4 + "]", n2, o3), n2 = e4 ? (r3 = s3.y - i2.y, i2.x - s3.x) : (r3 = i2.x - s3.x, i2.y - s3.y), t4.pv = t4.dpv = qt(r3, n2);
              }
              function tr(e4, t4) {
                var r3, o3 = t4.stack, n2 = o3.pop(), o3 = o3.pop(), s3 = t4.z2[n2], i2 = t4.z1[o3];
                j.DEBUG && console.log("SFVTL[" + e4 + "]", n2, o3), n2 = e4 ? (r3 = s3.y - i2.y, i2.x - s3.x) : (r3 = i2.x - s3.x, i2.y - s3.y), t4.fv = qt(r3, n2);
              }
              function rr(e4) {
                j.DEBUG && console.log(e4.step, "POP[]"), e4.stack.pop();
              }
              function or(e4, t4) {
                var r3 = t4.stack.pop(), o3 = t4.z0[r3], n2 = t4.fv, s3 = t4.pv, i2 = (j.DEBUG && console.log(t4.step, "MDAP[" + e4 + "]", r3), s3.distance(o3, Xt));
                e4 && (i2 = t4.round(i2)), n2.setRelative(o3, Xt, i2, s3), n2.touch(o3), t4.rp0 = t4.rp1 = r3;
              }
              function nr(e4, t4) {
                var r3, o3, n2, s3 = t4.z2, i2 = s3.length - 2;
                j.DEBUG && console.log(t4.step, "IUP[" + e4.axis + "]");
                for (var a2 = 0; a2 < i2; a2++)
                  r3 = s3[a2], e4.touched(r3) || (o3 = r3.prevTouched(e4)) !== r3 && (o3 === (n2 = r3.nextTouched(e4)) && e4.setRelative(r3, r3, e4.distance(o3, o3, false, true), e4, true), e4.interpolate(r3, o3, n2, e4));
              }
              function sr(e4, t4) {
                for (var r3 = t4.stack, o3 = e4 ? t4.rp1 : t4.rp2, n2 = (e4 ? t4.z0 : t4.z1)[o3], s3 = t4.fv, i2 = t4.pv, a2 = t4.loop, l2 = t4.z2; a2--; ) {
                  var u2 = r3.pop(), c2 = l2[u2], d2 = i2.distance(n2, n2, false, true);
                  s3.setRelative(c2, c2, d2, i2), s3.touch(c2), j.DEBUG && console.log(t4.step, (1 < t4.loop ? "loop " + (t4.loop - a2) + ": " : "") + "SHP[" + (e4 ? "rp1" : "rp2") + "]", u2);
                }
                t4.loop = 1;
              }
              function ir(e4, t4) {
                for (var r3 = t4.stack, o3 = e4 ? t4.rp1 : t4.rp2, n2 = (e4 ? t4.z0 : t4.z1)[o3], s3 = t4.fv, i2 = t4.pv, o3 = r3.pop(), a2 = t4.z2[t4.contours[o3]], l2 = a2, u2 = (j.DEBUG && console.log(t4.step, "SHC[" + e4 + "]", o3), i2.distance(n2, n2, false, true)); l2 !== n2 && s3.setRelative(l2, l2, u2, i2), (l2 = l2.nextPointOnContour) !== a2; )
                  ;
              }
              function ar(e4, t4) {
                var r3, o3, n2 = t4.stack, s3 = e4 ? t4.rp1 : t4.rp2, s3 = (e4 ? t4.z0 : t4.z1)[s3], i2 = t4.fv, a2 = t4.pv, n2 = n2.pop();
                switch (j.DEBUG && console.log(t4.step, "SHZ[" + e4 + "]", n2), n2) {
                  case 0:
                    r3 = t4.tZone;
                    break;
                  case 1:
                    r3 = t4.gZone;
                    break;
                  default:
                    throw new Error("Invalid zone");
                }
                for (var l2 = a2.distance(s3, s3, false, true), u2 = r3.length - 2, c2 = 0; c2 < u2; c2++)
                  o3 = r3[c2], i2.setRelative(o3, o3, l2, a2);
              }
              function lr(e4, t4) {
                var r3 = t4.stack, o3 = r3.pop() / 64, r3 = r3.pop(), n2 = t4.z1[r3], s3 = t4.z0[t4.rp0], i2 = t4.fv, a2 = t4.pv;
                i2.setRelative(n2, s3, o3, a2), i2.touch(n2), j.DEBUG && console.log(t4.step, "MSIRP[" + e4 + "]", o3, r3), t4.rp1 = t4.rp0, t4.rp2 = r3, e4 && (t4.rp0 = r3);
              }
              function ur(e4, t4) {
                var r3 = t4.stack, o3 = r3.pop(), r3 = r3.pop(), n2 = t4.z0[r3], s3 = t4.fv, i2 = t4.pv, a2 = t4.cvt[o3], o3 = (j.DEBUG && console.log(t4.step, "MIAP[" + e4 + "]", o3, "(", a2, ")", r3), i2.distance(n2, Xt));
                e4 && (Math.abs(o3 - a2) < t4.cvCutIn && (o3 = a2), o3 = t4.round(o3)), s3.setRelative(n2, Xt, o3, i2), 0 === t4.zp0 && (n2.xo = n2.x, n2.yo = n2.y), s3.touch(n2), t4.rp0 = t4.rp1 = r3;
              }
              function cr(e4, t4) {
                var r3 = t4.stack, o3 = r3.pop(), n2 = t4.z2[o3];
                j.DEBUG && console.log(t4.step, "GC[" + e4 + "]", o3), r3.push(64 * t4.dpv.distance(n2, Xt, e4, false));
              }
              function dr(e4, t4) {
                var r3 = t4.stack, o3 = r3.pop(), r3 = r3.pop(), n2 = t4.z1[o3], s3 = t4.z0[r3], s3 = t4.dpv.distance(s3, n2, e4, e4);
                j.DEBUG && console.log(t4.step, "MD[" + e4 + "]", o3, r3, "->", s3), t4.stack.push(Math.round(64 * s3));
              }
              function fr(e4, t4) {
                var r3 = t4.stack, o3 = r3.pop(), n2 = t4.fv, s3 = t4.pv, i2 = t4.ppem, a2 = t4.deltaBase + 16 * (e4 - 1), l2 = t4.deltaShift, u2 = t4.z0;
                j.DEBUG && console.log(t4.step, "DELTAP[" + e4 + "]", o3, r3);
                for (var c2 = 0; c2 < o3; c2++) {
                  var d2 = r3.pop(), f2 = r3.pop();
                  a2 + ((240 & f2) >> 4) === i2 && (0 <= (f2 = (15 & f2) - 8) && f2++, j.DEBUG && console.log(t4.step, "DELTAPFIX", d2, "by", f2 * l2), d2 = u2[d2], n2.setRelative(d2, d2, f2 * l2, s3));
                }
              }
              function hr(e4, t4) {
                var r3 = t4.stack, o3 = r3.pop();
                j.DEBUG && console.log(t4.step, "ROUND[]"), r3.push(64 * t4.round(o3 / 64));
              }
              function pr(e4, t4) {
                var r3 = t4.stack, o3 = r3.pop(), n2 = t4.ppem, s3 = t4.deltaBase + 16 * (e4 - 1), i2 = t4.deltaShift;
                j.DEBUG && console.log(t4.step, "DELTAC[" + e4 + "]", o3, r3);
                for (var a2 = 0; a2 < o3; a2++) {
                  var l2 = r3.pop(), u2 = r3.pop();
                  s3 + ((240 & u2) >> 4) === n2 && (0 <= (u2 = (15 & u2) - 8) && u2++, u2 = u2 * i2, j.DEBUG && console.log(t4.step, "DELTACFIX", l2, "by", u2), t4.cvt[l2] += u2);
                }
              }
              function mr(e4, t4) {
                var r3, o3 = t4.stack, n2 = o3.pop(), o3 = o3.pop(), s3 = t4.z2[n2], i2 = t4.z1[o3];
                j.DEBUG && console.log(t4.step, "SDPVTL[" + e4 + "]", n2, o3), n2 = e4 ? (r3 = s3.y - i2.y, i2.x - s3.x) : (r3 = i2.x - s3.x, i2.y - s3.y), t4.dpv = qt(r3, n2);
              }
              function C(e4, t4) {
                var r3 = t4.stack, o3 = t4.prog, n2 = t4.ip;
                j.DEBUG && console.log(t4.step, "PUSHB[" + e4 + "]");
                for (var s3 = 0; s3 < e4; s3++)
                  r3.push(o3[++n2]);
                t4.ip = n2;
              }
              function O(e4, t4) {
                var r3 = t4.ip, o3 = t4.prog, n2 = t4.stack;
                j.DEBUG && console.log(t4.ip, "PUSHW[" + e4 + "]");
                for (var s3 = 0; s3 < e4; s3++) {
                  var i2 = o3[++r3] << 8 | o3[++r3];
                  32768 & i2 && (i2 = -(1 + (65535 ^ i2))), n2.push(i2);
                }
                t4.ip = r3;
              }
              function L(e4, t4, r3, o3, n2, s3) {
                var i2, a2, l2 = s3.stack, u2 = e4 && l2.pop(), l2 = l2.pop(), c2 = s3.rp0, c2 = s3.z0[c2], d2 = s3.z1[l2], f2 = s3.minDis, h2 = s3.fv, p2 = s3.dpv, m2 = i2 = p2.distance(d2, c2, true, true), y2 = 0 <= m2 ? 1 : -1;
                m2 = Math.abs(m2), e4 && (a2 = s3.cvt[u2], o3 && Math.abs(m2 - a2) < s3.cvCutIn && (m2 = a2)), r3 && m2 < f2 && (m2 = f2), o3 && (m2 = s3.round(m2)), h2.setRelative(d2, c2, y2 * m2, p2), h2.touch(d2), j.DEBUG && console.log(s3.step, (e4 ? "MIRP[" : "MDRP[") + (t4 ? "M" : "m") + (r3 ? ">" : "_") + (o3 ? "R" : "_") + (0 === n2 ? "Gr" : 1 === n2 ? "Bl" : 2 === n2 ? "Wh" : "") + "]", e4 ? u2 + "(" + s3.cvt[u2] + "," + a2 + ")" : "", l2, "(d =", i2, "->", y2 * m2, ")"), s3.rp1 = s3.rp0, s3.rp2 = l2, t4 && (s3.rp0 = l2);
              }
              Ut.prototype.exec = function(e4, t4) {
                if ("number" != typeof t4)
                  throw new Error("Point size is not a number!");
                if (!(2 < this._errorState)) {
                  var r3 = this.font, o3 = this._prepState;
                  if (!o3 || o3.ppem !== t4) {
                    var n2 = this._fpgmState;
                    if (!n2) {
                      T.prototype = Yt, (n2 = this._fpgmState = new T("fpgm", r3.tables.fpgm)).funcs = [], n2.font = r3, j.DEBUG && (console.log("---EXEC FPGM---"), n2.step = -1);
                      try {
                        vr(n2);
                      } catch (e5) {
                        return console.log("Hinting error in FPGM:" + e5), void (this._errorState = 3);
                      }
                    }
                    T.prototype = n2, (o3 = this._prepState = new T("prep", r3.tables.prep)).ppem = t4;
                    var s3 = r3.tables.cvt;
                    if (s3)
                      for (var i2 = o3.cvt = new Array(s3.length), a2 = t4 / r3.unitsPerEm, l2 = 0; l2 < s3.length; l2++)
                        i2[l2] = s3[l2] * a2;
                    else
                      o3.cvt = [];
                    j.DEBUG && (console.log("---EXEC PREP---"), o3.step = -1);
                    try {
                      vr(o3);
                    } catch (e5) {
                      this._errorState < 2 && console.log("Hinting error in PREP:" + e5), this._errorState = 2;
                    }
                  }
                  if (!(1 < this._errorState))
                    try {
                      return yr(e4, o3);
                    } catch (e5) {
                      this._errorState < 1 && (console.log("Hinting error:" + e5), console.log("Note: further hinting errors are silenced")), this._errorState = 1;
                    }
                }
              };
              var yr = function(e4, t4) {
                var r3 = t4.ppem / t4.font.unitsPerEm, o3 = r3, n2 = e4.components;
                if (T.prototype = t4, n2) {
                  for (var s3 = t4.font, i2 = [], a2 = [], l2 = 0; l2 < n2.length; l2++) {
                    var u2 = n2[l2], c2 = s3.glyphs.get(u2.glyphIndex), d2 = new T("glyf", c2.instructions);
                    j.DEBUG && (console.log("---EXEC COMP " + l2 + "---"), d2.step = -1), gr(c2, d2, r3, o3);
                    for (var f2 = Math.round(u2.dx * r3), h2 = Math.round(u2.dy * o3), p2 = d2.gZone, m2 = d2.contours, y2 = 0; y2 < p2.length; y2++) {
                      var g2 = p2[y2];
                      g2.xTouched = g2.yTouched = false, g2.xo = g2.x = g2.x + f2, g2.yo = g2.y = g2.y + h2;
                    }
                    var v2 = i2.length;
                    i2.push.apply(i2, p2);
                    for (var b2 = 0; b2 < m2.length; b2++)
                      a2.push(m2[b2] + v2);
                  }
                  e4.instructions && !d2.inhibitGridFit && ((d2 = new T("glyf", e4.instructions)).gZone = d2.z0 = d2.z1 = d2.z2 = i2, d2.contours = a2, i2.push(new E(0, 0), new E(Math.round(e4.advanceWidth * r3), 0)), j.DEBUG && (console.log("---EXEC COMPOSITE---"), d2.step = -1), vr(d2), i2.length -= 2);
                } else
                  d2 = new T("glyf", e4.instructions), j.DEBUG && (console.log("---EXEC GLYPH---"), d2.step = -1), gr(e4, d2, r3, o3), i2 = d2.gZone;
                return i2;
              }, gr = function(e4, t4, r3, o3) {
                for (var n2, s3, i2, a2 = e4.points || [], l2 = a2.length, u2 = t4.gZone = t4.z0 = t4.z1 = t4.z2 = [], c2 = t4.contours = [], d2 = 0; d2 < l2; d2++)
                  n2 = a2[d2], u2[d2] = new E(n2.x * r3, n2.y * o3, n2.lastPointOfContour, n2.onCurve);
                for (var f2 = 0; f2 < l2; f2++)
                  n2 = u2[f2], s3 || (s3 = n2, c2.push(f2)), n2.lastPointOfContour ? ((n2.nextPointOnContour = s3).prevPointOnContour = n2, s3 = void 0) : (i2 = u2[f2 + 1], (n2.nextPointOnContour = i2).prevPointOnContour = n2);
                if (!t4.inhibitGridFit) {
                  if (j.DEBUG) {
                    console.log("PROCESSING GLYPH", t4.stack);
                    for (var h2 = 0; h2 < l2; h2++)
                      console.log(h2, u2[h2].x, u2[h2].y);
                  }
                  if (u2.push(new E(0, 0), new E(Math.round(e4.advanceWidth * r3), 0)), vr(t4), u2.length -= 2, j.DEBUG) {
                    console.log("FINISHED GLYPH", t4.stack);
                    for (var p2 = 0; p2 < l2; p2++)
                      console.log(p2, u2[p2].x, u2[p2].y);
                  }
                }
              }, vr = function(e4) {
                var t4 = e4.prog;
                if (t4) {
                  var r3, o3 = t4.length;
                  for (e4.ip = 0; e4.ip < o3; e4.ip++) {
                    if (j.DEBUG && e4.step++, !(r3 = br[t4[e4.ip]]))
                      throw new Error("unknown instruction: 0x" + Number(t4[e4.ip]).toString(16));
                    r3(e4);
                  }
                }
              }, br = [Kt.bind(void 0, M), Kt.bind(void 0, x), Jt.bind(void 0, M), Jt.bind(void 0, x), $t.bind(void 0, M), $t.bind(void 0, x), er.bind(void 0, 0), er.bind(void 0, 1), tr.bind(void 0, 0), tr.bind(void 0, 1), function(e4) {
                var t4 = (r3 = e4.stack).pop(), r3 = r3.pop();
                j.DEBUG && console.log(e4.step, "SPVFS[]", t4, r3), e4.pv = e4.dpv = qt(r3, t4);
              }, function(e4) {
                var t4 = (r3 = e4.stack).pop(), r3 = r3.pop();
                j.DEBUG && console.log(e4.step, "SPVFS[]", t4, r3), e4.fv = qt(r3, t4);
              }, function(e4) {
                var t4 = e4.stack, r3 = e4.pv;
                j.DEBUG && console.log(e4.step, "GPV[]"), t4.push(16384 * r3.x), t4.push(16384 * r3.y);
              }, function(e4) {
                var t4 = e4.stack, r3 = e4.fv;
                j.DEBUG && console.log(e4.step, "GFV[]"), t4.push(16384 * r3.x), t4.push(16384 * r3.y);
              }, function(e4) {
                e4.fv = e4.pv, j.DEBUG && console.log(e4.step, "SFVTPV[]");
              }, function(e4) {
                var t4 = (s3 = e4.stack).pop(), r3 = s3.pop(), o3 = s3.pop(), n2 = s3.pop(), s3 = s3.pop(), i2 = e4.z0, a2 = e4.z1, l2 = i2[t4], i2 = i2[r3], u2 = a2[o3], a2 = a2[n2], e4 = e4.z2[s3], t4 = (j.DEBUG && console.log("ISECT[], ", t4, r3, o3, n2, s3), l2.x), r3 = l2.y, o3 = i2.x, n2 = i2.y, s3 = u2.x, l2 = u2.y, i2 = a2.x, u2 = a2.y, a2 = (t4 - o3) * (l2 - u2) - (r3 - n2) * (s3 - i2), c2 = t4 * n2 - r3 * o3, d2 = s3 * u2 - l2 * i2;
                e4.x = (c2 * (s3 - i2) - d2 * (t4 - o3)) / a2, e4.y = (c2 * (l2 - u2) - d2 * (r3 - n2)) / a2;
              }, function(e4) {
                e4.rp0 = e4.stack.pop(), j.DEBUG && console.log(e4.step, "SRP0[]", e4.rp0);
              }, function(e4) {
                e4.rp1 = e4.stack.pop(), j.DEBUG && console.log(e4.step, "SRP1[]", e4.rp1);
              }, function(e4) {
                e4.rp2 = e4.stack.pop(), j.DEBUG && console.log(e4.step, "SRP2[]", e4.rp2);
              }, function(e4) {
                var t4 = e4.stack.pop();
                switch (j.DEBUG && console.log(e4.step, "SZP0[]", t4), e4.zp0 = t4) {
                  case 0:
                    e4.tZone || Zt(e4), e4.z0 = e4.tZone;
                    break;
                  case 1:
                    e4.z0 = e4.gZone;
                    break;
                  default:
                    throw new Error("Invalid zone pointer");
                }
              }, function(e4) {
                var t4 = e4.stack.pop();
                switch (j.DEBUG && console.log(e4.step, "SZP1[]", t4), e4.zp1 = t4) {
                  case 0:
                    e4.tZone || Zt(e4), e4.z1 = e4.tZone;
                    break;
                  case 1:
                    e4.z1 = e4.gZone;
                    break;
                  default:
                    throw new Error("Invalid zone pointer");
                }
              }, function(e4) {
                var t4 = e4.stack.pop();
                switch (j.DEBUG && console.log(e4.step, "SZP2[]", t4), e4.zp2 = t4) {
                  case 0:
                    e4.tZone || Zt(e4), e4.z2 = e4.tZone;
                    break;
                  case 1:
                    e4.z2 = e4.gZone;
                    break;
                  default:
                    throw new Error("Invalid zone pointer");
                }
              }, function(e4) {
                var t4 = e4.stack.pop();
                switch (j.DEBUG && console.log(e4.step, "SZPS[]", t4), e4.zp0 = e4.zp1 = e4.zp2 = t4) {
                  case 0:
                    e4.tZone || Zt(e4), e4.z0 = e4.z1 = e4.z2 = e4.tZone;
                    break;
                  case 1:
                    e4.z0 = e4.z1 = e4.z2 = e4.gZone;
                    break;
                  default:
                    throw new Error("Invalid zone pointer");
                }
              }, function(e4) {
                e4.loop = e4.stack.pop(), j.DEBUG && console.log(e4.step, "SLOOP[]", e4.loop);
              }, function(e4) {
                j.DEBUG && console.log(e4.step, "RTG[]"), e4.round = Ft;
              }, function(e4) {
                j.DEBUG && console.log(e4.step, "RTHG[]"), e4.round = Gt;
              }, function(e4) {
                var t4 = e4.stack.pop();
                j.DEBUG && console.log(e4.step, "SMD[]", t4), e4.minDis = t4 / 64;
              }, function(e4) {
                j.DEBUG && console.log(e4.step, "ELSE[]"), Qt(e4, false);
              }, function(e4) {
                var t4 = e4.stack.pop();
                j.DEBUG && console.log(e4.step, "JMPR[]", t4), e4.ip += t4 - 1;
              }, function(e4) {
                var t4 = e4.stack.pop();
                j.DEBUG && console.log(e4.step, "SCVTCI[]", t4), e4.cvCutIn = t4 / 64;
              }, void 0, void 0, function(e4) {
                var t4 = e4.stack;
                j.DEBUG && console.log(e4.step, "DUP[]"), t4.push(t4[t4.length - 1]);
              }, rr, function(e4) {
                j.DEBUG && console.log(e4.step, "CLEAR[]"), e4.stack.length = 0;
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "SWAP[]"), t4.push(r3), t4.push(o3);
              }, function(e4) {
                var t4 = e4.stack;
                j.DEBUG && console.log(e4.step, "DEPTH[]"), t4.push(t4.length);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop();
                j.DEBUG && console.log(e4.step, "CINDEX[]", r3), t4.push(t4[t4.length - r3]);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop();
                j.DEBUG && console.log(e4.step, "MINDEX[]", r3), t4.push(t4.splice(t4.length - r3, 1)[0]);
              }, void 0, void 0, void 0, function(e4) {
                var t4 = (o3 = e4.stack).pop(), r3 = o3.pop(), o3 = (j.DEBUG && console.log(e4.step, "LOOPCALL[]", t4, r3), e4.ip), n2 = e4.prog;
                e4.prog = e4.funcs[t4];
                for (var s3 = 0; s3 < r3; s3++)
                  vr(e4), j.DEBUG && console.log(++e4.step, s3 + 1 < r3 ? "next loopcall" : "done loopcall", s3);
                e4.ip = o3, e4.prog = n2;
              }, function(e4) {
                var t4 = e4.stack.pop(), r3 = (j.DEBUG && console.log(e4.step, "CALL[]", t4), e4.ip), o3 = e4.prog;
                e4.prog = e4.funcs[t4], vr(e4), e4.ip = r3, e4.prog = o3, j.DEBUG && console.log(++e4.step, "returning from", t4);
              }, function(e4) {
                if ("fpgm" !== e4.env)
                  throw new Error("FDEF not allowed here");
                var t4 = e4.stack, r3 = e4.prog, o3 = e4.ip, t4 = t4.pop(), n2 = o3;
                for (j.DEBUG && console.log(e4.step, "FDEF[]", t4); 45 !== r3[++o3]; )
                  ;
                e4.ip = o3, e4.funcs[t4] = r3.slice(n2 + 1, o3);
              }, void 0, or.bind(void 0, 0), or.bind(void 0, 1), nr.bind(void 0, M), nr.bind(void 0, x), sr.bind(void 0, 0), sr.bind(void 0, 1), ir.bind(void 0, 0), ir.bind(void 0, 1), ar.bind(void 0, 0), ar.bind(void 0, 1), function(e4) {
                for (var t4 = e4.stack, r3 = e4.loop, o3 = e4.fv, n2 = t4.pop() / 64, s3 = e4.z2; r3--; ) {
                  var i2 = t4.pop(), a2 = s3[i2];
                  j.DEBUG && console.log(e4.step, (1 < e4.loop ? "loop " + (e4.loop - r3) + ": " : "") + "SHPIX[]", i2, n2), o3.setRelative(a2, a2, n2), o3.touch(a2);
                }
                e4.loop = 1;
              }, function(e4) {
                for (var t4 = e4.stack, r3 = e4.rp1, o3 = e4.rp2, n2 = e4.loop, s3 = e4.z0[r3], i2 = e4.z1[o3], a2 = e4.fv, l2 = e4.dpv, u2 = e4.z2; n2--; ) {
                  var c2 = t4.pop(), d2 = u2[c2];
                  j.DEBUG && console.log(e4.step, (1 < e4.loop ? "loop " + (e4.loop - n2) + ": " : "") + "IP[]", c2, r3, "<->", o3), a2.interpolate(d2, s3, i2, l2), a2.touch(d2);
                }
                e4.loop = 1;
              }, lr.bind(void 0, 0), lr.bind(void 0, 1), function(e4) {
                for (var t4 = e4.stack, r3 = e4.rp0, o3 = e4.z0[r3], n2 = e4.loop, s3 = e4.fv, i2 = e4.pv, a2 = e4.z1; n2--; ) {
                  var l2 = t4.pop(), u2 = a2[l2];
                  j.DEBUG && console.log(e4.step, (1 < e4.loop ? "loop " + (e4.loop - n2) + ": " : "") + "ALIGNRP[]", l2), s3.setRelative(u2, o3, 0, i2), s3.touch(u2);
                }
                e4.loop = 1;
              }, function(e4) {
                j.DEBUG && console.log(e4.step, "RTDG[]"), e4.round = Bt;
              }, ur.bind(void 0, 0), ur.bind(void 0, 1), function(e4) {
                var t4 = e4.prog, r3 = e4.ip, o3 = e4.stack, n2 = t4[++r3];
                j.DEBUG && console.log(e4.step, "NPUSHB[]", n2);
                for (var s3 = 0; s3 < n2; s3++)
                  o3.push(t4[++r3]);
                e4.ip = r3;
              }, function(e4) {
                var t4 = e4.ip, r3 = e4.prog, o3 = e4.stack, n2 = r3[++t4];
                j.DEBUG && console.log(e4.step, "NPUSHW[]", n2);
                for (var s3 = 0; s3 < n2; s3++) {
                  var i2 = r3[++t4] << 8 | r3[++t4];
                  32768 & i2 && (i2 = -(1 + (65535 ^ i2))), o3.push(i2);
                }
                e4.ip = t4;
              }, function(e4) {
                var t4 = e4.stack, r3 = (r3 = e4.store) || (e4.store = []), o3 = t4.pop(), t4 = t4.pop();
                j.DEBUG && console.log(e4.step, "WS", o3, t4), r3[t4] = o3;
              }, function(e4) {
                var t4 = e4.stack, r3 = e4.store, o3 = t4.pop(), e4 = (j.DEBUG && console.log(e4.step, "RS", o3), r3 && r3[o3] || 0);
                t4.push(e4);
              }, function(e4) {
                var t4 = (r3 = e4.stack).pop(), r3 = r3.pop();
                j.DEBUG && console.log(e4.step, "WCVTP", t4, r3), e4.cvt[r3] = t4 / 64;
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop();
                j.DEBUG && console.log(e4.step, "RCVT", r3), t4.push(64 * e4.cvt[r3]);
              }, cr.bind(void 0, 0), cr.bind(void 0, 1), void 0, dr.bind(void 0, 0), dr.bind(void 0, 1), function(e4) {
                j.DEBUG && console.log(e4.step, "MPPEM[]"), e4.stack.push(e4.ppem);
              }, void 0, function(e4) {
                j.DEBUG && console.log(e4.step, "FLIPON[]"), e4.autoFlip = true;
              }, void 0, void 0, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "LT[]", r3, o3), t4.push(o3 < r3 ? 1 : 0);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "LTEQ[]", r3, o3), t4.push(o3 <= r3 ? 1 : 0);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "GT[]", r3, o3), t4.push(r3 < o3 ? 1 : 0);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "GTEQ[]", r3, o3), t4.push(r3 <= o3 ? 1 : 0);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "EQ[]", r3, o3), t4.push(r3 === o3 ? 1 : 0);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "NEQ[]", r3, o3), t4.push(r3 !== o3 ? 1 : 0);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop();
                j.DEBUG && console.log(e4.step, "ODD[]", r3), t4.push(Math.trunc(r3) % 2 ? 1 : 0);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop();
                j.DEBUG && console.log(e4.step, "EVEN[]", r3), t4.push(Math.trunc(r3) % 2 ? 0 : 1);
              }, function(e4) {
                var t4 = e4.stack.pop();
                j.DEBUG && console.log(e4.step, "IF[]", t4), t4 || (Qt(e4, true), j.DEBUG && console.log(e4.step, "EIF[]"));
              }, function(e4) {
                j.DEBUG && console.log(e4.step, "EIF[]");
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "AND[]", r3, o3), t4.push(r3 && o3 ? 1 : 0);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "OR[]", r3, o3), t4.push(r3 || o3 ? 1 : 0);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop();
                j.DEBUG && console.log(e4.step, "NOT[]", r3), t4.push(r3 ? 0 : 1);
              }, fr.bind(void 0, 1), function(e4) {
                var t4 = e4.stack.pop();
                j.DEBUG && console.log(e4.step, "SDB[]", t4), e4.deltaBase = t4;
              }, function(e4) {
                var t4 = e4.stack.pop();
                j.DEBUG && console.log(e4.step, "SDS[]", t4), e4.deltaShift = Math.pow(0.5, t4);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "ADD[]", r3, o3), t4.push(o3 + r3);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "SUB[]", r3, o3), t4.push(o3 - r3);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "DIV[]", r3, o3), t4.push(64 * o3 / r3);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "MUL[]", r3, o3), t4.push(o3 * r3 / 64);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop();
                j.DEBUG && console.log(e4.step, "ABS[]", r3), t4.push(Math.abs(r3));
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop();
                j.DEBUG && console.log(e4.step, "NEG[]", r3), t4.push(-r3);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop();
                j.DEBUG && console.log(e4.step, "FLOOR[]", r3), t4.push(64 * Math.floor(r3 / 64));
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop();
                j.DEBUG && console.log(e4.step, "CEILING[]", r3), t4.push(64 * Math.ceil(r3 / 64));
              }, hr.bind(void 0, 0), hr.bind(void 0, 1), hr.bind(void 0, 2), hr.bind(void 0, 3), void 0, void 0, void 0, void 0, function(e4) {
                var t4 = (r3 = e4.stack).pop(), r3 = r3.pop();
                j.DEBUG && console.log(e4.step, "WCVTF[]", t4, r3), e4.cvt[r3] = t4 * e4.ppem / e4.font.unitsPerEm;
              }, fr.bind(void 0, 2), fr.bind(void 0, 3), pr.bind(void 0, 1), pr.bind(void 0, 2), pr.bind(void 0, 3), function(e4) {
                var t4, r3 = e4.stack.pop();
                switch (j.DEBUG && console.log(e4.step, "SROUND[]", r3), e4.round = Ht, 192 & r3) {
                  case 0:
                    t4 = 0.5;
                    break;
                  case 64:
                    t4 = 1;
                    break;
                  case 128:
                    t4 = 2;
                    break;
                  default:
                    throw new Error("invalid SROUND value");
                }
                switch (e4.srPeriod = t4, 48 & r3) {
                  case 0:
                    e4.srPhase = 0;
                    break;
                  case 16:
                    e4.srPhase = 0.25 * t4;
                    break;
                  case 32:
                    e4.srPhase = 0.5 * t4;
                    break;
                  case 48:
                    e4.srPhase = 0.75 * t4;
                    break;
                  default:
                    throw new Error("invalid SROUND value");
                }
                e4.srThreshold = 0 === (r3 &= 15) ? 0 : (r3 / 8 - 0.5) * t4;
              }, function(e4) {
                var t4, r3 = e4.stack.pop();
                switch (j.DEBUG && console.log(e4.step, "S45ROUND[]", r3), e4.round = Ht, 192 & r3) {
                  case 0:
                    t4 = Math.sqrt(2) / 2;
                    break;
                  case 64:
                    t4 = Math.sqrt(2);
                    break;
                  case 128:
                    t4 = 2 * Math.sqrt(2);
                    break;
                  default:
                    throw new Error("invalid S45ROUND value");
                }
                switch (e4.srPeriod = t4, 48 & r3) {
                  case 0:
                    e4.srPhase = 0;
                    break;
                  case 16:
                    e4.srPhase = 0.25 * t4;
                    break;
                  case 32:
                    e4.srPhase = 0.5 * t4;
                    break;
                  case 48:
                    e4.srPhase = 0.75 * t4;
                    break;
                  default:
                    throw new Error("invalid S45ROUND value");
                }
                e4.srThreshold = 0 === (r3 &= 15) ? 0 : (r3 / 8 - 0.5) * t4;
              }, void 0, void 0, function(e4) {
                j.DEBUG && console.log(e4.step, "ROFF[]"), e4.round = Nt;
              }, void 0, function(e4) {
                j.DEBUG && console.log(e4.step, "RUTG[]"), e4.round = Vt;
              }, function(e4) {
                j.DEBUG && console.log(e4.step, "RDTG[]"), e4.round = zt;
              }, rr, rr, void 0, void 0, void 0, void 0, void 0, function(e4) {
                var t4 = e4.stack.pop();
                j.DEBUG && console.log(e4.step, "SCANCTRL[]", t4);
              }, mr.bind(void 0, 0), mr.bind(void 0, 1), function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = 0;
                j.DEBUG && console.log(e4.step, "GETINFO[]", r3), 1 & r3 && (o3 = 35), 32 & r3 && (o3 |= 4096), t4.push(o3);
              }, void 0, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop(), n2 = t4.pop();
                j.DEBUG && console.log(e4.step, "ROLL[]"), t4.push(o3), t4.push(r3), t4.push(n2);
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "MAX[]", r3, o3), t4.push(Math.max(o3, r3));
              }, function(e4) {
                var t4 = e4.stack, r3 = t4.pop(), o3 = t4.pop();
                j.DEBUG && console.log(e4.step, "MIN[]", r3, o3), t4.push(Math.min(o3, r3));
              }, function(e4) {
                var t4 = e4.stack.pop();
                j.DEBUG && console.log(e4.step, "SCANTYPE[]", t4);
              }, function(e4) {
                var t4 = e4.stack.pop(), r3 = e4.stack.pop();
                switch (j.DEBUG && console.log(e4.step, "INSTCTRL[]", t4, r3), t4) {
                  case 1:
                    return void (e4.inhibitGridFit = !!r3);
                  case 2:
                    return void (e4.ignoreCvt = !!r3);
                  default:
                    throw new Error("invalid INSTCTRL[] selector");
                }
              }, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, C.bind(void 0, 1), C.bind(void 0, 2), C.bind(void 0, 3), C.bind(void 0, 4), C.bind(void 0, 5), C.bind(void 0, 6), C.bind(void 0, 7), C.bind(void 0, 8), O.bind(void 0, 1), O.bind(void 0, 2), O.bind(void 0, 3), O.bind(void 0, 4), O.bind(void 0, 5), O.bind(void 0, 6), O.bind(void 0, 7), O.bind(void 0, 8), L.bind(void 0, 0, 0, 0, 0, 0), L.bind(void 0, 0, 0, 0, 0, 1), L.bind(void 0, 0, 0, 0, 0, 2), L.bind(void 0, 0, 0, 0, 0, 3), L.bind(void 0, 0, 0, 0, 1, 0), L.bind(void 0, 0, 0, 0, 1, 1), L.bind(void 0, 0, 0, 0, 1, 2), L.bind(void 0, 0, 0, 0, 1, 3), L.bind(void 0, 0, 0, 1, 0, 0), L.bind(void 0, 0, 0, 1, 0, 1), L.bind(void 0, 0, 0, 1, 0, 2), L.bind(void 0, 0, 0, 1, 0, 3), L.bind(void 0, 0, 0, 1, 1, 0), L.bind(void 0, 0, 0, 1, 1, 1), L.bind(void 0, 0, 0, 1, 1, 2), L.bind(void 0, 0, 0, 1, 1, 3), L.bind(void 0, 0, 1, 0, 0, 0), L.bind(void 0, 0, 1, 0, 0, 1), L.bind(void 0, 0, 1, 0, 0, 2), L.bind(void 0, 0, 1, 0, 0, 3), L.bind(void 0, 0, 1, 0, 1, 0), L.bind(void 0, 0, 1, 0, 1, 1), L.bind(void 0, 0, 1, 0, 1, 2), L.bind(void 0, 0, 1, 0, 1, 3), L.bind(void 0, 0, 1, 1, 0, 0), L.bind(void 0, 0, 1, 1, 0, 1), L.bind(void 0, 0, 1, 1, 0, 2), L.bind(void 0, 0, 1, 1, 0, 3), L.bind(void 0, 0, 1, 1, 1, 0), L.bind(void 0, 0, 1, 1, 1, 1), L.bind(void 0, 0, 1, 1, 1, 2), L.bind(void 0, 0, 1, 1, 1, 3), L.bind(void 0, 1, 0, 0, 0, 0), L.bind(void 0, 1, 0, 0, 0, 1), L.bind(void 0, 1, 0, 0, 0, 2), L.bind(void 0, 1, 0, 0, 0, 3), L.bind(void 0, 1, 0, 0, 1, 0), L.bind(void 0, 1, 0, 0, 1, 1), L.bind(void 0, 1, 0, 0, 1, 2), L.bind(void 0, 1, 0, 0, 1, 3), L.bind(void 0, 1, 0, 1, 0, 0), L.bind(void 0, 1, 0, 1, 0, 1), L.bind(void 0, 1, 0, 1, 0, 2), L.bind(void 0, 1, 0, 1, 0, 3), L.bind(void 0, 1, 0, 1, 1, 0), L.bind(void 0, 1, 0, 1, 1, 1), L.bind(void 0, 1, 0, 1, 1, 2), L.bind(void 0, 1, 0, 1, 1, 3), L.bind(void 0, 1, 1, 0, 0, 0), L.bind(void 0, 1, 1, 0, 0, 1), L.bind(void 0, 1, 1, 0, 0, 2), L.bind(void 0, 1, 1, 0, 0, 3), L.bind(void 0, 1, 1, 0, 1, 0), L.bind(void 0, 1, 1, 0, 1, 1), L.bind(void 0, 1, 1, 0, 1, 2), L.bind(void 0, 1, 1, 0, 1, 3), L.bind(void 0, 1, 1, 1, 0, 0), L.bind(void 0, 1, 1, 1, 0, 1), L.bind(void 0, 1, 1, 1, 0, 2), L.bind(void 0, 1, 1, 1, 0, 3), L.bind(void 0, 1, 1, 1, 1, 0), L.bind(void 0, 1, 1, 1, 1, 1), L.bind(void 0, 1, 1, 1, 1, 2), L.bind(void 0, 1, 1, 1, 1, 3)], jr = Array.from || function(e4) {
                return e4.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]?|[^\uD800-\uDFFF]|./g) || [];
              };
              function k(e4) {
                (e4 = e4 || {}).empty || (_(e4.familyName, "When creating a new Font object, familyName is required."), _(e4.styleName, "When creating a new Font object, styleName is required."), _(e4.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), _(e4.ascender, "When creating a new Font object, ascender is required."), _(e4.descender, "When creating a new Font object, descender is required."), _(e4.descender < 0, "Descender should be negative (e.g. -512)."), this.names = { fontFamily: { en: e4.familyName || " " }, fontSubfamily: { en: e4.styleName || " " }, fullName: { en: e4.fullName || e4.familyName + " " + e4.styleName }, postScriptName: { en: e4.postScriptName || (e4.familyName + e4.styleName).replace(/\s/g, "") }, designer: { en: e4.designer || " " }, designerURL: { en: e4.designerURL || " " }, manufacturer: { en: e4.manufacturer || " " }, manufacturerURL: { en: e4.manufacturerURL || " " }, license: { en: e4.license || " " }, licenseURL: { en: e4.licenseURL || " " }, version: { en: e4.version || "Version 0.1" }, description: { en: e4.description || " " }, copyright: { en: e4.copyright || " " }, trademark: { en: e4.trademark || " " } }, this.unitsPerEm = e4.unitsPerEm || 1e3, this.ascender = e4.ascender, this.descender = e4.descender, this.createdTimestamp = e4.createdTimestamp, this.tables = { os2: { usWeightClass: e4.weightClass || this.usWeightClasses.MEDIUM, usWidthClass: e4.widthClass || this.usWidthClasses.MEDIUM, fsSelection: e4.fsSelection || this.fsSelectionValues.REGULAR } }), this.supported = true, this.glyphs = new p.GlyphSet(this, e4.glyphs || []), this.encoding = new Te(this), this.position = new Ct(this), this.substitution = new i(this), this.tables = this.tables || {}, Object.defineProperty(this, "hinting", { get: function() {
                  return this._hinting || ("truetype" === this.outlinesFormat ? this._hinting = new Ut(this) : void 0);
                } });
              }
              function _r(e4, t4) {
                var r3, o3 = JSON.stringify(e4), n2 = 256;
                for (r3 in t4) {
                  var s3 = parseInt(r3);
                  if (s3 && !(s3 < 256)) {
                    if (JSON.stringify(t4[r3]) === o3)
                      return s3;
                    n2 <= s3 && (n2 = s3 + 1);
                  }
                }
                return t4[n2] = e4, n2;
              }
              k.prototype.hasChar = function(e4) {
                return null !== this.encoding.charToGlyphIndex(e4);
              }, k.prototype.charToGlyphIndex = function(e4) {
                return this.encoding.charToGlyphIndex(e4);
              }, k.prototype.charToGlyph = function(e4) {
                e4 = this.charToGlyphIndex(e4);
                return this.glyphs.get(e4) || this.glyphs.get(0);
              }, k.prototype.stringToGlyphs = function(e4, t4) {
                t4 = t4 || this.defaultRenderOptions;
                for (var r3 = jr(e4), o3 = [], n2 = 0; n2 < r3.length; n2 += 1) {
                  var s3 = r3[n2];
                  o3.push(this.charToGlyphIndex(s3));
                }
                var i2 = o3.length;
                if (t4.features) {
                  var e4 = t4.script || this.substitution.getDefaultScriptName(), a2 = [];
                  t4.features.liga && (a2 = a2.concat(this.substitution.getFeature("liga", e4, t4.language))), t4.features.rlig && (a2 = a2.concat(this.substitution.getFeature("rlig", e4, t4.language)));
                  for (var l2 = 0; l2 < i2; l2 += 1)
                    for (var u2 = 0; u2 < a2.length; u2++) {
                      for (var c2 = a2[u2], d2 = c2.sub, f2 = d2.length, h2 = 0; h2 < f2 && d2[h2] === o3[l2 + h2]; )
                        h2++;
                      h2 === f2 && (o3.splice(l2, f2, c2.by), i2 = i2 - f2 + 1);
                    }
                }
                for (var p2 = new Array(i2), m2 = this.glyphs.get(0), y2 = 0; y2 < i2; y2 += 1)
                  p2[y2] = this.glyphs.get(o3[y2]) || m2;
                return p2;
              }, k.prototype.nameToGlyphIndex = function(e4) {
                return this.glyphNames.nameToGlyphIndex(e4);
              }, k.prototype.nameToGlyph = function(e4) {
                e4 = this.nameToGlyphIndex(e4);
                return this.glyphs.get(e4) || this.glyphs.get(0);
              }, k.prototype.glyphIndexToName = function(e4) {
                return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(e4) : "";
              }, k.prototype.getKerningValue = function(e4, t4) {
                e4 = e4.index || e4, t4 = t4.index || t4;
                var r3 = this.position.defaultKerningTables;
                return r3 ? this.position.getKerningValue(r3, e4, t4) : this.kerningPairs[e4 + "," + t4] || 0;
              }, k.prototype.defaultRenderOptions = { kerning: true, features: { liga: true, rlig: true } }, k.prototype.forEachGlyph = function(e4, t4, r3, o3, n2, s3) {
                t4 = void 0 !== t4 ? t4 : 0, r3 = void 0 !== r3 ? r3 : 0, n2 = n2 || this.defaultRenderOptions;
                var i2, a2 = 1 / this.unitsPerEm * (o3 = void 0 !== o3 ? o3 : 72), l2 = this.stringToGlyphs(e4, n2);
                n2.kerning && (e4 = n2.script || this.position.getDefaultScriptName(), i2 = this.position.getKerningTables(e4, n2.language));
                for (var u2 = 0; u2 < l2.length; u2 += 1) {
                  var c2 = l2[u2];
                  s3.call(this, c2, t4, r3, o3, n2), c2.advanceWidth && (t4 += c2.advanceWidth * a2), n2.kerning && u2 < l2.length - 1 && (t4 += (i2 ? this.position.getKerningValue(i2, c2.index, l2[u2 + 1].index) : this.getKerningValue(c2, l2[u2 + 1])) * a2), n2.letterSpacing ? t4 += n2.letterSpacing * o3 : n2.tracking && (t4 += n2.tracking / 1e3 * o3);
                }
                return t4;
              }, k.prototype.getPath = function(e4, t4, r3, o3, n2) {
                var s3 = new f();
                return this.forEachGlyph(e4, t4, r3, o3, n2, function(e5, t5, r4, o4) {
                  e5 = e5.getPath(t5, r4, o4, n2, this);
                  s3.extend(e5);
                }), s3;
              }, k.prototype.getPaths = function(e4, t4, r3, o3, n2) {
                var s3 = [];
                return this.forEachGlyph(e4, t4, r3, o3, n2, function(e5, t5, r4, o4) {
                  e5 = e5.getPath(t5, r4, o4, n2, this);
                  s3.push(e5);
                }), s3;
              }, k.prototype.getAdvanceWidth = function(e4, t4, r3) {
                return this.forEachGlyph(e4, 0, 0, t4, r3, function() {
                });
              }, k.prototype.draw = function(e4, t4, r3, o3, n2, s3) {
                this.getPath(t4, r3, o3, n2, s3).draw(e4);
              }, k.prototype.drawPoints = function(n2, e4, t4, r3, o3, s3) {
                this.forEachGlyph(e4, t4, r3, o3, s3, function(e5, t5, r4, o4) {
                  e5.drawPoints(n2, t5, r4, o4);
                });
              }, k.prototype.drawMetrics = function(n2, e4, t4, r3, o3, s3) {
                this.forEachGlyph(e4, t4, r3, o3, s3, function(e5, t5, r4, o4) {
                  e5.drawMetrics(n2, t5, r4, o4);
                });
              }, k.prototype.getEnglishName = function(e4) {
                e4 = this.names[e4];
                if (e4)
                  return e4.en;
              }, k.prototype.validate = function() {
                var t4 = this;
                function e4(e5) {
                  e5 = t4.getEnglishName(e5);
                  e5 && e5.trim().length;
                }
                e4("fontFamily"), e4("weightName"), e4("manufacturer"), e4("copyright"), e4("version"), this.unitsPerEm;
              }, k.prototype.toTables = function() {
                return wt.fontToTable(this);
              }, k.prototype.toBuffer = function() {
                return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();
              }, k.prototype.toArrayBuffer = function() {
                for (var e4 = this.toTables().encode(), t4 = new ArrayBuffer(e4.length), r3 = new Uint8Array(t4), o3 = 0; o3 < e4.length; o3++)
                  r3[o3] = e4[o3];
                return t4;
              }, k.prototype.download = function(t4) {
                var e4 = this.getEnglishName("fontFamily"), r3 = this.getEnglishName("fontSubfamily"), o3 = (t4 = t4 || e4.replace(/\s/g, "") + "-" + r3 + ".otf", this.toArrayBuffer());
                "undefined" != typeof window ? (window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem, window.requestFileSystem(window.TEMPORARY, o3.byteLength, function(e5) {
                  e5.root.getFile(t4, { create: true }, function(r4) {
                    r4.createWriter(function(e6) {
                      var t5 = new DataView(o3), t5 = new Blob([t5], { type: "font/opentype" });
                      e6.write(t5), e6.addEventListener("writeend", function() {
                        location.href = r4.toURL();
                      }, false);
                    });
                  });
                }, function(e5) {
                  throw new Error(e5.name + ": " + e5.message);
                })) : (e4 = Ar("fs"), r3 = function(e5) {
                  for (var t5 = new kr(e5.byteLength), r4 = new Uint8Array(e5), o4 = 0; o4 < t5.length; ++o4)
                    t5[o4] = r4[o4];
                  return t5;
                }(o3), e4.writeFileSync(t4, r3));
              }, k.prototype.fsSelectionValues = { ITALIC: 1, UNDERSCORE: 2, NEGATIVE: 4, OUTLINED: 8, STRIKEOUT: 16, BOLD: 32, REGULAR: 64, USER_TYPO_METRICS: 128, WWS: 256, OBLIQUE: 512 }, k.prototype.usWidthClasses = { ULTRA_CONDENSED: 1, EXTRA_CONDENSED: 2, CONDENSED: 3, SEMI_CONDENSED: 4, MEDIUM: 5, SEMI_EXPANDED: 6, EXPANDED: 7, EXTRA_EXPANDED: 8, ULTRA_EXPANDED: 9 }, k.prototype.usWeightClasses = { THIN: 100, EXTRA_LIGHT: 200, LIGHT: 300, NORMAL: 400, MEDIUM: 500, SEMI_BOLD: 600, BOLD: 700, EXTRA_BOLD: 800, BLACK: 900 };
              var xr = { make: function(e4, t4) {
                var r3 = new S.Table("fvar", [{ name: "version", type: "ULONG", value: 65536 }, { name: "offsetToData", type: "USHORT", value: 0 }, { name: "countSizePairs", type: "USHORT", value: 2 }, { name: "axisCount", type: "USHORT", value: e4.axes.length }, { name: "axisSize", type: "USHORT", value: 20 }, { name: "instanceCount", type: "USHORT", value: e4.instances.length }, { name: "instanceSize", type: "USHORT", value: 4 + 4 * e4.axes.length }]);
                r3.offsetToData = r3.sizeOf();
                for (var o3, n2, s3, i2 = 0; i2 < e4.axes.length; i2++)
                  r3.fields = r3.fields.concat((o3 = i2, n2 = e4.axes[i2], s3 = t4, s3 = _r(n2.name, t4), [{ name: "tag_" + o3, type: "TAG", value: n2.tag }, { name: "minValue_" + o3, type: "FIXED", value: n2.minValue << 16 }, { name: "defaultValue_" + o3, type: "FIXED", value: n2.defaultValue << 16 }, { name: "maxValue_" + o3, type: "FIXED", value: n2.maxValue << 16 }, { name: "flags_" + o3, type: "USHORT", value: 0 }, { name: "nameID_" + o3, type: "USHORT", value: s3 }]));
                for (var a2 = 0; a2 < e4.instances.length; a2++)
                  r3.fields = r3.fields.concat(function(e5, t5, r4, o4) {
                    for (var n3 = [{ name: "nameID_" + e5, type: "USHORT", value: _r(t5.name, o4) }, { name: "flags_" + e5, type: "USHORT", value: 0 }], s4 = 0; s4 < r4.length; ++s4) {
                      var i3 = r4[s4].tag;
                      n3.push({ name: "axis_" + e5 + " " + i3, type: "FIXED", value: t5.coordinates[i3] << 16 });
                    }
                    return n3;
                  }(a2, e4.instances[a2], e4.axes, t4));
                return r3;
              }, parse: function(e4, t4, r3) {
                for (var o3, n2, s3, i2, a2 = new R.Parser(e4, t4), l2 = a2.parseULong(), u2 = (P.argument(65536 === l2, "Unsupported fvar table version."), a2.parseOffset16()), c2 = (a2.skip("uShort", 1), a2.parseUShort()), d2 = a2.parseUShort(), f2 = a2.parseUShort(), h2 = a2.parseUShort(), p2 = [], m2 = 0; m2 < c2; m2++)
                  p2.push((o3 = e4, n2 = t4 + u2 + m2 * d2, s3 = r3, void 0, i2 = {}, o3 = new R.Parser(o3, n2), i2.tag = o3.parseTag(), i2.minValue = o3.parseFixed(), i2.defaultValue = o3.parseFixed(), i2.maxValue = o3.parseFixed(), o3.skip("uShort", 1), i2.name = s3[o3.parseUShort()] || {}, i2));
                for (var y2 = [], g2 = t4 + u2 + c2 * d2, v2 = 0; v2 < f2; v2++)
                  y2.push(function(e5, t5, r4, o4) {
                    var n3 = {}, s4 = new R.Parser(e5, t5);
                    n3.name = o4[s4.parseUShort()] || {}, s4.skip("uShort", 1), n3.coordinates = {};
                    for (var i3 = 0; i3 < r4.length; ++i3)
                      n3.coordinates[r4[i3].tag] = s4.parseFixed();
                    return n3;
                  }(e4, g2 + v2 * h2, p2, r3));
                return { axes: p2, instances: y2 };
              } }, A = new Array(10);
              A[1] = function() {
                var e4 = this.offset + this.relativeOffset, t4 = this.parseUShort();
                return 1 === t4 ? { posFormat: 1, coverage: this.parsePointer(u.coverage), value: this.parseValueRecord() } : 2 === t4 ? { posFormat: 2, coverage: this.parsePointer(u.coverage), values: this.parseValueRecordList() } : void P.assert(false, "0x" + e4.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
              }, A[2] = function() {
                var e4, t4, r3, o3, n2 = this.offset + this.relativeOffset, s3 = this.parseUShort(), n2 = (P.assert(1 === s3 || 2 === s3, "0x" + n2.toString(16) + ": GPOS lookup type 2 format must be 1 or 2."), this.parsePointer(u.coverage)), i2 = this.parseUShort(), a2 = this.parseUShort();
                return 1 === s3 ? { posFormat: s3, coverage: n2, valueFormat1: i2, valueFormat2: a2, pairSets: this.parseList(u.pointer(u.list(function() {
                  return { secondGlyph: this.parseUShort(), value1: this.parseValueRecord(i2), value2: this.parseValueRecord(a2) };
                }))) } : 2 === s3 ? (e4 = this.parsePointer(u.classDef), t4 = this.parsePointer(u.classDef), r3 = this.parseUShort(), o3 = this.parseUShort(), { posFormat: s3, coverage: n2, valueFormat1: i2, valueFormat2: a2, classDef1: e4, classDef2: t4, class1Count: r3, class2Count: o3, classRecords: this.parseList(r3, u.list(o3, function() {
                  return { value1: this.parseValueRecord(i2), value2: this.parseValueRecord(a2) };
                })) }) : void 0;
              }, A[3] = function() {
                return { error: "GPOS Lookup 3 not supported" };
              }, A[4] = function() {
                return { error: "GPOS Lookup 4 not supported" };
              }, A[5] = function() {
                return { error: "GPOS Lookup 5 not supported" };
              }, A[6] = function() {
                return { error: "GPOS Lookup 6 not supported" };
              }, A[7] = function() {
                return { error: "GPOS Lookup 7 not supported" };
              }, A[8] = function() {
                return { error: "GPOS Lookup 8 not supported" };
              }, A[9] = function() {
                return { error: "GPOS Lookup 9 not supported" };
              };
              var wr = new Array(10);
              var Sr = { parse: function(e4, t4) {
                return t4 = (e4 = new u(e4, t4 = t4 || 0)).parseVersion(1), P.argument(1 === t4 || 1.1 === t4, "Unsupported GPOS table version " + t4), 1 === t4 ? { version: t4, scripts: e4.parseScriptList(), features: e4.parseFeatureList(), lookups: e4.parseLookupList(A) } : { version: t4, scripts: e4.parseScriptList(), features: e4.parseFeatureList(), lookups: e4.parseLookupList(A), variations: e4.parseFeatureVariationsList() };
              }, make: function(e4) {
                return new S.Table("GPOS", [{ name: "version", type: "ULONG", value: 65536 }, { name: "scripts", type: "TABLE", value: new S.ScriptList(e4.scripts) }, { name: "features", type: "TABLE", value: new S.FeatureList(e4.features) }, { name: "lookups", type: "TABLE", value: new S.LookupList(e4.lookups, wr) }]);
              } };
              var Mr = { parse: function(e4, t4) {
                if (e4 = new R.Parser(e4, t4), 0 === (t4 = e4.parseUShort())) {
                  var r3 = e4, o3 = {}, n2 = (r3.skip("uShort"), r3.parseUShort()), s3 = (P.argument(0 === n2, "Unsupported kern sub-table version."), r3.skip("uShort", 2), r3.parseUShort());
                  r3.skip("uShort", 3);
                  for (var i2 = 0; i2 < s3; i2 += 1) {
                    var a2 = r3.parseUShort(), l2 = r3.parseUShort(), u2 = r3.parseShort();
                    o3[a2 + "," + l2] = u2;
                  }
                  return o3;
                }
                if (1 !== t4)
                  throw new Error("Unsupported kern table version (" + t4 + ").");
                var c2 = e4, d2 = {}, n2 = (c2.skip("uShort"), 1 < c2.parseULong() && console.warn("Only the first kern subtable is supported."), c2.skip("uLong"), 255 & c2.parseUShort());
                if (c2.skip("uShort"), 0 == n2) {
                  var f2 = c2.parseUShort();
                  c2.skip("uShort", 3);
                  for (var h2 = 0; h2 < f2; h2 += 1) {
                    var p2 = c2.parseUShort(), m2 = c2.parseUShort(), y2 = c2.parseShort();
                    d2[p2 + "," + m2] = y2;
                  }
                }
                return d2;
              } };
              var Er = { parse: function(e4, t4, r3, o3) {
                for (var n2 = new R.Parser(e4, t4), s3 = o3 ? n2.parseUShort : n2.parseULong, i2 = [], a2 = 0; a2 < r3 + 1; a2 += 1) {
                  var l2 = s3.call(n2);
                  o3 && (l2 *= 2), i2.push(l2);
                }
                return i2;
              } };
              function Tr(e4, r3) {
                Ar("fs").readFile(e4, function(e5, t4) {
                  if (e5)
                    return r3(e5.message);
                  r3(null, Lt(t4));
                });
              }
              function Cr(e4, t4) {
                var r3 = new XMLHttpRequest();
                r3.open("get", e4, true), r3.responseType = "arraybuffer", r3.onload = function() {
                  return r3.response ? t4(null, r3.response) : t4("Font could not be loaded: " + r3.statusText);
                }, r3.onerror = function() {
                  t4("Font could not be loaded");
                }, r3.send();
              }
              function Or(e4, t4) {
                for (var r3 = [], o3 = 12, n2 = 0; n2 < t4; n2 += 1) {
                  var s3 = R.getTag(e4, o3), i2 = R.getULong(e4, o3 + 4), a2 = R.getULong(e4, o3 + 8), l2 = R.getULong(e4, o3 + 12);
                  r3.push({ tag: s3, checksum: i2, offset: a2, length: l2, compression: false }), o3 += 16;
                }
                return r3;
              }
              function D(e4, t4) {
                if ("WOFF" !== t4.compression)
                  return { data: e4, offset: t4.offset };
                var e4 = new Uint8Array(e4.buffer, t4.offset + 2, t4.compressedLength - 2), r3 = new Uint8Array(t4.length);
                if (re(e4, r3), r3.byteLength !== t4.length)
                  throw new Error("Decompression error: " + t4.tag + " decompressed length doesn't match recorded length");
                return { data: new DataView(r3.buffer, 0), offset: 0 };
              }
              function Lr(e4) {
                var t4, r3, o3, n2, s3, i2, a2, l2, u2, c2, d2, f2, h2, p2, m2 = new k({ empty: true }), y2 = new DataView(e4, 0), g2 = [], e4 = R.getTag(y2, 0);
                if (e4 === String.fromCharCode(0, 1, 0, 0) || "true" === e4 || "typ1" === e4)
                  m2.outlinesFormat = "truetype", g2 = Or(y2, o3 = R.getUShort(y2, 4));
                else if ("OTTO" === e4)
                  m2.outlinesFormat = "cff", g2 = Or(y2, o3 = R.getUShort(y2, 4));
                else {
                  if ("wOFF" !== e4)
                    throw new Error("Unsupported OpenType signature " + e4);
                  var v2 = R.getTag(y2, 4);
                  if (v2 === String.fromCharCode(0, 1, 0, 0))
                    m2.outlinesFormat = "truetype";
                  else {
                    if ("OTTO" !== v2)
                      throw new Error("Unsupported OpenType flavor " + e4);
                    m2.outlinesFormat = "cff";
                  }
                  g2 = function(e5, t5) {
                    for (var r4 = [], o4 = 44, n3 = 0; n3 < t5; n3 += 1) {
                      var s4 = R.getTag(e5, o4), i3 = R.getULong(e5, o4 + 4), a3 = R.getULong(e5, o4 + 8), l3 = R.getULong(e5, o4 + 12), u3 = void 0, u3 = a3 < l3 && "WOFF";
                      r4.push({ tag: s4, offset: i3, compression: u3, compressedLength: a3, length: l3 }), o4 += 20;
                    }
                    return r4;
                  }(y2, o3 = R.getUShort(y2, 12));
                }
                for (var b2 = 0; b2 < o3; b2 += 1) {
                  var j2 = g2[b2], _2 = void 0;
                  switch (j2.tag) {
                    case "cmap":
                      _2 = D(y2, j2), m2.tables.cmap = we.parse(_2.data, _2.offset), m2.encoding = new Ce(m2.tables.cmap);
                      break;
                    case "cvt ":
                      _2 = D(y2, j2), p2 = new R.Parser(_2.data, _2.offset), m2.tables.cvt = p2.parseShortList(j2.length / 2);
                      break;
                    case "fvar":
                      s3 = j2;
                      break;
                    case "fpgm":
                      _2 = D(y2, j2), p2 = new R.Parser(_2.data, _2.offset), m2.tables.fpgm = p2.parseByteList(j2.length);
                      break;
                    case "head":
                      _2 = D(y2, j2), m2.tables.head = Ze.parse(_2.data, _2.offset), m2.unitsPerEm = m2.tables.head.unitsPerEm, t4 = m2.tables.head.indexToLocFormat;
                      break;
                    case "hhea":
                      _2 = D(y2, j2), m2.tables.hhea = Qe.parse(_2.data, _2.offset), m2.ascender = m2.tables.hhea.ascender, m2.descender = m2.tables.hhea.descender, m2.numberOfHMetrics = m2.tables.hhea.numberOfHMetrics;
                      break;
                    case "hmtx":
                      u2 = j2;
                      break;
                    case "ltag":
                      _2 = D(y2, j2), r3 = Je.parse(_2.data, _2.offset);
                      break;
                    case "maxp":
                      _2 = D(y2, j2), m2.tables.maxp = $e.parse(_2.data, _2.offset), m2.numGlyphs = m2.tables.maxp.numGlyphs;
                      break;
                    case "name":
                      f2 = j2;
                      break;
                    case "OS/2":
                      _2 = D(y2, j2), m2.tables.os2 = ht.parse(_2.data, _2.offset);
                      break;
                    case "post":
                      _2 = D(y2, j2), m2.tables.post = pt.parse(_2.data, _2.offset), m2.glyphNames = new Le(m2.tables.post);
                      break;
                    case "prep":
                      _2 = D(y2, j2), p2 = new R.Parser(_2.data, _2.offset), m2.tables.prep = p2.parseByteList(j2.length);
                      break;
                    case "glyf":
                      i2 = j2;
                      break;
                    case "loca":
                      d2 = j2;
                      break;
                    case "CFF ":
                      n2 = j2;
                      break;
                    case "kern":
                      c2 = j2;
                      break;
                    case "GPOS":
                      a2 = j2;
                      break;
                    case "GSUB":
                      l2 = j2;
                      break;
                    case "meta":
                      h2 = j2;
                  }
                }
                v2 = D(y2, f2);
                if (m2.tables.name = dt.parse(v2.data, v2.offset, r3), m2.names = m2.tables.name, i2 && d2) {
                  e4 = 0 === t4, v2 = D(y2, d2), v2 = Er.parse(v2.data, v2.offset, m2.numGlyphs, e4), e4 = D(y2, i2);
                  m2.glyphs = It.parse(e4.data, e4.offset, v2, m2);
                } else {
                  if (!n2)
                    throw new Error("Font doesn't contain TrueType or CFF outlines.");
                  e4 = D(y2, n2);
                  Ye.parse(e4.data, e4.offset, m2);
                }
                for (var v2 = D(y2, u2), x2 = (Ke.parse(v2.data, v2.offset, m2.numberOfHMetrics, m2.numGlyphs, m2.glyphs), m2), w2 = x2.tables.cmap.glyphIndexMap, S2 = Object.keys(w2), M2 = 0; M2 < S2.length; M2 += 1) {
                  var E2, T2 = S2[M2], C2 = w2[T2];
                  (E2 = x2.glyphs.get(C2)).addUnicode(parseInt(T2));
                }
                for (var O2 = 0; O2 < x2.glyphs.length; O2 += 1)
                  E2 = x2.glyphs.get(O2), x2.cffEncoding ? x2.isCIDFont ? E2.name = "gid" + O2 : E2.name = x2.cffEncoding.charset[O2] : x2.glyphNames.names && (E2.name = x2.glyphNames.glyphIndexToName(O2));
                return c2 ? (e4 = D(y2, c2), m2.kerningPairs = Mr.parse(e4.data, e4.offset)) : m2.kerningPairs = {}, a2 && (v2 = D(y2, a2), m2.tables.gpos = Sr.parse(v2.data, v2.offset), m2.position.init()), l2 && (e4 = D(y2, l2), m2.tables.gsub = yt.parse(e4.data, e4.offset)), s3 && (v2 = D(y2, s3), m2.tables.fvar = xr.parse(v2.data, v2.offset, m2.names)), h2 && (e4 = D(y2, h2), m2.tables.meta = gt.parse(e4.data, e4.offset), m2.metas = m2.tables.meta), m2;
              }
              j.Font = k, j.Glyph = h, j.Path = f, j.BoundingBox = a, j._parse = R, j.parse = Lr, j.load = function(e4, o3) {
                ("undefined" == typeof window ? Tr : Cr)(e4, function(e5, t4) {
                  if (e5)
                    return o3(e5);
                  var r3;
                  try {
                    r3 = Lr(t4);
                  } catch (e6) {
                    return o3(e6, null);
                  }
                  return o3(null, r3);
                });
              }, j.loadSync = function(e4) {
                return Lr(Lt(Ar("fs").readFileSync(e4)));
              }, Object.defineProperty(j, "__esModule", { value: true });
            }, "object" == typeof o && void 0 !== r ? t2(o) : "function" == typeof s && s.amd ? s(["exports"], t2) : t2(e2.opentype = {});
          }.call(this, Ar("buffer").Buffer);
        }, { buffer: 4, fs: 2 }], 242: [function(e2, t2, u) {
          !function(n) {
            function s2(e3, t3) {
              for (var r = 0, o2 = e3.length - 1; 0 <= o2; o2--) {
                var n2 = e3[o2];
                "." === n2 ? e3.splice(o2, 1) : ".." === n2 ? (e3.splice(o2, 1), r++) : r && (e3.splice(o2, 1), r--);
              }
              if (t3)
                for (; r--; )
                  e3.unshift("..");
              return e3;
            }
            function i(e3, t3) {
              if (e3.filter)
                return e3.filter(t3);
              for (var r = [], o2 = 0; o2 < e3.length; o2++)
                t3(e3[o2], o2, e3) && r.push(e3[o2]);
              return r;
            }
            u.resolve = function() {
              for (var e3 = "", t3 = false, r = arguments.length - 1; -1 <= r && !t3; r--) {
                var o2 = 0 <= r ? arguments[r] : n.cwd();
                if ("string" != typeof o2)
                  throw new TypeError("Arguments to path.resolve must be strings");
                o2 && (e3 = o2 + "/" + e3, t3 = "/" === o2.charAt(0));
              }
              return (t3 ? "/" : "") + (e3 = s2(i(e3.split("/"), function(e4) {
                return !!e4;
              }), !t3).join("/")) || ".";
            }, u.normalize = function(e3) {
              var t3 = u.isAbsolute(e3), r = "/" === o(e3, -1);
              return (e3 = (e3 = s2(i(e3.split("/"), function(e4) {
                return !!e4;
              }), !t3).join("/")) || t3 ? e3 : ".") && r && (e3 += "/"), (t3 ? "/" : "") + e3;
            }, u.isAbsolute = function(e3) {
              return "/" === e3.charAt(0);
            }, u.join = function() {
              var e3 = Array.prototype.slice.call(arguments, 0);
              return u.normalize(i(e3, function(e4, t3) {
                if ("string" != typeof e4)
                  throw new TypeError("Arguments to path.join must be strings");
                return e4;
              }).join("/"));
            }, u.relative = function(e3, t3) {
              function r(e4) {
                for (var t4 = 0; t4 < e4.length && "" === e4[t4]; t4++)
                  ;
                for (var r2 = e4.length - 1; 0 <= r2 && "" === e4[r2]; r2--)
                  ;
                return r2 < t4 ? [] : e4.slice(t4, r2 - t4 + 1);
              }
              e3 = u.resolve(e3).substr(1), t3 = u.resolve(t3).substr(1);
              for (var o2 = r(e3.split("/")), n2 = r(t3.split("/")), s3 = Math.min(o2.length, n2.length), i2 = s3, a = 0; a < s3; a++)
                if (o2[a] !== n2[a]) {
                  i2 = a;
                  break;
                }
              for (var l = [], a = i2; a < o2.length; a++)
                l.push("..");
              return (l = l.concat(n2.slice(i2))).join("/");
            }, u.sep = "/", u.delimiter = ":", u.dirname = function(e3) {
              if ("string" != typeof e3 && (e3 += ""), 0 === e3.length)
                return ".";
              for (var t3 = 47 === e3.charCodeAt(0), r = -1, o2 = true, n2 = e3.length - 1; 1 <= n2; --n2)
                if (47 === e3.charCodeAt(n2)) {
                  if (!o2) {
                    r = n2;
                    break;
                  }
                } else
                  o2 = false;
              return -1 === r ? t3 ? "/" : "." : t3 && 1 === r ? "/" : e3.slice(0, r);
            }, u.basename = function(e3, t3) {
              e3 = function(e4) {
                "string" != typeof e4 && (e4 += "");
                for (var t4 = 0, r = -1, o2 = true, n2 = e4.length - 1; 0 <= n2; --n2)
                  if (47 === e4.charCodeAt(n2)) {
                    if (!o2) {
                      t4 = n2 + 1;
                      break;
                    }
                  } else
                    -1 === r && (o2 = false, r = n2 + 1);
                return -1 === r ? "" : e4.slice(t4, r);
              }(e3);
              return e3 = t3 && e3.substr(-1 * t3.length) === t3 ? e3.substr(0, e3.length - t3.length) : e3;
            }, u.extname = function(e3) {
              "string" != typeof e3 && (e3 += "");
              for (var t3 = -1, r = 0, o2 = -1, n2 = true, s3 = 0, i2 = e3.length - 1; 0 <= i2; --i2) {
                var a = e3.charCodeAt(i2);
                if (47 === a) {
                  if (n2)
                    continue;
                  r = i2 + 1;
                  break;
                }
                -1 === o2 && (n2 = false, o2 = i2 + 1), 46 === a ? -1 === t3 ? t3 = i2 : 1 !== s3 && (s3 = 1) : -1 !== t3 && (s3 = -1);
              }
              return -1 === t3 || -1 === o2 || 0 === s3 || 1 === s3 && t3 === o2 - 1 && t3 === r + 1 ? "" : e3.slice(t3, o2);
            };
            var o = "b" === "ab".substr(-1) ? function(e3, t3, r) {
              return e3.substr(t3, r);
            } : function(e3, t3, r) {
              return t3 < 0 && (t3 = e3.length + t3), e3.substr(t3, r);
            };
          }.call(this, e2("_process"));
        }, { _process: 243 }], 243: [function(e2, t2, r) {
          var o, n, t2 = t2.exports = {};
          function s2() {
            throw new Error("setTimeout has not been defined");
          }
          function i() {
            throw new Error("clearTimeout has not been defined");
          }
          try {
            o = "function" == typeof setTimeout ? setTimeout : s2;
          } catch (e3) {
            o = s2;
          }
          try {
            n = "function" == typeof clearTimeout ? clearTimeout : i;
          } catch (e3) {
            n = i;
          }
          function a(t3) {
            if (o === setTimeout)
              return setTimeout(t3, 0);
            if ((o === s2 || !o) && setTimeout)
              return (o = setTimeout)(t3, 0);
            try {
              return o(t3, 0);
            } catch (e3) {
              try {
                return o.call(null, t3, 0);
              } catch (e4) {
                return o.call(this, t3, 0);
              }
            }
          }
          var l, u = [], c = false, d = -1;
          function f() {
            c && l && (c = false, l.length ? u = l.concat(u) : d = -1, u.length && h());
          }
          function h() {
            if (!c) {
              for (var e3 = a(f), t3 = (c = true, u.length); t3; ) {
                for (l = u, u = []; ++d < t3; )
                  l && l[d].run();
                d = -1, t3 = u.length;
              }
              l = null, c = false, !function(t4) {
                if (n === clearTimeout)
                  return clearTimeout(t4);
                if ((n === i || !n) && clearTimeout)
                  return (n = clearTimeout)(t4);
                try {
                  n(t4);
                } catch (e4) {
                  try {
                    return n.call(null, t4);
                  } catch (e5) {
                    return n.call(this, t4);
                  }
                }
              }(e3);
            }
          }
          function p(e3, t3) {
            this.fun = e3, this.array = t3;
          }
          function m() {
          }
          t2.nextTick = function(e3) {
            var t3 = new Array(arguments.length - 1);
            if (1 < arguments.length)
              for (var r2 = 1; r2 < arguments.length; r2++)
                t3[r2 - 1] = arguments[r2];
            u.push(new p(e3, t3)), 1 !== u.length || c || a(h);
          }, p.prototype.run = function() {
            this.fun.apply(null, this.array);
          }, t2.title = "browser", t2.browser = true, t2.env = {}, t2.argv = [], t2.version = "", t2.versions = {}, t2.on = m, t2.addListener = m, t2.once = m, t2.off = m, t2.removeListener = m, t2.removeAllListeners = m, t2.emit = m, t2.prependListener = m, t2.prependOnceListener = m, t2.listeners = function(e3) {
            return [];
          }, t2.binding = function(e3) {
            throw new Error("process.binding is not supported");
          }, t2.cwd = function() {
            return "/";
          }, t2.chdir = function(e3) {
            throw new Error("process.chdir is not supported");
          }, t2.umask = function() {
            return 0;
          };
        }, {}], 244: [function(e2, t2, r) {
          t2 = function(s2) {
            "use strict";
            var l, e3 = Object.prototype, u = e3.hasOwnProperty, t3 = "function" == typeof Symbol ? Symbol : {}, o = t3.iterator || "@@iterator", r2 = t3.asyncIterator || "@@asyncIterator", n = t3.toStringTag || "@@toStringTag";
            function i(e4, t4, r3, o2) {
              var n2, s3, i2, a2, t4 = t4 && t4.prototype instanceof y ? t4 : y, t4 = Object.create(t4.prototype), o2 = new S(o2 || []);
              return t4._invoke = (n2 = e4, s3 = r3, i2 = o2, a2 = d, function(e5, t5) {
                if (a2 === h)
                  throw new Error("Generator is already running");
                if (a2 === p) {
                  if ("throw" === e5)
                    throw t5;
                  return E();
                }
                for (i2.method = e5, i2.arg = t5; ; ) {
                  var r4 = i2.delegate;
                  if (r4) {
                    r4 = function e6(t6, r5) {
                      var o3 = t6.iterator[r5.method];
                      if (o3 === l) {
                        if (r5.delegate = null, "throw" === r5.method) {
                          if (t6.iterator.return && (r5.method = "return", r5.arg = l, e6(t6, r5), "throw" === r5.method))
                            return m;
                          r5.method = "throw", r5.arg = new TypeError("The iterator does not provide a 'throw' method");
                        }
                        return m;
                      }
                      o3 = c(o3, t6.iterator, r5.arg);
                      if ("throw" === o3.type)
                        return r5.method = "throw", r5.arg = o3.arg, r5.delegate = null, m;
                      o3 = o3.arg;
                      if (!o3)
                        return r5.method = "throw", r5.arg = new TypeError("iterator result is not an object"), r5.delegate = null, m;
                      {
                        if (!o3.done)
                          return o3;
                        r5[t6.resultName] = o3.value, r5.next = t6.nextLoc, "return" !== r5.method && (r5.method = "next", r5.arg = l);
                      }
                      r5.delegate = null;
                      return m;
                    }(r4, i2);
                    if (r4) {
                      if (r4 === m)
                        continue;
                      return r4;
                    }
                  }
                  if ("next" === i2.method)
                    i2.sent = i2._sent = i2.arg;
                  else if ("throw" === i2.method) {
                    if (a2 === d)
                      throw a2 = p, i2.arg;
                    i2.dispatchException(i2.arg);
                  } else
                    "return" === i2.method && i2.abrupt("return", i2.arg);
                  a2 = h;
                  r4 = c(n2, s3, i2);
                  if ("normal" === r4.type) {
                    if (a2 = i2.done ? p : f, r4.arg !== m)
                      return { value: r4.arg, done: i2.done };
                  } else
                    "throw" === r4.type && (a2 = p, i2.method = "throw", i2.arg = r4.arg);
                }
              }), t4;
            }
            function c(e4, t4, r3) {
              try {
                return { type: "normal", arg: e4.call(t4, r3) };
              } catch (e5) {
                return { type: "throw", arg: e5 };
              }
            }
            s2.wrap = i;
            var d = "suspendedStart", f = "suspendedYield", h = "executing", p = "completed", m = {};
            function y() {
            }
            function a() {
            }
            function g() {
            }
            var t3 = {}, v = (t3[o] = function() {
              return this;
            }, Object.getPrototypeOf), v = v && v(v(M([]))), b = (v && v !== e3 && u.call(v, o) && (t3 = v), g.prototype = y.prototype = Object.create(t3));
            function j(e4) {
              ["next", "throw", "return"].forEach(function(t4) {
                e4[t4] = function(e5) {
                  return this._invoke(t4, e5);
                };
              });
            }
            function _(i2) {
              var t4;
              this._invoke = function(r3, o2) {
                function e4() {
                  return new Promise(function(e5, t5) {
                    !function t6(e6, r4, o3, n2) {
                      var s3, e6 = c(i2[e6], i2, r4);
                      if ("throw" !== e6.type)
                        return (r4 = (s3 = e6.arg).value) && "object" == typeof r4 && u.call(r4, "__await") ? Promise.resolve(r4.__await).then(function(e7) {
                          t6("next", e7, o3, n2);
                        }, function(e7) {
                          t6("throw", e7, o3, n2);
                        }) : Promise.resolve(r4).then(function(e7) {
                          s3.value = e7, o3(s3);
                        }, function(e7) {
                          return t6("throw", e7, o3, n2);
                        });
                      n2(e6.arg);
                    }(r3, o2, e5, t5);
                  });
                }
                return t4 = t4 ? t4.then(e4, e4) : e4();
              };
            }
            function x(e4) {
              var t4 = { tryLoc: e4[0] };
              1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
            }
            function w(e4) {
              var t4 = e4.completion || {};
              t4.type = "normal", delete t4.arg, e4.completion = t4;
            }
            function S(e4) {
              this.tryEntries = [{ tryLoc: "root" }], e4.forEach(x, this), this.reset(true);
            }
            function M(t4) {
              if (t4) {
                var r3, e4 = t4[o];
                if (e4)
                  return e4.call(t4);
                if ("function" == typeof t4.next)
                  return t4;
                if (!isNaN(t4.length))
                  return r3 = -1, (e4 = function e5() {
                    for (; ++r3 < t4.length; )
                      if (u.call(t4, r3))
                        return e5.value = t4[r3], e5.done = false, e5;
                    return e5.value = l, e5.done = true, e5;
                  }).next = e4;
              }
              return { next: E };
            }
            function E() {
              return { value: l, done: true };
            }
            return (a.prototype = b.constructor = g).constructor = a, g[n] = a.displayName = "GeneratorFunction", s2.isGeneratorFunction = function(e4) {
              e4 = "function" == typeof e4 && e4.constructor;
              return !!e4 && (e4 === a || "GeneratorFunction" === (e4.displayName || e4.name));
            }, s2.mark = function(e4) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(e4, g) : (e4.__proto__ = g, n in e4 || (e4[n] = "GeneratorFunction")), e4.prototype = Object.create(b), e4;
            }, s2.awrap = function(e4) {
              return { __await: e4 };
            }, j(_.prototype), _.prototype[r2] = function() {
              return this;
            }, s2.AsyncIterator = _, s2.async = function(e4, t4, r3, o2) {
              var n2 = new _(i(e4, t4, r3, o2));
              return s2.isGeneratorFunction(t4) ? n2 : n2.next().then(function(e5) {
                return e5.done ? e5.value : n2.next();
              });
            }, j(b), b[n] = "Generator", b[o] = function() {
              return this;
            }, b.toString = function() {
              return "[object Generator]";
            }, s2.keys = function(r3) {
              var e4, o2 = [];
              for (e4 in r3)
                o2.push(e4);
              return o2.reverse(), function e5() {
                for (; o2.length; ) {
                  var t4 = o2.pop();
                  if (t4 in r3)
                    return e5.value = t4, e5.done = false, e5;
                }
                return e5.done = true, e5;
              };
            }, s2.values = M, S.prototype = { constructor: S, reset: function(e4) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = l, this.done = false, this.delegate = null, this.method = "next", this.arg = l, this.tryEntries.forEach(w), !e4)
                for (var t4 in this)
                  "t" === t4.charAt(0) && u.call(this, t4) && !isNaN(+t4.slice(1)) && (this[t4] = l);
            }, stop: function() {
              this.done = true;
              var e4 = this.tryEntries[0].completion;
              if ("throw" === e4.type)
                throw e4.arg;
              return this.rval;
            }, dispatchException: function(r3) {
              if (this.done)
                throw r3;
              var o2 = this;
              function e4(e5, t5) {
                return s3.type = "throw", s3.arg = r3, o2.next = e5, t5 && (o2.method = "next", o2.arg = l), !!t5;
              }
              for (var t4 = this.tryEntries.length - 1; 0 <= t4; --t4) {
                var n2 = this.tryEntries[t4], s3 = n2.completion;
                if ("root" === n2.tryLoc)
                  return e4("end");
                if (n2.tryLoc <= this.prev) {
                  var i2 = u.call(n2, "catchLoc"), a2 = u.call(n2, "finallyLoc");
                  if (i2 && a2) {
                    if (this.prev < n2.catchLoc)
                      return e4(n2.catchLoc, true);
                    if (this.prev < n2.finallyLoc)
                      return e4(n2.finallyLoc);
                  } else if (i2) {
                    if (this.prev < n2.catchLoc)
                      return e4(n2.catchLoc, true);
                  } else {
                    if (!a2)
                      throw new Error("try statement without catch or finally");
                    if (this.prev < n2.finallyLoc)
                      return e4(n2.finallyLoc);
                  }
                }
              }
            }, abrupt: function(e4, t4) {
              for (var r3 = this.tryEntries.length - 1; 0 <= r3; --r3) {
                var o2 = this.tryEntries[r3];
                if (o2.tryLoc <= this.prev && u.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
                  var n2 = o2;
                  break;
                }
              }
              var s3 = (n2 = n2 && ("break" === e4 || "continue" === e4) && n2.tryLoc <= t4 && t4 <= n2.finallyLoc ? null : n2) ? n2.completion : {};
              return s3.type = e4, s3.arg = t4, n2 ? (this.method = "next", this.next = n2.finallyLoc, m) : this.complete(s3);
            }, complete: function(e4, t4) {
              if ("throw" === e4.type)
                throw e4.arg;
              return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), m;
            }, finish: function(e4) {
              for (var t4 = this.tryEntries.length - 1; 0 <= t4; --t4) {
                var r3 = this.tryEntries[t4];
                if (r3.finallyLoc === e4)
                  return this.complete(r3.completion, r3.afterLoc), w(r3), m;
              }
            }, catch: function(e4) {
              for (var t4 = this.tryEntries.length - 1; 0 <= t4; --t4) {
                var r3, o2, n2 = this.tryEntries[t4];
                if (n2.tryLoc === e4)
                  return "throw" === (r3 = n2.completion).type && (o2 = r3.arg, w(n2)), o2;
              }
              throw new Error("illegal catch attempt");
            }, delegateYield: function(e4, t4, r3) {
              return this.delegate = { iterator: M(e4), resultName: t4, nextLoc: r3 }, "next" === this.method && (this.arg = l), m;
            } }, s2;
          }("object" == typeof t2 ? t2.exports : {});
          try {
            regeneratorRuntime = t2;
          } catch (e3) {
            Function("r", "regeneratorRuntime = r")(t2);
          }
        }, {}], 245: [function(e2, t2, r) {
          !function(e3) {
            "use strict";
            var t3, r2, i, o, n, s2, a, l, u, c;
            function d(e4) {
              if ("string" != typeof e4 && (e4 = String(e4)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e4))
                throw new TypeError("Invalid character in header field name");
              return e4.toLowerCase();
            }
            function f(e4) {
              return e4 = "string" != typeof e4 ? String(e4) : e4;
            }
            function h(t4) {
              var e4 = { next: function() {
                var e5 = t4.shift();
                return { done: void 0 === e5, value: e5 };
              } };
              return r2 && (e4[Symbol.iterator] = function() {
                return e4;
              }), e4;
            }
            function p(t4) {
              this.map = {}, t4 instanceof p ? t4.forEach(function(e4, t5) {
                this.append(t5, e4);
              }, this) : Array.isArray(t4) ? t4.forEach(function(e4) {
                this.append(e4[0], e4[1]);
              }, this) : t4 && Object.getOwnPropertyNames(t4).forEach(function(e4) {
                this.append(e4, t4[e4]);
              }, this);
            }
            function m(e4) {
              if (e4.bodyUsed)
                return Promise.reject(new TypeError("Already read"));
              e4.bodyUsed = true;
            }
            function y(r3) {
              return new Promise(function(e4, t4) {
                r3.onload = function() {
                  e4(r3.result);
                }, r3.onerror = function() {
                  t4(r3.error);
                };
              });
            }
            function g(e4) {
              var t4 = new FileReader(), r3 = y(t4);
              return t4.readAsArrayBuffer(e4), r3;
            }
            function v(e4) {
              var t4;
              return e4.slice ? e4.slice(0) : ((t4 = new Uint8Array(e4.byteLength)).set(new Uint8Array(e4)), t4.buffer);
            }
            function b() {
              return this.bodyUsed = false, this._initBody = function(e4) {
                if (this._bodyInit = e4)
                  if ("string" == typeof e4)
                    this._bodyText = e4;
                  else if (i && Blob.prototype.isPrototypeOf(e4))
                    this._bodyBlob = e4;
                  else if (o && FormData.prototype.isPrototypeOf(e4))
                    this._bodyFormData = e4;
                  else if (t3 && URLSearchParams.prototype.isPrototypeOf(e4))
                    this._bodyText = e4.toString();
                  else if (n && i && a(e4))
                    this._bodyArrayBuffer = v(e4.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer]);
                  else {
                    if (!n || !ArrayBuffer.prototype.isPrototypeOf(e4) && !l(e4))
                      throw new Error("unsupported BodyInit type");
                    this._bodyArrayBuffer = v(e4);
                  }
                else
                  this._bodyText = "";
                this.headers.get("content-type") || ("string" == typeof e4 ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : t3 && URLSearchParams.prototype.isPrototypeOf(e4) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
              }, i && (this.blob = function() {
                var e4 = m(this);
                if (e4)
                  return e4;
                if (this._bodyBlob)
                  return Promise.resolve(this._bodyBlob);
                if (this._bodyArrayBuffer)
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                if (this._bodyFormData)
                  throw new Error("could not read FormData body as blob");
                return Promise.resolve(new Blob([this._bodyText]));
              }, this.arrayBuffer = function() {
                return this._bodyArrayBuffer ? m(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(g);
              }), this.text = function() {
                var e4, t4, r3 = m(this);
                if (r3)
                  return r3;
                if (this._bodyBlob)
                  return r3 = this._bodyBlob, e4 = new FileReader(), t4 = y(e4), e4.readAsText(r3), t4;
                if (this._bodyArrayBuffer)
                  return Promise.resolve(function(e5) {
                    for (var t5 = new Uint8Array(e5), r4 = new Array(t5.length), o2 = 0; o2 < t5.length; o2++)
                      r4[o2] = String.fromCharCode(t5[o2]);
                    return r4.join("");
                  }(this._bodyArrayBuffer));
                if (this._bodyFormData)
                  throw new Error("could not read FormData body as text");
                return Promise.resolve(this._bodyText);
              }, o && (this.formData = function() {
                return this.text().then(_);
              }), this.json = function() {
                return this.text().then(JSON.parse);
              }, this;
            }
            function j(e4, t4) {
              var r3, o2 = (t4 = t4 || {}).body;
              if (e4 instanceof j) {
                if (e4.bodyUsed)
                  throw new TypeError("Already read");
                this.url = e4.url, this.credentials = e4.credentials, t4.headers || (this.headers = new p(e4.headers)), this.method = e4.method, this.mode = e4.mode, o2 || null == e4._bodyInit || (o2 = e4._bodyInit, e4.bodyUsed = true);
              } else
                this.url = String(e4);
              if (this.credentials = t4.credentials || this.credentials || "omit", !t4.headers && this.headers || (this.headers = new p(t4.headers)), this.method = (e4 = t4.method || this.method || "GET", r3 = e4.toUpperCase(), -1 < u.indexOf(r3) ? r3 : e4), this.mode = t4.mode || this.mode || null, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && o2)
                throw new TypeError("Body not allowed for GET or HEAD requests");
              this._initBody(o2);
            }
            function _(e4) {
              var r3 = new FormData();
              return e4.trim().split("&").forEach(function(e5) {
                var t4;
                e5 && (t4 = (e5 = e5.split("=")).shift().replace(/\+/g, " "), e5 = e5.join("=").replace(/\+/g, " "), r3.append(decodeURIComponent(t4), decodeURIComponent(e5)));
              }), r3;
            }
            function x(e4, t4) {
              t4 = t4 || {}, this.type = "default", this.status = void 0 === t4.status ? 200 : t4.status, this.ok = 200 <= this.status && this.status < 300, this.statusText = "statusText" in t4 ? t4.statusText : "OK", this.headers = new p(t4.headers), this.url = t4.url || "", this._initBody(e4);
            }
            e3.fetch || (t3 = "URLSearchParams" in e3, r2 = "Symbol" in e3 && "iterator" in Symbol, i = "FileReader" in e3 && "Blob" in e3 && function() {
              try {
                return new Blob(), true;
              } catch (e4) {
                return false;
              }
            }(), o = "FormData" in e3, (n = "ArrayBuffer" in e3) && (s2 = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], a = function(e4) {
              return e4 && DataView.prototype.isPrototypeOf(e4);
            }, l = ArrayBuffer.isView || function(e4) {
              return e4 && -1 < s2.indexOf(Object.prototype.toString.call(e4));
            }), p.prototype.append = function(e4, t4) {
              e4 = d(e4), t4 = f(t4);
              var r3 = this.map[e4];
              this.map[e4] = r3 ? r3 + "," + t4 : t4;
            }, p.prototype.delete = function(e4) {
              delete this.map[d(e4)];
            }, p.prototype.get = function(e4) {
              return e4 = d(e4), this.has(e4) ? this.map[e4] : null;
            }, p.prototype.has = function(e4) {
              return this.map.hasOwnProperty(d(e4));
            }, p.prototype.set = function(e4, t4) {
              this.map[d(e4)] = f(t4);
            }, p.prototype.forEach = function(e4, t4) {
              for (var r3 in this.map)
                this.map.hasOwnProperty(r3) && e4.call(t4, this.map[r3], r3, this);
            }, p.prototype.keys = function() {
              var r3 = [];
              return this.forEach(function(e4, t4) {
                r3.push(t4);
              }), h(r3);
            }, p.prototype.values = function() {
              var t4 = [];
              return this.forEach(function(e4) {
                t4.push(e4);
              }), h(t4);
            }, p.prototype.entries = function() {
              var r3 = [];
              return this.forEach(function(e4, t4) {
                r3.push([t4, e4]);
              }), h(r3);
            }, r2 && (p.prototype[Symbol.iterator] = p.prototype.entries), u = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"], j.prototype.clone = function() {
              return new j(this, { body: this._bodyInit });
            }, b.call(j.prototype), b.call(x.prototype), x.prototype.clone = function() {
              return new x(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new p(this.headers), url: this.url });
            }, x.error = function() {
              var e4 = new x(null, { status: 0, statusText: "" });
              return e4.type = "error", e4;
            }, c = [301, 302, 303, 307, 308], x.redirect = function(e4, t4) {
              if (-1 === c.indexOf(t4))
                throw new RangeError("Invalid status code");
              return new x(null, { status: t4, headers: { location: e4 } });
            }, e3.Headers = p, e3.Request = j, e3.Response = x, e3.fetch = function(r3, s3) {
              return new Promise(function(o2, e4) {
                var t4 = new j(r3, s3), n2 = new XMLHttpRequest();
                n2.onload = function() {
                  var r4, e5 = { status: n2.status, statusText: n2.statusText, headers: (e5 = n2.getAllResponseHeaders() || "", r4 = new p(), e5.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function(e6) {
                    var e6 = e6.split(":"), t6 = e6.shift().trim();
                    t6 && (e6 = e6.join(":").trim(), r4.append(t6, e6));
                  }), r4) }, t5 = (e5.url = "responseURL" in n2 ? n2.responseURL : e5.headers.get("X-Request-URL"), "response" in n2 ? n2.response : n2.responseText);
                  o2(new x(t5, e5));
                }, n2.onerror = function() {
                  e4(new TypeError("Network request failed"));
                }, n2.ontimeout = function() {
                  e4(new TypeError("Network request failed"));
                }, n2.open(t4.method, t4.url, true), "include" === t4.credentials ? n2.withCredentials = true : "omit" === t4.credentials && (n2.withCredentials = false), "responseType" in n2 && i && (n2.responseType = "blob"), t4.headers.forEach(function(e5, t5) {
                  n2.setRequestHeader(t5, e5);
                }), n2.send(void 0 === t4._bodyInit ? null : t4._bodyInit);
              });
            }, e3.fetch.polyfill = true);
          }("undefined" != typeof self ? self : this);
        }, {}], 246: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.function.name"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.split"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var l, o = n(e2("../core/main")), u = n(e2("../color/color_conversion"));
          function n(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          var c = [{ h: 0, s: 0, b: 0.8275, name: "gray" }, { h: 0, s: 0, b: 0.8627, name: "gray" }, { h: 0, s: 0, b: 0.7529, name: "gray" }, { h: 0.0167, s: 0.1176, b: 1, name: "light pink" }], d = [{ h: 0, s: 0, b: 0, name: "black" }, { h: 0, s: 0, b: 0.5, name: "gray" }, { h: 0, s: 0, b: 1, name: "white" }, { h: 0, s: 0.5, b: 0.5, name: "dark maroon" }, { h: 0, s: 0.5, b: 1, name: "salmon pink" }, { h: 0, s: 1, b: 0, name: "black" }, { h: 0, s: 1, b: 0.5, name: "dark red" }, { h: 0, s: 1, b: 1, name: "red" }, { h: 5, s: 0, b: 1, name: "very light peach" }, { h: 5, s: 0.5, b: 0.5, name: "brown" }, { h: 5, s: 0.5, b: 1, name: "peach" }, { h: 5, s: 1, b: 0.5, name: "brick red" }, { h: 5, s: 1, b: 1, name: "crimson" }, { h: 10, s: 0, b: 1, name: "light peach" }, { h: 10, s: 0.5, b: 0.5, name: "brown" }, { h: 10, s: 0.5, b: 1, name: "light orange" }, { h: 10, s: 1, b: 0.5, name: "brown" }, { h: 10, s: 1, b: 1, name: "orange" }, { h: 15, s: 0, b: 1, name: "very light yellow" }, { h: 15, s: 0.5, b: 0.5, name: "olive green" }, { h: 15, s: 0.5, b: 1, name: "light yellow" }, { h: 15, s: 1, b: 0, name: "dark olive green" }, { h: 15, s: 1, b: 0.5, name: "olive green" }, { h: 15, s: 1, b: 1, name: "yellow" }, { h: 20, s: 0, b: 1, name: "very light yellow" }, { h: 20, s: 0.5, b: 0.5, name: "olive green" }, { h: 20, s: 0.5, b: 1, name: "light yellow green" }, { h: 20, s: 1, b: 0, name: "dark olive green" }, { h: 20, s: 1, b: 0.5, name: "dark yellow green" }, { h: 20, s: 1, b: 1, name: "yellow green" }, { h: 25, s: 0.5, b: 0.5, name: "dark yellow green" }, { h: 25, s: 0.5, b: 1, name: "light green" }, { h: 25, s: 1, b: 0.5, name: "dark green" }, { h: 25, s: 1, b: 1, name: "green" }, { h: 30, s: 0.5, b: 1, name: "light green" }, { h: 30, s: 1, b: 0.5, name: "dark green" }, { h: 30, s: 1, b: 1, name: "green" }, { h: 35, s: 0, b: 0.5, name: "light green" }, { h: 35, s: 0, b: 1, name: "very light green" }, { h: 35, s: 0.5, b: 0.5, name: "dark green" }, { h: 35, s: 0.5, b: 1, name: "light green" }, { h: 35, s: 1, b: 0, name: "very dark green" }, { h: 35, s: 1, b: 0.5, name: "dark green" }, { h: 35, s: 1, b: 1, name: "green" }, { h: 40, s: 0, b: 1, name: "very light green" }, { h: 40, s: 0.5, b: 0.5, name: "dark green" }, { h: 40, s: 0.5, b: 1, name: "light green" }, { h: 40, s: 1, b: 0.5, name: "dark green" }, { h: 40, s: 1, b: 1, name: "green" }, { h: 45, s: 0.5, b: 1, name: "light turquoise" }, { h: 45, s: 1, b: 0.5, name: "dark turquoise" }, { h: 45, s: 1, b: 1, name: "turquoise" }, { h: 50, s: 0, b: 1, name: "light sky blue" }, { h: 50, s: 0.5, b: 0.5, name: "dark cyan" }, { h: 50, s: 0.5, b: 1, name: "light cyan" }, { h: 50, s: 1, b: 0.5, name: "dark cyan" }, { h: 50, s: 1, b: 1, name: "cyan" }, { h: 55, s: 0, b: 1, name: "light sky blue" }, { h: 55, s: 0.5, b: 1, name: "light sky blue" }, { h: 55, s: 1, b: 0.5, name: "dark blue" }, { h: 55, s: 1, b: 1, name: "sky blue" }, { h: 60, s: 0, b: 0.5, name: "gray" }, { h: 60, s: 0, b: 1, name: "very light blue" }, { h: 60, s: 0.5, b: 0.5, name: "blue" }, { h: 60, s: 0.5, b: 1, name: "light blue" }, { h: 60, s: 1, b: 0.5, name: "navy blue" }, { h: 60, s: 1, b: 1, name: "blue" }, { h: 65, s: 0, b: 1, name: "lavender" }, { h: 65, s: 0.5, b: 0.5, name: "navy blue" }, { h: 65, s: 0.5, b: 1, name: "light purple" }, { h: 65, s: 1, b: 0.5, name: "dark navy blue" }, { h: 65, s: 1, b: 1, name: "blue" }, { h: 70, s: 0, b: 1, name: "lavender" }, { h: 70, s: 0.5, b: 0.5, name: "navy blue" }, { h: 70, s: 0.5, b: 1, name: "lavender blue" }, { h: 70, s: 1, b: 0.5, name: "dark navy blue" }, { h: 70, s: 1, b: 1, name: "blue" }, { h: 75, s: 0.5, b: 1, name: "lavender" }, { h: 75, s: 1, b: 0.5, name: "dark purple" }, { h: 75, s: 1, b: 1, name: "purple" }, { h: 80, s: 0.5, b: 1, name: "pinkish purple" }, { h: 80, s: 1, b: 0.5, name: "dark purple" }, { h: 80, s: 1, b: 1, name: "purple" }, { h: 85, s: 0, b: 1, name: "light pink" }, { h: 85, s: 0.5, b: 0.5, name: "purple" }, { h: 85, s: 0.5, b: 1, name: "light fuchsia" }, { h: 85, s: 1, b: 0.5, name: "dark fuchsia" }, { h: 85, s: 1, b: 1, name: "fuchsia" }, { h: 90, s: 0.5, b: 0.5, name: "dark fuchsia" }, { h: 90, s: 0.5, b: 1, name: "hot pink" }, { h: 90, s: 1, b: 0.5, name: "dark fuchsia" }, { h: 90, s: 1, b: 1, name: "fuchsia" }, { h: 95, s: 0, b: 1, name: "pink" }, { h: 95, s: 0.5, b: 1, name: "light pink" }, { h: 95, s: 1, b: 0.5, name: "dark magenta" }, { h: 95, s: 1, b: 1, name: "magenta" }];
          o.default.prototype._rgbColorName = function(e3) {
            var t3, r2, e3 = u.default._rgbaToHSBA(e3), o2 = [(l = e3)[0], e3[1], e3[2]];
            0 !== o2[0] && (o2[0] = Math.round(100 * o2[0]), (e3 = o2[0].toString().split(""))[r2 = e3.length - 1] = parseInt(e3[r2]), e3[r2] < 2.5 ? e3[r2] = 0 : 2.5 <= e3[r2] && e3[r2] < 7.5 && (e3[r2] = 5), 2 === e3.length ? (e3[0] = parseInt(e3[0]), 7.5 <= e3[r2] && (e3[r2] = 0, e3[0] = e3[0] + 1), o2[0] = 10 * e3[0] + e3[1]) : 7.5 <= e3[r2] ? o2[0] = 10 : o2[0] = e3[r2]), o2[2] = o2[2] / 255;
            for (var n2 = o2.length - 1; 1 <= n2; n2--)
              o2[n2] <= 0.25 ? o2[n2] = 0 : 0.25 < o2[n2] && o2[n2] < 0.75 ? o2[n2] = 0.5 : o2[n2] = 1;
            if (0 === o2[0] && 0 === o2[1] && 1 === o2[2]) {
              for (var s2 = 2; 0 <= s2; s2--)
                l[s2] = Math.round(1e4 * l[s2]) / 1e4;
              for (var i = 0; i < c.length; i++) {
                if (c[i].h === l[0] && c[i].s === l[1] && c[i].b === l[2]) {
                  t3 = c[i].name;
                  break;
                }
                t3 = "white";
              }
            } else
              for (var a = 0; a < d.length; a++)
                if (d[a].h === o2[0] && d[a].s === o2[1] && d[a].b === o2[2]) {
                  t3 = d[a].name;
                  break;
                }
            return t3;
          };
          e2 = o.default;
          r.default = e2;
        }, { "../color/color_conversion": 252, "../core/main": 267, "core-js/modules/es.function.name": 165, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.split": 191 }], 247: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.ends-with"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.ends-with"), e2("core-js/modules/es.string.replace"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var s2 = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          var i = "_Description", a = "_fallbackDesc", l = "_fallbackTable", u = "_Label", c = "_labelDesc", d = "_labelTable";
          function f(e3) {
            if ("label" === e3 || "fallback" === e3)
              throw new Error("description should not be LABEL or FALLBACK");
            return e3.endsWith(".") || e3.endsWith(";") || e3.endsWith(",") || e3.endsWith("?") || e3.endsWith("!") || (e3 += "."), e3;
          }
          s2.default.prototype.describe = function(e3, t3) {
            var r2;
            s2.default._validateParameters("describe", arguments), "string" == typeof e3 && (r2 = this.canvas.id, e3 = f(e3), this.dummyDOM || (this.dummyDOM = document.getElementById(r2).parentNode), this.descriptions || (this.descriptions = {}), this.descriptions.fallback ? this.descriptions.fallback.innerHTML !== e3 && (this.descriptions.fallback.innerHTML = e3) : this._describeHTML("fallback", e3), t3 === this.LABEL && (this.descriptions.label ? this.descriptions.label.innerHTML !== e3 && (this.descriptions.label.innerHTML = e3) : this._describeHTML("label", e3)));
          }, s2.default.prototype.describeElement = function(e3, t3, r2) {
            var o, n;
            s2.default._validateParameters("describeElement", arguments), "string" == typeof t3 && "string" == typeof e3 && (o = this.canvas.id, t3 = f(t3), n = function(e4) {
              if ("label" === e4 || "fallback" === e4)
                throw new Error("element name should not be LABEL or FALLBACK");
              e4.endsWith(".") || e4.endsWith(";") || e4.endsWith(",") ? e4 = e4.replace(/.$/, ":") : e4.endsWith(":") || (e4 += ":");
              return e4;
            }(e3), e3 = e3.replace(/[^a-zA-Z0-9]/g, ""), n = '<th scope="row">'.concat(n, "</th><td>").concat(t3, "</td>"), this.dummyDOM || (this.dummyDOM = document.getElementById(o).parentNode), this.descriptions ? this.descriptions.fallbackElements || (this.descriptions.fallbackElements = {}) : this.descriptions = { fallbackElements: {} }, this.descriptions.fallbackElements[e3] ? this.descriptions.fallbackElements[e3].innerHTML !== n && (this.descriptions.fallbackElements[e3].innerHTML = n) : this._describeElementHTML("fallback", e3, n), r2 === this.LABEL && (this.descriptions.labelElements || (this.descriptions.labelElements = {}), this.descriptions.labelElements[e3] ? this.descriptions.labelElements[e3].innerHTML !== n && (this.descriptions.labelElements[e3].innerHTML = n) : this._describeElementHTML("label", e3, n)));
          }, s2.default.prototype._describeHTML = function(e3, t3) {
            var r2, o = this.canvas.id;
            "fallback" === e3 ? (this.dummyDOM.querySelector("#".concat(o + i)) ? this.dummyDOM.querySelector("#" + o + l).insertAdjacentHTML("beforebegin", '<p id="'.concat(o + a, '"></p>')) : (r2 = '<div id="'.concat(o).concat(i, '" role="region" aria-label="Canvas Description"><p id="').concat(o).concat(a, '"></p></div>'), this.dummyDOM.querySelector("#".concat(o, "accessibleOutput")) ? this.dummyDOM.querySelector("#".concat(o, "accessibleOutput")).insertAdjacentHTML("beforebegin", r2) : this.dummyDOM.querySelector("#".concat(o)).innerHTML = r2), this.descriptions.fallback = this.dummyDOM.querySelector("#".concat(o).concat(a)), this.descriptions.fallback.innerHTML = t3) : "label" === e3 && (this.dummyDOM.querySelector("#".concat(o + u)) ? this.dummyDOM.querySelector("#".concat(o + d)) && this.dummyDOM.querySelector("#".concat(o + d)).insertAdjacentHTML("beforebegin", '<p id="'.concat(o).concat(c, '"></p>')) : (r2 = '<div id="'.concat(o).concat(u, '" class="p5Label"><p id="').concat(o).concat(c, '"></p></div>'), this.dummyDOM.querySelector("#".concat(o, "accessibleOutputLabel")) ? this.dummyDOM.querySelector("#".concat(o, "accessibleOutputLabel")).insertAdjacentHTML("beforebegin", r2) : this.dummyDOM.querySelector("#" + o).insertAdjacentHTML("afterend", r2)), this.descriptions.label = this.dummyDOM.querySelector("#" + o + c), this.descriptions.label.innerHTML = t3);
          }, s2.default.prototype._describeElementHTML = function(e3, t3, r2) {
            var o, n = this.canvas.id;
            "fallback" === e3 ? (this.dummyDOM.querySelector("#".concat(n + i)) ? this.dummyDOM.querySelector("#" + n + l) || this.dummyDOM.querySelector("#" + n + a).insertAdjacentHTML("afterend", '<table id="'.concat(n).concat(l, '"><caption>Canvas elements and their descriptions</caption></table>')) : (o = '<div id="'.concat(n).concat(i, '" role="region" aria-label="Canvas Description"><table id="').concat(n).concat(l, '"><caption>Canvas elements and their descriptions</caption></table></div>'), this.dummyDOM.querySelector("#".concat(n, "accessibleOutput")) ? this.dummyDOM.querySelector("#".concat(n, "accessibleOutput")).insertAdjacentHTML("beforebegin", o) : this.dummyDOM.querySelector("#" + n).innerHTML = o), (o = document.createElement("tr")).id = n + "_fte_" + t3, this.dummyDOM.querySelector("#" + n + l).appendChild(o), this.descriptions.fallbackElements[t3] = this.dummyDOM.querySelector("#".concat(n).concat("_fte_").concat(t3)), this.descriptions.fallbackElements[t3].innerHTML = r2) : "label" === e3 && (this.dummyDOM.querySelector("#".concat(n + u)) ? this.dummyDOM.querySelector("#".concat(n + d)) || this.dummyDOM.querySelector("#" + n + c).insertAdjacentHTML("afterend", '<table id="'.concat(n + d, '"></table>')) : (o = '<div id="'.concat(n).concat(u, '" class="p5Label"><table id="').concat(n).concat(d, '"></table></div>'), this.dummyDOM.querySelector("#".concat(n, "accessibleOutputLabel")) ? this.dummyDOM.querySelector("#".concat(n, "accessibleOutputLabel")).insertAdjacentHTML("beforebegin", o) : this.dummyDOM.querySelector("#" + n).insertAdjacentHTML("afterend", o)), (e3 = document.createElement("tr")).id = n + "_lte_" + t3, this.dummyDOM.querySelector("#" + n + d).appendChild(e3), this.descriptions.labelElements[t3] = this.dummyDOM.querySelector("#".concat(n).concat("_lte_").concat(t3)), this.descriptions.labelElements[t3].innerHTML = r2);
          };
          e2 = s2.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.string.ends-with": 184, "core-js/modules/es.string.replace": 189 }], 248: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.map"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          e2.default.prototype._updateGridOutput = function(e3) {
            var t3, r2, o, n;
            this.dummyDOM.querySelector("#".concat(e3, "_summary")) && (t3 = this._accessibleOutputs[e3], o = function(e4, t4, r3, o2) {
              t4 = "".concat(t4, " canvas, ").concat(r3, " by ").concat(o2, " pixels, contains ").concat(e4[0]);
              t4 = (1 === e4[0] ? "".concat(t4, " shape: ") : "".concat(t4, " shapes: ")).concat(e4[1]);
              return t4;
            }((r2 = function(e4, t4) {
              var r3, o2 = "", n2 = "", s2 = 0;
              for (r3 in t4) {
                var i, a = 0;
                for (i in t4[r3]) {
                  var l = '<li id="'.concat(e4, "shape").concat(s2, '">').concat(t4[r3][i].color, " ").concat(r3, ",");
                  "line" === r3 ? l += " location = ".concat(t4[r3][i].pos, ", length = ").concat(t4[r3][i].length, " pixels") : (l += " location = ".concat(t4[r3][i].pos), "point" !== r3 && (l += ", area = ".concat(t4[r3][i].area, " %")), l += "</li>"), o2 += l, a++, s2++;
                }
                n2 = 1 < a ? "".concat(n2, " ").concat(a, " ").concat(r3, "s") : "".concat(n2, " ").concat(a, " ").concat(r3);
              }
              return { numShapes: [s2, n2], details: o2 };
            }(e3, this.ingredients.shapes)).numShapes, this.ingredients.colors.background, this.width, this.height), n = function(e4, t4) {
              var r3, o2, n2, s2 = 0, i = "", a = Array.apply(null, Array(10)).map(function() {
              });
              for (r3 in a)
                a[r3] = Array.apply(null, Array(10)).map(function() {
                });
              for (o2 in t4)
                for (var l in t4[o2]) {
                  var u = void 0;
                  u = "line" !== o2 ? '<a href="#'.concat(e4, "shape").concat(s2, '">').concat(t4[o2][l].color, " ").concat(o2, "</a>") : '<a href="#'.concat(e4, "shape").concat(s2, '">').concat(t4[o2][l].color, " ").concat(o2, " midpoint</a>"), a[t4[o2][l].loc.locY][t4[o2][l].loc.locX] ? a[t4[o2][l].loc.locY][t4[o2][l].loc.locX] = a[t4[o2][l].loc.locY][t4[o2][l].loc.locX] + "  " + u : a[t4[o2][l].loc.locY][t4[o2][l].loc.locX] = u, s2++;
                }
              for (n2 in a) {
                var c, d = "<tr>";
                for (c in a[n2])
                  d += "<td>", void 0 !== a[n2][c] && (d += a[n2][c]), d += "</td>";
                i = i + d + "</tr>";
              }
              return i;
            }(e3, this.ingredients.shapes), o !== t3.summary.innerHTML && (t3.summary.innerHTML = o), n !== t3.map.innerHTML && (t3.map.innerHTML = n), r2.details !== t3.shapeDetails.innerHTML && (t3.shapeDetails.innerHTML = r2.details), this._accessibleOutputs[e3] = t3);
          };
          e2 = e2.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.map": 161 }], 249: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.number.to-fixed"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.number.to-fixed"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var o = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          function l(e3, t3, r2) {
            return e3[0] < 0.4 * t3 ? e3[1] < 0.4 * r2 ? "top left" : e3[1] > 0.6 * r2 ? "bottom left" : "mid left" : e3[0] > 0.6 * t3 ? e3[1] < 0.4 * r2 ? "top right" : e3[1] > 0.6 * r2 ? "bottom right" : "mid right" : e3[1] < 0.4 * r2 ? "top middle" : e3[1] > 0.6 * r2 ? "bottom middle" : "middle";
          }
          function u(e3, t3, r2) {
            t3 = Math.floor(e3[0] / t3 * 10), e3 = Math.floor(e3[1] / r2 * 10);
            return 10 === t3 && (t3 -= 1), 10 === e3 && (e3 -= 1), { locX: t3, locY: e3 };
          }
          o.default.prototype.textOutput = function(e3) {
            o.default._validateParameters("textOutput", arguments), this._accessibleOutputs.text || (this._accessibleOutputs.text = true, this._createOutput("textOutput", "Fallback"), e3 === this.LABEL && (this._accessibleOutputs.textLabel = true, this._createOutput("textOutput", "Label")));
          }, o.default.prototype.gridOutput = function(e3) {
            o.default._validateParameters("gridOutput", arguments), this._accessibleOutputs.grid || (this._accessibleOutputs.grid = true, this._createOutput("gridOutput", "Fallback"), e3 === this.LABEL && (this._accessibleOutputs.gridLabel = true, this._createOutput("gridOutput", "Label")));
          }, o.default.prototype._addAccsOutput = function() {
            return this._accessibleOutputs || (this._accessibleOutputs = { text: false, grid: false, textLabel: false, gridLabel: false }), this._accessibleOutputs.grid || this._accessibleOutputs.text;
          }, o.default.prototype._createOutput = function(e3, t3) {
            var r2, o2, n, s2 = this.canvas.id, i = (this.ingredients || (this.ingredients = { shapes: {}, colors: { background: "white", fill: "white", stroke: "black" }, pShapes: "" }), this.dummyDOM || (this.dummyDOM = document.getElementById(s2).parentNode), "");
            "Fallback" === t3 ? (r2 = s2 + e3, this.dummyDOM.querySelector("#".concat(o2 = s2 + "accessibleOutput")) || (this.dummyDOM.querySelector("#".concat(s2, "_Description")) ? this.dummyDOM.querySelector("#".concat(s2, "_Description")).insertAdjacentHTML("afterend", '<div id="'.concat(o2, '" role="region" aria-label="Canvas Outputs"></div>')) : this.dummyDOM.querySelector("#".concat(s2)).innerHTML = '<div id="'.concat(o2, '" role="region" aria-label="Canvas Outputs"></div>'))) : "Label" === t3 && (r2 = s2 + e3 + (i = t3), this.dummyDOM.querySelector("#".concat(o2 = s2 + "accessibleOutput" + t3)) || (this.dummyDOM.querySelector("#".concat(s2, "_Label")) ? this.dummyDOM.querySelector("#".concat(s2, "_Label")) : this.dummyDOM.querySelector("#".concat(s2))).insertAdjacentHTML("afterend", '<div id="'.concat(o2, '"></div>'))), this._accessibleOutputs[r2] = {}, "textOutput" === e3 ? (i = "#".concat(s2, "gridOutput").concat(i), n = '<div id="'.concat(r2, '">Text Output<div id="').concat(r2, 'Summary" aria-label="text output summary"><p id="').concat(r2, '_summary"></p><ul id="').concat(r2, '_list"></ul></div><table id="').concat(r2, '_shapeDetails" summary="text output shape details"></table></div>'), this.dummyDOM.querySelector(i) ? this.dummyDOM.querySelector(i).insertAdjacentHTML("beforebegin", n) : this.dummyDOM.querySelector("#".concat(o2)).innerHTML = n, this._accessibleOutputs[r2].list = this.dummyDOM.querySelector("#".concat(r2, "_list"))) : "gridOutput" === e3 && (i = "#".concat(s2, "textOutput").concat(i), n = '<div id="'.concat(r2, '">Grid Output<p id="').concat(r2, '_summary" aria-label="grid output summary"><table id="').concat(r2, '_map" summary="grid output content"></table><ul id="').concat(r2, '_shapeDetails" aria-label="grid output shape details"></ul></div>'), this.dummyDOM.querySelector(i) ? this.dummyDOM.querySelector(i).insertAdjacentHTML("afterend", n) : this.dummyDOM.querySelector("#".concat(o2)).innerHTML = n, this._accessibleOutputs[r2].map = this.dummyDOM.querySelector("#".concat(r2, "_map"))), this._accessibleOutputs[r2].shapeDetails = this.dummyDOM.querySelector("#".concat(r2, "_shapeDetails")), this._accessibleOutputs[r2].summary = this.dummyDOM.querySelector("#".concat(r2, "_summary"));
          }, o.default.prototype._updateAccsOutput = function() {
            var e3 = this.canvas.id;
            JSON.stringify(this.ingredients.shapes) !== this.ingredients.pShapes && (this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes), this._accessibleOutputs.text && this._updateTextOutput(e3 + "textOutput"), this._accessibleOutputs.grid && this._updateGridOutput(e3 + "gridOutput"), this._accessibleOutputs.textLabel && this._updateTextOutput(e3 + "textOutputLabel"), this._accessibleOutputs.gridLabel && this._updateGridOutput(e3 + "gridOutputLabel"));
          }, o.default.prototype._accsBackground = function(e3) {
            this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes), this.ingredients.shapes = {}, this.ingredients.colors.backgroundRGBA !== e3 && (this.ingredients.colors.backgroundRGBA = e3, this.ingredients.colors.background = this._rgbColorName(e3));
          }, o.default.prototype._accsCanvasColors = function(e3, t3) {
            "fill" === e3 ? this.ingredients.colors.fillRGBA !== t3 && (this.ingredients.colors.fillRGBA = t3, this.ingredients.colors.fill = this._rgbColorName(t3)) : "stroke" === e3 && this.ingredients.colors.strokeRGBA !== t3 && (this.ingredients.colors.strokeRGBA = t3, this.ingredients.colors.stroke = this._rgbColorName(t3));
          }, o.default.prototype._accsOutput = function(e3, t3) {
            "ellipse" === e3 && t3[2] === t3[3] ? e3 = "circle" : "rectangle" === e3 && t3[2] === t3[3] && (e3 = "square");
            var r2, o2, n = {}, s2 = true, i = function(e4, t4) {
              var r3;
              e4 = "rectangle" === e4 || "ellipse" === e4 || "arc" === e4 || "circle" === e4 || "square" === e4 ? (r3 = Math.round(t4[0] + t4[2] / 2), Math.round(t4[1] + t4[3] / 2)) : "triangle" === e4 ? (r3 = (t4[0] + t4[2] + t4[4]) / 3, (t4[1] + t4[3] + t4[5]) / 3) : "quadrilateral" === e4 ? (r3 = (t4[0] + t4[2] + t4[4] + t4[6]) / 4, (t4[1] + t4[3] + t4[5] + t4[7]) / 4) : "line" === e4 ? (r3 = (t4[0] + t4[2]) / 2, (t4[1] + t4[3]) / 2) : (r3 = t4[0], t4[1]);
              return [r3, e4];
            }(e3, t3);
            if ("line" === e3 ? (n.color = this.ingredients.colors.stroke, n.length = Math.round(this.dist(t3[0], t3[1], t3[2], t3[3])), r2 = l([t3[0], [1]], this.width, this.height), o2 = l([t3[2], [3]], this.width, this.height), n.loc = u(i, this.width, this.height), n.pos = r2 === o2 ? "at ".concat(r2) : "from ".concat(r2, " to ").concat(o2)) : ("point" === e3 ? n.color = this.ingredients.colors.stroke : (n.color = this.ingredients.colors.fill, n.area = function(e4, t4, r3, o3) {
              var n2 = 0;
              {
                var s3, i2, a2, l2, u2, c, d;
                "arc" === e4 ? (s3 = ((t4[5] - t4[4]) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI), n2 = s3 * t4[2] * t4[3] / 8, "open" !== t4[6] && "chord" !== t4[6] || (d = t4[0], i2 = t4[1], a2 = t4[0] + t4[2] / 2 * Math.cos(t4[4]).toFixed(2), l2 = t4[1] + t4[3] / 2 * Math.sin(t4[4]).toFixed(2), u2 = t4[0] + t4[2] / 2 * Math.cos(t4[5]).toFixed(2), c = t4[1] + t4[3] / 2 * Math.sin(t4[5]).toFixed(2), d = Math.abs(d * (l2 - c) + a2 * (c - i2) + u2 * (i2 - l2)) / 2, s3 > Math.PI ? n2 += d : n2 -= d)) : "ellipse" === e4 || "circle" === e4 ? n2 = 3.14 * t4[2] / 2 * t4[3] / 2 : "line" === e4 || "point" === e4 ? n2 = 0 : "quadrilateral" === e4 ? n2 = Math.abs((t4[6] + t4[0]) * (t4[7] - t4[1]) + (t4[0] + t4[2]) * (t4[1] - t4[3]) + (t4[2] + t4[4]) * (t4[3] - t4[5]) + (t4[4] + t4[6]) * (t4[5] - t4[7])) / 2 : "rectangle" === e4 || "square" === e4 ? n2 = t4[2] * t4[3] : "triangle" === e4 && (n2 = Math.abs(t4[0] * (t4[3] - t4[5]) + t4[2] * (t4[5] - t4[1]) + t4[4] * (t4[1] - t4[3])) / 2);
              }
              return Math.round(100 * n2 / (r3 * o3));
            }(e3, t3, this.width, this.height)), n.pos = l(i, this.width, this.height), n.loc = u(i, this.width, this.height)), this.ingredients.shapes[e3]) {
              if (this.ingredients.shapes[e3] !== [n]) {
                for (var a in this.ingredients.shapes[e3])
                  JSON.stringify(this.ingredients.shapes[e3][a]) === JSON.stringify(n) && (s2 = false);
                true === s2 && this.ingredients.shapes[e3].push(n);
              }
            } else
              this.ingredients.shapes[e3] = [n];
          };
          e2 = o.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.fill": 152, "core-js/modules/es.array.map": 161, "core-js/modules/es.number.to-fixed": 171 }], 250: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.concat"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          e2.default.prototype._updateTextOutput = function(e3) {
            var t3, r2, o, n;
            this.dummyDOM.querySelector("#".concat(e3, "_summary")) && (t3 = this._accessibleOutputs[e3], o = function(e4, t4, r3, o2) {
              r3 = "Your output is a, ".concat(r3, " by ").concat(o2, " pixels, ").concat(t4, " canvas containing the following");
              r3 = 1 === e4 ? "".concat(r3, " shape:") : "".concat(r3, " ").concat(e4, " shapes:");
              return r3;
            }((r2 = function(e4, t4) {
              var r3, o2 = "", n2 = 0;
              for (r3 in t4)
                for (var s2 in t4[r3]) {
                  var i = '<li><a href="#'.concat(e4, "shape").concat(n2, '">').concat(t4[r3][s2].color, " ").concat(r3, "</a>");
                  "line" === r3 ? i += ", ".concat(t4[r3][s2].pos, ", ").concat(t4[r3][s2].length, " pixels long.</li>") : (i += ", at ".concat(t4[r3][s2].pos), "point" !== r3 && (i += ", covering ".concat(t4[r3][s2].area, "% of the canvas")), i += ".</li>"), o2 += i, n2++;
                }
              return { numShapes: n2, listShapes: o2 };
            }(e3, this.ingredients.shapes)).numShapes, this.ingredients.colors.background, this.width, this.height), n = function(e4, t4) {
              var r3, o2 = "", n2 = 0;
              for (r3 in t4)
                for (var s2 in t4[r3]) {
                  var i = '<tr id="'.concat(e4, "shape").concat(n2, '"><th>').concat(t4[r3][s2].color, " ").concat(r3, "</th>");
                  "line" === r3 ? i += "<td>location = ".concat(t4[r3][s2].pos, "</td><td>length = ").concat(t4[r3][s2].length, " pixels</td></tr>") : (i += "<td>location = ".concat(t4[r3][s2].pos, "</td>"), "point" !== r3 && (i += "<td> area = ".concat(t4[r3][s2].area, "%</td>")), i += "</tr>"), o2 += i, n2++;
                }
              return o2;
            }(e3, this.ingredients.shapes), o !== t3.summary.innerHTML && (t3.summary.innerHTML = o), r2.listShapes !== t3.list.innerHTML && (t3.list.innerHTML = r2.listShapes), n !== t3.shapeDetails.innerHTML && (t3.shapeDetails.innerHTML = n), this._accessibleOutputs[e3] = t3);
          };
          e2 = e2.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.concat": 149 }], 251: [function(e2, t2, r) {
          "use strict";
          var o = (o = e2("./core/main")) && o.__esModule ? o : { default: o };
          e2("./core/constants"), e2("./core/environment"), e2("./core/friendly_errors/stacktrace"), e2("./core/friendly_errors/validate_params"), e2("./core/friendly_errors/file_errors"), e2("./core/friendly_errors/fes_core"), e2("./core/friendly_errors/sketch_reader"), e2("./core/helpers"), e2("./core/legacy"), e2("./core/preload"), e2("./core/p5.Element"), e2("./core/p5.Graphics"), e2("./core/p5.Renderer"), e2("./core/p5.Renderer2D"), e2("./core/rendering"), e2("./core/shim"), e2("./core/structure"), e2("./core/transform"), e2("./core/shape/2d_primitives"), e2("./core/shape/attributes"), e2("./core/shape/curves"), e2("./core/shape/vertex"), e2("./accessibility/outputs"), e2("./accessibility/textOutput"), e2("./accessibility/gridOutput"), e2("./accessibility/color_namer"), e2("./color/color_conversion"), e2("./color/creating_reading"), e2("./color/p5.Color"), e2("./color/setting"), e2("./data/p5.TypedDict"), e2("./data/local_storage.js"), e2("./dom/dom"), e2("./accessibility/describe"), e2("./events/acceleration"), e2("./events/keyboard"), e2("./events/mouse"), e2("./events/touch"), e2("./image/filters"), e2("./image/image"), e2("./image/loading_displaying"), e2("./image/p5.Image"), e2("./image/pixels"), e2("./io/files"), e2("./io/p5.Table"), e2("./io/p5.TableRow"), e2("./io/p5.XML"), e2("./math/calculation"), e2("./math/math"), e2("./math/noise"), e2("./math/p5.Vector"), e2("./math/random"), e2("./math/trigonometry"), e2("./typography/attributes"), e2("./typography/loading_displaying"), e2("./typography/p5.Font"), e2("./utilities/array_functions"), e2("./utilities/conversion"), e2("./utilities/string_functions"), e2("./utilities/time_date"), e2("./webgl/3d_primitives"), e2("./webgl/interaction"), e2("./webgl/light"), e2("./webgl/loading"), e2("./webgl/material"), e2("./webgl/p5.Camera"), e2("./webgl/p5.Geometry"), e2("./webgl/p5.Matrix"), e2("./webgl/p5.RendererGL.Immediate"), e2("./webgl/p5.RendererGL"), e2("./webgl/p5.RendererGL.Retained"), e2("./webgl/p5.Shader"), e2("./webgl/p5.RenderBuffer"), e2("./webgl/p5.Texture"), e2("./webgl/text"), e2("./core/init"), t2.exports = o.default;
        }, { "./accessibility/color_namer": 246, "./accessibility/describe": 247, "./accessibility/gridOutput": 248, "./accessibility/outputs": 249, "./accessibility/textOutput": 250, "./color/color_conversion": 252, "./color/creating_reading": 253, "./color/p5.Color": 254, "./color/setting": 255, "./core/constants": 256, "./core/environment": 257, "./core/friendly_errors/fes_core": 258, "./core/friendly_errors/file_errors": 259, "./core/friendly_errors/sketch_reader": 260, "./core/friendly_errors/stacktrace": 261, "./core/friendly_errors/validate_params": 262, "./core/helpers": 263, "./core/init": 264, "./core/legacy": 266, "./core/main": 267, "./core/p5.Element": 268, "./core/p5.Graphics": 269, "./core/p5.Renderer": 270, "./core/p5.Renderer2D": 271, "./core/preload": 272, "./core/rendering": 273, "./core/shape/2d_primitives": 274, "./core/shape/attributes": 275, "./core/shape/curves": 276, "./core/shape/vertex": 277, "./core/shim": 278, "./core/structure": 279, "./core/transform": 280, "./data/local_storage.js": 281, "./data/p5.TypedDict": 282, "./dom/dom": 283, "./events/acceleration": 284, "./events/keyboard": 285, "./events/mouse": 286, "./events/touch": 287, "./image/filters": 288, "./image/image": 289, "./image/loading_displaying": 290, "./image/p5.Image": 291, "./image/pixels": 292, "./io/files": 293, "./io/p5.Table": 294, "./io/p5.TableRow": 295, "./io/p5.XML": 296, "./math/calculation": 297, "./math/math": 298, "./math/noise": 299, "./math/p5.Vector": 300, "./math/random": 301, "./math/trigonometry": 302, "./typography/attributes": 303, "./typography/loading_displaying": 304, "./typography/p5.Font": 305, "./utilities/array_functions": 306, "./utilities/conversion": 307, "./utilities/string_functions": 308, "./utilities/time_date": 309, "./webgl/3d_primitives": 310, "./webgl/interaction": 311, "./webgl/light": 312, "./webgl/loading": 313, "./webgl/material": 314, "./webgl/p5.Camera": 315, "./webgl/p5.Geometry": 316, "./webgl/p5.Matrix": 317, "./webgl/p5.RenderBuffer": 318, "./webgl/p5.RendererGL": 321, "./webgl/p5.RendererGL.Immediate": 319, "./webgl/p5.RendererGL.Retained": 320, "./webgl/p5.Shader": 322, "./webgl/p5.Texture": 323, "./webgl/text": 324 }], 252: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          e2.default.ColorConversion = {}, e2.default.ColorConversion._hsbaToHSLA = function(e3) {
            var t3 = e3[0], r2 = e3[1], o = e3[2], n = (2 - r2) * o / 2;
            return 0 != n && (1 == n ? r2 = 0 : n < 0.5 ? r2 /= 2 - r2 : r2 = r2 * o / (2 - 2 * n)), [t3, r2, n, e3[3]];
          }, e2.default.ColorConversion._hsbaToRGBA = function(e3) {
            var t3, r2, o, n, s2, i = 6 * e3[0], a = e3[1], l = e3[2];
            return 0 === a ? [l, l, l, e3[3]] : (r2 = l * (1 - a), o = l * (1 - a * (i - (t3 = Math.floor(i)))), a = l * (1 - a * (1 + t3 - i)), i = 1 === t3 ? (n = o, s2 = l, r2) : 2 === t3 ? (n = r2, s2 = l, a) : 3 === t3 ? (n = r2, s2 = o, l) : 4 === t3 ? (n = a, s2 = r2, l) : 5 === t3 ? (n = l, s2 = r2, o) : (n = l, s2 = a, r2), [n, s2, i, e3[3]]);
          }, e2.default.ColorConversion._hslaToHSBA = function(e3) {
            var t3 = e3[0], r2 = e3[1], o = e3[2], n = o < 0.5 ? (1 + r2) * o : o + r2 - o * r2;
            return [t3, r2 = 2 * (n - o) / n, n, e3[3]];
          }, e2.default.ColorConversion._hslaToRGBA = function(e3) {
            var t3, r2 = 6 * e3[0], o = e3[1], n = e3[2];
            return 0 === o ? [n, n, n, e3[3]] : [(t3 = function(e4, t4, r3) {
              return e4 < 0 ? e4 += 6 : 6 <= e4 && (e4 -= 6), e4 < 1 ? t4 + (r3 - t4) * e4 : e4 < 3 ? r3 : e4 < 4 ? t4 + (r3 - t4) * (4 - e4) : t4;
            })(2 + r2, o = 2 * n - (n = n < 0.5 ? (1 + o) * n : n + o - n * o), n), t3(r2, o, n), t3(r2 - 2, o, n), e3[3]];
          }, e2.default.ColorConversion._rgbaToHSBA = function(e3) {
            var t3, r2, o = e3[0], n = e3[1], s2 = e3[2], i = Math.max(o, n, s2), a = i - Math.min(o, n, s2);
            return 0 == a ? r2 = t3 = 0 : (r2 = a / i, o === i ? t3 = (n - s2) / a : n === i ? t3 = 2 + (s2 - o) / a : s2 === i && (t3 = 4 + (o - n) / a), t3 < 0 ? t3 += 6 : 6 <= t3 && (t3 -= 6)), [t3 / 6, r2, i, e3[3]];
          }, e2.default.ColorConversion._rgbaToHSLA = function(e3) {
            var t3, r2, o = e3[0], n = e3[1], s2 = e3[2], i = Math.max(o, n, s2), a = Math.min(o, n, s2), l = i + a, a = i - a;
            return 0 == a ? r2 = t3 = 0 : (r2 = l < 1 ? a / l : a / (2 - l), o === i ? t3 = (n - s2) / a : n === i ? t3 = 2 + (s2 - o) / a : s2 === i && (t3 = 4 + (o - n) / a), t3 < 0 ? t3 += 6 : 6 <= t3 && (t3 -= 6)), [t3 / 6, r2, l / 2, e3[3]];
          };
          e2 = e2.default.ColorConversion;
          r.default = e2;
        }, { "../core/main": 267 }], 253: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.map"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var l = (n = e2("../core/main")) && n.__esModule ? n : { default: n }, u = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s2;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s2 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s2.get || s2.set) ? Object.defineProperty(o2, r2, s2) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          e2("./p5.Color"), e2("../core/friendly_errors/validate_params"), e2("../core/friendly_errors/file_errors"), e2("../core/friendly_errors/fes_core"), l.default.prototype.alpha = function(e3) {
            return l.default._validateParameters("alpha", arguments), this.color(e3)._getAlpha();
          }, l.default.prototype.blue = function(e3) {
            return l.default._validateParameters("blue", arguments), this.color(e3)._getBlue();
          }, l.default.prototype.brightness = function(e3) {
            return l.default._validateParameters("brightness", arguments), this.color(e3)._getBrightness();
          }, l.default.prototype.color = function() {
            var e3;
            return l.default._validateParameters("color", arguments), arguments[0] instanceof l.default.Color ? arguments[0] : (e3 = arguments[0] instanceof Array ? arguments[0] : arguments, new l.default.Color(this, e3));
          }, l.default.prototype.green = function(e3) {
            return l.default._validateParameters("green", arguments), this.color(e3)._getGreen();
          }, l.default.prototype.hue = function(e3) {
            return l.default._validateParameters("hue", arguments), this.color(e3)._getHue();
          }, l.default.prototype.lerpColor = function(e3, t3, r2) {
            l.default._validateParameters("lerpColor", arguments);
            var o2, n2, s2, i2 = this._colorMode, a2 = this._colorMaxes;
            if (i2 === u.RGB)
              n2 = e3.levels.map(function(e4) {
                return e4 / 255;
              }), s2 = t3.levels.map(function(e4) {
                return e4 / 255;
              });
            else if (i2 === u.HSB)
              e3._getBrightness(), t3._getBrightness(), n2 = e3.hsba, s2 = t3.hsba;
            else {
              if (i2 !== u.HSL)
                throw new Error("".concat(i2, "cannot be used for interpolation."));
              e3._getLightness(), t3._getLightness(), n2 = e3.hsla, s2 = t3.hsla;
            }
            return r2 = Math.max(Math.min(r2, 1), 0), void 0 === this.lerp && (this.lerp = function(e4, t4, r3) {
              return r3 * (t4 - e4) + e4;
            }), e3 = this.lerp(n2[0], s2[0], r2), t3 = this.lerp(n2[1], s2[1], r2), o2 = this.lerp(n2[2], s2[2], r2), n2 = this.lerp(n2[3], s2[3], r2), e3 *= a2[i2][0], t3 *= a2[i2][1], o2 *= a2[i2][2], n2 *= a2[i2][3], this.color(e3, t3, o2, n2);
          }, l.default.prototype.lightness = function(e3) {
            return l.default._validateParameters("lightness", arguments), this.color(e3)._getLightness();
          }, l.default.prototype.red = function(e3) {
            return l.default._validateParameters("red", arguments), this.color(e3)._getRed();
          }, l.default.prototype.saturation = function(e3) {
            return l.default._validateParameters("saturation", arguments), this.color(e3)._getSaturation();
          };
          var n = l.default;
          r.default = n;
        }, { "../core/constants": 256, "../core/friendly_errors/fes_core": 258, "../core/friendly_errors/file_errors": 259, "../core/friendly_errors/validate_params": 262, "../core/main": 267, "./p5.Color": 254, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.map": 161, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 254: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.constructor"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.trim"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.constructor"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.trim"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var c = n(e2("../core/main")), d = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants")), f = n(e2("./color_conversion"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          function n(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          c.default.Color = function(e3, t3) {
            if (this._storeModeAndMaxes(e3._colorMode, e3._colorMaxes), this.mode !== d.RGB && this.mode !== d.HSL && this.mode !== d.HSB)
              throw new Error("".concat(this.mode, " is an invalid colorMode."));
            return this._array = c.default.Color._parseInputs.apply(this, t3), this._calculateLevels(), this;
          }, c.default.Color.prototype.toString = function(e3) {
            var t3 = this.levels, r2 = this._array, o2 = r2[3];
            switch (e3) {
              case "#rrggbb":
                return "#".concat(t3[0] < 16 ? "0".concat(t3[0].toString(16)) : t3[0].toString(16), t3[1] < 16 ? "0".concat(t3[1].toString(16)) : t3[1].toString(16), t3[2] < 16 ? "0".concat(t3[2].toString(16)) : t3[2].toString(16));
              case "#rrggbbaa":
                return "#".concat(t3[0] < 16 ? "0".concat(t3[0].toString(16)) : t3[0].toString(16), t3[1] < 16 ? "0".concat(t3[1].toString(16)) : t3[1].toString(16), t3[2] < 16 ? "0".concat(t3[2].toString(16)) : t3[2].toString(16), t3[3] < 16 ? "0".concat(t3[3].toString(16)) : t3[3].toString(16));
              case "#rgb":
                return "#".concat(Math.round(15 * r2[0]).toString(16), Math.round(15 * r2[1]).toString(16), Math.round(15 * r2[2]).toString(16));
              case "#rgba":
                return "#".concat(Math.round(15 * r2[0]).toString(16), Math.round(15 * r2[1]).toString(16), Math.round(15 * r2[2]).toString(16), Math.round(15 * r2[3]).toString(16));
              case "rgb":
                return "rgb(".concat(t3[0], ", ", t3[1], ", ", t3[2], ")");
              case "rgb%":
                return "rgb(".concat((100 * r2[0]).toPrecision(3), "%, ", (100 * r2[1]).toPrecision(3), "%, ", (100 * r2[2]).toPrecision(3), "%)");
              case "rgba%":
                return "rgba(".concat((100 * r2[0]).toPrecision(3), "%, ", (100 * r2[1]).toPrecision(3), "%, ", (100 * r2[2]).toPrecision(3), "%, ", (100 * r2[3]).toPrecision(3), "%)");
              case "hsb":
              case "hsv":
                return this.hsba || (this.hsba = f.default._rgbaToHSBA(this._array)), "hsb(".concat(this.hsba[0] * this.maxes[d.HSB][0], ", ", this.hsba[1] * this.maxes[d.HSB][1], ", ", this.hsba[2] * this.maxes[d.HSB][2], ")");
              case "hsb%":
              case "hsv%":
                return this.hsba || (this.hsba = f.default._rgbaToHSBA(this._array)), "hsb(".concat((100 * this.hsba[0]).toPrecision(3), "%, ", (100 * this.hsba[1]).toPrecision(3), "%, ", (100 * this.hsba[2]).toPrecision(3), "%)");
              case "hsba":
              case "hsva":
                return this.hsba || (this.hsba = f.default._rgbaToHSBA(this._array)), "hsba(".concat(this.hsba[0] * this.maxes[d.HSB][0], ", ", this.hsba[1] * this.maxes[d.HSB][1], ", ", this.hsba[2] * this.maxes[d.HSB][2], ", ", o2, ")");
              case "hsba%":
              case "hsva%":
                return this.hsba || (this.hsba = f.default._rgbaToHSBA(this._array)), "hsba(".concat((100 * this.hsba[0]).toPrecision(3), "%, ", (100 * this.hsba[1]).toPrecision(3), "%, ", (100 * this.hsba[2]).toPrecision(3), "%, ", (100 * o2).toPrecision(3), "%)");
              case "hsl":
                return this.hsla || (this.hsla = f.default._rgbaToHSLA(this._array)), "hsl(".concat(this.hsla[0] * this.maxes[d.HSL][0], ", ", this.hsla[1] * this.maxes[d.HSL][1], ", ", this.hsla[2] * this.maxes[d.HSL][2], ")");
              case "hsl%":
                return this.hsla || (this.hsla = f.default._rgbaToHSLA(this._array)), "hsl(".concat((100 * this.hsla[0]).toPrecision(3), "%, ", (100 * this.hsla[1]).toPrecision(3), "%, ", (100 * this.hsla[2]).toPrecision(3), "%)");
              case "hsla":
                return this.hsla || (this.hsla = f.default._rgbaToHSLA(this._array)), "hsla(".concat(this.hsla[0] * this.maxes[d.HSL][0], ", ", this.hsla[1] * this.maxes[d.HSL][1], ", ", this.hsla[2] * this.maxes[d.HSL][2], ", ", o2, ")");
              case "hsla%":
                return this.hsla || (this.hsla = f.default._rgbaToHSLA(this._array)), "hsl(".concat((100 * this.hsla[0]).toPrecision(3), "%, ", (100 * this.hsla[1]).toPrecision(3), "%, ", (100 * this.hsla[2]).toPrecision(3), "%, ", (100 * o2).toPrecision(3), "%)");
              default:
                return "rgba(".concat(t3[0], ",", t3[1], ",", t3[2], ",", o2, ")");
            }
          }, c.default.Color.prototype.setRed = function(e3) {
            this._array[0] = e3 / this.maxes[d.RGB][0], this._calculateLevels();
          }, c.default.Color.prototype.setGreen = function(e3) {
            this._array[1] = e3 / this.maxes[d.RGB][1], this._calculateLevels();
          }, c.default.Color.prototype.setBlue = function(e3) {
            this._array[2] = e3 / this.maxes[d.RGB][2], this._calculateLevels();
          }, c.default.Color.prototype.setAlpha = function(e3) {
            this._array[3] = e3 / this.maxes[this.mode][3], this._calculateLevels();
          }, c.default.Color.prototype._calculateLevels = function() {
            for (var e3 = this._array, t3 = this.levels = new Array(e3.length), r2 = e3.length - 1; 0 <= r2; --r2)
              t3[r2] = Math.round(255 * e3[r2]);
            this.hsla = null, this.hsba = null;
          }, c.default.Color.prototype._getAlpha = function() {
            return this._array[3] * this.maxes[this.mode][3];
          }, c.default.Color.prototype._storeModeAndMaxes = function(e3, t3) {
            this.mode = e3, this.maxes = t3;
          }, c.default.Color.prototype._getMode = function() {
            return this.mode;
          }, c.default.Color.prototype._getMaxes = function() {
            return this.maxes;
          }, c.default.Color.prototype._getBlue = function() {
            return this._array[2] * this.maxes[d.RGB][2];
          }, c.default.Color.prototype._getBrightness = function() {
            return this.hsba || (this.hsba = f.default._rgbaToHSBA(this._array)), this.hsba[2] * this.maxes[d.HSB][2];
          }, c.default.Color.prototype._getGreen = function() {
            return this._array[1] * this.maxes[d.RGB][1];
          }, c.default.Color.prototype._getHue = function() {
            return this.mode === d.HSB ? (this.hsba || (this.hsba = f.default._rgbaToHSBA(this._array)), this.hsba[0] * this.maxes[d.HSB][0]) : (this.hsla || (this.hsla = f.default._rgbaToHSLA(this._array)), this.hsla[0] * this.maxes[d.HSL][0]);
          }, c.default.Color.prototype._getLightness = function() {
            return this.hsla || (this.hsla = f.default._rgbaToHSLA(this._array)), this.hsla[2] * this.maxes[d.HSL][2];
          }, c.default.Color.prototype._getRed = function() {
            return this._array[0] * this.maxes[d.RGB][0];
          }, c.default.Color.prototype._getSaturation = function() {
            return this.mode === d.HSB ? (this.hsba || (this.hsba = f.default._rgbaToHSBA(this._array)), this.hsba[1] * this.maxes[d.HSB][1]) : (this.hsla || (this.hsla = f.default._rgbaToHSLA(this._array)), this.hsla[1] * this.maxes[d.HSL][1]);
          };
          var h = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgray: "#d3d3d3", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370db", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#db7093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", slategrey: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" }, e2 = /\s*/, s2 = /(\d{1,3})/, l = /((?:\d+(?:\.\d+)?)|(?:\.\d+))/, u = new RegExp("".concat(l.source, "%")), p = { HEX3: /^#([a-f0-9])([a-f0-9])([a-f0-9])$/i, HEX4: /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])$/i, HEX6: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i, HEX8: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i, RGB: new RegExp(["^rgb\\(", s2.source, ",", s2.source, ",", s2.source, "\\)$"].join(e2.source), "i"), RGB_PERCENT: new RegExp(["^rgb\\(", u.source, ",", u.source, ",", u.source, "\\)$"].join(e2.source), "i"), RGBA: new RegExp(["^rgba\\(", s2.source, ",", s2.source, ",", s2.source, ",", l.source, "\\)$"].join(e2.source), "i"), RGBA_PERCENT: new RegExp(["^rgba\\(", u.source, ",", u.source, ",", u.source, ",", l.source, "\\)$"].join(e2.source), "i"), HSL: new RegExp(["^hsl\\(", s2.source, ",", u.source, ",", u.source, "\\)$"].join(e2.source), "i"), HSLA: new RegExp(["^hsla\\(", s2.source, ",", u.source, ",", u.source, ",", l.source, "\\)$"].join(e2.source), "i"), HSB: new RegExp(["^hsb\\(", s2.source, ",", u.source, ",", u.source, "\\)$"].join(e2.source), "i"), HSBA: new RegExp(["^hsba\\(", s2.source, ",", u.source, ",", u.source, ",", l.source, "\\)$"].join(e2.source), "i") }, s2 = (c.default.Color._parseInputs = function(e3, t3, r2, o2) {
            var n2, s3 = arguments.length, i2 = this.mode, a2 = this.maxes[i2], l2 = [];
            if (3 <= s3) {
              for (l2[0] = e3 / a2[0], l2[1] = t3 / a2[1], l2[2] = r2 / a2[2], l2[3] = "number" == typeof o2 ? o2 / a2[3] : 1, n2 = l2.length - 1; 0 <= n2; --n2) {
                var u2 = l2[n2];
                u2 < 0 ? l2[n2] = 0 : 1 < u2 && (l2[n2] = 1);
              }
              return i2 === d.HSL ? f.default._hslaToRGBA(l2) : i2 === d.HSB ? f.default._hsbaToRGBA(l2) : l2;
            }
            if (1 === s3 && "string" == typeof e3) {
              r2 = e3.trim().toLowerCase();
              if (h[r2])
                return c.default.Color._parseInputs.call(this, h[r2]);
              if (p.HEX3.test(r2))
                return (l2 = p.HEX3.exec(r2).slice(1).map(function(e4) {
                  return parseInt(e4 + e4, 16) / 255;
                }))[3] = 1, l2;
              if (p.HEX6.test(r2))
                return (l2 = p.HEX6.exec(r2).slice(1).map(function(e4) {
                  return parseInt(e4, 16) / 255;
                }))[3] = 1, l2;
              if (p.HEX4.test(r2))
                return l2 = p.HEX4.exec(r2).slice(1).map(function(e4) {
                  return parseInt(e4 + e4, 16) / 255;
                });
              if (p.HEX8.test(r2))
                return l2 = p.HEX8.exec(r2).slice(1).map(function(e4) {
                  return parseInt(e4, 16) / 255;
                });
              if (p.RGB.test(r2))
                return (l2 = p.RGB.exec(r2).slice(1).map(function(e4) {
                  return e4 / 255;
                }))[3] = 1, l2;
              if (p.RGB_PERCENT.test(r2))
                return (l2 = p.RGB_PERCENT.exec(r2).slice(1).map(function(e4) {
                  return parseFloat(e4) / 100;
                }))[3] = 1, l2;
              if (p.RGBA.test(r2))
                return l2 = p.RGBA.exec(r2).slice(1).map(function(e4, t4) {
                  return 3 === t4 ? parseFloat(e4) : e4 / 255;
                });
              if (p.RGBA_PERCENT.test(r2))
                return l2 = p.RGBA_PERCENT.exec(r2).slice(1).map(function(e4, t4) {
                  return 3 === t4 ? parseFloat(e4) : parseFloat(e4) / 100;
                });
              if (p.HSL.test(r2) ? (l2 = p.HSL.exec(r2).slice(1).map(function(e4, t4) {
                return 0 === t4 ? parseInt(e4, 10) / 360 : parseInt(e4, 10) / 100;
              }))[3] = 1 : p.HSLA.test(r2) && (l2 = p.HSLA.exec(r2).slice(1).map(function(e4, t4) {
                return 0 === t4 ? parseInt(e4, 10) / 360 : 3 === t4 ? parseFloat(e4) : parseInt(e4, 10) / 100;
              })), (l2 = l2.map(function(e4) {
                return Math.max(Math.min(e4, 1), 0);
              })).length)
                return f.default._hslaToRGBA(l2);
              if (p.HSB.test(r2) ? (l2 = p.HSB.exec(r2).slice(1).map(function(e4, t4) {
                return 0 === t4 ? parseInt(e4, 10) / 360 : parseInt(e4, 10) / 100;
              }))[3] = 1 : p.HSBA.test(r2) && (l2 = p.HSBA.exec(r2).slice(1).map(function(e4, t4) {
                return 0 === t4 ? parseInt(e4, 10) / 360 : 3 === t4 ? parseFloat(e4) : parseInt(e4, 10) / 100;
              })), l2.length) {
                for (n2 = l2.length - 1; 0 <= n2; --n2)
                  l2[n2] = Math.max(Math.min(l2[n2], 1), 0);
                return f.default._hsbaToRGBA(l2);
              }
              l2 = [1, 1, 1, 1];
            } else {
              if (1 !== s3 && 2 !== s3 || "number" != typeof e3)
                throw new Error("".concat(arguments, "is not a valid color representation."));
              l2[0] = e3 / a2[2], l2[1] = e3 / a2[2], l2[2] = e3 / a2[2], l2[3] = "number" == typeof t3 ? t3 / a2[3] : 1, l2 = l2.map(function(e4) {
                return Math.max(Math.min(e4, 1), 0);
              });
            }
            return l2;
          }, c.default.Color);
          r.default = s2;
        }, { "../core/constants": 256, "../core/main": 267, "./color_conversion": 252, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.join": 159, "core-js/modules/es.array.map": 161, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.constructor": 180, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.trim": 193, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 255: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.fill"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var s2 = (n = e2("../core/main")) && n.__esModule ? n : { default: n }, a = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = l();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function l() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), l = function() {
              return e3;
            }, e3);
          }
          e2("./p5.Color"), s2.default.prototype.background = function() {
            var e3;
            return (e3 = this._renderer).background.apply(e3, arguments), this;
          }, s2.default.prototype.clear = function() {
            return this._renderer.clear((arguments.length <= 0 ? void 0 : arguments[0]) || 0, (arguments.length <= 1 ? void 0 : arguments[1]) || 0, (arguments.length <= 2 ? void 0 : arguments[2]) || 0, (arguments.length <= 3 ? void 0 : arguments[3]) || 0), this;
          }, s2.default.prototype.colorMode = function(e3, t3, r2, o2, n2) {
            return s2.default._validateParameters("colorMode", arguments), e3 !== a.RGB && e3 !== a.HSB && e3 !== a.HSL || (this._colorMode = e3, e3 = this._colorMaxes[e3], 2 === arguments.length ? (e3[0] = t3, e3[1] = t3, e3[2] = t3, e3[3] = t3) : 4 === arguments.length ? (e3[0] = t3, e3[1] = r2, e3[2] = o2) : 5 === arguments.length && (e3[0] = t3, e3[1] = r2, e3[2] = o2, e3[3] = n2)), this;
          }, s2.default.prototype.fill = function() {
            var e3;
            return this._renderer._setProperty("_fillSet", true), this._renderer._setProperty("_doFill", true), (e3 = this._renderer).fill.apply(e3, arguments), this;
          }, s2.default.prototype.noFill = function() {
            return this._renderer._setProperty("_doFill", false), this;
          }, s2.default.prototype.noStroke = function() {
            return this._renderer._setProperty("_doStroke", false), this;
          }, s2.default.prototype.stroke = function() {
            var e3;
            return this._renderer._setProperty("_strokeSet", true), this._renderer._setProperty("_doStroke", true), (e3 = this._renderer).stroke.apply(e3, arguments), this;
          }, s2.default.prototype.erase = function() {
            return this._renderer.erase(0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 255, 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 255), this;
          }, s2.default.prototype.noErase = function() {
            return this._renderer.noErase(), this;
          };
          var n = s2.default;
          r.default = n;
        }, { "../core/constants": 256, "../core/main": 267, "./p5.Color": 254, "core-js/modules/es.array.fill": 152, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 256: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.BEZIER = r.QUADRATIC = r.LINEAR = r._CTX_MIDDLE = r._DEFAULT_LEADMULT = r._DEFAULT_TEXT_FILL = r.WORD = r.CHAR = r.BOLDITALIC = r.BOLD = r.ITALIC = r.NORMAL = r.BLUR = r.ERODE = r.DILATE = r.POSTERIZE = r.INVERT = r.OPAQUE = r.GRAY = r.THRESHOLD = r.BURN = r.DODGE = r.SOFT_LIGHT = r.HARD_LIGHT = r.OVERLAY = r.REPLACE = r.SCREEN = r.MULTIPLY = r.EXCLUSION = r.SUBTRACT = r.DIFFERENCE = r.LIGHTEST = r.DARKEST = r.ADD = r.REMOVE = r.BLEND = r.UP_ARROW = r.TAB = r.SHIFT = r.RIGHT_ARROW = r.RETURN = r.OPTION = r.LEFT_ARROW = r.ESCAPE = r.ENTER = r.DOWN_ARROW = r.DELETE = r.CONTROL = r.BACKSPACE = r.ALT = r.AUTO = r.HSL = r.HSB = r.RGB = r.MITER = r.BEVEL = r.ROUND = r.SQUARE = r.PROJECT = r.PIE = r.CHORD = r.OPEN = r.CLOSE = r.TESS = r.QUAD_STRIP = r.QUADS = r.TRIANGLE_STRIP = r.TRIANGLE_FAN = r.TRIANGLES = r.LINE_LOOP = r.LINE_STRIP = r.LINES = r.POINTS = r.BASELINE = r.BOTTOM = r.TOP = r.CENTER = r.LEFT = r.RIGHT = r.RADIUS = r.CORNERS = r.CORNER = r.RAD_TO_DEG = r.DEG_TO_RAD = r.RADIANS = r.DEGREES = r.TWO_PI = r.TAU = r.QUARTER_PI = r.PI = r.HALF_PI = r.WAIT = r.TEXT = r.MOVE = r.HAND = r.CROSS = r.ARROW = r.WEBGL = r.P2D = r.VERSION = void 0, r.COVER = r.CONTAIN = r.FALLBACK = r.LABEL = r.AXES = r.GRID = r._DEFAULT_FILL = r._DEFAULT_STROKE = r.PORTRAIT = r.LANDSCAPE = r.MIRROR = r.CLAMP = r.REPEAT = r.NEAREST = r.IMAGE = r.IMMEDIATE = r.TEXTURE = r.FILL = r.STROKE = r.CURVE = void 0;
          var o = Math.PI, n = (r.VERSION = "1.5.0", r.P2D = "p2d", r.WEBGL = "webgl", r.ARROW = "default", r.CROSS = "crosshair", r.HAND = "pointer", r.MOVE = "move", r.TEXT = "text", r.WAIT = "wait", o / 2), n = (r.HALF_PI = n, o), n = (r.PI = n, o / 4), n = (r.QUARTER_PI = n, 2 * o), n = (r.TAU = n, 2 * o), n = (r.TWO_PI = n, r.DEGREES = "degrees", r.RADIANS = "radians", o / 180), n = (r.DEG_TO_RAD = n, 180 / o);
          r.RAD_TO_DEG = n, r.CORNER = "corner", r.CORNERS = "corners", r.RADIUS = "radius", r.RIGHT = "right", r.LEFT = "left", r.CENTER = "center", r.TOP = "top", r.BOTTOM = "bottom", r.BASELINE = "alphabetic", r.POINTS = 0, r.LINES = 1, r.LINE_STRIP = 3, r.LINE_LOOP = 2, r.TRIANGLES = 4, r.TRIANGLE_FAN = 6, r.TRIANGLE_STRIP = 5, r.QUADS = "quads", r.QUAD_STRIP = "quad_strip", r.TESS = "tess", r.CLOSE = "close", r.OPEN = "open", r.CHORD = "chord", r.PIE = "pie", r.PROJECT = "square", r.SQUARE = "butt", r.ROUND = "round", r.BEVEL = "bevel", r.MITER = "miter", r.RGB = "rgb", r.HSB = "hsb", r.HSL = "hsl", r.AUTO = "auto", r.ALT = 18, r.BACKSPACE = 8, r.CONTROL = 17, r.DELETE = 46, r.DOWN_ARROW = 40, r.ENTER = 13, r.ESCAPE = 27, r.LEFT_ARROW = 37, r.OPTION = 18, r.RETURN = 13, r.RIGHT_ARROW = 39, r.SHIFT = 16, r.TAB = 9, r.UP_ARROW = 38, r.BLEND = "source-over", r.REMOVE = "destination-out", r.ADD = "lighter", r.DARKEST = "darken", r.LIGHTEST = "lighten", r.DIFFERENCE = "difference", r.SUBTRACT = "subtract", r.EXCLUSION = "exclusion", r.MULTIPLY = "multiply", r.SCREEN = "screen", r.REPLACE = "copy", r.OVERLAY = "overlay", r.HARD_LIGHT = "hard-light", r.SOFT_LIGHT = "soft-light", r.DODGE = "color-dodge", r.BURN = "color-burn", r.THRESHOLD = "threshold", r.GRAY = "gray", r.OPAQUE = "opaque", r.INVERT = "invert", r.POSTERIZE = "posterize", r.DILATE = "dilate", r.ERODE = "erode", r.BLUR = "blur", r.NORMAL = "normal", r.ITALIC = "italic", r.BOLD = "bold", r.BOLDITALIC = "bold italic", r.CHAR = "CHAR", r.WORD = "WORD", r._DEFAULT_TEXT_FILL = "#000000", r._DEFAULT_LEADMULT = 1.25, r._CTX_MIDDLE = "middle", r.LINEAR = "linear", r.QUADRATIC = "quadratic", r.BEZIER = "bezier", r.CURVE = "curve", r.STROKE = "stroke", r.FILL = "fill", r.TEXTURE = "texture", r.IMMEDIATE = "immediate", r.IMAGE = "image", r.NEAREST = "nearest", r.REPEAT = "repeat", r.CLAMP = "clamp", r.MIRROR = "mirror", r.LANDSCAPE = "landscape", r.PORTRAIT = "portrait", r._DEFAULT_STROKE = "#000000", r._DEFAULT_FILL = "#FFFFFF", r.GRID = "grid", r.AXES = "axes", r.LABEL = "label", r.FALLBACK = "fallback", r.CONTAIN = "contain";
          r.COVER = "cover";
        }, {}], 257: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.search"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.search"), e2("core-js/modules/es.string.split"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (s2 = e2("./main")) && s2.__esModule ? s2 : { default: s2 }, s2 = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("./constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          var l = [s2.ARROW, s2.CROSS, s2.HAND, s2.MOVE, s2.TEXT, s2.WAIT], u = (n.default.prototype._frameRate = 0, n.default.prototype._lastFrameTime = window.performance.now(), n.default.prototype._targetFrameRate = 60, window.print);
          function c() {
            return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth || 0;
          }
          function d() {
            return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight || 0;
          }
          n.default.prototype.print = function() {
            var e3;
            arguments.length ? (e3 = console).log.apply(e3, arguments) : u();
          }, n.default.prototype.frameCount = 0, n.default.prototype.deltaTime = 0, n.default.prototype.focused = document.hasFocus(), n.default.prototype.cursor = function(e3, t3, r2) {
            var o2, n2 = "auto", s3 = this._curElement.elt;
            l.includes(e3) ? n2 = e3 : "string" == typeof e3 && (o2 = "", t3 && r2 && "number" == typeof t3 && "number" == typeof r2 && (o2 = "".concat(t3, " ").concat(r2)), n2 = "http://" === e3.substring(0, 7) || "https://" === e3.substring(0, 8) || /\.(cur|jpg|jpeg|gif|png|CUR|JPG|JPEG|GIF|PNG)$/.test(e3) ? "url(".concat(e3, ") ").concat(o2, ", auto") : e3), s3.style.cursor = n2;
          }, n.default.prototype.frameRate = function(e3) {
            return n.default._validateParameters("frameRate", arguments), "number" != typeof e3 || e3 < 0 ? this._frameRate : (this._setProperty("_targetFrameRate", e3), 0 === e3 && this._setProperty("_frameRate", e3), this);
          }, n.default.prototype.getFrameRate = function() {
            return this.frameRate();
          }, n.default.prototype.setFrameRate = function(e3) {
            return this.frameRate(e3);
          }, n.default.prototype.noCursor = function() {
            this._curElement.elt.style.cursor = "none";
          }, n.default.prototype.displayWidth = screen.width, n.default.prototype.displayHeight = screen.height, n.default.prototype.windowWidth = c(), n.default.prototype.windowHeight = d(), n.default.prototype._onresize = function(e3) {
            this._setProperty("windowWidth", c()), this._setProperty("windowHeight", d());
            var t3 = this._isGlobal ? window : this;
            "function" != typeof t3.windowResized || void 0 === (t3 = t3.windowResized(e3)) || t3 || e3.preventDefault();
          }, n.default.prototype.width = 0, n.default.prototype.height = 0, n.default.prototype.fullscreen = function(e3) {
            if (n.default._validateParameters("fullscreen", arguments), void 0 === e3)
              return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
            if (e3) {
              e3 = document.documentElement;
              if (!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled))
                throw new Error("Fullscreen not enabled in this browser.");
              e3.requestFullscreen ? e3.requestFullscreen() : e3.mozRequestFullScreen ? e3.mozRequestFullScreen() : e3.webkitRequestFullscreen ? e3.webkitRequestFullscreen() : e3.msRequestFullscreen && e3.msRequestFullscreen();
            } else
              document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen();
          }, n.default.prototype.pixelDensity = function(e3) {
            var t3;
            return n.default._validateParameters("pixelDensity", arguments), "number" == typeof e3 ? (e3 !== this._pixelDensity && (this._pixelDensity = e3), (t3 = this).resizeCanvas(this.width, this.height, true)) : t3 = this._pixelDensity, t3;
          }, n.default.prototype.displayDensity = function() {
            return window.devicePixelRatio;
          }, n.default.prototype.getURL = function() {
            return location.href;
          }, n.default.prototype.getURLPath = function() {
            return location.pathname.split("/").filter(function(e3) {
              return "" !== e3;
            });
          }, n.default.prototype.getURLParams = function() {
            for (var e3, t3 = /[?&]([^&=]+)(?:[&=])([^&=]+)/gim, r2 = {}; null != (e3 = t3.exec(location.search)); )
              e3.index === t3.lastIndex && t3.lastIndex++, r2[e3[1]] = e3[2];
            return r2;
          };
          e2 = n.default;
          r.default = e2;
        }, { "./constants": 256, "./main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.filter": 153, "core-js/modules/es.array.includes": 156, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.string.includes": 185, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.search": 190, "core-js/modules/es.string.split": 191, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 258: [function(r, e2, t2) {
          "use strict";
          r("core-js/modules/es.symbol"), r("core-js/modules/es.symbol.description"), r("core-js/modules/es.symbol.iterator"), r("core-js/modules/es.array.concat"), r("core-js/modules/es.array.filter"), r("core-js/modules/es.array.for-each"), r("core-js/modules/es.array.includes"), r("core-js/modules/es.array.iterator"), r("core-js/modules/es.array.join"), r("core-js/modules/es.array.map"), r("core-js/modules/es.array.slice"), r("core-js/modules/es.array.some"), r("core-js/modules/es.function.name"), r("core-js/modules/es.object.assign"), r("core-js/modules/es.object.get-own-property-names"), r("core-js/modules/es.object.keys"), r("core-js/modules/es.object.to-string"), r("core-js/modules/es.regexp.constructor"), r("core-js/modules/es.regexp.exec"), r("core-js/modules/es.regexp.to-string"), r("core-js/modules/es.string.iterator"), r("core-js/modules/es.string.match"), r("core-js/modules/es.string.replace"), r("core-js/modules/es.string.search"), r("core-js/modules/es.string.split"), r("core-js/modules/web.dom-collections.for-each"), r("core-js/modules/web.dom-collections.iterator"), r("core-js/modules/es.symbol"), r("core-js/modules/es.symbol.description"), r("core-js/modules/es.symbol.iterator"), r("core-js/modules/es.array.concat"), r("core-js/modules/es.array.filter"), r("core-js/modules/es.array.for-each"), r("core-js/modules/es.array.includes"), r("core-js/modules/es.array.iterator"), r("core-js/modules/es.array.join"), r("core-js/modules/es.array.map"), r("core-js/modules/es.array.slice"), r("core-js/modules/es.array.some"), r("core-js/modules/es.function.name"), r("core-js/modules/es.object.assign"), r("core-js/modules/es.object.get-own-property-names"), r("core-js/modules/es.object.keys"), r("core-js/modules/es.object.to-string"), r("core-js/modules/es.regexp.constructor"), r("core-js/modules/es.regexp.exec"), r("core-js/modules/es.regexp.to-string"), r("core-js/modules/es.string.iterator"), r("core-js/modules/es.string.match"), r("core-js/modules/es.string.replace"), r("core-js/modules/es.string.search"), r("core-js/modules/es.string.split"), r("core-js/modules/web.dom-collections.for-each"), r("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
          var o = (l = r("../main")) && l.__esModule ? l : { default: l };
          r("../internationalization");
          function n(r2, o2) {
            o2 = o2 || console.log.bind(console), s2 || i(), s2.some(function(e3) {
              var t3;
              if (r2.message && null !== r2.message.match("\\W?".concat(e3.name, "\\W")))
                return t3 = "function" === e3.type ? "".concat(e3.name, "()") : e3.name, o2("Did you just try to use p5.js's ".concat(t3, " ").concat(e3.type, "? If so, you may want to move it into your sketch's setup() function.\n\nFor more details, see: ").concat(a)), true;
            });
          }
          var s2 = null, i = null, a = (o.default._friendlyError = o.default._checkForUserDefinedFunctions = o.default._fesErrorMonitor = function() {
          }, s2 = null, "https://github.com/processing/p5.js/wiki/p5.js-overview#why-cant-i-assign-variables-using-p5-functions-and-variables-before-setup"), i = function() {
            function e3(r2) {
              return Object.getOwnPropertyNames(r2).filter(function(e4) {
                return "_" !== e4[0] && (!(e4 in t3) && (t3[e4] = true));
              }).map(function(e4) {
                var t4 = "function" == typeof r2[e4] ? "function" : e4 === e4.toUpperCase() ? "constant" : "variable";
                return { name: e4, type: t4 };
              });
            }
            var t3 = {};
            (s2 = [].concat(e3(o.default.prototype), e3(r("../constants")))).sort(function(e4, t4) {
              return t4.name.length - e4.name.length;
            });
          }, l = (o.default.prototype._helpForMisusedAtTopLevelCode = n, "complete" !== document.readyState && (window.addEventListener("error", n, false), window.addEventListener("load", function() {
            window.removeEventListener("error", n, false);
          })), o.default);
          t2.default = l;
        }, { "../constants": 256, "../internationalization": 265, "../main": 267, "./browser_errors": void 0, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.filter": 153, "core-js/modules/es.array.for-each": 154, "core-js/modules/es.array.includes": 156, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.join": 159, "core-js/modules/es.array.map": 161, "core-js/modules/es.array.slice": 162, "core-js/modules/es.array.some": 163, "core-js/modules/es.function.name": 165, "core-js/modules/es.object.assign": 172, "core-js/modules/es.object.get-own-property-names": 174, "core-js/modules/es.object.keys": 176, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.constructor": 180, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.match": 187, "core-js/modules/es.string.replace": 189, "core-js/modules/es.string.search": 190, "core-js/modules/es.string.split": 191, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/web.dom-collections.for-each": 229, "core-js/modules/web.dom-collections.iterator": 230 }], 259: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var o = (o = e2("../main")) && o.__esModule ? o : { default: o };
          e2("../internationalization");
          o.default._friendlyFileLoadError = function() {
          };
          e2 = o.default;
          r.default = e2;
        }, { "../internationalization": 265, "../main": 267 }], 260: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.constructor"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.match"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.trim"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.for-each"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.constructor"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.match"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.trim"), e2("core-js/modules/web.dom-collections.for-each"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = L(e2("../main")), s2 = e2("../internationalization"), a = O(e2("../constants")), l, u, c, d, f, h, p, m, y, g, v, b, j, _, x, w, S, M, E, T, D;
          function C() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), C = function() {
              return e3;
            }, e3);
          }
          function O(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = C();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2, n2 = {}, s3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3)
              Object.prototype.hasOwnProperty.call(e3, r2) && ((o2 = s3 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (o2.get || o2.set) ? Object.defineProperty(n2, r2, o2) : n2[r2] = e3[r2]);
            return n2.default = e3, t3 && t3.set(e3, n2), n2;
          }
          function L(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          function I(e3) {
            return P(e3) || A(e3) || k();
          }
          function k() {
            throw new TypeError("Invalid attempt to spread non-iterable instance");
          }
          function A(e3) {
            if (Symbol.iterator in Object(e3) || "[object Arguments]" === Object.prototype.toString.call(e3))
              return Array.from(e3);
          }
          function P(e3) {
            if (Array.isArray(e3)) {
              for (var t3 = 0, r2 = new Array(e3.length); t3 < e3.length; t3++)
                r2[t3] = e3[t3];
              return r2;
            }
          }
          n.default._fesCodeReader = function() {
          };
          var R = n.default;
          r.default = R;
        }, { "../constants": 256, "../internationalization": 265, "../main": 267, "core-js/modules/es.array.filter": 153, "core-js/modules/es.array.for-each": 154, "core-js/modules/es.array.from": 155, "core-js/modules/es.array.includes": 156, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.join": 159, "core-js/modules/es.array.map": 161, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.keys": 176, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.constructor": 180, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.includes": 185, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.match": 187, "core-js/modules/es.string.split": 191, "core-js/modules/es.string.trim": 193, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.for-each": 229, "core-js/modules/web.dom-collections.iterator": 230 }], 261: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.match"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.match"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("../main")) && e2.__esModule ? e2 : { default: e2 };
          function o() {
            var t3 = /(^|@)\S+:\d+/, r2 = /^\s*at .*(\S+:\d+|\(native\))/m, o2 = /^(eval@)?(\[native code])?$/;
            return { parse: function(e3) {
              return void 0 !== e3.stacktrace || void 0 !== e3["opera#sourceloc"] ? this.parseOpera(e3) : e3.stack && e3.stack.match(r2) ? this.parseV8OrIE(e3) : e3.stack ? this.parseFFOrSafari(e3) : void 0;
            }, extractLocation: function(e3) {
              return -1 === e3.indexOf(":") ? [e3] : [(e3 = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(e3.replace(/[()]/g, "")))[1], e3[2] || void 0, e3[3] || void 0];
            }, parseV8OrIE: function(e3) {
              return e3.stack.split("\n").filter(function(e4) {
                return !!e4.match(r2);
              }, this).map(function(e4) {
                var t4 = (e4 = -1 < e4.indexOf("(eval ") ? e4.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(\),.*$)/g, "") : e4).replace(/^\s+/, "").replace(/\(eval code/g, "("), r3 = t4.match(/ (\((.+):(\d+):(\d+)\)$)/), t4 = (t4 = r3 ? t4.replace(r3[0], "") : t4).split(/\s+/).slice(1), r3 = this.extractLocation(r3 ? r3[1] : t4.pop());
                return { functionName: t4.join(" ") || void 0, fileName: -1 < ["eval", "<anonymous>"].indexOf(r3[0]) ? void 0 : r3[0], lineNumber: r3[1], columnNumber: r3[2], source: e4 };
              }, this);
            }, parseFFOrSafari: function(e3) {
              return e3.stack.split("\n").filter(function(e4) {
                return !e4.match(o2);
              }, this).map(function(e4) {
                var t4, r3;
                return -1 === (e4 = -1 < e4.indexOf(" > eval") ? e4.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1") : e4).indexOf("@") && -1 === e4.indexOf(":") ? { functionName: e4 } : { functionName: (r3 = e4.match(t4 = /((.*".+"[^@]*)?[^@]*)(?:@)/)) && r3[1] ? r3[1] : void 0, fileName: (r3 = this.extractLocation(e4.replace(t4, "")))[0], lineNumber: r3[1], columnNumber: r3[2], source: e4 };
              }, this);
            }, parseOpera: function(e3) {
              return !e3.stacktrace || -1 < e3.message.indexOf("\n") && e3.message.split("\n").length > e3.stacktrace.split("\n").length ? this.parseOpera9(e3) : e3.stack ? this.parseOpera11(e3) : this.parseOpera10(e3);
            }, parseOpera9: function(e3) {
              for (var t4 = /Line (\d+).*script (?:in )?(\S+)/i, r3 = e3.message.split("\n"), o3 = [], n = 2, s2 = r3.length; n < s2; n += 2) {
                var i = t4.exec(r3[n]);
                i && o3.push({ fileName: i[2], lineNumber: i[1], source: r3[n] });
              }
              return o3;
            }, parseOpera10: function(e3) {
              for (var t4 = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i, r3 = e3.stacktrace.split("\n"), o3 = [], n = 0, s2 = r3.length; n < s2; n += 2) {
                var i = t4.exec(r3[n]);
                i && o3.push({ functionName: i[3] || void 0, fileName: i[2], lineNumber: i[1], source: r3[n] });
              }
              return o3;
            }, parseOpera11: function(e3) {
              return e3.stack.split("\n").filter(function(e4) {
                return !!e4.match(t3) && !e4.match(/^Error created at/);
              }, this).map(function(e4) {
                var t4, r3 = e4.split("@"), o3 = this.extractLocation(r3.pop()), r3 = r3.shift() || "";
                return { functionName: r3.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0, args: void 0 === (t4 = r3.match(/\(([^)]*)\)/) ? r3.replace(/^[^(]+\(([^)]*)\)$/, "$1") : t4) || "[arguments not available]" === t4 ? void 0 : t4.split(","), fileName: o3[0], lineNumber: o3[1], columnNumber: o3[2], source: e4 };
              }, this);
            } };
          }
          e2.default._getErrorStackParser = function() {
            return new o();
          };
          e2 = e2.default;
          r.default = e2;
        }, { "../main": 267, "core-js/modules/es.array.filter": 153, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.join": 159, "core-js/modules/es.array.map": 161, "core-js/modules/es.array.slice": 162, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.string.match": 187, "core-js/modules/es.string.replace": 189, "core-js/modules/es.string.split": 191 }], 262: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.last-index-of"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.map"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.get-prototype-of"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.reflect.construct"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.set"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.for-each"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.last-index-of"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.map"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.object.get-prototype-of"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.reflect.construct"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.set"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.split"), e2("core-js/modules/web.dom-collections.for-each"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (n = e2("../main")) && n.__esModule ? n : { default: n };
          (function(e3) {
            if (e3 && e3.__esModule)
              return;
            if (null === e3 || "object" !== a(e3) && "function" != typeof e3)
              return;
            var t3 = i();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s2;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s2 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s2.get || s2.set) ? Object.defineProperty(o2, r2, s2) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
          })(e2("../constants")), e2("../internationalization");
          function i() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), i = function() {
              return e3;
            }, e3);
          }
          function a(e3) {
            return (a = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          n.default._validateParameters = n.default._clearValidateParamsCache = function() {
          };
          e2 = n.default;
          r.default = e2;
        }, { "../../../docs/parameterData.json": void 0, "../constants": 256, "../internationalization": 265, "../main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.for-each": 154, "core-js/modules/es.array.includes": 156, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.join": 159, "core-js/modules/es.array.last-index-of": 160, "core-js/modules/es.array.map": 161, "core-js/modules/es.array.slice": 162, "core-js/modules/es.function.name": 165, "core-js/modules/es.map": 166, "core-js/modules/es.number.constructor": 169, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.get-prototype-of": 175, "core-js/modules/es.object.keys": 176, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.reflect.construct": 179, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.set": 183, "core-js/modules/es.string.includes": 185, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.split": 191, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.for-each": 229, "core-js/modules/web.dom-collections.iterator": 230 }], 263: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var s2 = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("./constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          r.default = { modeAdjust: function(e3, t3, r2, o2, n) {
            return n === s2.CORNER ? { x: e3, y: t3, w: r2, h: o2 } : n === s2.CORNERS ? { x: e3, y: t3, w: r2 - e3, h: o2 - t3 } : n === s2.RADIUS ? { x: e3 - r2, y: t3 - o2, w: 2 * r2, h: 2 * o2 } : n === s2.CENTER ? { x: e3 - 0.5 * r2, y: t3 - 0.5 * o2, w: r2, h: o2 } : void 0;
          } };
        }, { "./constants": 256, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 264: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator");
          var o = (n = e2("../core/main")) && n.__esModule ? n : { default: n };
          e2("./internationalization");
          var n = Promise.resolve();
          Promise.all([new Promise(function(e3, t3) {
            "complete" === document.readyState ? e3() : window.addEventListener("load", e3, false);
          }), n]).then(function() {
            void 0 !== window._setupDone ? console.warn("p5.js seems to have been imported multiple times. Please remove the duplicate import") : window.mocha || (window.setup && "function" == typeof window.setup || window.draw && "function" == typeof window.draw) && !o.default.instance && new o.default();
          });
        }, { "../core/main": 267, "./internationalization": 265, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.promise": 178, "core-js/modules/es.string.iterator": 186, "core-js/modules/web.dom-collections.iterator": 230 }], 265: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.split"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.split"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.setTranslatorLanguage = r.currentTranslatorLanguage = r.availableTranslatorLanguages = r.initialize = r.translator = void 0;
          var n, s2, o = a(e2("i18next")), i = a(e2("i18next-browser-languagedetector"));
          function a(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          function l(e3, t3) {
            for (var r2 = 0; r2 < t3.length; r2++) {
              var o2 = t3[r2];
              o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, o2.key, o2);
            }
          }
          var u = function() {
            function r2(e4, t4) {
              if (!(this instanceof r2))
                throw new TypeError("Cannot call a class as a function");
              this.init(e4, t4);
            }
            var e3, t3, o2;
            return e3 = r2, (t3 = [{ key: "fetchWithTimeout", value: function(e4, t4) {
              var r3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 2e3;
              return Promise.race([fetch(e4, t4), new Promise(function(e5, t5) {
                return setTimeout(function() {
                  return t5(new Error("timeout"));
                }, r3);
              })]);
            } }, { key: "init", value: function(e4) {
              var t4 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
              this.services = e4, this.options = t4;
            } }, { key: "read", value: function(e4, t4, r3) {
              var o3 = this.options.loadPath;
              e4 === this.options.fallback ? r3(null, n[e4][t4]) : s2.includes(e4) ? (o3 = this.services.interpolator.interpolate(o3, { lng: e4, ns: t4 }), this.loadUrl(o3, r3)) : r3("Not found", false);
            } }, { key: "loadUrl", value: function(t4, r3) {
              this.fetchWithTimeout(t4).then(function(e4) {
                if (e4.ok)
                  return e4.json();
                throw new Error("failed loading ".concat(t4));
              }, function() {
                throw new Error("failed loading ".concat(t4));
              }).then(function(e4) {
                return r3(null, e4);
              }).catch(r3);
            } }]) && l(e3.prototype, t3), o2 && l(e3, o2), r2;
          }();
          u.type = "backend", r.translator = function(e3, t3) {
            console.debug("p5.js translator called before translations were loaded"), o.default.t(e3, t3);
          }, r.initialize = function() {
            return o.default.use(i.default).use(u).init({ fallbackLng: "en", nestingPrefix: "$tr(", nestingSuffix: ")", defaultNS: "translation", returnEmptyString: false, interpolation: { escapeValue: false }, detection: { checkWhitelist: false, order: ["querystring", "navigator", "htmlTag", "path", "subdomain"], caches: [] }, backend: { fallback: "en", loadPath: "https://cdn.jsdelivr.net/npm/p5/translations/{{lng}}/{{ns}}.json" }, partialBundledLanguages: true, resources: n }).then(function(e3) {
              r.translator = e3;
            }, function(e3) {
              return console.debug("Translations failed to load (".concat(e3, ")"));
            });
          }, r.availableTranslatorLanguages = function() {
            return o.default.languages;
          }, r.currentTranslatorLanguage = function(e3) {
            return o.default.language;
          };
          r.setTranslatorLanguage = function(e3) {
            return o.default.changeLanguage(e3 || void 0, function(e4) {
              return console.debug("Translations failed to load (".concat(e4, ")"));
            });
          };
        }, { "../../translations": void 0, "../../translations/dev": void 0, "core-js/modules/es.array.includes": 156, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.join": 159, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.keys": 176, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.promise": 178, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.string.includes": 185, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.split": 191, "core-js/modules/web.dom-collections.iterator": 230, i18next: 3, "i18next-browser-languagedetector": 3 }], 266: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("./main")) && e2.__esModule ? e2 : { default: e2 };
          e2.default.prototype.pushStyle = function() {
            throw new Error("pushStyle() not used, see push()");
          }, e2.default.prototype.popStyle = function() {
            throw new Error("popStyle() not used, see pop()");
          }, e2.default.prototype.popMatrix = function() {
            throw new Error("popMatrix() not used, see pop()");
          }, e2.default.prototype.pushMatrix = function() {
            throw new Error("pushMatrix() not used, see push()");
          };
          e2 = e2.default;
          r.default = e2;
        }, { "./main": 267 }], 267: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.get-own-property-names"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.for-each"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.get-own-property-names"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.for-each"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0, e2("./shim");
          var n = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("./constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          function s2(e3, t3) {
            for (var r2 = 0; r2 < t3.length; r2++) {
              var o2 = t3[r2];
              o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e3, o2.key, o2);
            }
          }
          var l, u = function() {
            function v(e4, t4, r3) {
              var d = this;
              if (!(this instanceof v))
                throw new TypeError("Cannot call a class as a function");
              this._setupDone = false, this._preloadDone = false, this._pixelDensity = Math.ceil(window.devicePixelRatio) || 1, this._userNode = t4, this._curElement = null, this._elements = [], this._glAttributes = null, this._requestAnimId = 0, this._preloadCount = 0, this._isGlobal = false, this._loop = true, this._initializeInstanceVariables(), this._defaultCanvasSize = { width: 100, height: 100 }, this._events = { mousemove: null, mousedown: null, mouseup: null, dragend: null, dragover: null, click: null, dblclick: null, mouseover: null, mouseout: null, keydown: null, keyup: null, keypress: null, touchstart: null, touchmove: null, touchend: null, resize: null, blur: null }, this._millisStart = -1, this._lcg_random_state = null, this._gaussian_previous = false, this._events.wheel = null, this._loadingScreenId = "p5_loading", this._registeredMethods = {};
              var t4 = Object.getOwnPropertyNames(v.prototype._registeredMethods), o2 = true, n2 = false, s3 = void 0;
              try {
                for (var i2, a2 = t4[Symbol.iterator](); !(o2 = (i2 = a2.next()).done); o2 = true) {
                  var l2 = i2.value;
                  this._registeredMethods[l2] = v.prototype._registeredMethods[l2].slice();
                }
              } catch (e5) {
                n2 = true, s3 = e5;
              } finally {
                try {
                  o2 || null == a2.return || a2.return();
                } finally {
                  if (n2)
                    throw s3;
                }
              }
              window.DeviceOrientationEvent && (this._events.deviceorientation = null), window.DeviceMotionEvent && !window._isNodeWebkit && (this._events.devicemotion = null), this._start = function() {
                d._userNode && "string" == typeof d._userNode && (d._userNode = document.getElementById(d._userNode));
                var e5 = d._isGlobal ? window : d;
                if (e5.preload) {
                  var t5, r4 = document.getElementById(d._loadingScreenId), o3 = (r4 || ((r4 = document.createElement("div")).innerHTML = "Loading...", r4.style.position = "absolute", r4.id = d._loadingScreenId, (d._userNode || document.body).appendChild(r4)), d._preloadMethods);
                  for (t5 in o3) {
                    o3[t5] = o3[t5] || v;
                    var n3 = o3[t5];
                    n3 !== v.prototype && n3 !== v || (d._isGlobal && (window[t5] = d._wrapPreload(d, t5)), n3 = d), d._registeredPreloadMethods[t5] = n3[t5], n3[t5] = d._wrapPreload(n3, t5);
                  }
                  e5.preload(), d._runIfPreloadsAreDone();
                } else
                  d._setup(), d._draw();
              }, this._runIfPreloadsAreDone = function() {
                var e5, t5 = this._isGlobal ? window : this;
                0 === t5._preloadCount && ((e5 = document.getElementById(t5._loadingScreenId)) && e5.parentNode.removeChild(e5), this._setupDone || (this._lastFrameTime = window.performance.now(), t5._setup(), t5._draw()));
              }, this._decrementPreload = function() {
                var e5 = this._isGlobal ? window : this;
                e5._preloadDone || "function" != typeof e5.preload || (e5._setProperty("_preloadCount", e5._preloadCount - 1), e5._runIfPreloadsAreDone());
              }, this._wrapPreload = function(o3, n3) {
                var s4 = this;
                return function() {
                  s4._incrementPreload();
                  for (var e5 = arguments.length, t5 = new Array(e5), r4 = 0; r4 < e5; r4++)
                    t5[r4] = arguments[r4];
                  return s4._registeredPreloadMethods[n3].apply(o3, t5);
                };
              }, this._incrementPreload = function() {
                var e5 = this._isGlobal ? window : this;
                e5._preloadDone || e5._setProperty("_preloadCount", e5._preloadCount + 1);
              }, this._setup = function() {
                d.createCanvas(d._defaultCanvasSize.width, d._defaultCanvasSize.height, "p2d");
                var e5 = d._isGlobal ? window : d;
                if ("function" == typeof e5.preload)
                  for (var t5 in d._preloadMethods)
                    e5[t5] = d._preloadMethods[t5][t5], e5[t5] && d && (e5[t5] = e5[t5].bind(d));
                d._millisStart = window.performance.now(), e5._preloadDone = true, "function" == typeof e5.setup && e5.setup();
                var r4 = document.getElementsByTagName("canvas"), o3 = true, n3 = false, s4 = void 0;
                try {
                  for (var i3, a3 = r4[Symbol.iterator](); !(o3 = (i3 = a3.next()).done); o3 = true) {
                    var l3 = i3.value;
                    "true" === l3.dataset.hidden && (l3.style.visibility = "", delete l3.dataset.hidden);
                  }
                } catch (e6) {
                  n3 = true, s4 = e6;
                } finally {
                  try {
                    o3 || null == a3.return || a3.return();
                  } finally {
                    if (n3)
                      throw s4;
                  }
                }
                d._lastFrameTime = window.performance.now(), d._setupDone = true, (d._accessibleOutputs.grid || d._accessibleOutputs.text) && d._updateAccsOutput();
              }, this._draw = function() {
                var e5 = window.performance.now(), t5 = e5 - d._lastFrameTime, r4 = 1e3 / d._targetFrameRate;
                (!d._loop || r4 - 5 <= t5) && (d.redraw(), d._frameRate = 1e3 / (e5 - d._lastFrameTime), d.deltaTime = e5 - d._lastFrameTime, d._setProperty("deltaTime", d.deltaTime), d._lastFrameTime = e5, void 0 !== d._updateMouseCoords && (d._updateMouseCoords(), d._setProperty("movedX", 0), d._setProperty("movedY", 0))), d._loop && (d._requestAnimId = window.requestAnimationFrame(d._draw));
              }, this._setProperty = function(e5, t5) {
                d[e5] = t5, d._isGlobal && (window[e5] = t5);
              }, this.remove = function() {
                var t5 = document.getElementById(d._loadingScreenId);
                if (t5 && (t5.parentNode.removeChild(t5), d._incrementPreload()), d._curElement) {
                  for (var e5 in d._loop = false, d._requestAnimId && window.cancelAnimationFrame(d._requestAnimId), d._events)
                    window.removeEventListener(e5, d._events[e5]);
                  var r4 = true, t5 = false, o3 = void 0;
                  try {
                    for (var n3, s4 = d._elements[Symbol.iterator](); !(r4 = (n3 = s4.next()).done); r4 = true) {
                      var i3, a3 = n3.value;
                      for (i3 in a3.elt && a3.elt.parentNode && a3.elt.parentNode.removeChild(a3.elt), a3._events)
                        a3.elt.removeEventListener(i3, a3._events[i3]);
                    }
                  } catch (e6) {
                    t5 = true, o3 = e6;
                  } finally {
                    try {
                      r4 || null == s4.return || s4.return();
                    } finally {
                      if (t5)
                        throw o3;
                    }
                  }
                  var l3 = d;
                  d._registeredMethods.remove.forEach(function(e6) {
                    void 0 !== e6 && e6.call(l3);
                  });
                }
                if (d._isGlobal) {
                  for (var u3 in v.prototype)
                    try {
                      delete window[u3];
                    } catch (e6) {
                      window[u3] = void 0;
                    }
                  for (var c2 in d)
                    if (d.hasOwnProperty(c2))
                      try {
                        delete window[c2];
                      } catch (e6) {
                        window[c2] = void 0;
                      }
                  v.instance = null;
                }
              }, this._registeredMethods.init.forEach(function(e5) {
                void 0 !== e5 && e5.call(this);
              }, this), this._setupPromisePreloads();
              var u2, c, f = this._createFriendlyGlobalFunctionBinder();
              if (e4)
                e4(this), v._checkForUserDefinedFunctions(this);
              else {
                for (var h in this._isGlobal = true, v.instance = this, v.prototype)
                  "function" == typeof v.prototype[h] ? (u2 = h.substring(2), this._events.hasOwnProperty(u2) || (Math.hasOwnProperty(h) && Math[h] === v.prototype[h] ? f(h, v.prototype[h]) : f(h, v.prototype[h].bind(this)))) : f(h, v.prototype[h]);
                for (var p in this)
                  this.hasOwnProperty(p) && f(p, this[p]);
              }
              for (c in this._events) {
                var m = this["_on".concat(c)];
                m && (m = m.bind(this), window.addEventListener(c, m, { passive: false }), this._events[c] = m);
              }
              function y() {
                d._setProperty("focused", true);
              }
              function g() {
                d._setProperty("focused", false);
              }
              window.addEventListener("focus", y), window.addEventListener("blur", g), this.registerMethod("remove", function() {
                window.removeEventListener("focus", y), window.removeEventListener("blur", g);
              }), "complete" === document.readyState ? this._start() : window.addEventListener("load", this._start.bind(this), false);
            }
            var e3, t3, r2;
            return e3 = v, (t3 = [{ key: "_initializeInstanceVariables", value: function() {
              this._accessibleOutputs = { text: false, grid: false, textLabel: false, gridLabel: false }, this._styles = [], this._bezierDetail = 20, this._curveDetail = 20, this._colorMode = n.RGB, this._colorMaxes = { rgb: [255, 255, 255, 255], hsb: [360, 100, 100, 1], hsl: [360, 100, 100, 1] }, this._downKeys = {};
            } }, { key: "registerPreloadMethod", value: function(e4, t4) {
              v.prototype._preloadMethods.hasOwnProperty(e4) || (v.prototype._preloadMethods[e4] = t4);
            } }, { key: "registerMethod", value: function(e4, t4) {
              var r3 = this || v.prototype;
              r3._registeredMethods.hasOwnProperty(e4) || (r3._registeredMethods[e4] = []), r3._registeredMethods[e4].push(t4);
            } }, { key: "_createFriendlyGlobalFunctionBinder", value: function() {
              var e4 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}, r3 = e4.globalObject || window;
              e4.log || console.log.bind(console);
              return function(e5, t4) {
                v.disableFriendlyErrors, r3[e5] = t4;
              };
            } }]) && s2(e3.prototype, t3), r2 && s2(e3, r2), v;
          }();
          for (l in u.instance = null, u.disableFriendlyErrors = false, n)
            u.prototype[l] = n[l];
          u.VERSION = n.VERSION, u.prototype._preloadMethods = { loadJSON: u.prototype, loadImage: u.prototype, loadStrings: u.prototype, loadXML: u.prototype, loadBytes: u.prototype, loadTable: u.prototype, loadFont: u.prototype, loadModel: u.prototype, loadShader: u.prototype }, u.prototype._registeredMethods = { init: [], pre: [], post: [], remove: [] }, u.prototype._registeredPreloadMethods = {}, r.default = u;
        }, { "./constants": 256, "./shim": 278, "core-js/modules/es.array.for-each": 154, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.get-own-property-names": 174, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.for-each": 229, "core-js/modules/web.dom-collections.iterator": 230 }], 268: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var o = (e2 = e2("./main")) && e2.__esModule ? e2 : { default: e2 };
          o.default.Element = function(e3, t3) {
            this.elt = e3, this._pInst = this._pixelsState = t3, this._events = {}, this.width = this.elt.offsetWidth, this.height = this.elt.offsetHeight;
          }, o.default.Element.prototype.parent = function(e3) {
            return void 0 === e3 ? this.elt.parentNode : ("string" == typeof e3 ? ("#" === e3[0] && (e3 = e3.substring(1)), e3 = document.getElementById(e3)) : e3 instanceof o.default.Element && (e3 = e3.elt), e3.appendChild(this.elt), this);
          }, o.default.Element.prototype.id = function(e3) {
            return void 0 === e3 ? this.elt.id : (this.elt.id = e3, this.width = this.elt.offsetWidth, this.height = this.elt.offsetHeight, this);
          }, o.default.Element.prototype.class = function(e3) {
            return void 0 === e3 ? this.elt.className : (this.elt.className = e3, this);
          }, o.default.Element.prototype.mousePressed = function(t3) {
            return o.default.Element._adjustListener("mousedown", function(e3) {
              return this._pInst._setProperty("mouseIsPressed", true), this._pInst._setMouseButton(e3), t3.call(this, e3);
            }, this), this;
          }, o.default.Element.prototype.doubleClicked = function(e3) {
            return o.default.Element._adjustListener("dblclick", e3, this), this;
          }, o.default.Element.prototype.mouseWheel = function(e3) {
            return o.default.Element._adjustListener("wheel", e3, this), this;
          }, o.default.Element.prototype.mouseReleased = function(e3) {
            return o.default.Element._adjustListener("mouseup", e3, this), this;
          }, o.default.Element.prototype.mouseClicked = function(e3) {
            return o.default.Element._adjustListener("click", e3, this), this;
          }, o.default.Element.prototype.mouseMoved = function(e3) {
            return o.default.Element._adjustListener("mousemove", e3, this), this;
          }, o.default.Element.prototype.mouseOver = function(e3) {
            return o.default.Element._adjustListener("mouseover", e3, this), this;
          }, o.default.Element.prototype.mouseOut = function(e3) {
            return o.default.Element._adjustListener("mouseout", e3, this), this;
          }, o.default.Element.prototype.touchStarted = function(e3) {
            return o.default.Element._adjustListener("touchstart", e3, this), this;
          }, o.default.Element.prototype.touchMoved = function(e3) {
            return o.default.Element._adjustListener("touchmove", e3, this), this;
          }, o.default.Element.prototype.touchEnded = function(e3) {
            return o.default.Element._adjustListener("touchend", e3, this), this;
          }, o.default.Element.prototype.dragOver = function(e3) {
            return o.default.Element._adjustListener("dragover", e3, this), this;
          }, o.default.Element.prototype.dragLeave = function(e3) {
            return o.default.Element._adjustListener("dragleave", e3, this), this;
          }, o.default.Element._adjustListener = function(e3, t3, r2) {
            return false === t3 ? o.default.Element._detachListener(e3, r2) : o.default.Element._attachListener(e3, t3, r2), this;
          }, o.default.Element._attachListener = function(e3, t3, r2) {
            r2._events[e3] && o.default.Element._detachListener(e3, r2);
            t3 = t3.bind(r2);
            r2.elt.addEventListener(e3, t3, false), r2._events[e3] = t3;
          }, o.default.Element._detachListener = function(e3, t3) {
            var r2 = t3._events[e3];
            t3.elt.removeEventListener(e3, r2, false), t3._events[e3] = null;
          }, o.default.Element.prototype._setProperty = function(e3, t3) {
            this[e3] = t3;
          };
          e2 = o.default.Element;
          r.default = e2;
        }, { "./main": 267 }], 269: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.splice"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var s2 = (n = e2("./main")) && n.__esModule ? n : { default: n }, a = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = l();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("./constants"));
          function l() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), l = function() {
              return e3;
            }, e3);
          }
          s2.default.Graphics = function(e3, t3, r2, o2) {
            var n2, r2 = r2 || a.P2D;
            for (n2 in this.canvas = document.createElement("canvas"), (o2._userNode || document.body).appendChild(this.canvas), s2.default.Element.call(this, this.canvas, o2), s2.default.prototype)
              this[n2] || ("function" == typeof s2.default.prototype[n2] ? this[n2] = s2.default.prototype[n2].bind(this) : this[n2] = s2.default.prototype[n2]);
            return s2.default.prototype._initializeInstanceVariables.apply(this), this.width = e3, this.height = t3, this._pixelDensity = o2._pixelDensity, r2 === a.WEBGL ? this._renderer = new s2.default.RendererGL(this.canvas, this, false) : this._renderer = new s2.default.Renderer2D(this.canvas, this, false), o2._elements.push(this), Object.defineProperty(this, "deltaTime", { get: function() {
              return this._pInst.deltaTime;
            } }), this._renderer.resize(e3, t3), this._renderer._applyDefaults(), this;
          }, s2.default.Graphics.prototype = Object.create(s2.default.Element.prototype), s2.default.Graphics.prototype.reset = function() {
            this._renderer.resetMatrix(), this._renderer.isP3D && this._renderer._update();
          }, s2.default.Graphics.prototype.remove = function() {
            this.elt.parentNode && this.elt.parentNode.removeChild(this.elt);
            var e3, t3 = this._pInst._elements.indexOf(this);
            for (e3 in -1 !== t3 && this._pInst._elements.splice(t3, 1), this._events)
              this.elt.removeEventListener(e3, this._events[e3]);
          };
          var n = s2.default.Graphics;
          r.default = n;
        }, { "./constants": 256, "./main": 267, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.splice": 164, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 270: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.object.assign"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.trim"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.object.assign"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.trim"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var a = (n = e2("./main")) && n.__esModule ? n : { default: n }, k = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== l(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = i();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s2;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s2 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s2.get || s2.set) ? Object.defineProperty(o2, r2, s2) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function i() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), i = function() {
              return e3;
            }, e3);
          }
          function l(e3) {
            return (l = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          function u(e3) {
            var t3 = 0, r2 = 0;
            if (e3.offsetParent)
              for (; t3 += e3.offsetLeft, r2 += e3.offsetTop, e3 = e3.offsetParent; )
                ;
            else
              t3 += e3.offsetLeft, r2 += e3.offsetTop;
            return [t3, r2];
          }
          a.default.Renderer = function(e3, t3, r2) {
            a.default.Element.call(this, e3, t3), this.canvas = e3, this._pixelsState = t3, r2 ? (this._isMainCanvas = true, this._pInst._setProperty("_curElement", this), this._pInst._setProperty("canvas", this.canvas), this._pInst._setProperty("width", this.width), this._pInst._setProperty("height", this.height)) : (this.canvas.style.display = "none", this._styles = []), this._textSize = 12, this._textLeading = 15, this._textFont = "sans-serif", this._textStyle = k.NORMAL, this._textAscent = null, this._textDescent = null, this._textAlign = k.LEFT, this._textBaseline = k.BASELINE, this._textWrap = k.WORD, this._rectMode = k.CORNER, this._ellipseMode = k.CENTER, this._curveTightness = 0, this._imageMode = k.CORNER, this._tint = null, this._doStroke = true, this._doFill = true, this._strokeSet = false, this._fillSet = false, this._leadingSet = false;
          }, a.default.Renderer.prototype = Object.create(a.default.Element.prototype), a.default.Renderer.prototype.push = function() {
            return { properties: { _doStroke: this._doStroke, _strokeSet: this._strokeSet, _doFill: this._doFill, _fillSet: this._fillSet, _tint: this._tint, _imageMode: this._imageMode, _rectMode: this._rectMode, _ellipseMode: this._ellipseMode, _textFont: this._textFont, _textLeading: this._textLeading, _leadingSet: this._leadingSet, _textSize: this._textSize, _textAlign: this._textAlign, _textBaseline: this._textBaseline, _textStyle: this._textStyle, _textWrap: this._textWrap } };
          }, a.default.Renderer.prototype.pop = function(e3) {
            e3.properties && Object.assign(this, e3.properties);
          }, a.default.Renderer.prototype.resize = function(e3, t3) {
            this.width = e3, this.height = t3, this.elt.width = e3 * this._pInst._pixelDensity, this.elt.height = t3 * this._pInst._pixelDensity, this.elt.style.width = "".concat(e3, "px"), this.elt.style.height = "".concat(t3, "px"), this._isMainCanvas && (this._pInst._setProperty("width", this.width), this._pInst._setProperty("height", this.height));
          }, a.default.Renderer.prototype.get = function(e3, t3, r2, o2) {
            var n2 = this._pixelsState, s2 = n2._pixelDensity, i2 = this.canvas;
            if (void 0 === e3 && void 0 === t3)
              e3 = t3 = 0, r2 = n2.width, o2 = n2.height;
            else if (e3 *= s2, t3 *= s2, void 0 === r2 && void 0 === o2)
              return e3 < 0 || t3 < 0 || e3 >= i2.width || t3 >= i2.height ? [0, 0, 0, 0] : this._getPixel(e3, t3);
            n2 = new a.default.Image(r2, o2);
            return n2.canvas.getContext("2d").drawImage(i2, e3, t3, r2 * s2, o2 * s2, 0, 0, r2, o2), n2;
          }, a.default.Renderer.prototype.textLeading = function(e3) {
            return "number" == typeof e3 ? (this._setProperty("_leadingSet", true), this._setProperty("_textLeading", e3), this._pInst) : this._textLeading;
          }, a.default.Renderer.prototype.textSize = function(e3) {
            return "number" == typeof e3 ? (this._setProperty("_textSize", e3), this._leadingSet || this._setProperty("_textLeading", e3 * k._DEFAULT_LEADMULT), this._applyTextProperties()) : this._textSize;
          }, a.default.Renderer.prototype.textStyle = function(e3) {
            return e3 ? (e3 !== k.NORMAL && e3 !== k.ITALIC && e3 !== k.BOLD && e3 !== k.BOLDITALIC || this._setProperty("_textStyle", e3), this._applyTextProperties()) : this._textStyle;
          }, a.default.Renderer.prototype.textAscent = function() {
            return null === this._textAscent && this._updateTextMetrics(), this._textAscent;
          }, a.default.Renderer.prototype.textDescent = function() {
            return null === this._textDescent && this._updateTextMetrics(), this._textDescent;
          }, a.default.Renderer.prototype.textAlign = function(e3, t3) {
            return void 0 !== e3 ? (this._setProperty("_textAlign", e3), void 0 !== t3 && this._setProperty("_textBaseline", t3), this._applyTextProperties()) : { horizontal: this._textAlign, vertical: this._textBaseline };
          }, a.default.Renderer.prototype.textWrap = function(e3) {
            return this._setProperty("_textWrap", e3), this._textWrap;
          }, a.default.Renderer.prototype.text = function(e3, t3, r2, o2, n2) {
            var s2, i2, a2, l2, u2 = this._pInst, c = this._textWrap, d = Number.MAX_VALUE, f = r2;
            if ((this._doFill || this._doStroke) && void 0 !== e3) {
              if (s2 = (e3 = (e3 = "string" != typeof e3 ? e3.toString() : e3).replace(/(\t)/g, "  ")).split("\n"), void 0 !== o2) {
                switch (this._rectMode === k.CENTER && (t3 -= o2 / 2), this._textAlign) {
                  case k.CENTER:
                    t3 += o2 / 2;
                    break;
                  case k.RIGHT:
                    t3 += o2;
                }
                if (void 0 !== n2) {
                  this._rectMode === k.CENTER && (r2 -= n2 / 2);
                  var e3 = r2, h = u2.textAscent();
                  switch (this._textBaseline) {
                    case k.BOTTOM:
                      l2 = r2 + n2, r2 = Math.max(l2, r2), f += h;
                      break;
                    case k.CENTER:
                      l2 = r2 + n2 / 2, r2 = Math.max(l2, r2), f += h / 2;
                  }
                  d = r2 + n2 - h, this._textBaseline === k.CENTER && (d = e3 + n2 - h / 2);
                } else {
                  if (this._textBaseline === k.BOTTOM)
                    return console.warn("textAlign(*, BOTTOM) requires x, y, width and height");
                  if (this._textBaseline === k.CENTER)
                    return console.warn("textAlign(*, CENTER) requires x, y, width and height");
                }
                if (c === k.WORD) {
                  for (var p = [], m = 0; m < s2.length; m++) {
                    for (var y = "", g = s2[m].split(" "), v = 0; v < g.length; v++)
                      i2 = "".concat(y + g[v]) + " ", y = o2 < (a2 = this.textWidth(i2)) && 0 < y.length ? (p.push(y), "".concat(g[v]) + " ") : i2;
                    p.push(y);
                  }
                  var b = 0;
                  this._textBaseline === k.CENTER ? b = (p.length - 1) * u2.textLeading() / 2 : this._textBaseline === k.BOTTOM && (b = (p.length - 1) * u2.textLeading());
                  for (var j = 0; j < s2.length; j++) {
                    y = "", g = s2[j].split(" ");
                    for (var _ = 0; _ < g.length; _++)
                      i2 = "".concat(y + g[_]) + " ", o2 < (a2 = this.textWidth(i2)) && 0 < y.length ? (this._renderText(u2, y.trim(), t3, r2 - b, d, f), y = "".concat(g[_]) + " ", r2 += u2.textLeading()) : y = i2;
                    this._renderText(u2, y.trim(), t3, r2 - b, d, f), r2 += u2.textLeading();
                  }
                } else {
                  for (var x = [], w = 0; w < s2.length; w++)
                    for (var S = s2[w].split(y = ""), M = 0; M < S.length; M++)
                      i2 = "".concat(y + S[M]), (a2 = this.textWidth(i2)) <= o2 ? y += S[M] : o2 < a2 && 0 < y.length && (x.push(y), y = "".concat(S[M]));
                  x.push(y);
                  var E = 0;
                  this._textBaseline === k.CENTER ? E = (x.length - 1) * u2.textLeading() / 2 : this._textBaseline === k.BOTTOM && (E = (x.length - 1) * u2.textLeading());
                  for (var T = 0; T < s2.length; T++) {
                    S = s2[T].split(y = "");
                    for (var C = 0; C < S.length; C++)
                      i2 = "".concat(y + S[C]), (a2 = this.textWidth(i2)) <= o2 ? y += S[C] : o2 < a2 && 0 < y.length && (this._renderText(u2, y.trim(), t3, r2 - E, d, f), r2 += u2.textLeading(), y = "".concat(S[C]));
                  }
                  this._renderText(u2, y.trim(), t3, r2 - E, d, f), r2 += u2.textLeading();
                }
              } else {
                var O = 0;
                this._textBaseline === k.CENTER ? O = (s2.length - 1) * u2.textLeading() / 2 : this._textBaseline === k.BOTTOM && (O = (s2.length - 1) * u2.textLeading());
                for (var L = 0; L < s2.length; L++)
                  this._renderText(u2, s2[L], t3, r2 - O, d, f), r2 += u2.textLeading();
              }
              return u2;
            }
          }, a.default.Renderer.prototype._applyDefaults = function() {
            return this;
          }, a.default.Renderer.prototype._isOpenType = function() {
            var e3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : this._textFont;
            return "object" === l(e3) && e3.font && e3.font.supported;
          }, a.default.Renderer.prototype._updateTextMetrics = function() {
            var e3, t3, r2, o2, n2, s2;
            return this._isOpenType() ? (this._setProperty("_textAscent", this._textFont._textAscent()), this._setProperty("_textDescent", this._textFont._textDescent())) : ((e3 = document.createElement("span")).style.fontFamily = this._textFont, e3.style.fontSize = "".concat(this._textSize, "px"), e3.innerHTML = "ABCjgq|", (s2 = document.createElement("div")).style.display = "inline-block", s2.style.width = "1px", s2.style.height = "0px", o2 = ((t3 = document.createElement("div")).appendChild(e3), t3.appendChild(s2), t3.style.height = "0px", t3.style.overflow = "hidden", document.body.appendChild(t3), s2.style.verticalAlign = "baseline", u(s2)), n2 = u(e3), r2 = o2[1] - n2[1], o2 = (s2.style.verticalAlign = "bottom", u(s2)), n2 = u(e3), s2 = o2[1] - n2[1] - r2, document.body.removeChild(t3), this._setProperty("_textAscent", r2), this._setProperty("_textDescent", s2)), this;
          };
          var n = a.default.Renderer;
          r.default = n;
        }, { "../core/constants": 256, "./main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.number.constructor": 169, "core-js/modules/es.object.assign": 172, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.replace": 189, "core-js/modules/es.string.split": 191, "core-js/modules/es.string.trim": 193, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 271: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.number.to-fixed"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.number.to-fixed"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var d = (n = e2("./main")) && n.__esModule ? n : { default: n }, p = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s2;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s2 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s2.get || s2.set) ? Object.defineProperty(o2, r2, s2) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("./constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          e2("./p5.Renderer");
          var h = "rgba(0,0,0,0)", n = (d.default.Renderer2D = function(e3, t3, r2) {
            return d.default.Renderer.call(this, e3, t3, r2), this.drawingContext = this.canvas.getContext("2d"), this._pInst._setProperty("drawingContext", this.drawingContext), this;
          }, d.default.Renderer2D.prototype = Object.create(d.default.Renderer.prototype), d.default.Renderer2D.prototype._applyDefaults = function() {
            this._cachedFillStyle = this._cachedStrokeStyle = void 0, this._cachedBlendMode = p.BLEND, this._setFill(p._DEFAULT_FILL), this._setStroke(p._DEFAULT_STROKE), this.drawingContext.lineCap = p.ROUND, this.drawingContext.font = "normal 12px sans-serif";
          }, d.default.Renderer2D.prototype.resize = function(e3, t3) {
            d.default.Renderer.prototype.resize.call(this, e3, t3), this.drawingContext.scale(this._pInst._pixelDensity, this._pInst._pixelDensity);
          }, d.default.Renderer2D.prototype.background = function() {
            var e3, t3;
            this.drawingContext.save(), this.resetMatrix(), (arguments.length <= 0 ? void 0 : arguments[0]) instanceof d.default.Image ? 0 <= (arguments.length <= 1 ? void 0 : arguments[1]) ? (e3 = arguments.length <= 0 ? void 0 : arguments[0], this.drawingContext.globalAlpha = (arguments.length <= 1 ? void 0 : arguments[1]) / 255, this._pInst.image(e3, 0, 0, this.width, this.height)) : this._pInst.image(arguments.length <= 0 ? void 0 : arguments[0], 0, 0, this.width, this.height) : (e3 = this._getFill(), t3 = (t3 = this._pInst).color.apply(t3, arguments), this._pInst._addAccsOutput() && this._pInst._accsBackground(t3.levels), t3 = t3.toString(), this._setFill(t3), this._isErasing && this.blendMode(this._cachedBlendMode), this.drawingContext.fillRect(0, 0, this.width, this.height), this._setFill(e3), this._isErasing && this._pInst.erase()), this.drawingContext.restore();
          }, d.default.Renderer2D.prototype.clear = function() {
            this.drawingContext.save(), this.resetMatrix(), this.drawingContext.clearRect(0, 0, this.width, this.height), this.drawingContext.restore();
          }, d.default.Renderer2D.prototype.fill = function() {
            var e3 = (e3 = this._pInst).color.apply(e3, arguments);
            this._setFill(e3.toString()), this._pInst._addAccsOutput() && this._pInst._accsCanvasColors("fill", e3.levels);
          }, d.default.Renderer2D.prototype.stroke = function() {
            var e3 = (e3 = this._pInst).color.apply(e3, arguments);
            this._setStroke(e3.toString()), this._pInst._addAccsOutput() && this._pInst._accsCanvasColors("stroke", e3.levels);
          }, d.default.Renderer2D.prototype.erase = function(e3, t3) {
            this._isErasing || (this._cachedFillStyle = this.drawingContext.fillStyle, e3 = this._pInst.color(255, e3).toString(), this.drawingContext.fillStyle = e3, this._cachedStrokeStyle = this.drawingContext.strokeStyle, e3 = this._pInst.color(255, t3).toString(), this.drawingContext.strokeStyle = e3, t3 = this._cachedBlendMode, this.blendMode(p.REMOVE), this._cachedBlendMode = t3, this._isErasing = true);
          }, d.default.Renderer2D.prototype.noErase = function() {
            this._isErasing && (this.drawingContext.fillStyle = this._cachedFillStyle, this.drawingContext.strokeStyle = this._cachedStrokeStyle, this.blendMode(this._cachedBlendMode), this._isErasing = false);
          }, d.default.Renderer2D.prototype.image = function(e3, t3, r2, o2, n2, s2, i2, a2, l) {
            e3.gifProperties && e3._animateGif(this._pInst);
            try {
              var u = (u = this._tint && e3.canvas ? this._getTintedImageCanvas(e3) : u) || e3.canvas || e3.elt, c = 1;
              e3.width && 0 < e3.width && (c = u.width / e3.width), this._isErasing && this.blendMode(this._cachedBlendMode), this.drawingContext.drawImage(u, c * t3, c * r2, c * o2, c * n2, s2, i2, a2, l), this._isErasing && this._pInst.erase();
            } catch (e4) {
              if ("NS_ERROR_NOT_AVAILABLE" !== e4.name)
                throw e4;
            }
          }, d.default.Renderer2D.prototype._getTintedImageCanvas = function(e3) {
            if (!e3.canvas)
              return e3;
            e3.tintCanvas || (e3.tintCanvas = document.createElement("canvas")), e3.tintCanvas.width !== e3.canvas.width && (e3.tintCanvas.width = e3.canvas.width), e3.tintCanvas.height !== e3.canvas.height && (e3.tintCanvas.height = e3.canvas.height);
            var t3 = e3.tintCanvas.getContext("2d");
            return t3.save(), t3.clearRect(0, 0, e3.canvas.width, e3.canvas.height), (this._tint[0] < 255 || this._tint[1] < 255 || this._tint[2] < 255) && (t3.drawImage(e3.canvas, 0, 0), t3.globalCompositeOperation = "luminosity", t3.drawImage(e3.canvas, 0, 0), t3.globalCompositeOperation = "color", t3.drawImage(e3.canvas, 0, 0), t3.globalCompositeOperation = "multiply", t3.fillStyle = "rgb(".concat(this._tint.slice(0, 3).join(", "), ")"), t3.fillRect(0, 0, e3.canvas.width, e3.canvas.height), t3.globalCompositeOperation = "destination-in"), t3.globalAlpha = this._tint[3] / 255, t3.drawImage(e3.canvas, 0, 0), t3.restore(), e3.tintCanvas;
          }, d.default.Renderer2D.prototype.blendMode = function(e3) {
            if (e3 === p.SUBTRACT)
              console.warn("blendMode(SUBTRACT) only works in WEBGL mode.");
            else {
              if (e3 !== p.BLEND && e3 !== p.REMOVE && e3 !== p.DARKEST && e3 !== p.LIGHTEST && e3 !== p.DIFFERENCE && e3 !== p.MULTIPLY && e3 !== p.EXCLUSION && e3 !== p.SCREEN && e3 !== p.REPLACE && e3 !== p.OVERLAY && e3 !== p.HARD_LIGHT && e3 !== p.SOFT_LIGHT && e3 !== p.DODGE && e3 !== p.BURN && e3 !== p.ADD)
                throw new Error("Mode ".concat(e3, " not recognized."));
              this._cachedBlendMode = e3, this.drawingContext.globalCompositeOperation = e3;
            }
          }, d.default.Renderer2D.prototype.blend = function() {
            for (var e3 = this.drawingContext.globalCompositeOperation, t3 = arguments.length, r2 = new Array(t3), o2 = 0; o2 < t3; o2++)
              r2[o2] = arguments[o2];
            var n2 = r2[r2.length - 1], s2 = Array.prototype.slice.call(r2, 0, r2.length - 1);
            this.drawingContext.globalCompositeOperation = n2, d.default.prototype.copy.apply(this, s2), this.drawingContext.globalCompositeOperation = e3;
          }, d.default.Renderer2D.prototype._getPixel = function(e3, t3) {
            e3 = this.drawingContext.getImageData(e3, t3, 1, 1).data;
            return [e3[0], e3[1], e3[2], e3[3]];
          }, d.default.Renderer2D.prototype.loadPixels = function() {
            var e3 = this._pixelsState, t3 = e3._pixelDensity, r2 = this.width * t3, t3 = this.height * t3, r2 = this.drawingContext.getImageData(0, 0, r2, t3);
            e3._setProperty("imageData", r2), e3._setProperty("pixels", r2.data);
          }, d.default.Renderer2D.prototype.set = function(e3, t3, r2) {
            e3 = Math.floor(e3), t3 = Math.floor(t3);
            var o2 = this._pixelsState;
            if (r2 instanceof d.default.Image)
              this.drawingContext.save(), this.drawingContext.setTransform(1, 0, 0, 1, 0, 0), this.drawingContext.scale(o2._pixelDensity, o2._pixelDensity), this.drawingContext.clearRect(e3, t3, r2.width, r2.height), this.drawingContext.drawImage(r2.canvas, e3, t3), this.drawingContext.restore();
            else {
              var n2 = 0, s2 = 0, i2 = 0, a2 = 0, l = 4 * (t3 * o2._pixelDensity * (this.width * o2._pixelDensity) + e3 * o2._pixelDensity);
              if (o2.imageData || o2.loadPixels.call(o2), "number" == typeof r2)
                l < o2.pixels.length && (i2 = s2 = n2 = r2, a2 = 255);
              else if (r2 instanceof Array) {
                if (r2.length < 4)
                  throw new Error("pixel array must be of the form [R, G, B, A]");
                l < o2.pixels.length && (n2 = r2[0], s2 = r2[1], i2 = r2[2], a2 = r2[3]);
              } else
                r2 instanceof d.default.Color && l < o2.pixels.length && (n2 = r2.levels[0], s2 = r2.levels[1], i2 = r2.levels[2], a2 = r2.levels[3]);
              for (var u = 0; u < o2._pixelDensity; u++)
                for (var c = 0; c < o2._pixelDensity; c++)
                  l = 4 * ((t3 * o2._pixelDensity + c) * this.width * o2._pixelDensity + (e3 * o2._pixelDensity + u)), o2.pixels[l] = n2, o2.pixels[l + 1] = s2, o2.pixels[l + 2] = i2, o2.pixels[l + 3] = a2;
            }
          }, d.default.Renderer2D.prototype.updatePixels = function(e3, t3, r2, o2) {
            var n2 = this._pixelsState, s2 = n2._pixelDensity;
            void 0 === e3 && void 0 === t3 && void 0 === r2 && void 0 === o2 && (t3 = e3 = 0, r2 = this.width, o2 = this.height), e3 *= s2, t3 *= s2, r2 *= s2, o2 *= s2, this.gifProperties && (this.gifProperties.frames[this.gifProperties.displayIndex].image = n2.imageData), this.drawingContext.putImageData(n2.imageData, e3, t3, 0, 0, r2, o2);
          }, d.default.Renderer2D.prototype._acuteArcToBezier = function(e3, t3) {
            var r2 = t3 / 2, o2 = Math.cos(r2), n2 = Math.sin(r2), s2 = 1 / Math.tan(r2), r2 = e3 + r2, i2 = Math.cos(r2), r2 = Math.sin(r2), a2 = (4 - o2) / 3, n2 = n2 + (o2 - a2) * s2;
            return { ax: Math.cos(e3).toFixed(7), ay: Math.sin(e3).toFixed(7), bx: (a2 * i2 + n2 * r2).toFixed(7), by: (a2 * r2 - n2 * i2).toFixed(7), cx: (a2 * i2 - n2 * r2).toFixed(7), cy: (a2 * r2 + n2 * i2).toFixed(7), dx: Math.cos(e3 + t3).toFixed(7), dy: Math.sin(e3 + t3).toFixed(7) };
          }, d.default.Renderer2D.prototype.arc = function(r2, o2, e3, t3, n2, s2, i2) {
            var a2, l = this.drawingContext, u = e3 / 2, c = t3 / 2, d2 = [];
            for (r2 += u, o2 += c; 1e-5 <= s2 - n2; )
              a2 = Math.min(s2 - n2, p.HALF_PI), d2.push(this._acuteArcToBezier(n2, a2)), n2 += a2;
            return this._doFill && (l.beginPath(), d2.forEach(function(e4, t4) {
              0 === t4 && l.moveTo(r2 + e4.ax * u, o2 + e4.ay * c), l.bezierCurveTo(r2 + e4.bx * u, o2 + e4.by * c, r2 + e4.cx * u, o2 + e4.cy * c, r2 + e4.dx * u, o2 + e4.dy * c);
            }), i2 !== p.PIE && null != i2 || l.lineTo(r2, o2), l.closePath(), l.fill()), this._doStroke && (l.beginPath(), d2.forEach(function(e4, t4) {
              0 === t4 && l.moveTo(r2 + e4.ax * u, o2 + e4.ay * c), l.bezierCurveTo(r2 + e4.bx * u, o2 + e4.by * c, r2 + e4.cx * u, o2 + e4.cy * c, r2 + e4.dx * u, o2 + e4.dy * c);
            }), i2 === p.PIE ? (l.lineTo(r2, o2), l.closePath()) : i2 === p.CHORD && l.closePath(), l.stroke()), this;
          }, d.default.Renderer2D.prototype.ellipse = function(e3) {
            var t3 = this.drawingContext, r2 = this._doFill, o2 = this._doStroke, n2 = parseFloat(e3[0]), s2 = parseFloat(e3[1]), i2 = parseFloat(e3[2]), e3 = parseFloat(e3[3]);
            if (r2 && !o2) {
              if (this._getFill() === h)
                return this;
            } else if (!r2 && o2 && this._getStroke() === h)
              return this;
            var a2 = i2 / 2 * 0.5522847498, l = e3 / 2 * 0.5522847498, u = n2 + i2, c = s2 + e3, i2 = n2 + i2 / 2, e3 = s2 + e3 / 2;
            t3.beginPath(), t3.moveTo(n2, e3), t3.bezierCurveTo(n2, e3 - l, i2 - a2, s2, i2, s2), t3.bezierCurveTo(i2 + a2, s2, u, e3 - l, u, e3), t3.bezierCurveTo(u, e3 + l, i2 + a2, c, i2, c), t3.bezierCurveTo(i2 - a2, c, n2, e3 + l, n2, e3), r2 && t3.fill(), o2 && t3.stroke();
          }, d.default.Renderer2D.prototype.line = function(e3, t3, r2, o2) {
            var n2 = this.drawingContext;
            return this._doStroke && this._getStroke() !== h && (n2.beginPath(), n2.moveTo(e3, t3), n2.lineTo(r2, o2), n2.stroke()), this;
          }, d.default.Renderer2D.prototype.point = function(e3, t3) {
            var r2, o2, n2 = this.drawingContext;
            return !this._doStroke || this._getStroke() === h ? this : (r2 = this._getStroke(), o2 = this._getFill(), this._setFill(r2), n2.beginPath(), n2.arc(e3, t3, n2.lineWidth / 2, 0, p.TWO_PI, false), n2.fill(), void this._setFill(o2));
          }, d.default.Renderer2D.prototype.quad = function(e3, t3, r2, o2, n2, s2, i2, a2) {
            var l = this.drawingContext, u = this._doFill, c = this._doStroke;
            if (u && !c) {
              if (this._getFill() === h)
                return this;
            } else if (!u && c && this._getStroke() === h)
              return this;
            return l.beginPath(), l.moveTo(e3, t3), l.lineTo(r2, o2), l.lineTo(n2, s2), l.lineTo(i2, a2), l.closePath(), u && l.fill(), c && l.stroke(), this;
          }, d.default.Renderer2D.prototype.rect = function(e3) {
            var t3, r2, o2 = e3[0], n2 = e3[1], s2 = e3[2], i2 = e3[3], a2 = e3[4], l = e3[5], u = e3[6], e3 = e3[7], c = this.drawingContext, d2 = this._doFill, f = this._doStroke;
            if (d2 && !f) {
              if (this._getFill() === h)
                return this;
            } else if (!d2 && f && this._getStroke() === h)
              return this;
            return c.beginPath(), void 0 === a2 ? c.rect(o2, n2, s2, i2) : (void 0 === l && (l = a2), void 0 === u && (u = l), void 0 === e3 && (e3 = u), f = (d2 = Math.abs(s2)) / 2, r2 = (t3 = Math.abs(i2)) / 2, t3 < 2 * (a2 = d2 < 2 * a2 ? f : a2) && (a2 = r2), t3 < 2 * (l = d2 < 2 * l ? f : l) && (l = r2), t3 < 2 * (u = d2 < 2 * u ? f : u) && (u = r2), t3 < 2 * (e3 = d2 < 2 * e3 ? f : e3) && (e3 = r2), c.beginPath(), c.moveTo(o2 + a2, n2), c.arcTo(o2 + s2, n2, o2 + s2, n2 + i2, l), c.arcTo(o2 + s2, n2 + i2, o2, n2 + i2, u), c.arcTo(o2, n2 + i2, o2, n2, e3), c.arcTo(o2, n2, o2 + s2, n2, a2), c.closePath()), this._doFill && c.fill(), this._doStroke && c.stroke(), this;
          }, d.default.Renderer2D.prototype.triangle = function(e3) {
            var t3 = this.drawingContext, r2 = this._doFill, o2 = this._doStroke, n2 = e3[0], s2 = e3[1], i2 = e3[2], a2 = e3[3], l = e3[4], e3 = e3[5];
            if (r2 && !o2) {
              if (this._getFill() === h)
                return this;
            } else if (!r2 && o2 && this._getStroke() === h)
              return this;
            t3.beginPath(), t3.moveTo(n2, s2), t3.lineTo(i2, a2), t3.lineTo(l, e3), t3.closePath(), r2 && t3.fill(), o2 && t3.stroke();
          }, d.default.Renderer2D.prototype.endShape = function(e3, t3, r2, o2, n2, s2, i2) {
            if (0 !== t3.length && (this._doStroke || this._doFill)) {
              var a2, l, u, c = e3 === p.CLOSE, d2 = (c && !s2 && t3.push(t3[0]), t3.length);
              if (!r2 || i2 !== p.POLYGON && null !== i2)
                if (!o2 || i2 !== p.POLYGON && null !== i2)
                  if (!n2 || i2 !== p.POLYGON && null !== i2)
                    if (i2 === p.POINTS)
                      for (l = 0; l < d2; l++)
                        a2 = t3[l], this._doStroke && this._pInst.stroke(a2[6]), this._pInst.point(a2[0], a2[1]);
                    else if (i2 === p.LINES)
                      for (l = 0; l + 1 < d2; l += 2)
                        a2 = t3[l], this._doStroke && this._pInst.stroke(t3[l + 1][6]), this._pInst.line(a2[0], a2[1], t3[l + 1][0], t3[l + 1][1]);
                    else if (i2 === p.TRIANGLES)
                      for (l = 0; l + 2 < d2; l += 3)
                        a2 = t3[l], this.drawingContext.beginPath(), this.drawingContext.moveTo(a2[0], a2[1]), this.drawingContext.lineTo(t3[l + 1][0], t3[l + 1][1]), this.drawingContext.lineTo(t3[l + 2][0], t3[l + 2][1]), this.drawingContext.closePath(), this._doFill && (this._pInst.fill(t3[l + 2][5]), this.drawingContext.fill()), this._doStroke && (this._pInst.stroke(t3[l + 2][6]), this.drawingContext.stroke());
                    else if (i2 === p.TRIANGLE_STRIP)
                      for (l = 0; l + 1 < d2; l++)
                        a2 = t3[l], this.drawingContext.beginPath(), this.drawingContext.moveTo(t3[l + 1][0], t3[l + 1][1]), this.drawingContext.lineTo(a2[0], a2[1]), this._doStroke && this._pInst.stroke(t3[l + 1][6]), this._doFill && this._pInst.fill(t3[l + 1][5]), l + 2 < d2 && (this.drawingContext.lineTo(t3[l + 2][0], t3[l + 2][1]), this._doStroke && this._pInst.stroke(t3[l + 2][6]), this._doFill && this._pInst.fill(t3[l + 2][5])), this._doFillStrokeClose(c);
                    else if (i2 === p.TRIANGLE_FAN) {
                      if (2 < d2) {
                        for (this.drawingContext.beginPath(), l = 2; l < d2; l++)
                          a2 = t3[l], this.drawingContext.moveTo(t3[0][0], t3[0][1]), this.drawingContext.lineTo(t3[l - 1][0], t3[l - 1][1]), this.drawingContext.lineTo(a2[0], a2[1]), this.drawingContext.lineTo(t3[0][0], t3[0][1]), l < d2 - 1 && (this._doFill && a2[5] !== t3[l + 1][5] || this._doStroke && a2[6] !== t3[l + 1][6]) && (this._doFill && (this._pInst.fill(a2[5]), this.drawingContext.fill(), this._pInst.fill(t3[l + 1][5])), this._doStroke && (this._pInst.stroke(a2[6]), this.drawingContext.stroke(), this._pInst.stroke(t3[l + 1][6])), this.drawingContext.closePath(), this.drawingContext.beginPath());
                        this._doFillStrokeClose(c);
                      }
                    } else if (i2 === p.QUADS)
                      for (l = 0; l + 3 < d2; l += 4) {
                        for (a2 = t3[l], this.drawingContext.beginPath(), this.drawingContext.moveTo(a2[0], a2[1]), u = 1; u < 4; u++)
                          this.drawingContext.lineTo(t3[l + u][0], t3[l + u][1]);
                        this.drawingContext.lineTo(a2[0], a2[1]), this._doFill && this._pInst.fill(t3[l + 3][5]), this._doStroke && this._pInst.stroke(t3[l + 3][6]), this._doFillStrokeClose(c);
                      }
                    else if (i2 === p.QUAD_STRIP) {
                      if (3 < d2)
                        for (l = 0; l + 1 < d2; l += 2)
                          a2 = t3[l], this.drawingContext.beginPath(), l + 3 < d2 ? (this.drawingContext.moveTo(t3[l + 2][0], t3[l + 2][1]), this.drawingContext.lineTo(a2[0], a2[1]), this.drawingContext.lineTo(t3[l + 1][0], t3[l + 1][1]), this.drawingContext.lineTo(t3[l + 3][0], t3[l + 3][1]), this._doFill && this._pInst.fill(t3[l + 3][5]), this._doStroke && this._pInst.stroke(t3[l + 3][6])) : (this.drawingContext.moveTo(a2[0], a2[1]), this.drawingContext.lineTo(t3[l + 1][0], t3[l + 1][1])), this._doFillStrokeClose(c);
                    } else {
                      for (this.drawingContext.beginPath(), this.drawingContext.moveTo(t3[0][0], t3[0][1]), l = 1; l < d2; l++)
                        (a2 = t3[l]).isVert && (a2.moveTo ? this.drawingContext.moveTo(a2[0], a2[1]) : this.drawingContext.lineTo(a2[0], a2[1]));
                      this._doFillStrokeClose(c);
                    }
                  else {
                    for (this.drawingContext.beginPath(), l = 0; l < d2; l++)
                      t3[l].isVert ? t3[l].moveTo ? this.drawingContext.moveTo(t3[l][0], t3[l][1]) : this.drawingContext.lineTo(t3[l][0], t3[l][1]) : this.drawingContext.quadraticCurveTo(t3[l][0], t3[l][1], t3[l][2], t3[l][3]);
                    this._doFillStrokeClose(c);
                  }
                else {
                  for (this.drawingContext.beginPath(), l = 0; l < d2; l++)
                    t3[l].isVert ? t3[l].moveTo ? this.drawingContext.moveTo(t3[l][0], t3[l][1]) : this.drawingContext.lineTo(t3[l][0], t3[l][1]) : this.drawingContext.bezierCurveTo(t3[l][0], t3[l][1], t3[l][2], t3[l][3], t3[l][4], t3[l][5]);
                  this._doFillStrokeClose(c);
                }
              else if (3 < d2) {
                var f = [], h2 = 1 - this._curveTightness;
                for (this.drawingContext.beginPath(), this.drawingContext.moveTo(t3[1][0], t3[1][1]), l = 1; l + 2 < d2; l++)
                  a2 = t3[l], f[0] = [a2[0], a2[1]], f[1] = [a2[0] + (h2 * t3[l + 1][0] - h2 * t3[l - 1][0]) / 6, a2[1] + (h2 * t3[l + 1][1] - h2 * t3[l - 1][1]) / 6], f[2] = [t3[l + 1][0] + (h2 * t3[l][0] - h2 * t3[l + 2][0]) / 6, t3[l + 1][1] + (h2 * t3[l][1] - h2 * t3[l + 2][1]) / 6], f[3] = [t3[l + 1][0], t3[l + 1][1]], this.drawingContext.bezierCurveTo(f[1][0], f[1][1], f[2][0], f[2][1], f[3][0], f[3][1]);
                c && this.drawingContext.lineTo(t3[l + 1][0], t3[l + 1][1]), this._doFillStrokeClose(c);
              }
              s2 = n2 = o2 = r2 = false, c && t3.pop();
            }
            return this;
          }, d.default.Renderer2D.prototype.strokeCap = function(e3) {
            return e3 !== p.ROUND && e3 !== p.SQUARE && e3 !== p.PROJECT || (this.drawingContext.lineCap = e3), this;
          }, d.default.Renderer2D.prototype.strokeJoin = function(e3) {
            return e3 !== p.ROUND && e3 !== p.BEVEL && e3 !== p.MITER || (this.drawingContext.lineJoin = e3), this;
          }, d.default.Renderer2D.prototype.strokeWeight = function(e3) {
            return this.drawingContext.lineWidth = void 0 === e3 || 0 === e3 ? 1e-4 : e3, this;
          }, d.default.Renderer2D.prototype._getFill = function() {
            return this._cachedFillStyle || (this._cachedFillStyle = this.drawingContext.fillStyle), this._cachedFillStyle;
          }, d.default.Renderer2D.prototype._setFill = function(e3) {
            e3 !== this._cachedFillStyle && (this.drawingContext.fillStyle = e3, this._cachedFillStyle = e3);
          }, d.default.Renderer2D.prototype._getStroke = function() {
            return this._cachedStrokeStyle || (this._cachedStrokeStyle = this.drawingContext.strokeStyle), this._cachedStrokeStyle;
          }, d.default.Renderer2D.prototype._setStroke = function(e3) {
            e3 !== this._cachedStrokeStyle && (this.drawingContext.strokeStyle = e3, this._cachedStrokeStyle = e3);
          }, d.default.Renderer2D.prototype.bezier = function(e3, t3, r2, o2, n2, s2, i2, a2) {
            return this._pInst.beginShape(), this._pInst.vertex(e3, t3), this._pInst.bezierVertex(r2, o2, n2, s2, i2, a2), this._pInst.endShape(), this;
          }, d.default.Renderer2D.prototype.curve = function(e3, t3, r2, o2, n2, s2, i2, a2) {
            return this._pInst.beginShape(), this._pInst.curveVertex(e3, t3), this._pInst.curveVertex(r2, o2), this._pInst.curveVertex(n2, s2), this._pInst.curveVertex(i2, a2), this._pInst.endShape(), this;
          }, d.default.Renderer2D.prototype._doFillStrokeClose = function(e3) {
            e3 && this.drawingContext.closePath(), this._doFill && this.drawingContext.fill(), this._doStroke && this.drawingContext.stroke();
          }, d.default.Renderer2D.prototype.applyMatrix = function(e3, t3, r2, o2, n2, s2) {
            this.drawingContext.transform(e3, t3, r2, o2, n2, s2);
          }, d.default.Renderer2D.prototype.resetMatrix = function() {
            return this.drawingContext.setTransform(1, 0, 0, 1, 0, 0), this.drawingContext.scale(this._pInst._pixelDensity, this._pInst._pixelDensity), this;
          }, d.default.Renderer2D.prototype.rotate = function(e3) {
            this.drawingContext.rotate(e3);
          }, d.default.Renderer2D.prototype.scale = function(e3, t3) {
            return this.drawingContext.scale(e3, t3), this;
          }, d.default.Renderer2D.prototype.translate = function(e3, t3) {
            return e3 instanceof d.default.Vector && (t3 = e3.y, e3 = e3.x), this.drawingContext.translate(e3, t3), this;
          }, d.default.Renderer2D.prototype.text = function(e3, t3, r2, o2, n2) {
            void 0 !== o2 && this.drawingContext.textBaseline === p.BASELINE && (s2 = true, this.drawingContext.textBaseline = p.TOP);
            var s2, o2 = d.default.Renderer.prototype.text.apply(this, arguments);
            return s2 && (this.drawingContext.textBaseline = p.BASELINE), o2;
          }, d.default.Renderer2D.prototype._renderText = function(e3, t3, r2, o2, n2, s2) {
            if (!(o2 < s2 || n2 <= o2))
              return e3.push(), this._isOpenType() ? this._textFont._renderPath(t3, r2, o2, { renderer: this }) : (this._doStroke && this._strokeSet && this.drawingContext.strokeText(t3, r2, o2), this._doFill && (this._fillSet || this._setFill(p._DEFAULT_TEXT_FILL), this.drawingContext.fillText(t3, r2, o2))), e3.pop(), e3;
          }, d.default.Renderer2D.prototype.textWidth = function(e3) {
            return this._isOpenType() ? this._textFont._textWidth(e3, this._textSize) : this.drawingContext.measureText(e3).width;
          }, d.default.Renderer2D.prototype._applyTextProperties = function() {
            var e3, t3 = this._pInst;
            return this._setProperty("_textAscent", null), this._setProperty("_textDescent", null), e3 = this._textFont, this._isOpenType() && (e3 = this._textFont.font.familyName, this._setProperty("_textStyle", this._textFont.font.styleName)), this.drawingContext.font = "".concat(this._textStyle || "normal", " ").concat(this._textSize || 12, "px ").concat(e3 || "sans-serif"), this.drawingContext.textAlign = this._textAlign, this._textBaseline === p.CENTER ? this.drawingContext.textBaseline = p._CTX_MIDDLE : this.drawingContext.textBaseline = this._textBaseline, t3;
          }, d.default.Renderer2D.prototype.push = function() {
            return this.drawingContext.save(), d.default.Renderer.prototype.push.apply(this);
          }, d.default.Renderer2D.prototype.pop = function(e3) {
            this.drawingContext.restore(), this._cachedFillStyle = this.drawingContext.fillStyle, this._cachedStrokeStyle = this.drawingContext.strokeStyle, d.default.Renderer.prototype.pop.call(this, e3);
          }, d.default.Renderer2D);
          r.default = n;
        }, { "./constants": 256, "./main": 267, "./p5.Renderer": 270, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.fill": 152, "core-js/modules/es.array.for-each": 154, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.join": 159, "core-js/modules/es.array.slice": 162, "core-js/modules/es.function.name": 165, "core-js/modules/es.number.to-fixed": 171, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 272: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.assign"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.assign"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator");
          var f = (e2 = e2("./main")) && e2.__esModule ? e2 : { default: e2 };
          f.default.prototype._promisePreloads = [];
          function s2() {
            return {};
          }
          var h = !(f.default.prototype.registerPromisePreload = function(e3) {
            f.default.prototype._promisePreloads.push(e3);
          });
          f.default.prototype._setupPromisePreloads = function() {
            var e3 = true, t3 = false, r2 = void 0;
            try {
              for (var o, n = this._promisePreloads[Symbol.iterator](); !(e3 = (o = n.next()).done); e3 = true) {
                var s3 = o.value, i = this, a = s3.method, l = s3.addCallbacks, u = s3.legacyPreloadSetup, c = s3.target || this, d = c[a].bind(c);
                if (c === f.default.prototype) {
                  if (h)
                    continue;
                  i = null, d = c[a];
                }
                c[a] = this._wrapPromisePreload(i, d, l), u && (c[u.method] = this._legacyPreloadGenerator(i, u, c[a]));
              }
            } catch (e4) {
              t3 = true, r2 = e4;
            } finally {
              try {
                e3 || null == n.return || n.return();
              } finally {
                if (t3)
                  throw r2;
              }
            }
            h = true;
          }, f.default.prototype._wrapPromisePreload = function(e3, l, u) {
            var t3 = function() {
              for (var e4 = this, t4 = (this._incrementPreload(), null), r2 = null, o = arguments.length, n = new Array(o), s3 = 0; s3 < o; s3++)
                n[s3] = arguments[s3];
              if (u)
                for (var i = n.length - 1; 0 <= i && !r2 && "function" == typeof n[i]; i--)
                  r2 = t4, t4 = n.pop();
              var a = Promise.resolve(l.apply(this, n));
              return t4 && a.then(t4), r2 && a.catch(r2), a.then(function() {
                return e4._decrementPreload();
              }), a;
            };
            return t3 = e3 ? t3.bind(e3) : t3;
          };
          f.default.prototype._legacyPreloadGenerator = function(e3, t3, o) {
            var n = t3.createBaseObject || s2, t3 = function() {
              var t4 = this, r2 = (this._incrementPreload(), n.apply(this, arguments));
              return o.apply(this, arguments).then(function(e4) {
                Object.assign(r2, e4), t4._decrementPreload();
              }), r2;
            };
            return t3 = e3 ? t3.bind(e3) : t3;
          };
        }, { "./main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.assign": 172, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.promise": 178, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/web.dom-collections.iterator": 230 }], 273: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var a = (n = e2("./main")) && n.__esModule ? n : { default: n }, l = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== u(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = i();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s2;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s2 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s2.get || s2.set) ? Object.defineProperty(o2, r2, s2) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("./constants"));
          function i() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), i = function() {
              return e3;
            }, e3);
          }
          function u(e3) {
            return (u = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("./p5.Graphics"), e2("./p5.Renderer2D"), e2("../webgl/p5.RendererGL");
          var c = "defaultCanvas0", n = (a.default.prototype.createCanvas = function(e3, t3, r2) {
            a.default._validateParameters("createCanvas", arguments);
            var o2, n2, s2, r2 = r2 || l.P2D;
            if (r2 === l.WEBGL)
              (n2 = document.getElementById(c)) && (n2.parentNode.removeChild(n2), o2 = this._renderer, this._elements = this._elements.filter(function(e4) {
                return e4 !== o2;
              })), (n2 = document.createElement("canvas")).id = c, n2.classList.add("p5Canvas");
            else if (this._defaultGraphicsCreated)
              n2 = this.canvas;
            else {
              n2 = document.createElement("canvas");
              for (var i2 = 0; document.getElementById("defaultCanvas".concat(i2)); )
                i2++;
              c = "defaultCanvas".concat(i2), n2.id = c, n2.classList.add("p5Canvas");
            }
            return this._setupDone || (n2.dataset.hidden = true, n2.style.visibility = "hidden"), (this._userNode || (0 === document.getElementsByTagName("main").length && (s2 = document.createElement("main"), document.body.appendChild(s2)), document.getElementsByTagName("main")[0])).appendChild(n2), r2 === l.WEBGL ? (this._setProperty("_renderer", new a.default.RendererGL(n2, this, true)), this._elements.push(this._renderer)) : this._defaultGraphicsCreated || (this._setProperty("_renderer", new a.default.Renderer2D(n2, this, true)), this._defaultGraphicsCreated = true, this._elements.push(this._renderer)), this._renderer.resize(e3, t3), this._renderer._applyDefaults(), this._renderer;
          }, a.default.prototype.resizeCanvas = function(e3, t3, r2) {
            if (a.default._validateParameters("resizeCanvas", arguments), this._renderer) {
              var o2, n2, s2 = {};
              for (o2 in this.drawingContext) {
                var i2 = this.drawingContext[o2];
                "object" !== u(i2) && "function" != typeof i2 && (s2[o2] = i2);
              }
              for (n2 in this._renderer.resize(e3, t3), this.width = e3, this.height = t3, s2)
                try {
                  this.drawingContext[n2] = s2[n2];
                } catch (e4) {
                }
              r2 || this.redraw();
            }
            this._addAccsOutput() && this._updateAccsOutput();
          }, a.default.prototype.noCanvas = function() {
            this.canvas && this.canvas.parentNode.removeChild(this.canvas);
          }, a.default.prototype.createGraphics = function(e3, t3, r2) {
            return a.default._validateParameters("createGraphics", arguments), new a.default.Graphics(e3, t3, r2, this);
          }, a.default.prototype.blendMode = function(e3) {
            a.default._validateParameters("blendMode", arguments), e3 === l.NORMAL && (console.warn("NORMAL has been deprecated for use in blendMode. defaulting to BLEND instead."), e3 = l.BLEND), this._renderer.blendMode(e3);
          }, a.default);
          r.default = n;
        }, { "../webgl/p5.RendererGL": 321, "./constants": 256, "./main": 267, "./p5.Graphics": 269, "./p5.Renderer2D": 271, "core-js/modules/es.array.filter": 153, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 274: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.slice"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var l = n(e2("../main")), a = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = c();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s2;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s2 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s2.get || s2.set) ? Object.defineProperty(o2, r2, s2) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../constants")), u = n(e2("../helpers"));
          function c() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), c = function() {
              return e3;
            }, e3);
          }
          function n(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          e2("../friendly_errors/fes_core"), e2("../friendly_errors/file_errors"), e2("../friendly_errors/validate_params"), l.default.prototype._normalizeArcAngles = function(e3, t3, r2, o2, n2) {
            var s2;
            return e3 -= a.TWO_PI * Math.floor(e3 / a.TWO_PI), t3 -= a.TWO_PI * Math.floor(t3 / a.TWO_PI), s2 = Math.min(Math.abs(e3 - t3), a.TWO_PI - Math.abs(e3 - t3)), n2 && (e3 = e3 <= a.HALF_PI ? Math.atan(r2 / o2 * Math.tan(e3)) : e3 > a.HALF_PI && e3 <= 3 * a.HALF_PI ? Math.atan(r2 / o2 * Math.tan(e3)) + a.PI : Math.atan(r2 / o2 * Math.tan(e3)) + a.TWO_PI, t3 = t3 <= a.HALF_PI ? Math.atan(r2 / o2 * Math.tan(t3)) : t3 > a.HALF_PI && t3 <= 3 * a.HALF_PI ? Math.atan(r2 / o2 * Math.tan(t3)) + a.PI : Math.atan(r2 / o2 * Math.tan(t3)) + a.TWO_PI), t3 < e3 && (t3 += a.TWO_PI), { start: e3, stop: t3, correspondToSamePoint: s2 < 1e-5 };
          }, l.default.prototype.arc = function(e3, t3, r2, o2, n2, s2, i2, a2) {
            return l.default._validateParameters("arc", arguments), (this._renderer._doStroke || this._renderer._doFill) && n2 !== s2 && (n2 = this._toRadians(n2), s2 = this._toRadians(s2), r2 = Math.abs(r2), o2 = Math.abs(o2), e3 = u.default.modeAdjust(e3, t3, r2, o2, this._renderer._ellipseMode), (t3 = this._normalizeArcAngles(n2, s2, e3.w, e3.h, true)).correspondToSamePoint ? this._renderer.ellipse([e3.x, e3.y, e3.w, e3.h, a2]) : (this._renderer.arc(e3.x, e3.y, e3.w, e3.h, t3.start, t3.stop, i2, a2), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("arc", [e3.x, e3.y, e3.w, e3.h, t3.start, t3.stop, i2]))), this;
          }, l.default.prototype.ellipse = function(e3, t3, r2, o2, n2) {
            return l.default._validateParameters("ellipse", arguments), this._renderEllipse.apply(this, arguments);
          }, l.default.prototype.circle = function() {
            l.default._validateParameters("circle", arguments);
            var e3 = Array.prototype.slice.call(arguments, 0, 2);
            return e3.push(arguments[2]), e3.push(arguments[2]), this._renderEllipse.apply(this, e3);
          }, l.default.prototype._renderEllipse = function(e3, t3, r2, o2, n2) {
            return (this._renderer._doStroke || this._renderer._doFill) && (r2 < 0 && (r2 = Math.abs(r2)), void 0 === o2 ? o2 = r2 : o2 < 0 && (o2 = Math.abs(o2)), e3 = u.default.modeAdjust(e3, t3, r2, o2, this._renderer._ellipseMode), this._renderer.ellipse([e3.x, e3.y, e3.w, e3.h, n2]), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("ellipse", [e3.x, e3.y, e3.w, e3.h])), this;
          }, l.default.prototype.line = function() {
            for (var e3, t3 = arguments.length, r2 = new Array(t3), o2 = 0; o2 < t3; o2++)
              r2[o2] = arguments[o2];
            return l.default._validateParameters("line", r2), this._renderer._doStroke && (e3 = this._renderer).line.apply(e3, r2), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("line", r2), this;
          }, l.default.prototype.point = function() {
            for (var e3, t3 = arguments.length, r2 = new Array(t3), o2 = 0; o2 < t3; o2++)
              r2[o2] = arguments[o2];
            return l.default._validateParameters("point", r2), this._renderer._doStroke && (1 === r2.length && r2[0] instanceof l.default.Vector ? this._renderer.point.call(this._renderer, r2[0].x, r2[0].y, r2[0].z) : ((e3 = this._renderer).point.apply(e3, r2), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("point", r2))), this;
          }, l.default.prototype.quad = function() {
            for (var e3, t3 = arguments.length, r2 = new Array(t3), o2 = 0; o2 < t3; o2++)
              r2[o2] = arguments[o2];
            return l.default._validateParameters("quad", r2), (this._renderer._doStroke || this._renderer._doFill) && (this._renderer.isP3D && r2.length <= 12 ? this._renderer.quad.call(this._renderer, r2[0], r2[1], 0, r2[2], r2[3], 0, r2[4], r2[5], 0, r2[6], r2[7], 0, r2[8], r2[9]) : ((e3 = this._renderer).quad.apply(e3, r2), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("quadrilateral", r2))), this;
          }, l.default.prototype.rect = function() {
            return l.default._validateParameters("rect", arguments), this._renderRect.apply(this, arguments);
          }, l.default.prototype.square = function(e3, t3, r2, o2, n2, s2, i2) {
            return l.default._validateParameters("square", arguments), this._renderRect.call(this, e3, t3, r2, r2, o2, n2, s2, i2);
          }, l.default.prototype._renderRect = function() {
            if (this._renderer._doStroke || this._renderer._doFill) {
              3 === arguments.length && (arguments[3] = arguments[2]);
              for (var e3 = u.default.modeAdjust(arguments[0], arguments[1], arguments[2], arguments[3], this._renderer._rectMode), t3 = [e3.x, e3.y, e3.w, e3.h], r2 = 4; r2 < arguments.length; r2++)
                t3[r2] = arguments[r2];
              this._renderer.rect(t3), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("rectangle", [e3.x, e3.y, e3.w, e3.h]);
            }
            return this;
          }, l.default.prototype.triangle = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            return l.default._validateParameters("triangle", t3), (this._renderer._doStroke || this._renderer._doFill) && this._renderer.triangle(t3), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._accsOutput("triangle", t3), this;
          };
          e2 = l.default;
          r.default = e2;
        }, { "../constants": 256, "../friendly_errors/fes_core": 258, "../friendly_errors/file_errors": 259, "../friendly_errors/validate_params": 262, "../helpers": 263, "../main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 275: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (l = e2("../main")) && l.__esModule ? l : { default: l }, s2 = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          n.default.prototype.ellipseMode = function(e3) {
            return n.default._validateParameters("ellipseMode", arguments), e3 !== s2.CORNER && e3 !== s2.CORNERS && e3 !== s2.RADIUS && e3 !== s2.CENTER || (this._renderer._ellipseMode = e3), this;
          }, n.default.prototype.noSmooth = function() {
            return this._renderer.isP3D ? this.setAttributes("antialias", false) : "imageSmoothingEnabled" in this.drawingContext && (this.drawingContext.imageSmoothingEnabled = false), this;
          }, n.default.prototype.rectMode = function(e3) {
            return n.default._validateParameters("rectMode", arguments), e3 !== s2.CORNER && e3 !== s2.CORNERS && e3 !== s2.RADIUS && e3 !== s2.CENTER || (this._renderer._rectMode = e3), this;
          }, n.default.prototype.smooth = function() {
            return this.setAttributes("antialias", true), this._renderer.isP3D || "imageSmoothingEnabled" in this.drawingContext && (this.drawingContext.imageSmoothingEnabled = true), this;
          }, n.default.prototype.strokeCap = function(e3) {
            return n.default._validateParameters("strokeCap", arguments), e3 !== s2.ROUND && e3 !== s2.SQUARE && e3 !== s2.PROJECT || this._renderer.strokeCap(e3), this;
          }, n.default.prototype.strokeJoin = function(e3) {
            return n.default._validateParameters("strokeJoin", arguments), e3 !== s2.ROUND && e3 !== s2.BEVEL && e3 !== s2.MITER || this._renderer.strokeJoin(e3), this;
          }, n.default.prototype.strokeWeight = function(e3) {
            return n.default._validateParameters("strokeWeight", arguments), this._renderer.strokeWeight(e3), this;
          };
          var l = n.default;
          r.default = l;
        }, { "../constants": 256, "../main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 276: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var a = (o = e2("../main")) && o.__esModule ? o : { default: o };
          e2("../friendly_errors/fes_core"), e2("../friendly_errors/file_errors"), e2("../friendly_errors/validate_params"), a.default.prototype.bezier = function() {
            for (var e3, t3 = arguments.length, r2 = new Array(t3), o2 = 0; o2 < t3; o2++)
              r2[o2] = arguments[o2];
            return a.default._validateParameters("bezier", r2), (this._renderer._doStroke || this._renderer._doFill) && (e3 = this._renderer).bezier.apply(e3, r2), this;
          }, a.default.prototype.bezierDetail = function(e3) {
            return a.default._validateParameters("bezierDetail", arguments), this._bezierDetail = e3, this;
          }, a.default.prototype.bezierPoint = function(e3, t3, r2, o2, n) {
            a.default._validateParameters("bezierPoint", arguments);
            var s2 = 1 - n;
            return Math.pow(s2, 3) * e3 + 3 * Math.pow(s2, 2) * n * t3 + 3 * s2 * Math.pow(n, 2) * r2 + Math.pow(n, 3) * o2;
          }, a.default.prototype.bezierTangent = function(e3, t3, r2, o2, n) {
            a.default._validateParameters("bezierTangent", arguments);
            var s2 = 1 - n;
            return 3 * o2 * Math.pow(n, 2) - 3 * r2 * Math.pow(n, 2) + 6 * r2 * s2 * n - 6 * t3 * s2 * n + 3 * t3 * Math.pow(s2, 2) - 3 * e3 * Math.pow(s2, 2);
          }, a.default.prototype.curve = function() {
            for (var e3, t3 = arguments.length, r2 = new Array(t3), o2 = 0; o2 < t3; o2++)
              r2[o2] = arguments[o2];
            return a.default._validateParameters("curve", r2), this._renderer._doStroke && (e3 = this._renderer).curve.apply(e3, r2), this;
          }, a.default.prototype.curveDetail = function(e3) {
            return a.default._validateParameters("curveDetail", arguments), this._curveDetail = e3 < 3 ? 3 : e3, this;
          }, a.default.prototype.curveTightness = function(e3) {
            return a.default._validateParameters("curveTightness", arguments), this._renderer._curveTightness = e3, this;
          }, a.default.prototype.curvePoint = function(e3, t3, r2, o2, n) {
            a.default._validateParameters("curvePoint", arguments);
            var s2 = n * n * n, i = n * n;
            return e3 * (-0.5 * s2 + i - 0.5 * n) + t3 * (1.5 * s2 - 2.5 * i + 1) + r2 * (-1.5 * s2 + 2 * i + 0.5 * n) + o2 * (0.5 * s2 - 0.5 * i);
          }, a.default.prototype.curveTangent = function(e3, t3, r2, o2, n) {
            a.default._validateParameters("curveTangent", arguments);
            var s2 = n * n;
            return e3 * (-3 * s2 / 2 + 2 * n - 0.5) + t3 * (9 * s2 / 2 - 5 * n) + r2 * (-9 * s2 / 2 + 4 * n + 0.5) + o2 * (3 * s2 / 2 - n);
          };
          var o = a.default;
          r.default = o;
        }, { "../friendly_errors/fes_core": 258, "../friendly_errors/file_errors": 259, "../friendly_errors/validate_params": 262, "../main": 267 }], 277: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.slice"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var a = (y = e2("../main")) && y.__esModule ? y : { default: y }, l = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = u();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../constants"));
          function u() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), u = function() {
              return e3;
            }, e3);
          }
          var n = null, c = [], d = [], f = false, s2 = false, h = false, p = false, m = true, y = (a.default.prototype.beginContour = function() {
            return d = [], p = true, this;
          }, a.default.prototype.beginShape = function(e3) {
            var t3;
            return a.default._validateParameters("beginShape", arguments), this._renderer.isP3D ? (t3 = this._renderer).beginShape.apply(t3, arguments) : (n = e3 === l.POINTS || e3 === l.LINES || e3 === l.TRIANGLES || e3 === l.TRIANGLE_FAN || e3 === l.TRIANGLE_STRIP || e3 === l.QUADS || e3 === l.QUAD_STRIP ? e3 : null, c = [], d = []), this;
          }, a.default.prototype.bezierVertex = function() {
            for (var e3, t3 = arguments.length, r2 = new Array(t3), o2 = 0; o2 < t3; o2++)
              r2[o2] = arguments[o2];
            if (a.default._validateParameters("bezierVertex", r2), this._renderer.isP3D)
              (e3 = this._renderer).bezierVertex.apply(e3, r2);
            else if (0 === c.length)
              a.default._friendlyError("vertex() must be used once before calling bezierVertex()", "bezierVertex");
            else {
              f = true;
              for (var n2 = [], s3 = 0; s3 < r2.length; s3++)
                n2[s3] = r2[s3];
              n2.isVert = false, (p ? d : c).push(n2);
            }
            return this;
          }, a.default.prototype.curveVertex = function() {
            for (var e3, t3 = arguments.length, r2 = new Array(t3), o2 = 0; o2 < t3; o2++)
              r2[o2] = arguments[o2];
            return a.default._validateParameters("curveVertex", r2), this._renderer.isP3D ? (e3 = this._renderer).curveVertex.apply(e3, r2) : (s2 = true, this.vertex(r2[0], r2[1])), this;
          }, a.default.prototype.endContour = function() {
            var e3 = d[0].slice();
            e3.isVert = d[0].isVert, e3.moveTo = false, d.push(e3), m && (c.push(c[0]), m = false);
            for (var t3 = 0; t3 < d.length; t3++)
              c.push(d[t3]);
            return this;
          }, a.default.prototype.endShape = function(e3) {
            if (a.default._validateParameters("endShape", arguments), this._renderer.isP3D)
              this._renderer.endShape(e3, s2, f, h, p, n);
            else {
              if (0 === c.length)
                return this;
              if (!this._renderer._doStroke && !this._renderer._doFill)
                return this;
              var t3 = e3 === l.CLOSE;
              t3 && !p && c.push(c[0]), this._renderer.endShape(e3, c, s2, f, h, p, n), m = !(p = h = f = s2 = false), t3 && c.pop();
            }
            return this;
          }, a.default.prototype.quadraticVertex = function() {
            for (var e3, t3 = arguments.length, r2 = new Array(t3), o2 = 0; o2 < t3; o2++)
              r2[o2] = arguments[o2];
            if (a.default._validateParameters("quadraticVertex", r2), this._renderer.isP3D)
              (e3 = this._renderer).quadraticVertex.apply(e3, r2);
            else {
              if (this._contourInited)
                return (e3 = {}).x = r2[0], e3.y = r2[1], e3.x3 = r2[2], e3.y3 = r2[3], e3.type = l.QUADRATIC, this._contourVertices.push(e3), this;
              if (0 < c.length) {
                h = true;
                for (var n2 = [], s3 = 0; s3 < r2.length; s3++)
                  n2[s3] = r2[s3];
                n2.isVert = false, (p ? d : c).push(n2);
              } else
                a.default._friendlyError("vertex() must be used once before calling quadraticVertex()", "quadraticVertex");
            }
            return this;
          }, a.default.prototype.vertex = function(e3, t3, r2, o2, n2) {
            var s3;
            return this._renderer.isP3D ? (s3 = this._renderer).vertex.apply(s3, arguments) : ((s3 = []).isVert = true, s3[0] = e3, s3[1] = t3, s3[2] = 0, s3[3] = 0, s3[4] = 0, s3[5] = this._renderer._getFill(), s3[6] = this._renderer._getStroke(), r2 && (s3.moveTo = r2), (p ? (0 === d.length && (s3.moveTo = true), d) : c).push(s3)), this;
          }, a.default.prototype.normal = function(e3, t3, r2) {
            var o2;
            return this._assert3d("normal"), a.default._validateParameters("normal", arguments), (o2 = this._renderer).normal.apply(o2, arguments), this;
          }, a.default);
          r.default = y;
        }, { "../constants": 256, "../main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 278: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function n(e3) {
            return (n = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          var a, l, u;
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.assign"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.typed-array.uint8-clamped-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.assign"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.typed-array.uint8-clamped-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/web.dom-collections.iterator"), window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(e3, t3) {
            window.setTimeout(e3, 1e3 / 60);
          }, "undefined" == typeof Uint8ClampedArray || Uint8ClampedArray.prototype.slice || Object.defineProperty(Uint8ClampedArray.prototype, "slice", { value: Array.prototype.slice, writable: true, configurable: true, enumerable: false }), Object.assign || (a = Object.keys, e2 = Object.defineProperty, l = "function" == typeof Symbol && "symbol" === n(Symbol()), u = Object.prototype.propertyIsEnumerable, e2(Object, "assign", { value: function(e3, t3) {
            if (null == e3)
              throw new TypeError("target must be an object");
            for (var r2, o2, n2, s2 = Object(e3), i = 1; i < arguments.length; ++i)
              for (r2 = Object(arguments[i]), n2 = a(r2), l && Object.getOwnPropertySymbols && n2.push.apply(n2, Object.getOwnPropertySymbols(r2).filter(function(t4) {
                return function(e4) {
                  return u.call(t4, e4);
                };
              }(r2))), o2 = 0; o2 < n2.length; ++o2)
                s2[n2[o2]] = r2[n2[o2]];
            return s2;
          }, configurable: true, enumerable: false, writable: true }));
        }, { "core-js/modules/es.array.filter": 153, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.assign": 172, "core-js/modules/es.object.keys": 176, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.typed-array.copy-within": 197, "core-js/modules/es.typed-array.every": 198, "core-js/modules/es.typed-array.fill": 199, "core-js/modules/es.typed-array.filter": 200, "core-js/modules/es.typed-array.find": 202, "core-js/modules/es.typed-array.find-index": 201, "core-js/modules/es.typed-array.for-each": 205, "core-js/modules/es.typed-array.includes": 206, "core-js/modules/es.typed-array.index-of": 207, "core-js/modules/es.typed-array.iterator": 210, "core-js/modules/es.typed-array.join": 211, "core-js/modules/es.typed-array.last-index-of": 212, "core-js/modules/es.typed-array.map": 213, "core-js/modules/es.typed-array.reduce": 215, "core-js/modules/es.typed-array.reduce-right": 214, "core-js/modules/es.typed-array.reverse": 216, "core-js/modules/es.typed-array.set": 217, "core-js/modules/es.typed-array.slice": 218, "core-js/modules/es.typed-array.some": 219, "core-js/modules/es.typed-array.sort": 220, "core-js/modules/es.typed-array.subarray": 221, "core-js/modules/es.typed-array.to-locale-string": 222, "core-js/modules/es.typed-array.to-string": 223, "core-js/modules/es.typed-array.uint8-clamped-array": 227, "core-js/modules/web.dom-collections.iterator": 230 }], 279: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.object.assign"), e2("core-js/modules/web.dom-collections.for-each"), e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.object.assign"), e2("core-js/modules/web.dom-collections.for-each"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("./main")) && e2.__esModule ? e2 : { default: e2 };
          e2.default.prototype.noLoop = function() {
            this._loop = false;
          }, e2.default.prototype.loop = function() {
            this._loop || (this._loop = true, this._setupDone && this._draw());
          }, e2.default.prototype.isLooping = function() {
            return this._loop;
          }, e2.default.prototype.push = function() {
            this._styles.push({ props: { _colorMode: this._colorMode }, renderer: this._renderer.push() });
          }, e2.default.prototype.pop = function() {
            var e3 = this._styles.pop();
            e3 ? (this._renderer.pop(e3.renderer), Object.assign(this, e3.props)) : console.warn("pop() was called without matching push()");
          }, e2.default.prototype.redraw = function(e3) {
            if (!this._inUserDraw && this._setupDone) {
              var t3 = parseInt(e3), r2 = ((isNaN(t3) || t3 < 1) && (t3 = 1), this._isGlobal ? window : this);
              if ("function" == typeof r2.draw) {
                void 0 === r2.setup && r2.scale(r2._pixelDensity, r2._pixelDensity);
                for (var o = function(e4) {
                  e4.call(r2);
                }, n = 0; n < t3; n++) {
                  r2.resetMatrix(), (this._accessibleOutputs.grid || this._accessibleOutputs.text) && this._updateAccsOutput(), r2._renderer.isP3D && r2._renderer._update(), r2._setProperty("frameCount", r2.frameCount + 1), r2._registeredMethods.pre.forEach(o), this._inUserDraw = true;
                  try {
                    r2.draw();
                  } finally {
                    this._inUserDraw = false;
                  }
                  r2._registeredMethods.post.forEach(o);
                }
              }
            }
          };
          e2 = e2.default;
          r.default = e2;
        }, { "./main": 267, "core-js/modules/es.array.for-each": 154, "core-js/modules/es.object.assign": 172, "core-js/modules/web.dom-collections.for-each": 229 }], 280: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-prototype-of"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-prototype-of"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (e2 = e2("./main")) && e2.__esModule ? e2 : { default: e2 };
          function o(e3) {
            return function(e4) {
              if (Array.isArray(e4)) {
                for (var t3 = 0, r2 = new Array(e4.length); t3 < e4.length; t3++)
                  r2[t3] = e4[t3];
                return r2;
              }
            }(e3) || function(e4) {
              if (Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4))
                return Array.from(e4);
            }(e3) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance");
            }();
          }
          n.default.prototype.applyMatrix = function() {
            var e3 = arguments[0] instanceof Object.getPrototypeOf(Uint8Array);
            return Array.isArray(arguments[0]) || e3 ? (e3 = this._renderer).applyMatrix.apply(e3, o(arguments[0])) : (e3 = this._renderer).applyMatrix.apply(e3, arguments), this;
          }, n.default.prototype.resetMatrix = function() {
            return this._renderer.resetMatrix(), this;
          }, n.default.prototype.rotate = function(e3, t3) {
            return n.default._validateParameters("rotate", arguments), this._renderer.rotate(this._toRadians(e3), t3), this;
          }, n.default.prototype.rotateX = function(e3) {
            return this._assert3d("rotateX"), n.default._validateParameters("rotateX", arguments), this._renderer.rotateX(this._toRadians(e3)), this;
          }, n.default.prototype.rotateY = function(e3) {
            return this._assert3d("rotateY"), n.default._validateParameters("rotateY", arguments), this._renderer.rotateY(this._toRadians(e3)), this;
          }, n.default.prototype.rotateZ = function(e3) {
            return this._assert3d("rotateZ"), n.default._validateParameters("rotateZ", arguments), this._renderer.rotateZ(this._toRadians(e3)), this;
          }, n.default.prototype.scale = function(e3, t3, r2) {
            var o2;
            return n.default._validateParameters("scale", arguments), e3 instanceof n.default.Vector ? (e3 = (o2 = e3).x, t3 = o2.y, r2 = o2.z) : e3 instanceof Array && (e3 = (o2 = e3)[0], t3 = o2[1], r2 = o2[2] || 1), isNaN(t3) ? t3 = r2 = e3 : isNaN(r2) && (r2 = 1), this._renderer.scale.call(this._renderer, e3, t3, r2), this;
          }, n.default.prototype.shearX = function(e3) {
            n.default._validateParameters("shearX", arguments);
            e3 = this._toRadians(e3);
            return this._renderer.applyMatrix(1, 0, Math.tan(e3), 1, 0, 0), this;
          }, n.default.prototype.shearY = function(e3) {
            n.default._validateParameters("shearY", arguments);
            e3 = this._toRadians(e3);
            return this._renderer.applyMatrix(1, Math.tan(e3), 0, 1, 0, 0), this;
          }, n.default.prototype.translate = function(e3, t3, r2) {
            return n.default._validateParameters("translate", arguments), this._renderer.isP3D ? this._renderer.translate(e3, t3, r2) : this._renderer.translate(e3, t3), this;
          };
          e2 = n.default;
          r.default = e2;
        }, { "./main": 267, "core-js/modules/es.array.from": 155, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-prototype-of": 175, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.typed-array.copy-within": 197, "core-js/modules/es.typed-array.every": 198, "core-js/modules/es.typed-array.fill": 199, "core-js/modules/es.typed-array.filter": 200, "core-js/modules/es.typed-array.find": 202, "core-js/modules/es.typed-array.find-index": 201, "core-js/modules/es.typed-array.for-each": 205, "core-js/modules/es.typed-array.includes": 206, "core-js/modules/es.typed-array.index-of": 207, "core-js/modules/es.typed-array.iterator": 210, "core-js/modules/es.typed-array.join": 211, "core-js/modules/es.typed-array.last-index-of": 212, "core-js/modules/es.typed-array.map": 213, "core-js/modules/es.typed-array.reduce": 215, "core-js/modules/es.typed-array.reduce-right": 214, "core-js/modules/es.typed-array.reverse": 216, "core-js/modules/es.typed-array.set": 217, "core-js/modules/es.typed-array.slice": 218, "core-js/modules/es.typed-array.some": 219, "core-js/modules/es.typed-array.sort": 220, "core-js/modules/es.typed-array.subarray": 221, "core-js/modules/es.typed-array.to-locale-string": 222, "core-js/modules/es.typed-array.to-string": 223, "core-js/modules/es.typed-array.uint8-array": 226, "core-js/modules/web.dom-collections.iterator": 230 }], 281: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.ends-with"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.ends-with"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator");
          var n = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          function s2(e3) {
            return function(e4) {
              if (Array.isArray(e4)) {
                for (var t3 = 0, r2 = new Array(e4.length); t3 < e4.length; t3++)
                  r2[t3] = e4[t3];
                return r2;
              }
            }(e3) || function(e4) {
              if (Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4))
                return Array.from(e4);
            }(e3) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance");
            }();
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          n.default.prototype.storeItem = function(e3, t3) {
            "string" != typeof e3 && console.log("The argument that you passed to storeItem() - ".concat(e3, " is not a string.")), e3.endsWith("p5TypeID") && console.log("The argument that you passed to storeItem() - ".concat(e3, " must not end with 'p5TypeID'.")), void 0 === t3 && console.log("You cannot store undefined variables using storeItem().");
            var r2 = i(t3);
            switch (r2) {
              case "number":
              case "boolean":
                t3 = t3.toString();
                break;
              case "object":
                t3 instanceof n.default.Color ? r2 = "p5.Color" : t3 instanceof n.default.Vector && (r2 = "p5.Vector", t3 = [t3.x, t3.y, t3.z]), t3 = JSON.stringify(t3);
            }
            localStorage.setItem(e3, t3);
            e3 = "".concat(e3, "p5TypeID");
            localStorage.setItem(e3, r2);
          }, n.default.prototype.getItem = function(e3) {
            var t3 = localStorage.getItem(e3), r2 = localStorage.getItem("".concat(e3, "p5TypeID"));
            if (void 0 === r2)
              console.log("Unable to determine type of item stored under ".concat(e3, "in local storage. Did you save the item with something other than setItem()?"));
            else if (null !== t3)
              switch (r2) {
                case "number":
                  t3 = parseFloat(t3);
                  break;
                case "boolean":
                  t3 = "true" === t3;
                  break;
                case "object":
                  t3 = JSON.parse(t3);
                  break;
                case "p5.Color":
                  t3 = JSON.parse(t3), t3 = this.color.apply(this, s2(t3.levels));
                  break;
                case "p5.Vector":
                  t3 = JSON.parse(t3), t3 = this.createVector.apply(this, s2(t3));
              }
            return t3;
          }, n.default.prototype.clearStorage = function() {
            localStorage.clear();
          }, n.default.prototype.removeItem = function(e3) {
            "string" != typeof e3 && console.log("The argument that you passed to removeItem() - ".concat(e3, " is not a string.")), localStorage.removeItem(e3), localStorage.removeItem("".concat(e3, "p5TypeID"));
          };
        }, { "../core/main": 267, "core-js/modules/es.array.from": 155, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.ends-with": 184, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/web.dom-collections.iterator": 230 }], 282: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.string.sub"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.string.sub"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          n.default.prototype.createStringDict = function(e3, t3) {
            return n.default._validateParameters("createStringDict", arguments), new n.default.StringDict(e3, t3);
          }, n.default.prototype.createNumberDict = function(e3, t3) {
            return n.default._validateParameters("createNumberDict", arguments), new n.default.NumberDict(e3, t3);
          }, n.default.TypedDict = function(e3, t3) {
            return e3 instanceof Object ? this.data = e3 : (this.data = {}, this.data[e3] = t3), this;
          }, n.default.TypedDict.prototype.size = function() {
            return Object.keys(this.data).length;
          }, n.default.TypedDict.prototype.hasKey = function(e3) {
            return this.data.hasOwnProperty(e3);
          }, n.default.TypedDict.prototype.get = function(e3) {
            if (this.data.hasOwnProperty(e3))
              return this.data[e3];
            console.log("".concat(e3, " does not exist in this Dictionary"));
          }, n.default.TypedDict.prototype.set = function(e3, t3) {
            this._validate(t3) ? this.data[e3] = t3 : console.log("Those values dont work for this dictionary type.");
          }, n.default.TypedDict.prototype._addObj = function(e3) {
            for (var t3 in e3)
              this.set(t3, e3[t3]);
          }, n.default.TypedDict.prototype.create = function(e3, t3) {
            e3 instanceof Object && void 0 === t3 ? this._addObj(e3) : void 0 !== e3 ? this.set(e3, t3) : console.log("In order to create a new Dictionary entry you must pass an object or a key, value pair");
          }, n.default.TypedDict.prototype.clear = function() {
            this.data = {};
          }, n.default.TypedDict.prototype.remove = function(e3) {
            if (!this.data.hasOwnProperty(e3))
              throw new Error("".concat(e3, " does not exist in this Dictionary"));
            delete this.data[e3];
          }, n.default.TypedDict.prototype.print = function() {
            for (var e3 in this.data)
              console.log("key:".concat(e3, " value:").concat(this.data[e3]));
          }, n.default.TypedDict.prototype.saveTable = function(e3) {
            var t3, r2 = "";
            for (t3 in this.data)
              r2 += "".concat(t3, ",").concat(this.data[t3], "\n");
            var o = new Blob([r2], { type: "text/csv" });
            n.default.prototype.downloadFile(o, e3 || "mycsv", "csv");
          }, n.default.TypedDict.prototype.saveJSON = function(e3, t3) {
            n.default.prototype.saveJSON(this.data, e3, t3);
          }, n.default.TypedDict.prototype._validate = function(e3) {
            return true;
          }, n.default.StringDict = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            n.default.TypedDict.apply(this, t3);
          }, n.default.StringDict.prototype = Object.create(n.default.TypedDict.prototype), n.default.StringDict.prototype._validate = function(e3) {
            return "string" == typeof e3;
          }, n.default.NumberDict = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            n.default.TypedDict.apply(this, t3);
          }, n.default.NumberDict.prototype = Object.create(n.default.TypedDict.prototype), n.default.NumberDict.prototype._validate = function(e3) {
            return "number" == typeof e3;
          }, n.default.NumberDict.prototype.add = function(e3, t3) {
            this.data.hasOwnProperty(e3) ? this.data[e3] += t3 : console.log("The key - ".concat(e3, " does not exist in this dictionary."));
          }, n.default.NumberDict.prototype.sub = function(e3, t3) {
            this.add(e3, -t3);
          }, n.default.NumberDict.prototype.mult = function(e3, t3) {
            this.data.hasOwnProperty(e3) ? this.data[e3] *= t3 : console.log("The key - ".concat(e3, " does not exist in this dictionary."));
          }, n.default.NumberDict.prototype.div = function(e3, t3) {
            this.data.hasOwnProperty(e3) ? this.data[e3] /= t3 : console.log("The key - ".concat(e3, " does not exist in this dictionary."));
          }, n.default.NumberDict.prototype._valueTest = function(e3) {
            if (0 === Object.keys(this.data).length)
              throw new Error("Unable to search for a minimum or maximum value on an empty NumberDict");
            if (1 === Object.keys(this.data).length)
              return this.data[Object.keys(this.data)[0]];
            var t3, r2 = this.data[Object.keys(this.data)[0]];
            for (t3 in this.data)
              this.data[t3] * e3 < r2 * e3 && (r2 = this.data[t3]);
            return r2;
          }, n.default.NumberDict.prototype.minValue = function() {
            return this._valueTest(1);
          }, n.default.NumberDict.prototype.maxValue = function() {
            return this._valueTest(-1);
          }, n.default.NumberDict.prototype._keyTest = function(e3) {
            if (0 === Object.keys(this.data).length)
              throw new Error("Unable to use minValue on an empty NumberDict");
            if (1 === Object.keys(this.data).length)
              return Object.keys(this.data)[0];
            for (var t3 = Object.keys(this.data)[0], r2 = 1; r2 < Object.keys(this.data).length; r2++)
              Object.keys(this.data)[r2] * e3 < t3 * e3 && (t3 = Object.keys(this.data)[r2]);
            return t3;
          }, n.default.NumberDict.prototype.minKey = function() {
            return this._keyTest(1);
          }, n.default.NumberDict.prototype.maxKey = function() {
            return this._keyTest(-1);
          };
          e2 = n.default.TypedDict;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.object.keys": 176, "core-js/modules/es.string.sub": 192 }], 283: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.every"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.trim"), e2("core-js/modules/web.dom-collections.for-each"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/web.url"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.every"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.for-each"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.trim"), e2("core-js/modules/web.dom-collections.for-each"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/web.url"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var h = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          function f(e3) {
            return (f = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          function p(e3, t3, r2) {
            (t3._userNode || document.body).appendChild(e3);
            r2 = new (r2 ? h.default.MediaElement : h.default.Element)(e3, t3);
            return t3._elements.push(r2), r2;
          }
          function n(e3, t3, r2, o2) {
            var n2 = document.createElement(t3), s3 = ("string" == typeof (r2 = r2 || "") && (r2 = [r2]), true), t3 = false, i = void 0;
            try {
              for (var a, l = r2[Symbol.iterator](); !(s3 = (a = l.next()).done); s3 = true) {
                var u = a.value, c = document.createElement("source");
                c.setAttribute("src", u), n2.appendChild(c);
              }
            } catch (e4) {
              t3 = true, i = e4;
            } finally {
              try {
                s3 || null == l.return || l.return();
              } finally {
                if (t3)
                  throw i;
              }
            }
            "function" == typeof o2 && n2.addEventListener("canplaythrough", function e4() {
              o2(), n2.removeEventListener("canplaythrough", e4);
            });
            var d = p(n2, e3, true);
            return d.loadedmetadata = false, n2.addEventListener("loadedmetadata", function() {
              d.width = n2.videoWidth, d.height = n2.videoHeight, 0 === d.elt.width && (d.elt.width = n2.videoWidth), 0 === d.elt.height && (d.elt.height = n2.videoHeight), d.presetPlaybackRate && (d.elt.playbackRate = d.presetPlaybackRate, delete d.presetPlaybackRate), d.loadedmetadata = true;
            }), d;
          }
          h.default.prototype.select = function(e3, t3) {
            h.default._validateParameters("select", arguments);
            t3 = this._getContainer(t3).querySelector(e3);
            return t3 ? this._wrapElement(t3) : null;
          }, h.default.prototype.selectAll = function(e3, t3) {
            h.default._validateParameters("selectAll", arguments);
            var r2 = [], o2 = this._getContainer(t3).querySelectorAll(e3);
            if (o2)
              for (var n2 = 0; n2 < o2.length; n2++) {
                var s3 = this._wrapElement(o2[n2]);
                r2.push(s3);
              }
            return r2;
          }, h.default.prototype._getContainer = function(e3) {
            var t3 = document;
            return "string" == typeof e3 ? t3 = document.querySelector(e3) || document : e3 instanceof h.default.Element ? t3 = e3.elt : e3 instanceof HTMLElement && (t3 = e3), t3;
          }, h.default.prototype._wrapElement = function(e3) {
            var t3, r2 = Array.prototype.slice.call(e3.children);
            return "INPUT" === e3.tagName && "checkbox" === e3.type ? ((t3 = new h.default.Element(e3, this)).checked = function() {
              return 0 === arguments.length ? this.elt.checked : (this.elt.checked = !!arguments[0], this);
            }, t3) : "VIDEO" === e3.tagName || "AUDIO" === e3.tagName ? new h.default.MediaElement(e3, this) : "SELECT" === e3.tagName ? this.createSelect(new h.default.Element(e3, this)) : 0 < r2.length && r2.every(function(e4) {
              return "INPUT" === e4.tagName || "LABEL" === e4.tagName;
            }) ? this.createRadio(new h.default.Element(e3, this)) : new h.default.Element(e3, this);
          }, h.default.prototype.removeElements = function(e3) {
            h.default._validateParameters("removeElements", arguments);
            this._elements.filter(function(e4) {
              return !(e4.elt instanceof HTMLCanvasElement);
            }).map(function(e4) {
              return e4.remove();
            });
          }, h.default.Element.prototype.changed = function(e3) {
            return h.default.Element._adjustListener("change", e3, this), this;
          }, h.default.Element.prototype.input = function(e3) {
            return h.default.Element._adjustListener("input", e3, this), this;
          }, h.default.prototype.createDiv = function() {
            var e3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "", t3 = document.createElement("div");
            return t3.innerHTML = e3, p(t3, this);
          }, h.default.prototype.createP = function() {
            var e3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "", t3 = document.createElement("p");
            return t3.innerHTML = e3, p(t3, this);
          }, h.default.prototype.createSpan = function() {
            var e3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "", t3 = document.createElement("span");
            return t3.innerHTML = e3, p(t3, this);
          }, h.default.prototype.createImg = function() {
            h.default._validateParameters("createImg", arguments);
            var t3, r2 = document.createElement("img"), o2 = arguments;
            return 1 < o2.length && "string" == typeof o2[1] && (r2.alt = o2[1]), 2 < o2.length && "string" == typeof o2[2] && (r2.crossOrigin = o2[2]), r2.src = o2[0], t3 = p(r2, this), r2.addEventListener("load", function() {
              t3.width = r2.offsetWidth || r2.width, t3.height = r2.offsetHeight || r2.height;
              var e3 = o2[o2.length - 1];
              "function" == typeof e3 && e3(t3);
            }), t3;
          }, h.default.prototype.createA = function(e3, t3, r2) {
            h.default._validateParameters("createA", arguments);
            var o2 = document.createElement("a");
            return o2.href = e3, o2.innerHTML = t3, r2 && (o2.target = r2), p(o2, this);
          }, h.default.prototype.createSlider = function(e3, t3, r2, o2) {
            h.default._validateParameters("createSlider", arguments);
            var n2 = document.createElement("input");
            return n2.type = "range", n2.min = e3, n2.max = t3, 0 === o2 ? n2.step = 1e-18 : o2 && (n2.step = o2), "number" == typeof r2 && (n2.value = r2), p(n2, this);
          }, h.default.prototype.createButton = function(e3, t3) {
            h.default._validateParameters("createButton", arguments);
            var r2 = document.createElement("button");
            return r2.innerHTML = e3, t3 && (r2.value = t3), p(r2, this);
          }, h.default.prototype.createCheckbox = function() {
            h.default._validateParameters("createCheckbox", arguments);
            var e3 = document.createElement("div"), t3 = document.createElement("input"), r2 = (t3.type = "checkbox", document.createElement("label")), o2 = (r2.appendChild(t3), e3.appendChild(r2), p(e3, this));
            return o2.checked = function() {
              var e4 = o2.elt.firstElementChild.getElementsByTagName("input")[0];
              if (e4) {
                if (0 === arguments.length)
                  return e4.checked;
                e4.checked = !!arguments[0];
              }
              return o2;
            }, this.value = function(e4) {
              return o2.value = e4, this;
            }, arguments[0] && (o2.value(arguments[0]), (e3 = document.createElement("span")).innerHTML = arguments[0], r2.appendChild(e3)), arguments[1] && (t3.checked = true), o2;
          }, h.default.prototype.createSelect = function() {
            h.default._validateParameters("createSelect", arguments);
            var e3, t3, r2 = arguments[0];
            return r2 instanceof h.default.Element && r2.elt instanceof HTMLSelectElement ? this.elt = (e3 = r2).elt : r2 instanceof HTMLSelectElement ? (e3 = p(r2, this), this.elt = r2) : (t3 = document.createElement("select"), r2 && "boolean" == typeof r2 && t3.setAttribute("multiple", "true"), e3 = p(t3, this), this.elt = t3), e3.option = function(e4, t4) {
              var r3;
              if (void 0 !== e4) {
                for (var o2, n2 = 0; n2 < this.elt.length; n2 += 1)
                  if (this.elt[n2].textContent === e4) {
                    r3 = n2;
                    break;
                  }
                void 0 !== r3 ? false === t4 ? this.elt.remove(r3) : this.elt[r3].value = t4 : ((o2 = document.createElement("option")).textContent = e4, o2.value = void 0 === t4 ? e4 : t4, this.elt.appendChild(o2), this._pInst._elements.push(o2));
              }
            }, e3.selected = function(e4) {
              if (void 0 !== e4) {
                for (var t4 = 0; t4 < this.elt.length; t4 += 1)
                  this.elt[t4].value.toString() === e4.toString() && (this.elt.selectedIndex = t4);
                return this;
              }
              if (this.elt.getAttribute("multiple")) {
                var r3 = [], o2 = true, n2 = false, s3 = void 0;
                try {
                  for (var i, a = this.elt.selectedOptions[Symbol.iterator](); !(o2 = (i = a.next()).done); o2 = true) {
                    var l = i.value;
                    r3.push(l.value);
                  }
                } catch (e5) {
                  n2 = true, s3 = e5;
                } finally {
                  try {
                    o2 || null == a.return || a.return();
                  } finally {
                    if (n2)
                      throw s3;
                  }
                }
                return r3;
              }
              return this.elt.value;
            }, e3.disable = function(e4) {
              if ("string" == typeof e4)
                for (var t4 = 0; t4 < this.elt.length; t4++)
                  this.elt[t4].value.toString() === e4 && (this.elt[t4].disabled = true, this.elt[t4].selected = false);
              else
                this.elt.disabled = true;
              return this;
            }, e3;
          }, h.default.prototype.createRadio = function() {
            function t3(e4) {
              return e4 instanceof HTMLInputElement && "radio" === e4.type;
            }
            function d(e4) {
              return e4 instanceof HTMLLabelElement;
            }
            var f2, e3, r2, o2 = arguments[0];
            o2 instanceof h.default.Element && (o2.elt instanceof HTMLDivElement || o2.elt instanceof HTMLSpanElement) ? (f2 = o2, this.elt = o2.elt) : o2 instanceof HTMLDivElement || o2 instanceof HTMLSpanElement ? (f2 = p(o2, this), e3 = this.elt = o2, "string" == typeof arguments[1] && (r2 = arguments[1])) : ("string" == typeof o2 && (r2 = o2), e3 = document.createElement("div"), f2 = p(e3, this), this.elt = e3), f2._name = r2 || "radioOption";
            return f2._getOptionsArray = function() {
              return Array.from(this.elt.children).filter(function(e4) {
                return t3(e4) || d(e4) && t3(e4.firstElementChild);
              }).map(function(e4) {
                return t3(e4) ? e4 : e4.firstElementChild;
              });
            }, f2.option = function(e4, t4) {
              var r3, o3, n2, s3 = true, i = false, a = void 0;
              try {
                for (var l, u = f2._getOptionsArray()[Symbol.iterator](); !(s3 = (l = u.next()).done); s3 = true) {
                  var c = l.value;
                  if (c.value === e4) {
                    r3 = c;
                    break;
                  }
                }
              } catch (e5) {
                i = true, a = e5;
              } finally {
                try {
                  s3 || null == u.return || u.return();
                } finally {
                  if (i)
                    throw a;
                }
              }
              return void 0 === r3 && ((r3 = document.createElement("input")).setAttribute("type", "radio"), r3.setAttribute("value", e4)), r3.setAttribute("name", f2._name), d(r3.parentElement) ? o3 = r3.parentElement : (o3 = document.createElement("label")).insertAdjacentElement("afterbegin", r3), o3.lastElementChild instanceof HTMLSpanElement ? n2 = o3.lastElementChild : (n2 = document.createElement("span"), r3.insertAdjacentElement("afterend", n2)), n2.innerHTML = void 0 === t4 ? e4 : t4, this.elt.appendChild(o3), r3;
            }, f2.remove = function(e4) {
              var t4 = true, r3 = false, o3 = void 0;
              try {
                for (var n2, s3 = f2._getOptionsArray()[Symbol.iterator](); !(t4 = (n2 = s3.next()).done); t4 = true) {
                  var i = n2.value;
                  if (i.value === e4)
                    return void (d(i.parentElement) ? i.parentElement : i).remove();
                }
              } catch (e5) {
                r3 = true, o3 = e5;
              } finally {
                try {
                  t4 || null == s3.return || s3.return();
                } finally {
                  if (r3)
                    throw o3;
                }
              }
            }, f2.value = function() {
              var e4 = "", t4 = true, r3 = false, o3 = void 0;
              try {
                for (var n2, s3 = f2._getOptionsArray()[Symbol.iterator](); !(t4 = (n2 = s3.next()).done); t4 = true) {
                  var i = n2.value;
                  if (i.checked) {
                    e4 = i.value;
                    break;
                  }
                }
              } catch (e5) {
                r3 = true, o3 = e5;
              } finally {
                try {
                  t4 || null == s3.return || s3.return();
                } finally {
                  if (r3)
                    throw o3;
                }
              }
              return e4;
            }, f2.selected = function(e4) {
              var t4 = null;
              if (void 0 === e4) {
                var r3 = true, o3 = false, n2 = void 0;
                try {
                  for (var s3, i = f2._getOptionsArray()[Symbol.iterator](); !(r3 = (s3 = i.next()).done); r3 = true) {
                    var a = s3.value;
                    if (a.checked) {
                      t4 = a;
                      break;
                    }
                  }
                } catch (e5) {
                  o3 = true, n2 = e5;
                } finally {
                  try {
                    r3 || null == i.return || i.return();
                  } finally {
                    if (o3)
                      throw n2;
                  }
                }
              } else {
                f2._getOptionsArray().forEach(function(e5) {
                  e5.checked = false, e5.removeAttribute("checked");
                });
                var l = true, o3 = false, n2 = void 0;
                try {
                  for (var u, c = f2._getOptionsArray()[Symbol.iterator](); !(l = (u = c.next()).done); l = true) {
                    var d2 = u.value;
                    d2.value === e4 && (d2.setAttribute("checked", true), d2.checked = true, t4 = d2);
                  }
                } catch (e5) {
                  o3 = true, n2 = e5;
                } finally {
                  try {
                    l || null == c.return || c.return();
                  } finally {
                    if (o3)
                      throw n2;
                  }
                }
              }
              return t4;
            }, f2.disable = function() {
              var e4 = !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0], t4 = true, r3 = false, o3 = void 0;
              try {
                for (var n2, s3 = f2._getOptionsArray()[Symbol.iterator](); !(t4 = (n2 = s3.next()).done); t4 = true)
                  n2.value.setAttribute("disabled", e4);
              } catch (e5) {
                r3 = true, o3 = e5;
              } finally {
                try {
                  t4 || null == s3.return || s3.return();
                } finally {
                  if (r3)
                    throw o3;
                }
              }
            }, f2;
          }, h.default.prototype.createColorPicker = function(e3) {
            h.default._validateParameters("createColorPicker", arguments);
            var t3 = document.createElement("input");
            return t3.type = "color", e3 ? e3 instanceof h.default.Color ? t3.value = e3.toString("#rrggbb") : (h.default.prototype._colorMode = "rgb", h.default.prototype._colorMaxes = { rgb: [255, 255, 255, 255], hsb: [360, 100, 100, 1], hsl: [360, 100, 100, 1] }, t3.value = h.default.prototype.color(e3).toString("#rrggbb")) : t3.value = "#000000", (t3 = p(t3, this)).color = function() {
              return e3 && (e3.mode && (h.default.prototype._colorMode = e3.mode), e3.maxes && (h.default.prototype._colorMaxes = e3.maxes)), h.default.prototype.color(this.elt.value);
            }, t3;
          }, h.default.prototype.createInput = function() {
            var e3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "", t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "text", r2 = (h.default._validateParameters("createInput", arguments), document.createElement("input"));
            return r2.setAttribute("value", e3), r2.setAttribute("type", t3), p(r2, this);
          }, h.default.prototype.createFileInput = function(a) {
            var e3, t3 = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
            h.default._validateParameters("createFileInput", arguments);
            if (window.File && window.FileReader && window.FileList && window.Blob)
              return (e3 = document.createElement("input")).setAttribute("type", "file"), t3 && e3.setAttribute("multiple", true), e3.addEventListener("change", function(e4) {
                var t4 = true, r2 = false, o2 = void 0;
                try {
                  for (var n2, s3 = e4.target.files[Symbol.iterator](); !(t4 = (n2 = s3.next()).done); t4 = true) {
                    var i = n2.value;
                    h.default.File._load(i, a);
                  }
                } catch (e5) {
                  r2 = true, o2 = e5;
                } finally {
                  try {
                    t4 || null == s3.return || s3.return();
                  } finally {
                    if (r2)
                      throw o2;
                  }
                }
              }, false), p(e3, this);
            console.log("The File APIs are not fully supported in this browser. Cannot create element.");
          }, h.default.prototype.createVideo = function(e3, t3) {
            return h.default._validateParameters("createVideo", arguments), n(this, "video", e3, t3);
          }, h.default.prototype.createAudio = function(e3, t3) {
            return h.default._validateParameters("createAudio", arguments), n(this, "audio", e3, t3);
          }, h.default.prototype.VIDEO = "video", h.default.prototype.AUDIO = "audio", void 0 === navigator.mediaDevices && (navigator.mediaDevices = {}), void 0 === navigator.mediaDevices.getUserMedia && (navigator.mediaDevices.getUserMedia = function(r2) {
            var o2 = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
            return o2 ? new Promise(function(e3, t3) {
              o2.call(navigator, r2, e3, t3);
            }) : Promise.reject(new Error("getUserMedia is not implemented in this browser"));
          }), h.default.prototype.createCapture = function() {
            if (h.default._validateParameters("createCapture", arguments), !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
              throw new DOMException("getUserMedia not supported in this browser");
            var e3, t3 = true, r2 = true, o2 = true, n2 = false, s3 = void 0;
            try {
              for (var i, a = arguments[Symbol.iterator](); !(o2 = (i = a.next()).done); o2 = true) {
                var l = i.value;
                l === h.default.prototype.VIDEO ? r2 = false : l === h.default.prototype.AUDIO ? t3 = false : "object" === f(l) ? u = l : "function" == typeof l && (e3 = l);
              }
            } catch (e4) {
              n2 = true, s3 = e4;
            } finally {
              try {
                o2 || null == a.return || a.return();
              } finally {
                if (n2)
                  throw s3;
              }
            }
            var u = u || { video: t3, audio: r2 }, c = document.createElement("video"), d = (c.setAttribute("playsinline", ""), navigator.mediaDevices.getUserMedia(u).then(function(t4) {
              try {
                "srcObject" in c ? c.srcObject = t4 : c.src = window.URL.createObjectURL(t4);
              } catch (e4) {
                c.src = t4;
              }
            }, console.log), p(c, this, true));
            return d.loadedmetadata = false, c.addEventListener("loadedmetadata", function() {
              c.play(), c.width ? (d.width = c.width, d.height = c.height) : (d.width = d.elt.width = c.videoWidth, d.height = d.elt.height = c.videoHeight), d.loadedmetadata = true, e3 && e3(c.srcObject);
            }), d;
          }, h.default.prototype.createElement = function(e3, t3) {
            h.default._validateParameters("createElement", arguments);
            e3 = document.createElement(e3);
            return void 0 !== t3 && (e3.innerHTML = t3), p(e3, this);
          }, h.default.Element.prototype.addClass = function(e3) {
            return this.elt.className ? this.hasClass(e3) || (this.elt.className = this.elt.className + " " + e3) : this.elt.className = e3, this;
          }, h.default.Element.prototype.removeClass = function(e3) {
            return this.elt.classList.remove(e3), this;
          }, h.default.Element.prototype.hasClass = function(e3) {
            return this.elt.classList.contains(e3);
          }, h.default.Element.prototype.toggleClass = function(e3) {
            return this.elt.classList.contains(e3) ? this.elt.classList.remove(e3) : this.elt.classList.add(e3), this;
          }, h.default.Element.prototype.child = function(e3) {
            return void 0 === e3 ? this.elt.childNodes : ("string" == typeof e3 ? ("#" === e3[0] && (e3 = e3.substring(1)), e3 = document.getElementById(e3)) : e3 instanceof h.default.Element && (e3 = e3.elt), e3 instanceof HTMLElement && this.elt.appendChild(e3), this);
          }, h.default.Element.prototype.center = function(e3) {
            var t3 = this.elt.style.display, r2 = "none" === this.elt.style.display, o2 = "none" === this.parent().style.display, n2 = { x: this.elt.offsetLeft, y: this.elt.offsetTop }, s3 = (r2 && this.show(), o2 && this.parent().show(), this.elt.style.display = "block", this.position(0, 0), Math.abs(this.parent().offsetWidth - this.elt.offsetWidth)), i = Math.abs(this.parent().offsetHeight - this.elt.offsetHeight);
            return "both" === e3 || void 0 === e3 ? this.position(s3 / 2 + this.parent().offsetLeft, i / 2 + this.parent().offsetTop) : "horizontal" === e3 ? this.position(s3 / 2 + this.parent().offsetLeft, n2.y) : "vertical" === e3 && this.position(n2.x, i / 2 + this.parent().offsetTop), this.style("display", t3), r2 && this.hide(), o2 && this.parent().hide(), this;
          }, h.default.Element.prototype.html = function() {
            return 0 === arguments.length ? this.elt.innerHTML : (arguments[1] ? this.elt.insertAdjacentHTML("beforeend", arguments[0]) : this.elt.innerHTML = arguments[0], this);
          }, h.default.Element.prototype.position = function() {
            return 0 === arguments.length ? { x: this.elt.offsetLeft, y: this.elt.offsetTop } : (this.elt.style.position = "static" !== arguments[2] && "fixed" !== arguments[2] && "relative" !== arguments[2] && "sticky" !== arguments[2] && "initial" !== arguments[2] && "inherit" !== arguments[2] ? "absolute" : arguments[2], this.elt.style.left = arguments[0] + "px", this.elt.style.top = arguments[1] + "px", this.x = arguments[0], this.y = arguments[1], this);
          }, h.default.Element.prototype._translate = function() {
            this.elt.style.position = "absolute";
            var e3 = "";
            return this.elt.style.transform && (e3 = (e3 = this.elt.style.transform.replace(/translate3d\(.*\)/g, "")).replace(/translate[X-Z]?\(.*\)/g, "")), 2 === arguments.length ? this.elt.style.transform = "translate(" + arguments[0] + "px, " + arguments[1] + "px)" : 2 < arguments.length && (this.elt.style.transform = "translate3d(" + arguments[0] + "px," + arguments[1] + "px," + arguments[2] + "px)", this.elt.parentElement.style.perspective = 3 === arguments.length ? "1000px" : arguments[3] + "px"), this.elt.style.transform += e3, this;
          }, h.default.Element.prototype._rotate = function() {
            var e3 = "";
            return this.elt.style.transform && (e3 = (e3 = this.elt.style.transform.replace(/rotate3d\(.*\)/g, "")).replace(/rotate[X-Z]?\(.*\)/g, "")), 1 === arguments.length ? this.elt.style.transform = "rotate(" + arguments[0] + "deg)" : 2 === arguments.length ? this.elt.style.transform = "rotate(" + arguments[0] + "deg, " + arguments[1] + "deg)" : 3 === arguments.length && (this.elt.style.transform = "rotateX(" + arguments[0] + "deg)", this.elt.style.transform += "rotateY(" + arguments[1] + "deg)", this.elt.style.transform += "rotateZ(" + arguments[2] + "deg)"), this.elt.style.transform += e3, this;
          }, h.default.Element.prototype.style = function(e3, t3) {
            if (void 0 === (t3 = t3 instanceof h.default.Color ? "rgba(" + t3.levels[0] + "," + t3.levels[1] + "," + t3.levels[2] + "," + t3.levels[3] / 255 + ")" : t3)) {
              if (-1 === e3.indexOf(":"))
                return window.getComputedStyle(this.elt).getPropertyValue(e3);
              for (var r2 = e3.split(";"), o2 = 0; o2 < r2.length; o2++) {
                var n2 = r2[o2].split(":");
                n2[0] && n2[1] && (this.elt.style[n2[0].trim()] = n2[1].trim());
              }
            } else
              this.elt.style[e3] = t3, "width" !== e3 && "height" !== e3 && "left" !== e3 && "top" !== e3 || (t3 = window.getComputedStyle(this.elt).getPropertyValue(e3).replace(/[^\d.]/g, ""), this[e3] = Math.round(parseFloat(t3, 10)));
            return this;
          }, h.default.Element.prototype.attribute = function(e3, t3) {
            if (null == this.elt.firstChild || "checkbox" !== this.elt.firstChild.type && "radio" !== this.elt.firstChild.type)
              return void 0 === t3 ? this.elt.getAttribute(e3) : (this.elt.setAttribute(e3, t3), this);
            if (void 0 === t3)
              return this.elt.firstChild.getAttribute(e3);
            for (var r2 = 0; r2 < this.elt.childNodes.length; r2++)
              this.elt.childNodes[r2].setAttribute(e3, t3);
          }, h.default.Element.prototype.removeAttribute = function(e3) {
            if (null != this.elt.firstChild && ("checkbox" === this.elt.firstChild.type || "radio" === this.elt.firstChild.type))
              for (var t3 = 0; t3 < this.elt.childNodes.length; t3++)
                this.elt.childNodes[t3].removeAttribute(e3);
            return this.elt.removeAttribute(e3), this;
          }, h.default.Element.prototype.value = function() {
            return 0 < arguments.length ? (this.elt.value = arguments[0], this) : "range" === this.elt.type ? parseFloat(this.elt.value) : this.elt.value;
          }, h.default.Element.prototype.show = function() {
            return this.elt.style.display = "block", this;
          }, h.default.Element.prototype.hide = function() {
            return this.elt.style.display = "none", this;
          }, h.default.Element.prototype.size = function(e3, t3) {
            if (0 === arguments.length)
              return { width: this.elt.offsetWidth, height: this.elt.offsetHeight };
            var r2 = e3, o2 = t3, n2 = h.default.prototype.AUTO;
            if (r2 !== n2 || o2 !== n2) {
              if (r2 === n2 ? r2 = t3 * this.width / this.height : o2 === n2 && (o2 = e3 * this.height / this.width), this.elt instanceof HTMLCanvasElement) {
                var s3, i = {}, a = this.elt.getContext("2d");
                for (s3 in a)
                  i[s3] = a[s3];
                for (s3 in this.elt.setAttribute("width", r2 * this._pInst._pixelDensity), this.elt.setAttribute("height", o2 * this._pInst._pixelDensity), this.elt.style.width = r2 + "px", this.elt.style.height = o2 + "px", this._pInst.scale(this._pInst._pixelDensity, this._pInst._pixelDensity), i)
                  this.elt.getContext("2d")[s3] = i[s3];
              } else
                this.elt.style.width = r2 + "px", this.elt.style.height = o2 + "px", this.elt.width = r2, this.elt.height = o2;
              this.width = this.elt.offsetWidth, this.height = this.elt.offsetHeight, this._pInst && this._pInst._curElement && this._pInst._curElement.elt === this.elt && (this._pInst._setProperty("width", this.elt.offsetWidth), this._pInst._setProperty("height", this.elt.offsetHeight));
            }
            return this;
          }, h.default.Element.prototype.remove = function() {
            this instanceof h.default.MediaElement && (this.stop(), null !== (t3 = this.elt.srcObject) && t3.getTracks().forEach(function(e4) {
              e4.stop();
            }));
            var e3, t3 = this._pInst._elements.indexOf(this);
            for (e3 in -1 !== t3 && this._pInst._elements.splice(t3, 1), this._events)
              this.elt.removeEventListener(e3, this._events[e3]);
            this.elt && this.elt.parentNode && this.elt.parentNode.removeChild(this.elt);
          }, h.default.Element.prototype.drop = function(n2, s3) {
            var e3;
            return window.File && window.FileReader && window.FileList && window.Blob ? (this._dragDisabled || (this._dragDisabled = true, this.elt.addEventListener("dragover", e3 = function(e4) {
              e4.preventDefault();
            }), this.elt.addEventListener("dragleave", e3)), h.default.Element._attachListener("drop", function(e4) {
              e4.preventDefault(), "function" == typeof s3 && s3.call(this, e4);
              for (var t3 = e4.dataTransfer.files, r2 = 0; r2 < t3.length; r2++) {
                var o2 = t3[r2];
                h.default.File._load(o2, n2);
              }
            }, this)) : console.log("The File APIs are not fully supported in this browser."), this;
          }, h.default.MediaElement = function(o2, e3) {
            h.default.Element.call(this, o2, e3);
            var n2 = this;
            this.elt.crossOrigin = "anonymous", this._prevTime = 0, this._cueIDCounter = 0, this._cues = [], (this._pixelsState = this)._pixelDensity = 1, this._modified = false, Object.defineProperty(n2, "src", { get: function() {
              var e4 = n2.elt.children[0].src, t3 = n2.elt.src === window.location.href ? "" : n2.elt.src;
              return e4 === window.location.href ? t3 : e4;
            }, set: function(e4) {
              for (var t3 = 0; t3 < n2.elt.children.length; t3++)
                n2.elt.removeChild(n2.elt.children[t3]);
              var r2 = document.createElement("source");
              r2.src = e4, o2.appendChild(r2), n2.elt.src = e4, n2.modified = true;
            } }), n2._onended = function() {
            }, n2.elt.onended = function() {
              n2._onended(n2);
            };
          }, h.default.MediaElement.prototype = Object.create(h.default.Element.prototype), h.default.MediaElement.prototype.play = function() {
            var e3, t3 = this;
            return this.elt.currentTime === this.elt.duration && (this.elt.currentTime = 0), 1 < this.elt.readyState || this.elt.load(), (e3 = this.elt.play()) && e3.catch && e3.catch(function(e4) {
              "NotAllowedError" === e4.name ? h.default._friendlyAutoplayError(t3.src) : console.error("Media play method encountered an unexpected error", e4);
            }), this;
          }, h.default.MediaElement.prototype.stop = function() {
            return this.elt.pause(), this.elt.currentTime = 0, this;
          }, h.default.MediaElement.prototype.pause = function() {
            return this.elt.pause(), this;
          }, h.default.MediaElement.prototype.loop = function() {
            return this.elt.setAttribute("loop", true), this.play(), this;
          }, h.default.MediaElement.prototype.noLoop = function() {
            return this.elt.removeAttribute("loop"), this;
          }, h.default.MediaElement.prototype._setupAutoplayFailDetection = function() {
            var e3 = this, t3 = setTimeout(function() {
              return h.default._friendlyAutoplayError(e3.src);
            }, 500);
            this.elt.addEventListener("play", function() {
              return clearTimeout(t3);
            }, { passive: true, once: true });
          }, h.default.MediaElement.prototype.autoplay = function(e3) {
            var t3 = this, r2 = this.elt.getAttribute("autoplay");
            return this.elt.setAttribute("autoplay", e3), e3 && !r2 && (e3 = function() {
              return t3._setupAutoplayFailDetection();
            }, 4 === this.elt.readyState ? e3() : this.elt.addEventListener("canplay", e3, { passive: true, once: true })), this;
          }, h.default.MediaElement.prototype.volume = function(e3) {
            if (void 0 === e3)
              return this.elt.volume;
            this.elt.volume = e3;
          }, h.default.MediaElement.prototype.speed = function(e3) {
            if (void 0 === e3)
              return this.presetPlaybackRate || this.elt.playbackRate;
            this.loadedmetadata ? this.elt.playbackRate = e3 : this.presetPlaybackRate = e3;
          }, h.default.MediaElement.prototype.time = function(e3) {
            return void 0 === e3 ? this.elt.currentTime : (this.elt.currentTime = e3, this);
          }, h.default.MediaElement.prototype.duration = function() {
            return this.elt.duration;
          }, h.default.MediaElement.prototype.pixels = [], h.default.MediaElement.prototype._ensureCanvas = function() {
            this.canvas || (this.canvas = document.createElement("canvas"), this.drawingContext = this.canvas.getContext("2d"), this.setModified(true)), this.loadedmetadata && (this.canvas.width !== this.elt.width && (this.canvas.width = this.elt.width, this.canvas.height = this.elt.height, this.width = this.canvas.width, this.height = this.canvas.height), this.drawingContext.drawImage(this.elt, 0, 0, this.canvas.width, this.canvas.height), this.setModified(true));
          }, h.default.MediaElement.prototype.loadPixels = function() {
            return this._ensureCanvas(), h.default.Renderer2D.prototype.loadPixels.apply(this, arguments);
          }, h.default.MediaElement.prototype.updatePixels = function(e3, t3, r2, o2) {
            return this.loadedmetadata && (this._ensureCanvas(), h.default.Renderer2D.prototype.updatePixels.call(this, e3, t3, r2, o2)), this.setModified(true), this;
          }, h.default.MediaElement.prototype.get = function() {
            return this._ensureCanvas(), h.default.Renderer2D.prototype.get.apply(this, arguments);
          }, h.default.MediaElement.prototype._getPixel = function() {
            return this.loadPixels(), h.default.Renderer2D.prototype._getPixel.apply(this, arguments);
          }, h.default.MediaElement.prototype.set = function(e3, t3, r2) {
            this.loadedmetadata && (this._ensureCanvas(), h.default.Renderer2D.prototype.set.call(this, e3, t3, r2), this.setModified(true));
          }, h.default.MediaElement.prototype.copy = function() {
            this._ensureCanvas(), h.default.prototype.copy.apply(this, arguments);
          }, h.default.MediaElement.prototype.mask = function() {
            this.loadPixels(), this.setModified(true), h.default.Image.prototype.mask.apply(this, arguments);
          }, h.default.MediaElement.prototype.isModified = function() {
            return this._modified;
          }, h.default.MediaElement.prototype.setModified = function(e3) {
            this._modified = e3;
          }, h.default.MediaElement.prototype.onended = function(e3) {
            return this._onended = e3, this;
          }, h.default.MediaElement.prototype.connect = function(e3) {
            var t3, r2;
            if ("function" == typeof h.default.prototype.getAudioContext)
              t3 = h.default.prototype.getAudioContext(), r2 = h.default.soundOut.input;
            else
              try {
                r2 = (t3 = e3.context).destination;
              } catch (e4) {
                throw "connect() is meant to be used with Web Audio API or p5.sound.js";
              }
            this.audioSourceNode || (this.audioSourceNode = t3.createMediaElementSource(this.elt), this.audioSourceNode.connect(r2)), e3 ? e3.input ? this.audioSourceNode.connect(e3.input) : this.audioSourceNode.connect(e3) : this.audioSourceNode.connect(r2);
          }, h.default.MediaElement.prototype.disconnect = function() {
            if (!this.audioSourceNode)
              throw "nothing to disconnect";
            this.audioSourceNode.disconnect();
          }, h.default.MediaElement.prototype.showControls = function() {
            this.elt.style["text-align"] = "inherit", this.elt.controls = true;
          }, h.default.MediaElement.prototype.hideControls = function() {
            this.elt.controls = false;
          };
          function s2(e3, t3, r2, o2) {
            this.callback = e3, this.time = t3, this.id = r2, this.val = o2;
          }
          h.default.MediaElement.prototype.addCue = function(e3, t3, r2) {
            var o2 = this._cueIDCounter++, t3 = new s2(t3, e3, o2, r2);
            return this._cues.push(t3), this.elt.ontimeupdate || (this.elt.ontimeupdate = this._onTimeUpdate.bind(this)), o2;
          }, h.default.MediaElement.prototype.removeCue = function(e3) {
            for (var t3 = 0; t3 < this._cues.length; t3++)
              this._cues[t3].id === e3 && (console.log(e3), this._cues.splice(t3, 1));
            0 === this._cues.length && (this.elt.ontimeupdate = null);
          }, h.default.MediaElement.prototype.clearCues = function() {
            this._cues = [], this.elt.ontimeupdate = null;
          }, h.default.MediaElement.prototype._onTimeUpdate = function() {
            for (var e3 = this.time(), t3 = 0; t3 < this._cues.length; t3++) {
              var r2 = this._cues[t3].time, o2 = this._cues[t3].val;
              this._prevTime < r2 && r2 <= e3 && this._cues[t3].callback(o2);
            }
            this._prevTime = e3;
          }, h.default.File = function(e3, t3) {
            this.file = e3, this._pInst = t3;
            t3 = e3.type.split("/");
            this.type = t3[0], this.subtype = t3[1], this.name = e3.name, this.size = e3.size, this.data = void 0;
          }, h.default.File._createLoader = function(o2, n2) {
            var e3 = new FileReader();
            return e3.onload = function(e4) {
              var t3, r2 = new h.default.File(o2);
              "application/json" === r2.file.type ? r2.data = JSON.parse(e4.target.result) : "text/xml" === r2.file.type ? (t3 = new DOMParser().parseFromString(e4.target.result, "text/xml"), r2.data = new h.default.XML(t3.documentElement)) : r2.data = e4.target.result, n2(r2);
            }, e3;
          }, h.default.File._load = function(e3, t3) {
            var r2;
            /^text\//.test(e3.type) || "application/json" === e3.type ? h.default.File._createLoader(e3, t3).readAsText(e3) : /^(video|audio)\//.test(e3.type) ? ((r2 = new h.default.File(e3)).data = URL.createObjectURL(e3), t3(r2)) : h.default.File._createLoader(e3, t3).readAsDataURL(e3);
          };
          e2 = h.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.every": 151, "core-js/modules/es.array.filter": 153, "core-js/modules/es.array.for-each": 154, "core-js/modules/es.array.from": 155, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.map": 161, "core-js/modules/es.array.slice": 162, "core-js/modules/es.array.splice": 164, "core-js/modules/es.function.name": 165, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.promise": 178, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.replace": 189, "core-js/modules/es.string.split": 191, "core-js/modules/es.string.trim": 193, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/web.dom-collections.for-each": 229, "core-js/modules/web.dom-collections.iterator": 230, "core-js/modules/web.url": 232 }], 284: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (y = e2("../core/main")) && y.__esModule ? y : { default: y }, s2 = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          n.default.prototype.deviceOrientation = 1 < window.innerWidth / window.innerHeight ? "landscape" : "portrait", n.default.prototype.accelerationX = 0, n.default.prototype.accelerationY = 0, n.default.prototype.accelerationZ = 0, n.default.prototype.pAccelerationX = 0, n.default.prototype.pAccelerationY = 0, n.default.prototype.pAccelerationZ = 0, n.default.prototype._updatePAccelerations = function() {
            this._setProperty("pAccelerationX", this.accelerationX), this._setProperty("pAccelerationY", this.accelerationY), this._setProperty("pAccelerationZ", this.accelerationZ);
          }, n.default.prototype.rotationX = 0, n.default.prototype.rotationY = 0, n.default.prototype.rotationZ = 0, n.default.prototype.pRotationX = 0, n.default.prototype.pRotationY = 0;
          var l = n.default.prototype.pRotationZ = 0, u = 0, c = 0, d = "clockwise", f = "clockwise", h = "clockwise", p = (n.default.prototype.pRotateDirectionX = void 0, n.default.prototype.pRotateDirectionY = void 0, n.default.prototype.pRotateDirectionZ = void 0, n.default.prototype._updatePRotations = function() {
            this._setProperty("pRotationX", this.rotationX), this._setProperty("pRotationY", this.rotationY), this._setProperty("pRotationZ", this.rotationZ);
          }, n.default.prototype.turnAxis = void 0, 0.5), m = 30, y = (n.default.prototype.setMoveThreshold = function(e3) {
            n.default._validateParameters("setMoveThreshold", arguments), p = e3;
          }, n.default.prototype.setShakeThreshold = function(e3) {
            n.default._validateParameters("setShakeThreshold", arguments), m = e3;
          }, n.default.prototype._ondeviceorientation = function(e3) {
            this._updatePRotations(), this._angleMode === s2.radians && (e3.beta = e3.beta * (_PI / 180), e3.gamma = e3.gamma * (_PI / 180), e3.alpha = e3.alpha * (_PI / 180)), this._setProperty("rotationX", e3.beta), this._setProperty("rotationY", e3.gamma), this._setProperty("rotationZ", e3.alpha), this._handleMotion();
          }, n.default.prototype._ondevicemotion = function(e3) {
            this._updatePAccelerations(), this._setProperty("accelerationX", 2 * e3.acceleration.x), this._setProperty("accelerationY", 2 * e3.acceleration.y), this._setProperty("accelerationZ", 2 * e3.acceleration.z), this._handleMotion();
          }, n.default.prototype._handleMotion = function() {
            90 === window.orientation || -90 === window.orientation ? this._setProperty("deviceOrientation", "landscape") : 0 === window.orientation ? this._setProperty("deviceOrientation", "portrait") : void 0 === window.orientation && this._setProperty("deviceOrientation", "undefined");
            var e3, t3, r2, o2, n2, s3 = this._isGlobal ? window : this;
            "function" == typeof s3.deviceMoved && (Math.abs(this.accelerationX - this.pAccelerationX) > p || Math.abs(this.accelerationY - this.pAccelerationY) > p || Math.abs(this.accelerationZ - this.pAccelerationZ) > p) && s3.deviceMoved(), "function" == typeof s3.deviceTurned && (t3 = this.rotationX + 180, e3 = this.pRotationX + 180, r2 = l + 180, 0 < t3 - e3 && t3 - e3 < 270 || t3 - e3 < -270 ? d = "clockwise" : (t3 - e3 < 0 || 270 < t3 - e3) && (d = "counter-clockwise"), d !== this.pRotateDirectionX && (r2 = t3), 90 < Math.abs(t3 - r2) && Math.abs(t3 - r2) < 270 && (r2 = t3, this._setProperty("turnAxis", "X"), s3.deviceTurned()), this.pRotateDirectionX = d, l = r2 - 180, e3 = this.rotationY + 180, t3 = this.pRotationY + 180, r2 = u + 180, 0 < e3 - t3 && e3 - t3 < 270 || e3 - t3 < -270 ? f = "clockwise" : (e3 - t3 < 0 || 270 < e3 - this.pRotationY) && (f = "counter-clockwise"), f !== this.pRotateDirectionY && (r2 = e3), 90 < Math.abs(e3 - r2) && Math.abs(e3 - r2) < 270 && (r2 = e3, this._setProperty("turnAxis", "Y"), s3.deviceTurned()), this.pRotateDirectionY = f, u = r2 - 180, 0 < this.rotationZ - this.pRotationZ && this.rotationZ - this.pRotationZ < 270 || this.rotationZ - this.pRotationZ < -270 ? h = "clockwise" : (this.rotationZ - this.pRotationZ < 0 || 270 < this.rotationZ - this.pRotationZ) && (h = "counter-clockwise"), h !== this.pRotateDirectionZ && (c = this.rotationZ), 90 < Math.abs(this.rotationZ - c) && Math.abs(this.rotationZ - c) < 270 && (c = this.rotationZ, this._setProperty("turnAxis", "Z"), s3.deviceTurned()), this.pRotateDirectionZ = h, this._setProperty("turnAxis", void 0)), "function" == typeof s3.deviceShaken && (null !== this.pAccelerationX && (o2 = Math.abs(this.accelerationX - this.pAccelerationX), n2 = Math.abs(this.accelerationY - this.pAccelerationY)), m < o2 + n2 && s3.deviceShaken());
          }, n.default);
          r.default = y;
        }, { "../core/constants": 256, "../core/main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 285: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var o = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          o.default.prototype.isKeyPressed = false, o.default.prototype.keyIsPressed = false, o.default.prototype.key = "", o.default.prototype.keyCode = 0, o.default.prototype._onkeydown = function(e3) {
            var t3;
            this._downKeys[e3.which] || (this._setProperty("isKeyPressed", true), this._setProperty("keyIsPressed", true), this._setProperty("keyCode", e3.which), this._downKeys[e3.which] = true, this._setProperty("key", e3.key || String.fromCharCode(e3.which) || e3.which), "function" != typeof (t3 = this._isGlobal ? window : this).keyPressed || e3.charCode || false === t3.keyPressed(e3) && e3.preventDefault());
          }, o.default.prototype._onkeyup = function(e3) {
            this._downKeys[e3.which] = false, this._areDownKeys() || (this._setProperty("isKeyPressed", false), this._setProperty("keyIsPressed", false)), this._setProperty("_lastKeyCodeTyped", null), this._setProperty("key", e3.key || String.fromCharCode(e3.which) || e3.which), this._setProperty("keyCode", e3.which);
            var t3 = this._isGlobal ? window : this;
            "function" == typeof t3.keyReleased && false === t3.keyReleased(e3) && e3.preventDefault();
          }, o.default.prototype._onkeypress = function(e3) {
            var t3;
            e3.which !== this._lastKeyCodeTyped && (this._setProperty("_lastKeyCodeTyped", e3.which), this._setProperty("key", e3.key || String.fromCharCode(e3.which) || e3.which), "function" == typeof (t3 = this._isGlobal ? window : this).keyTyped && false === t3.keyTyped(e3) && e3.preventDefault());
          }, o.default.prototype._onblur = function(e3) {
            this._downKeys = {};
          }, o.default.prototype.keyIsDown = function(e3) {
            return o.default._validateParameters("keyIsDown", arguments), this._downKeys[e3] || false;
          }, o.default.prototype._areDownKeys = function() {
            for (var e3 in this._downKeys)
              if (this._downKeys.hasOwnProperty(e3) && true === this._downKeys[e3])
                return true;
            return false;
          };
          e2 = o.default;
          r.default = e2;
        }, { "../core/main": 267 }], 286: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.string.includes"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (n = e2("../core/main")) && n.__esModule ? n : { default: n }, s2 = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          n.default.prototype.movedX = 0, n.default.prototype.movedY = 0, n.default.prototype._hasMouseInteracted = false, n.default.prototype.mouseX = 0, n.default.prototype.mouseY = 0, n.default.prototype.pmouseX = 0, n.default.prototype.pmouseY = 0, n.default.prototype.winMouseX = 0, n.default.prototype.winMouseY = 0, n.default.prototype.pwinMouseX = 0, n.default.prototype.pwinMouseY = 0, n.default.prototype.mouseButton = 0, n.default.prototype.mouseIsPressed = false, n.default.prototype._updateNextMouseCoords = function(e3) {
            var t3, r2, o2, n2, s3;
            null !== this._curElement && (!e3.touches || 0 < e3.touches.length) && (t3 = this._curElement.elt, r2 = this.width, o2 = this.height, (n2 = e3) && !n2.clientX && (n2.touches ? n2 = n2.touches[0] : n2.changedTouches && (n2 = n2.changedTouches[0])), s3 = t3.getBoundingClientRect(), r2 = t3.scrollWidth / r2 || 1, t3 = t3.scrollHeight / o2 || 1, o2 = { x: (n2.clientX - s3.left) / r2, y: (n2.clientY - s3.top) / t3, winX: n2.clientX, winY: n2.clientY, id: n2.identifier }, this._setProperty("movedX", e3.movementX), this._setProperty("movedY", e3.movementY), this._setProperty("mouseX", o2.x), this._setProperty("mouseY", o2.y), this._setProperty("winMouseX", o2.winX), this._setProperty("winMouseY", o2.winY)), this._hasMouseInteracted || (this._updateMouseCoords(), this._setProperty("_hasMouseInteracted", true));
          }, n.default.prototype._updateMouseCoords = function() {
            this._setProperty("pmouseX", this.mouseX), this._setProperty("pmouseY", this.mouseY), this._setProperty("pwinMouseX", this.winMouseX), this._setProperty("pwinMouseY", this.winMouseY), this._setProperty("_pmouseWheelDeltaY", this._mouseWheelDeltaY);
          }, n.default.prototype._setMouseButton = function(e3) {
            1 === e3.button ? this._setProperty("mouseButton", s2.CENTER) : 2 === e3.button ? this._setProperty("mouseButton", s2.RIGHT) : this._setProperty("mouseButton", s2.LEFT);
          }, n.default.prototype._onmousemove = function(e3) {
            var t3 = this._isGlobal ? window : this;
            this._updateNextMouseCoords(e3), this.mouseIsPressed ? "function" == typeof t3.mouseDragged ? false === t3.mouseDragged(e3) && e3.preventDefault() : "function" == typeof t3.touchMoved && false === t3.touchMoved(e3) && e3.preventDefault() : "function" == typeof t3.mouseMoved && false === t3.mouseMoved(e3) && e3.preventDefault();
          }, n.default.prototype._onmousedown = function(e3) {
            var t3 = this._isGlobal ? window : this;
            this._setProperty("mouseIsPressed", true), this._setMouseButton(e3), this._updateNextMouseCoords(e3), "function" == typeof t3.mousePressed ? false === t3.mousePressed(e3) && e3.preventDefault() : navigator.userAgent.toLowerCase().includes("safari") && "function" == typeof t3.touchStarted && false === t3.touchStarted(e3) && e3.preventDefault();
          }, n.default.prototype._onmouseup = function(e3) {
            var t3 = this._isGlobal ? window : this;
            this._setProperty("mouseIsPressed", false), "function" == typeof t3.mouseReleased ? false === t3.mouseReleased(e3) && e3.preventDefault() : "function" == typeof t3.touchEnded && false === t3.touchEnded(e3) && e3.preventDefault();
          }, n.default.prototype._ondragend = n.default.prototype._onmouseup, n.default.prototype._ondragover = n.default.prototype._onmousemove, n.default.prototype._onclick = function(e3) {
            var t3 = this._isGlobal ? window : this;
            "function" == typeof t3.mouseClicked && false === t3.mouseClicked(e3) && e3.preventDefault();
          }, n.default.prototype._ondblclick = function(e3) {
            var t3 = this._isGlobal ? window : this;
            "function" == typeof t3.doubleClicked && false === t3.doubleClicked(e3) && e3.preventDefault();
          }, n.default.prototype._mouseWheelDeltaY = 0, n.default.prototype._pmouseWheelDeltaY = 0, n.default.prototype._onwheel = function(e3) {
            var t3 = this._isGlobal ? window : this;
            this._setProperty("_mouseWheelDeltaY", e3.deltaY), "function" == typeof t3.mouseWheel && (e3.delta = e3.deltaY, false === t3.mouseWheel(e3) && e3.preventDefault());
          }, n.default.prototype.requestPointerLock = function() {
            var e3 = this._curElement.elt;
            return e3.requestPointerLock = e3.requestPointerLock || e3.mozRequestPointerLock, e3.requestPointerLock ? (e3.requestPointerLock(), true) : (console.log("requestPointerLock is not implemented in this browser"), false);
          }, n.default.prototype.exitPointerLock = function() {
            document.exitPointerLock();
          };
          e2 = n.default;
          r.default = e2;
        }, { "../core/constants": 256, "../core/main": 267, "core-js/modules/es.array.includes": 156, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.includes": 185, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 287: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.string.includes"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          e2.default.prototype.touches = [], e2.default.prototype._updateTouchCoords = function(e3) {
            if (null !== this._curElement) {
              for (var t3 = [], r2 = 0; r2 < e3.touches.length; r2++)
                t3[r2] = function(e4, t4, r3, o) {
                  var n = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, s2 = e4.getBoundingClientRect(), t4 = e4.scrollWidth / t4 || 1, e4 = e4.scrollHeight / r3 || 1, r3 = o.touches[n] || o.changedTouches[n];
                  return { x: (r3.clientX - s2.left) / t4, y: (r3.clientY - s2.top) / e4, winX: r3.clientX, winY: r3.clientY, id: r3.identifier };
                }(this._curElement.elt, this.width, this.height, e3, r2);
              this._setProperty("touches", t3);
            }
          }, e2.default.prototype._ontouchstart = function(e3) {
            var t3 = this._isGlobal ? window : this;
            this._setProperty("mouseIsPressed", true), this._updateTouchCoords(e3), this._updateNextMouseCoords(e3), this._updateMouseCoords(), "function" == typeof t3.touchStarted ? false === t3.touchStarted(e3) && e3.preventDefault() : navigator.userAgent.toLowerCase().includes("safari") && "function" == typeof t3.mousePressed && false === t3.mousePressed(e3) && e3.preventDefault();
          }, e2.default.prototype._ontouchmove = function(e3) {
            var t3 = this._isGlobal ? window : this;
            this._updateTouchCoords(e3), this._updateNextMouseCoords(e3), "function" == typeof t3.touchMoved ? false === t3.touchMoved(e3) && e3.preventDefault() : "function" == typeof t3.mouseDragged && false === t3.mouseDragged(e3) && e3.preventDefault();
          }, e2.default.prototype._ontouchend = function(e3) {
            this._setProperty("mouseIsPressed", false), this._updateTouchCoords(e3), this._updateNextMouseCoords(e3);
            var t3 = this._isGlobal ? window : this;
            "function" == typeof t3.touchEnded ? false === t3.touchEnded(e3) && e3.preventDefault() : "function" == typeof t3.mouseReleased && false === t3.mouseReleased(e3) && e3.preventDefault();
          };
          e2 = e2.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.includes": 156, "core-js/modules/es.string.includes": 185 }], 288: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.typed-array.int32-array"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.typed-array.int32-array"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var N, F, B, G, V = {};
          function o(e3, I) {
            for (var t3, r2, o2, n, s2, i, a, l, u, c, d = V._toPixels(e3), f = e3.width, h = e3.height, p = f * h, m = new Int32Array(p), y = 0; y < p; y++)
              m[y] = V._getARGB(d, y);
            var g, v, b, j = new Int32Array(p), _ = new Int32Array(p), x = new Int32Array(p), w = new Int32Array(p), S = 0, M = 3.5 * I | 0;
            if (N !== (M = M < 1 ? 1 : M < 248 ? M : 248)) {
              F = 1 + (N = M) << 1, B = new Int32Array(F), G = new Array(F);
              for (var E, T, C = 0; C < F; C++)
                G[C] = new Int32Array(256);
              for (var O = 1, L = M - 1; O < M; O++) {
                B[M + O] = B[L] = T = L * L;
                for (var k = G[M + O], U = G[L--], A = 0; A < 256; A++)
                  k[A] = U[A] = T * A;
              }
              E = B[M] = M * M, k = G[M];
              for (var P = 0; P < 256; P++)
                k[P] = E * P;
            }
            for (v = 0; v < h; v++) {
              for (g = 0; g < f; g++) {
                if (n = o2 = r2 = s2 = t3 = 0, (i = g - N) < 0)
                  c = -i, i = 0;
                else {
                  if (f <= i)
                    break;
                  c = 0;
                }
                for (b = c; b < F && !(f <= i); b++) {
                  var R, D = m[i + S];
                  s2 += (R = G[b])[(-16777216 & D) >>> 24], r2 += R[(16711680 & D) >> 16], o2 += R[(65280 & D) >> 8], n += R[255 & D], t3 += B[b], i++;
                }
                j[a = S + g] = s2 / t3, _[a] = r2 / t3, x[a] = o2 / t3, w[a] = n / t3;
              }
              S += f;
            }
            for (u = (l = -N) * f, v = S = 0; v < h; v++) {
              for (g = 0; g < f; g++) {
                if (l < (n = o2 = r2 = s2 = t3 = 0))
                  c = a = -l, i = g;
                else {
                  if (h <= l)
                    break;
                  c = 0, a = l, i = g + u;
                }
                for (b = c; b < F && !(h <= a); b++)
                  s2 += (R = G[b])[j[i]], r2 += R[_[i]], o2 += R[x[i]], n += R[w[i]], t3 += B[b], a++, i += f;
                m[g + S] = s2 / t3 << 24 | r2 / t3 << 16 | o2 / t3 << 8 | n / t3;
              }
              S += f, u += f, l++;
            }
            V._setPixels(d, m);
          }
          V._toPixels = function(e3) {
            var t3, r2;
            return e3 instanceof ImageData ? e3.data : e3.getContext("2d") ? e3.getContext("2d").getImageData(0, 0, e3.width, e3.height).data : e3.getContext("webgl") ? (r2 = (t3 = e3.getContext("webgl")).drawingBufferWidth * t3.drawingBufferHeight * 4, r2 = new Uint8Array(r2), t3.readPixels(0, 0, e3.width, e3.height, t3.RGBA, t3.UNSIGNED_BYTE, r2), r2) : void 0;
          }, V._getARGB = function(e3, t3) {
            t3 *= 4;
            return e3[3 + t3] << 24 & 4278190080 | e3[t3] << 16 & 16711680 | e3[1 + t3] << 8 & 65280 | 255 & e3[2 + t3];
          }, V._setPixels = function(e3, t3) {
            for (var r2, o2 = 0, n = e3.length; o2 < n; o2++)
              e3[0 + (r2 = 4 * o2)] = (16711680 & t3[o2]) >>> 16, e3[1 + r2] = (65280 & t3[o2]) >>> 8, e3[2 + r2] = 255 & t3[o2], e3[3 + r2] = (4278190080 & t3[o2]) >>> 24;
          }, V._toImageData = function(e3) {
            return e3 instanceof ImageData ? e3 : e3.getContext("2d").getImageData(0, 0, e3.width, e3.height);
          }, V._createImageData = function(e3, t3) {
            return V._tmpCanvas = document.createElement("canvas"), V._tmpCtx = V._tmpCanvas.getContext("2d"), this._tmpCtx.createImageData(e3, t3);
          }, V.apply = function(e3, t3, r2) {
            var o2 = e3.getContext("2d"), n = o2.getImageData(0, 0, e3.width, e3.height), t3 = t3(n, r2);
            t3 instanceof ImageData ? o2.putImageData(t3, 0, 0, 0, 0, e3.width, e3.height) : o2.putImageData(n, 0, 0, 0, 0, e3.width, e3.height);
          }, V.threshold = function(e3, t3) {
            for (var r2 = V._toPixels(e3), o2 = (void 0 === t3 && (t3 = 0.5), Math.floor(255 * t3)), n = 0; n < r2.length; n += 4) {
              var s2 = void 0, s2 = o2 <= 0.2126 * r2[n] + 0.7152 * r2[n + 1] + 0.0722 * r2[n + 2] ? 255 : 0;
              r2[n] = r2[n + 1] = r2[n + 2] = s2;
            }
          }, V.gray = function(e3) {
            for (var t3 = V._toPixels(e3), r2 = 0; r2 < t3.length; r2 += 4) {
              var o2 = t3[r2], n = t3[r2 + 1], s2 = t3[r2 + 2];
              t3[r2] = t3[r2 + 1] = t3[r2 + 2] = 0.2126 * o2 + 0.7152 * n + 0.0722 * s2;
            }
          }, V.opaque = function(e3) {
            for (var t3 = V._toPixels(e3), r2 = 0; r2 < t3.length; r2 += 4)
              t3[r2 + 3] = 255;
            return t3;
          }, V.invert = function(e3) {
            for (var t3 = V._toPixels(e3), r2 = 0; r2 < t3.length; r2 += 4)
              t3[r2] = 255 - t3[r2], t3[r2 + 1] = 255 - t3[r2 + 1], t3[r2 + 2] = 255 - t3[r2 + 2];
          }, V.posterize = function(e3, t3) {
            var r2 = V._toPixels(e3);
            if (t3 < 2 || 255 < t3)
              throw new Error("Level must be greater than 2 and less than 255 for posterize");
            for (var o2 = t3 - 1, n = 0; n < r2.length; n += 4) {
              var s2 = r2[n], i = r2[n + 1], a = r2[n + 2];
              r2[n] = 255 * (s2 * t3 >> 8) / o2, r2[n + 1] = 255 * (i * t3 >> 8) / o2, r2[n + 2] = 255 * (a * t3 >> 8) / o2;
            }
          }, V.dilate = function(e3) {
            for (var t3, r2, o2, n, s2, i, a, l, u, c = V._toPixels(e3), d = 0, f = c.length ? c.length / 4 : 0, h = new Int32Array(f); d < f; )
              for (r2 = (t3 = d) + e3.width; d < r2; )
                n = o2 = V._getARGB(c, d), (u = d - 1) < t3 && (u = d), r2 <= (l = d + 1) && (l = d), (s2 = d - e3.width) < 0 && (s2 = 0), f <= (i = d + e3.width) && (i = d), s2 = V._getARGB(c, s2), u = V._getARGB(c, u), i = V._getARGB(c, i), (n = 77 * (n >> 16 & 255) + 151 * (n >> 8 & 255) + 28 * (255 & n)) < (a = 77 * (u >> 16 & 255) + 151 * (u >> 8 & 255) + 28 * (255 & u)) && (o2 = u, n = a), n < (a = 77 * ((u = V._getARGB(c, l)) >> 16 & 255) + 151 * (u >> 8 & 255) + 28 * (255 & u)) && (o2 = u, n = a), n < (l = 77 * (s2 >> 16 & 255) + 151 * (s2 >> 8 & 255) + 28 * (255 & s2)) && (o2 = s2, n = l), n < (u = 77 * (i >> 16 & 255) + 151 * (i >> 8 & 255) + 28 * (255 & i)) && (o2 = i, n = u), h[d++] = o2;
            V._setPixels(c, h);
          }, V.erode = function(e3) {
            for (var t3, r2, o2, n, s2, i, a, l, u, c = V._toPixels(e3), d = 0, f = c.length ? c.length / 4 : 0, h = new Int32Array(f); d < f; )
              for (r2 = (t3 = d) + e3.width; d < r2; )
                n = o2 = V._getARGB(c, d), (u = d - 1) < t3 && (u = d), r2 <= (l = d + 1) && (l = d), (s2 = d - e3.width) < 0 && (s2 = 0), f <= (i = d + e3.width) && (i = d), s2 = V._getARGB(c, s2), u = V._getARGB(c, u), i = V._getARGB(c, i), (a = 77 * (u >> 16 & 255) + 151 * (u >> 8 & 255) + 28 * (255 & u)) < (n = 77 * (n >> 16 & 255) + 151 * (n >> 8 & 255) + 28 * (255 & n)) && (o2 = u, n = a), (a = 77 * ((u = V._getARGB(c, l)) >> 16 & 255) + 151 * (u >> 8 & 255) + 28 * (255 & u)) < n && (o2 = u, n = a), (l = 77 * (s2 >> 16 & 255) + 151 * (s2 >> 8 & 255) + 28 * (255 & s2)) < n && (o2 = s2, n = l), (u = 77 * (i >> 16 & 255) + 151 * (i >> 8 & 255) + 28 * (255 & i)) < n && (o2 = i, n = u), h[d++] = o2;
            V._setPixels(c, h);
          }, V.blur = function(e3, t3) {
            o(e3, t3);
          }, r.default = V;
        }, { "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.typed-array.copy-within": 197, "core-js/modules/es.typed-array.every": 198, "core-js/modules/es.typed-array.fill": 199, "core-js/modules/es.typed-array.filter": 200, "core-js/modules/es.typed-array.find": 202, "core-js/modules/es.typed-array.find-index": 201, "core-js/modules/es.typed-array.for-each": 205, "core-js/modules/es.typed-array.includes": 206, "core-js/modules/es.typed-array.index-of": 207, "core-js/modules/es.typed-array.int32-array": 209, "core-js/modules/es.typed-array.iterator": 210, "core-js/modules/es.typed-array.join": 211, "core-js/modules/es.typed-array.last-index-of": 212, "core-js/modules/es.typed-array.map": 213, "core-js/modules/es.typed-array.reduce": 215, "core-js/modules/es.typed-array.reduce-right": 214, "core-js/modules/es.typed-array.reverse": 216, "core-js/modules/es.typed-array.set": 217, "core-js/modules/es.typed-array.slice": 218, "core-js/modules/es.typed-array.some": 219, "core-js/modules/es.typed-array.sort": 220, "core-js/modules/es.typed-array.subarray": 221, "core-js/modules/es.typed-array.to-locale-string": 222, "core-js/modules/es.typed-array.to-string": 223, "core-js/modules/es.typed-array.uint8-array": 226 }], 289: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.set"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.uint32-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.set"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.uint32-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var O = o(e2("../core/main")), L = o(e2("omggif"));
          function o(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          function k(e3) {
            return function(e4) {
              if (Array.isArray(e4)) {
                for (var t3 = 0, r2 = new Array(e4.length); t3 < e4.length; t3++)
                  r2[t3] = e4[t3];
                return r2;
              }
            }(e3) || function(e4) {
              if (Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4))
                return Array.from(e4);
            }(e3) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance");
            }();
          }
          O.default.prototype.createImage = function(e3, t3) {
            return O.default._validateParameters("createImage", arguments), new O.default.Image(e3, t3);
          }, O.default.prototype.saveCanvas = function() {
            O.default._validateParameters("saveCanvas", arguments);
            var e3, t3, r2, o2, n = [].slice.call(arguments);
            switch (arguments[0] instanceof HTMLCanvasElement ? (e3 = arguments[0], n.shift()) : arguments[0] instanceof O.default.Element ? (e3 = arguments[0].elt, n.shift()) : e3 = this._curElement && this._curElement.elt, 1 <= n.length && (t3 = n[0]), r2 = (r2 = 2 <= n.length ? n[1] : r2) || O.default.prototype._checkFileExtension(t3, r2)[1] || "png") {
              default:
                o2 = "image/png";
                break;
              case "jpeg":
              case "jpg":
                o2 = "image/jpeg";
            }
            e3.toBlob(function(e4) {
              O.default.prototype.downloadFile(e4, t3, r2);
            }, o2);
          }, O.default.prototype.encodeAndDownloadGif = function(h, e3) {
            for (var p = h.gifProperties, t3 = p.loopLimit, r2 = (1 === t3 ? t3 = null : null === t3 && (t3 = 0), new Uint8Array(h.width * h.height * p.numFrames)), m = [], o2 = {}, n = 0; n < p.numFrames; n++) {
              for (var s2 = /* @__PURE__ */ new Set(), i = p.frames[n].image.data, a = i.length, l = new Uint32Array(h.width * h.height), u = 0, c = 0; u < a; u += 4, c++) {
                var d = i[u + 0] << 16 | i[u + 1] << 8 | i[u + 2] << 0;
                s2.add(d), l[c] = d;
              }
              var f = k(s2).sort().toString();
              void 0 === o2[f] ? o2[f] = { freq: 1, frames: [n] } : (o2[f].freq += 1, o2[f].frames.push(n)), m.push(l);
            }
            for (var y = [], g = Object.keys(o2).sort(function(e4, t4) {
              return o2[t4].freq - o2[e4].freq;
            }), v = g[0].split(",").map(function(e4) {
              return parseInt(e4);
            }), y = y.concat(o2[v].frames), b = new Set(v), j = 1; j < g.length; j++) {
              var _ = g[j].split(",").map(function(e4) {
                return parseInt(e4);
              }).filter(function(e4) {
                return !b.has(e4);
              });
              if (v.length + _.length <= 256) {
                for (var x = 0; x < _.length; x++)
                  v.push(_[x]), b.add(_[x]);
                y = y.concat(o2[g[j]].frames);
              }
            }
            y = new Set(y);
            for (var w = {}, S = 0; S < v.length; S++)
              w[v[S]] || (w[v[S]] = S);
            for (var M = 1; M < v.length; )
              M <<= 1;
            v.length = M;
            for (var t3 = { loop: t3, palette: new Uint32Array(v) }, E = new L.default.GifWriter(r2, h.width, h.height, t3), T = {}, C = 0; C < p.numFrames; C++)
              !function(e4) {
                for (var t4 = !y.has(e4), r3 = t4 ? [] : v, o3 = new Uint8Array(h.width * h.height), n2 = {}, s3 = /* @__PURE__ */ new Set(), i2 = 0; i2 < m[e4].length; i2++) {
                  var a2 = m[e4][i2];
                  t4 ? (void 0 === n2[a2] && (n2[a2] = r3.length, r3.push(a2)), o3[i2] = n2[a2]) : o3[i2] = w[a2], 0 < e4 && m[e4 - 1][i2] !== a2 && s3.add(a2);
                }
                var l2 = {}, u2 = r3.filter(function(e5) {
                  return !s3.has(e5);
                });
                if (0 < u2.length) {
                  var u2 = u2[0], c2 = (t4 ? n2 : w)[u2];
                  if (0 < e4) {
                    for (var d2 = 0; d2 < m[e4].length; d2++)
                      m[e4 - 1][d2] === m[e4][d2] && (o3[d2] = c2);
                    l2.transparent = c2, T.frameOpts.disposal = 1;
                  }
                }
                if (l2.delay = p.frames[e4].delay / 10, t4) {
                  for (var f2 = 1; f2 < r3.length; )
                    f2 <<= 1;
                  r3.length = f2, l2.palette = new Uint32Array(r3);
                }
                0 < e4 && E.addFrame(0, 0, h.width, h.height, T.pixelPaletteIndex, T.frameOpts), T = { pixelPaletteIndex: o3, frameOpts: l2 };
              }(C);
            T.frameOpts.disposal = 1, E.addFrame(0, 0, h.width, h.height, T.pixelPaletteIndex, T.frameOpts);
            t3 = new Blob([r2.slice(0, E.end())], { type: "image/gif" });
            O.default.prototype.downloadFile(t3, e3, "gif");
          }, O.default.prototype.saveFrames = function(e3, t3, r2, o2, i) {
            O.default._validateParameters("saveFrames", arguments);
            r2 = O.default.prototype.constrain(r2 = r2 || 3, 0, 15);
            r2 *= 1e3;
            var o2 = O.default.prototype.constrain(o2 || 15, 0, 22), n = 0, s2 = O.default.prototype._makeFrame, a = this._curElement.elt, l = [], u = setInterval(function() {
              l.push(s2(e3 + n, t3, a)), n++;
            }, 1e3 / o2);
            setTimeout(function() {
              if (clearInterval(u), i)
                i(l);
              else {
                var e4 = true, t4 = false, r3 = void 0;
                try {
                  for (var o3, n2 = l[Symbol.iterator](); !(e4 = (o3 = n2.next()).done); e4 = true) {
                    var s3 = o3.value;
                    O.default.prototype.downloadFile(s3.imageData, s3.filename, s3.ext);
                  }
                } catch (e5) {
                  t4 = true, r3 = e5;
                } finally {
                  try {
                    e4 || null == n2.return || n2.return();
                  } finally {
                    if (t4)
                      throw r3;
                  }
                }
              }
              l = [];
            }, 0.01 + r2);
          }, O.default.prototype._makeFrame = function(e3, t3, r2) {
            var o2, r2 = this ? this._curElement.elt : r2;
            if (t3)
              switch (t3.toLowerCase()) {
                case "png":
                  o2 = "image/png";
                  break;
                case "jpeg":
                case "jpg":
                  o2 = "image/jpeg";
                  break;
                default:
                  o2 = "image/png";
              }
            else
              t3 = "png", o2 = "image/png";
            var r2 = (r2 = r2.toDataURL(o2)).replace(o2, "image/octet-stream"), n = {};
            return n.imageData = r2, n.filename = e3, n.ext = t3, n;
          };
          e2 = O.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.filter": 153, "core-js/modules/es.array.from": 155, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.map": 161, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.keys": 176, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.set": 183, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.replace": 189, "core-js/modules/es.string.split": 191, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.typed-array.copy-within": 197, "core-js/modules/es.typed-array.every": 198, "core-js/modules/es.typed-array.fill": 199, "core-js/modules/es.typed-array.filter": 200, "core-js/modules/es.typed-array.find": 202, "core-js/modules/es.typed-array.find-index": 201, "core-js/modules/es.typed-array.for-each": 205, "core-js/modules/es.typed-array.includes": 206, "core-js/modules/es.typed-array.index-of": 207, "core-js/modules/es.typed-array.iterator": 210, "core-js/modules/es.typed-array.join": 211, "core-js/modules/es.typed-array.last-index-of": 212, "core-js/modules/es.typed-array.map": 213, "core-js/modules/es.typed-array.reduce": 215, "core-js/modules/es.typed-array.reduce-right": 214, "core-js/modules/es.typed-array.reverse": 216, "core-js/modules/es.typed-array.set": 217, "core-js/modules/es.typed-array.slice": 218, "core-js/modules/es.typed-array.some": 219, "core-js/modules/es.typed-array.sort": 220, "core-js/modules/es.typed-array.subarray": 221, "core-js/modules/es.typed-array.to-locale-string": 222, "core-js/modules/es.typed-array.to-string": 223, "core-js/modules/es.typed-array.uint32-array": 225, "core-js/modules/es.typed-array.uint8-array": 226, "core-js/modules/web.dom-collections.iterator": 230, omggif: 240 }], 290: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.copy-within"), e2("core-js/modules/es.array.every"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.uint8-clamped-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.copy-within"), e2("core-js/modules/es.array.every"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.uint8-clamped-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0, e2("regenerator-runtime/runtime");
          var O = n(e2("../core/main")), m = n(e2("../core/helpers")), j = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s2;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s2 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s2.get || s2.set) ? Object.defineProperty(o2, r2, s2) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants")), g = n(e2("omggif")), L = e2("gifenc");
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          function n(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          function l(e3, t3, r2, o2, n2, s2, i2) {
            try {
              var a2 = e3[s2](i2), l2 = a2.value;
            } catch (e4) {
              return void r2(e4);
            }
            a2.done ? t3(l2) : Promise.resolve(l2).then(o2, n2);
          }
          function y(e3, t3, r2, o2, n2, s2, i2, a2, l2, u, c) {
            var d, f, h, p, m2, y2, g2, v2, b;
            return e3 === j.COVER && (d = t3, h = r2, g2 = s2, v2 = i2, y2 = a2, b = l2, f = u, p = c, m2 = Math.max(g2 / f, v2 / p), g2 /= m2, v2 /= m2, m2 = y2, y2 = b, d === j.CENTER ? m2 += (f - g2) / 2 : d === j.RIGHT && (m2 += f - g2), h === j.CENTER ? y2 += (p - v2) / 2 : h === j.BOTTOM && (y2 += p - v2), a2 = (b = { x: m2, y: y2, w: g2, h: v2 }).x, l2 = b.y, u = b.w, c = b.h), e3 === j.CONTAIN && (d = t3, f = r2, h = o2, p = n2, m2 = s2, y2 = i2, g2 = u, v2 = c, b = Math.max(g2 / m2, v2 / y2), g2 /= b, v2 /= b, b = h, h = p, d === j.CENTER ? b += (m2 - g2) / 2 : d === j.RIGHT && (b += m2 - g2), f === j.CENTER ? h += (y2 - v2) / 2 : f === j.BOTTOM && (h += y2 - v2), o2 = (e3 = { x: b, y: h, w: g2, h: v2 }).x, n2 = e3.y, s2 = e3.w, i2 = e3.h), { sx: a2, sy: l2, sw: u, sh: c, dx: o2, dy: n2, dw: s2, dh: i2 };
          }
          function v(e3, t3) {
            return 0 < e3 && e3 < t3 ? e3 : t3;
          }
          e2("../core/friendly_errors/validate_params"), e2("../core/friendly_errors/file_errors"), e2("../core/friendly_errors/fes_core"), O.default.prototype.loadImage = function(o2, h, p) {
            O.default._validateParameters("loadImage", arguments);
            var m2 = new O.default.Image(1, 1, this), y2 = this, e3 = new Request(o2, { method: "GET", mode: "cors" });
            return fetch(o2, e3).then(function(e4) {
              var t3, r2 = e4.headers.get("content-type");
              null === r2 && console.warn("The image you loaded does not have a Content-Type header. If you are using the online editor consider reuploading the asset."), r2 && r2.includes("image/gif") ? e4.arrayBuffer().then(function(e5) {
                if (e5) {
                  var e5 = new Uint8Array(e5), r3 = m2, t4 = h, o3 = p, n2 = function(e6) {
                    y2._decrementPreload();
                  }.bind(y2), s2 = new g.default.GifReader(e5), i2 = (r3.width = r3.canvas.width = s2.width, r3.height = r3.canvas.height = s2.height, []), a2 = s2.numFrames(), l2 = new Uint8ClampedArray(r3.width * r3.height * 4);
                  if (1 < a2) {
                    for (var u = 0; u < a2; u++) {
                      var c = s2.frameInfo(u), d = r3.drawingContext.getImageData(0, 0, r3.width, r3.height), f = (l2 = d.data.slice(), !function(e6, t5) {
                        try {
                          t5.decodeAndBlitFrameRGBA(e6, l2);
                        } catch (e7) {
                          O.default._friendlyFileLoadError(8, r3.src), "function" == typeof o3 ? o3(e7) : console.error(e7);
                        }
                      }(u, s2), new ImageData(l2, r3.width, r3.height)), f = (r3.drawingContext.putImageData(f, 0, 0), c.delay);
                      0 === f && (f = 10), i2.push({ image: r3.drawingContext.getImageData(0, 0, r3.width, r3.height), delay: 10 * f }), 2 === c.disposal ? r3.drawingContext.clearRect(c.x, c.y, c.width, c.height) : 3 === c.disposal && r3.drawingContext.putImageData(d, 0, 0, c.x, c.y, c.width, c.height);
                    }
                    e5 = s2.loopCount();
                    null === e5 ? e5 = 1 : 0 === e5 && (e5 = null), r3.drawingContext.putImageData(i2[0].image, 0, 0), r3.gifProperties = { displayIndex: 0, loopLimit: e5, loopCount: 0, frames: i2, numFrames: a2, playing: true, timeDisplayed: 0, lastChangeTime: 0 };
                  }
                  "function" == typeof t4 && t4(r3), n2();
                }
              }, function(e5) {
                "function" == typeof p ? p(e5) : console.error(e5);
              }) : ((t3 = new Image()).onload = function() {
                m2.width = m2.canvas.width = t3.width, m2.height = m2.canvas.height = t3.height, m2.drawingContext.drawImage(t3, 0, 0), m2.modified = true, "function" == typeof h && h(m2), y2._decrementPreload();
              }, t3.onerror = function(e5) {
                O.default._friendlyFileLoadError(0, t3.src), "function" == typeof p ? p(e5) : console.error(e5);
              }, 0 !== o2.indexOf("data:image/") && (t3.crossOrigin = "Anonymous"), t3.src = o2), m2.modified = true;
            }).catch(function(e4) {
              O.default._friendlyFileLoadError(0, o2), "function" == typeof p ? p(e4) : console.error(e4);
            }), m2;
          }, O.default.prototype.saveGif = function() {
            a2 = regeneratorRuntime.mark(function e3(t3, r3) {
              var o2, n2, s2, i2, a3, l2, u, c, d, f, h, p, m2, y2, g2, v2, b, j2, _, x, w, S, M, E, T, C = arguments;
              return regeneratorRuntime.wrap(function(e4) {
                for (; ; )
                  switch (e4.prev = e4.next) {
                    case 0:
                      if (o2 = 2 < C.length && void 0 !== C[2] ? C[2] : { delay: 0, units: "seconds" }, "string" != typeof t3)
                        throw TypeError("fileName parameter must be a string");
                      e4.next = 3;
                      break;
                    case 3:
                      if ("number" != typeof r3)
                        throw TypeError("Duration parameter must be a number");
                      e4.next = 5;
                      break;
                    case 5:
                      if ("number" != typeof o2.delay)
                        throw TypeError("Delay parameter must be a number");
                      e4.next = 7;
                      break;
                    case 7:
                      if ("seconds" !== o2.units && "frames" !== o2.units)
                        throw TypeError('Units parameter must be either "frames" or "seconds"');
                      e4.next = 9;
                      break;
                    case 9:
                      l2 = o2.units, a3 = o2.delay, i2 = this._targetFrameRate, n2 = (n2 = 1 / (i2 = i2 !== 1 / 0 && void 0 !== i2 && 0 !== i2 ? i2 : 60) * 1e3) < 20 ? 20 : n2, i2 = (s2 = "seconds" === l2 ? r3 * i2 : r3) + (l2 = "seconds" === l2 ? a3 * i2 : a3), a3 = l2, this.frameCount = a3, l2 = this._pixelDensity, this.pixelDensity(1), u = [], c = "p5.gif.progressBar", null !== document.getElementById(c) && document.getElementById(c).remove(), (c = this.createP("")).id("progressBar"), c.style("font-size", "16px"), c.style("font-family", "Montserrat"), c.style("background-color", "#ffffffa0"), c.style("padding", "8px"), c.style("border-radius", "10px"), c.position(0, 0), this.drawingContext instanceof WebGLRenderingContext && (f = document.getElementById("defaultCanvas0").getContext("webgl"), d = new Uint8Array(f.drawingBufferWidth * f.drawingBufferHeight * 4)), this.noLoop();
                    case 35:
                      if (a3 < i2)
                        return this.redraw(), g2 = void 0, g2 = this.drawingContext instanceof WebGLRenderingContext ? (d = new Uint8Array(f.drawingBufferWidth * f.drawingBufferHeight * 4), f.readPixels(0, 0, f.drawingBufferWidth, f.drawingBufferHeight, f.RGBA, f.UNSIGNED_BYTE, d), function(e5) {
                          for (var t4 = parseInt(height / 2), r4 = 4 * width, o3 = new Uint8Array(4 * width), n3 = 0; n3 < t4; ++n3) {
                            var s3 = n3 * r4, i3 = (height - n3 - 1) * r4;
                            o3.set(e5.subarray(s3, s3 + r4)), e5.copyWithin(s3, i3, i3 + r4), e5.set(o3, i3);
                          }
                          return e5;
                        }(d)) : this.drawingContext.getImageData(0, 0, this.width, this.height).data, u.push(g2), a3++, c.html("Saved frame <b>" + u.length.toString() + "</b> out of " + s2.toString()), e4.next = 44, new Promise(function(e5) {
                          return setTimeout(e5, 0);
                        });
                      e4.next = 46;
                      break;
                    case 44:
                      e4.next = 35;
                      break;
                    case 46:
                      c.html("Frames processed, generating color palette..."), this.loop(), this.pixelDensity(l2), h = (0, L.GIFEncoder)(), p = function(e5) {
                        for (var t4 = new Uint8Array(e5.length * e5[0].length), r4 = 0; r4 < e5.length; r4++)
                          t4.set(e5[0], r4 * e5[0].length);
                        var o3 = (0, L.quantize)(t4, 256, { format: "rgba444", oneBitAlpha: true });
                        256 === o3.length ? o3[o3.length - 1] = [255 * Math.random(), 255 * Math.random(), 255 * Math.random(), 0] : o3.push([255 * Math.random(), 255 * Math.random(), 255 * Math.random(), 0]);
                        return o3;
                      }(u), m2 = p.length - 1, y2 = 0;
                    case 53:
                      if (y2 < u.length) {
                        if (0 === y2)
                          return g2 = (0, L.applyPalette)(u[y2], p, { format: "rgba4444" }), h.writeFrame(g2, this.width, this.height, { palette: p, delay: n2, dispose: 1 }), e4.abrupt("continue", 68);
                        e4.next = 58;
                      } else
                        e4.next = 71;
                      break;
                    case 58:
                      for (v2 = u[y2], b = u[y2 - 1], j2 = [], _ = 0; _ < v2.length; _ += 4)
                        x = [v2[_], v2[_ + 1], v2[_ + 2], v2[_ + 3]], w = [b[_], b[_ + 1], b[_ + 2], b[_ + 3]], !function(e5, r4) {
                          return Array.isArray(e5) && Array.isArray(r4) && e5.length === r4.length && e5.every(function(e6, t4) {
                            return e6 === r4[t4];
                          });
                        }(x, w) || j2.push(_ / 4);
                      for (S = (0, L.applyPalette)(v2, p, { format: "rgba4444" }), M = 0; M < j2.length; M++)
                        E = j2[M], S[E] = m2;
                      return h.writeFrame(S, this.width, this.height, { delay: n2, transparent: true, transparentIndex: m2, dispose: 1 }), c.html("Rendered frame <b>" + y2.toString() + "</b> out of " + s2.toString()), e4.next = 68, new Promise(function(e5) {
                        return setTimeout(e5, 0);
                      });
                    case 68:
                      y2++, e4.next = 53;
                      break;
                    case 71:
                      h.finish(), T = h.bytesView(), T = new Blob([T], { type: "image/gif" }), u = [], this.loop(), c.html("Done. Downloading your gif!\u{1F338}"), O.default.prototype.downloadFile(T, t3, "gif");
                    case 79:
                    case "end":
                      return e4.stop();
                  }
              }, e3, this);
            });
            var a2, r2 = function() {
              var e3 = this, i2 = arguments;
              return new Promise(function(t3, r3) {
                var o2 = a2.apply(e3, i2);
                function n2(e4) {
                  l(o2, t3, r3, n2, s2, "next", e4);
                }
                function s2(e4) {
                  l(o2, t3, r3, n2, s2, "throw", e4);
                }
                n2(void 0);
              });
            };
            return function(e3, t3) {
              return r2.apply(this, arguments);
            };
          }(), O.default.prototype.image = function(e3, t3, r2, o2, n2, s2, i2, a2, l2, u, c, d) {
            O.default._validateParameters("image", arguments);
            var f = e3.width, h = e3.height, p = (d = d || j.CENTER, c = c || j.CENTER, e3.elt && e3.elt.videoWidth && !e3.canvas && (f = e3.elt.videoWidth, h = e3.elt.videoHeight), o2 || f), n2 = n2 || h, s2 = s2 || 0, i2 = i2 || 0, a2 = v(a2 || f, f), f = v(l2 || h, h), l2 = 1;
            e3.elt && !e3.canvas && e3.elt.style.width && (l2 = e3.elt.videoWidth && !o2 ? e3.elt.videoWidth : e3.elt.width, l2 /= parseInt(e3.elt.style.width, 10)), s2 *= l2, i2 *= l2, f *= l2, a2 *= l2;
            h = y(u, c, d, (h = m.default.modeAdjust(t3, r2, p, n2, this._renderer._imageMode)).x, h.y, h.w, h.h, s2, i2, a2, f);
            this._renderer.image(e3, h.sx, h.sy, h.sw, h.sh, h.dx, h.dy, h.dw, h.dh);
          }, O.default.prototype.tint = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            O.default._validateParameters("tint", t3);
            var o2 = this.color.apply(this, t3);
            this._renderer._tint = o2.levels;
          }, O.default.prototype.noTint = function() {
            this._renderer._tint = null;
          }, O.default.prototype._getTintedImageCanvas = O.default.Renderer2D.prototype._getTintedImageCanvas, O.default.prototype.imageMode = function(e3) {
            O.default._validateParameters("imageMode", arguments), e3 !== j.CORNER && e3 !== j.CORNERS && e3 !== j.CENTER || (this._renderer._imageMode = e3);
          };
          e2 = O.default;
          r.default = e2;
        }, { "../core/constants": 256, "../core/friendly_errors/fes_core": 258, "../core/friendly_errors/file_errors": 259, "../core/friendly_errors/validate_params": 262, "../core/helpers": 263, "../core/main": 267, "core-js/modules/es.array.copy-within": 150, "core-js/modules/es.array.every": 151, "core-js/modules/es.array.includes": 156, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.promise": 178, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.includes": 185, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.typed-array.copy-within": 197, "core-js/modules/es.typed-array.every": 198, "core-js/modules/es.typed-array.fill": 199, "core-js/modules/es.typed-array.filter": 200, "core-js/modules/es.typed-array.find": 202, "core-js/modules/es.typed-array.find-index": 201, "core-js/modules/es.typed-array.for-each": 205, "core-js/modules/es.typed-array.includes": 206, "core-js/modules/es.typed-array.index-of": 207, "core-js/modules/es.typed-array.iterator": 210, "core-js/modules/es.typed-array.join": 211, "core-js/modules/es.typed-array.last-index-of": 212, "core-js/modules/es.typed-array.map": 213, "core-js/modules/es.typed-array.reduce": 215, "core-js/modules/es.typed-array.reduce-right": 214, "core-js/modules/es.typed-array.reverse": 216, "core-js/modules/es.typed-array.set": 217, "core-js/modules/es.typed-array.slice": 218, "core-js/modules/es.typed-array.some": 219, "core-js/modules/es.typed-array.sort": 220, "core-js/modules/es.typed-array.subarray": 221, "core-js/modules/es.typed-array.to-locale-string": 222, "core-js/modules/es.typed-array.to-string": 223, "core-js/modules/es.typed-array.uint8-array": 226, "core-js/modules/es.typed-array.uint8-clamped-array": 227, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230, gifenc: 237, omggif: 240, "regenerator-runtime/runtime": 244 }], 291: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var s2 = n(e2("../core/main")), o = n(e2("./filters"));
          function n(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          s2.default.Image = function(e3, t3) {
            this.width = e3, this.height = t3, this.canvas = document.createElement("canvas"), this.canvas.width = this.width, this.canvas.height = this.height, this.drawingContext = this.canvas.getContext("2d"), (this._pixelsState = this)._pixelDensity = 1, this.gifProperties = null, this._modified = false, this.pixels = [];
          }, s2.default.Image.prototype._animateGif = function(e3) {
            var t3, r2 = this.gifProperties, e3 = e3._lastFrameTime;
            0 === r2.lastChangeTime && (r2.lastChangeTime = e3), r2.playing && (r2.timeDisplayed = e3 - r2.lastChangeTime, t3 = r2.frames[r2.displayIndex].delay, r2.timeDisplayed >= t3 && (t3 = Math.floor(r2.timeDisplayed / t3), r2.timeDisplayed = 0, r2.lastChangeTime = e3, r2.displayIndex += t3, r2.loopCount = Math.floor(r2.displayIndex / r2.numFrames), null !== r2.loopLimit && r2.loopCount >= r2.loopLimit ? r2.playing = false : (e3 = r2.displayIndex % r2.numFrames, this.drawingContext.putImageData(r2.frames[e3].image, 0, 0), r2.displayIndex = e3, this.setModified(true))));
          }, s2.default.Image.prototype._setProperty = function(e3, t3) {
            this[e3] = t3, this.setModified(true);
          }, s2.default.Image.prototype.loadPixels = function() {
            s2.default.Renderer2D.prototype.loadPixels.call(this), this.setModified(true);
          }, s2.default.Image.prototype.updatePixels = function(e3, t3, r2, o2) {
            s2.default.Renderer2D.prototype.updatePixels.call(this, e3, t3, r2, o2), this.setModified(true);
          }, s2.default.Image.prototype.get = function(e3, t3, r2, o2) {
            return s2.default._validateParameters("p5.Image.get", arguments), s2.default.Renderer2D.prototype.get.apply(this, arguments);
          }, s2.default.Image.prototype._getPixel = s2.default.Renderer2D.prototype._getPixel, s2.default.Image.prototype.set = function(e3, t3, r2) {
            s2.default.Renderer2D.prototype.set.call(this, e3, t3, r2), this.setModified(true);
          }, s2.default.Image.prototype.resize = function(e3, t3) {
            0 === e3 && 0 === t3 ? (e3 = this.canvas.width, t3 = this.canvas.height) : 0 === e3 ? e3 = this.canvas.width * t3 / this.canvas.height : 0 === t3 && (t3 = this.canvas.height * e3 / this.canvas.width), e3 = Math.floor(e3), t3 = Math.floor(t3);
            var r2 = document.createElement("canvas");
            if (r2.width = e3, r2.height = t3, this.gifProperties)
              for (var o2 = this.gifProperties, n2 = 0; n2 < o2.numFrames; n2++) {
                for (var s3 = this.drawingContext.createImageData(e3, t3), i = (d = d = c = u = l = void 0, o2.frames[n2].image), a = s3, l = 0, u = 0; u < a.height; u++)
                  for (var c = 0; c < a.width; c++) {
                    var d = Math.floor(c * i.width / a.width), d = 4 * (Math.floor(u * i.height / a.height) * i.width + d);
                    a.data[l++] = i.data[d++], a.data[l++] = i.data[d++], a.data[l++] = i.data[d++], a.data[l++] = i.data[+d];
                  }
                o2.frames[n2].image = s3;
              }
            r2.getContext("2d").drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, r2.width, r2.height), this.canvas.width = this.width = e3, this.canvas.height = this.height = t3, this.drawingContext.drawImage(r2, 0, 0, e3, t3, 0, 0, e3, t3), 0 < this.pixels.length && this.loadPixels(), this.setModified(true);
          }, s2.default.Image.prototype.copy = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            s2.default.prototype.copy.apply(this, t3);
          }, s2.default.Image.prototype.mask = function(e3) {
            var t3 = this.drawingContext.globalCompositeOperation, r2 = 1, o2 = [e3 = void 0 === e3 ? this : e3, 0, 0, (r2 = e3 instanceof s2.default.Renderer ? e3._pInst._pixelDensity : r2) * e3.width, r2 * e3.height, 0, 0, this.width, this.height];
            if (this.drawingContext.globalCompositeOperation = "destination-in", this.gifProperties) {
              for (var n2 = 0; n2 < this.gifProperties.frames.length; n2++)
                this.drawingContext.putImageData(this.gifProperties.frames[n2].image, 0, 0), s2.default.Image.prototype.copy.apply(this, o2), this.gifProperties.frames[n2].image = this.drawingContext.getImageData(0, 0, this.width, this.height);
              this.drawingContext.putImageData(this.gifProperties.frames[this.gifProperties.displayIndex].image, 0, 0);
            } else
              s2.default.Image.prototype.copy.apply(this, o2);
            this.drawingContext.globalCompositeOperation = t3, this.setModified(true);
          }, s2.default.Image.prototype.filter = function(e3, t3) {
            o.default.apply(this.canvas, o.default[e3], t3), this.setModified(true);
          }, s2.default.Image.prototype.blend = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            s2.default._validateParameters("p5.Image.blend", arguments), s2.default.prototype.blend.apply(this, t3), this.setModified(true);
          }, s2.default.Image.prototype.setModified = function(e3) {
            this._modified = e3;
          }, s2.default.Image.prototype.isModified = function() {
            return this._modified;
          }, s2.default.Image.prototype.save = function(e3, t3) {
            this.gifProperties ? s2.default.prototype.encodeAndDownloadGif(this, e3) : s2.default.prototype.saveCanvas(this.canvas, e3, t3);
          }, s2.default.Image.prototype.reset = function() {
            var e3;
            this.gifProperties && ((e3 = this.gifProperties).playing = true, e3.timeSinceStart = 0, e3.timeDisplayed = 0, e3.lastChangeTime = 0, e3.loopCount = 0, e3.displayIndex = 0, this.drawingContext.putImageData(e3.frames[0].image, 0, 0));
          }, s2.default.Image.prototype.getCurrentFrame = function() {
            var e3;
            if (this.gifProperties)
              return (e3 = this.gifProperties).displayIndex % e3.numFrames;
          }, s2.default.Image.prototype.setFrame = function(e3) {
            var t3;
            this.gifProperties && (e3 < (t3 = this.gifProperties).numFrames && 0 <= e3 ? (t3.timeDisplayed = 0, t3.lastChangeTime = 0, t3.displayIndex = e3, this.drawingContext.putImageData(t3.frames[e3].image, 0, 0)) : console.log("Cannot set GIF to a frame number that is higher than total number of frames or below zero."));
          }, s2.default.Image.prototype.numFrames = function() {
            if (this.gifProperties)
              return this.gifProperties.numFrames;
          }, s2.default.Image.prototype.play = function() {
            this.gifProperties && (this.gifProperties.playing = true);
          }, s2.default.Image.prototype.pause = function() {
            this.gifProperties && (this.gifProperties.playing = false);
          }, s2.default.Image.prototype.delay = function(e3, t3) {
            if (this.gifProperties) {
              var r2 = this.gifProperties;
              if (t3 < r2.numFrames && 0 <= t3)
                r2.frames[t3].delay = e3;
              else {
                var o2 = true, t3 = false, n2 = void 0;
                try {
                  for (var s3, i = r2.frames[Symbol.iterator](); !(o2 = (s3 = i.next()).done); o2 = true)
                    s3.value.delay = e3;
                } catch (e4) {
                  t3 = true, n2 = e4;
                } finally {
                  try {
                    o2 || null == i.return || i.return();
                  } finally {
                    if (t3)
                      throw n2;
                  }
                }
              }
            }
          };
          e2 = s2.default.Image;
          r.default = e2;
        }, { "../core/main": 267, "./filters": 288, "core-js/modules/es.array.filter": 153, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/web.dom-collections.iterator": 230 }], 292: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.filter"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var h = n(e2("../core/main")), o = n(e2("./filters"));
          function n(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          e2("../color/p5.Color"), h.default.prototype.pixels = [], h.default.prototype.blend = function() {
            for (var e3, t3 = arguments.length, r2 = new Array(t3), o2 = 0; o2 < t3; o2++)
              r2[o2] = arguments[o2];
            h.default._validateParameters("blend", r2), this._renderer ? (e3 = this._renderer).blend.apply(e3, r2) : h.default.Renderer2D.prototype.blend.apply(this, r2);
          }, h.default.prototype.copy = function() {
            for (var e3, t3, r2, o2, n2, s2, i, a, l, u = arguments.length, c = new Array(u), d = 0; d < u; d++)
              c[d] = arguments[d];
            if (h.default._validateParameters("copy", c), 9 === c.length)
              e3 = c[0], t3 = c[1], r2 = c[2], o2 = c[3], n2 = c[4], s2 = c[5], i = c[6], a = c[7], l = c[8];
            else {
              if (8 !== c.length)
                throw new Error("Signature not supported");
              e3 = this, t3 = c[0], r2 = c[1], o2 = c[2], n2 = c[3], s2 = c[4], i = c[5], a = c[6], l = c[7];
            }
            h.default.prototype._copyHelper(this, e3, t3, r2, o2, n2, s2, i, a, l);
          }, h.default.prototype._copyHelper = function(e3, t3, r2, o2, n2, s2, i, a, l, u) {
            t3.loadPixels();
            var c = t3.canvas.width / t3.width, d = 0, f = 0;
            t3._renderer && t3._renderer.isP3D && (d = t3.width / 2, f = t3.height / 2), e3._renderer && e3._renderer.isP3D ? h.default.RendererGL.prototype.image.call(e3._renderer, t3, r2 + d, o2 + f, n2, s2, i, a, l, u) : e3.drawingContext.drawImage(t3.canvas, c * (r2 + d), c * (o2 + f), c * n2, c * s2, i, a, l, u);
          }, h.default.prototype.filter = function(e3, t3) {
            h.default._validateParameters("filter", arguments), void 0 !== this.canvas ? o.default.apply(this.canvas, o.default[e3], t3) : o.default.apply(this.elt, o.default[e3], t3);
          }, h.default.prototype.get = function(e3, t3, r2, o2) {
            var n2;
            return h.default._validateParameters("get", arguments), (n2 = this._renderer).get.apply(n2, arguments);
          }, h.default.prototype.loadPixels = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            h.default._validateParameters("loadPixels", t3), this._renderer.loadPixels();
          }, h.default.prototype.set = function(e3, t3, r2) {
            this._renderer.set(e3, t3, r2);
          }, h.default.prototype.updatePixels = function(e3, t3, r2, o2) {
            h.default._validateParameters("updatePixels", arguments), 0 !== this.pixels.length && this._renderer.updatePixels(e3, t3, r2, o2);
          };
          e2 = h.default;
          r.default = e2;
        }, { "../color/p5.Color": 254, "../core/main": 267, "./filters": 288, "core-js/modules/es.array.filter": 153 }], 293: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.last-index-of"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/web.url"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.last-index-of"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.promise"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/web.url"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var v = s2(e2("../core/main")), m = (e2("whatwg-fetch"), e2("es6-promise/auto"), s2(e2("fetch-jsonp"))), n = s2(e2("file-saver"));
          function s2(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          function y(e3) {
            return (y = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          function g(e3) {
            return e3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
          }
          function i(e3, t3) {
            t3 && true !== t3 && "true" !== t3 || (t3 = "");
            var r2 = "";
            return (e3 = e3 || "untitled") && e3.includes(".") && (r2 = e3.split(".").pop()), t3 && r2 !== t3 && (r2 = t3, e3 = "".concat(e3, ".").concat(r2)), [e3, r2];
          }
          e2("../core/friendly_errors/validate_params"), e2("../core/friendly_errors/file_errors"), e2("../core/friendly_errors/fes_core"), v.default.prototype.loadJSON = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            v.default._validateParameters("loadJSON", t3);
            for (var o2, n2, s3, i2 = t3[0], a = {}, l = "json", u = 1; u < t3.length; u++) {
              var c = t3[u];
              "string" == typeof c ? "jsonp" !== c && "json" !== c || (l = c) : "function" == typeof c ? o2 ? n2 = c : o2 = c : "object" === y(c) && (c.hasOwnProperty("jsonpCallback") || c.hasOwnProperty("jsonpCallbackFunction")) && (l = "jsonp", s3 = c);
            }
            var d = this;
            return this.httpDo(i2, "GET", s3, l, function(e4) {
              for (var t4 in e4)
                a[t4] = e4[t4];
              void 0 !== o2 && o2(e4), d._decrementPreload();
            }, function(e4) {
              if (v.default._friendlyFileLoadError(5, i2), !n2)
                throw e4;
              n2(e4);
            }), a;
          }, v.default.prototype.loadStrings = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            v.default._validateParameters("loadStrings", t3);
            for (var n2, o2, s3 = [], i2 = 1; i2 < t3.length; i2++) {
              var a = t3[i2];
              "function" == typeof a && (void 0 === n2 ? n2 = a : void 0 === o2 && (o2 = a));
            }
            var l = this;
            return v.default.prototype.httpDo.call(this, t3[0], "GET", "text", function(e4) {
              for (var t4 = e4.replace(/\r\n/g, "\r").replace(/\n/g, "\r").split(/\r/), r3 = 0, o3 = t4.length; r3 < o3; r3 += 32768)
                Array.prototype.push.apply(s3, t4.slice(r3, Math.min(r3 + 32768, o3)));
              void 0 !== n2 && n2(s3), l._decrementPreload();
            }, function(e4) {
              if (v.default._friendlyFileLoadError(3, e4), !o2)
                throw e4;
              o2(e4);
            }), s3;
          }, v.default.prototype.loadTable = function(t3) {
            var h, r2, p, e3 = [], m2 = false, o2 = t3.substring(t3.lastIndexOf(".") + 1, t3.length);
            "csv" === o2 ? p = "," : "ssv" === o2 ? p = ";" : "tsv" === o2 && (p = "	");
            for (var n2 = 1; n2 < arguments.length; n2++)
              "function" == typeof arguments[n2] ? void 0 === h ? h = arguments[n2] : void 0 === r2 && (r2 = arguments[n2]) : "string" == typeof arguments[n2] && (e3.push(arguments[n2]), "header" === arguments[n2] && (m2 = true), "csv" === arguments[n2] ? p = "," : "ssv" === arguments[n2] ? p = ";" : "tsv" === arguments[n2] && (p = "	"));
            var y2 = new v.default.Table(), g2 = this;
            return this.httpDo(t3, "GET", "table", function(e4) {
              for (var t4, r3, o3 = {}, n3 = 0, s3 = [], i2 = 0, a = null, l = function() {
                o3.currentState = n3, o3.token = "";
              }, u = function() {
                a.push(o3.token), l();
              }, c = function() {
                o3.currentState = 4, s3.push(a), a = null;
              }; ; ) {
                if (null == (t4 = e4[i2++])) {
                  if (o3.escaped)
                    throw new Error("Unclosed quote in file.");
                  if (a) {
                    u(), c();
                    break;
                  }
                }
                if (null === a && (o3.escaped = false, a = [], l()), o3.currentState === n3) {
                  if ('"' === t4) {
                    o3.escaped = true, o3.currentState = 1;
                    continue;
                  }
                  o3.currentState = 1;
                }
                if (1 === o3.currentState && o3.escaped)
                  if ('"' === t4)
                    '"' === e4[i2] ? (o3.token += '"', i2++) : (o3.escaped = false, o3.currentState = 2);
                  else {
                    if ("\r" === t4)
                      continue;
                    o3.token += t4;
                  }
                else
                  "\r" === t4 ? ("\n" === e4[i2] && i2++, u(), c()) : "\n" === t4 ? (u(), c()) : t4 === p ? u() : 1 === o3.currentState && (o3.token += t4);
              }
              if (m2)
                y2.columns = s3.shift();
              else
                for (var d = 0; d < s3[0].length; d++)
                  y2.columns[d] = "null";
              for (var f = 0; f < s3.length; f++)
                (1 !== s3[f].length || "undefined" !== s3[f][0] && "" !== s3[f][0]) && ((r3 = new v.default.TableRow()).arr = s3[f], r3.obj = function(e5, t5) {
                  var r4 = {};
                  if (void 0 === (t5 = t5 || []))
                    for (var o4 = 0; o4 < e5.length; o4++)
                      t5[o4.toString()] = o4;
                  for (var n4 = 0; n4 < t5.length; n4++) {
                    var s4 = t5[n4], i3 = e5[n4];
                    r4[s4] = i3;
                  }
                  return r4;
                }(s3[f], y2.columns), y2.addRow(r3));
              "function" == typeof h && h(y2), g2._decrementPreload();
            }, function(e4) {
              v.default._friendlyFileLoadError(2, t3), r2 ? r2(e4) : console.error(e4);
            }), y2;
          }, v.default.prototype.loadXML = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            for (var o2, n2, s3 = new v.default.XML(), i2 = 1; i2 < t3.length; i2++) {
              var a = t3[i2];
              "function" == typeof a && (void 0 === o2 ? o2 = a : void 0 === n2 && (n2 = a));
            }
            var l = this;
            return this.httpDo(t3[0], "GET", "xml", function(e4) {
              for (var t4 in e4)
                s3[t4] = e4[t4];
              void 0 !== o2 && o2(s3), l._decrementPreload();
            }, function(e4) {
              if (v.default._friendlyFileLoadError(1, e4), !n2)
                throw e4;
              n2(e4);
            }), s3;
          }, v.default.prototype.loadBytes = function(t3, r2, o2) {
            var n2 = {}, s3 = this;
            return this.httpDo(t3, "GET", "arrayBuffer", function(e3) {
              n2.bytes = new Uint8Array(e3), "function" == typeof r2 && r2(n2), s3._decrementPreload();
            }, function(e3) {
              if (v.default._friendlyFileLoadError(6, t3), !o2)
                throw e3;
              o2(e3);
            }), n2;
          }, v.default.prototype.httpGet = function() {
            v.default._validateParameters("httpGet", arguments);
            var e3 = Array.prototype.slice.call(arguments);
            return e3.splice(1, 0, "GET"), v.default.prototype.httpDo.apply(this, e3);
          }, v.default.prototype.httpPost = function() {
            v.default._validateParameters("httpPost", arguments);
            var e3 = Array.prototype.slice.call(arguments);
            return e3.splice(1, 0, "POST"), v.default.prototype.httpDo.apply(this, e3);
          }, v.default.prototype.httpDo = function() {
            for (var r2, e3, t3, o2 = {}, n2 = 0, s3 = "text/plain", i2 = arguments.length - 1; 0 < i2 && "function" == typeof (i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]); i2--)
              n2++;
            var a = arguments.length - n2, l = arguments.length <= 0 ? void 0 : arguments[0];
            if (2 == a && "string" == typeof l && "object" === y(arguments.length <= 1 ? void 0 : arguments[1]))
              p = new Request(l, arguments.length <= 1 ? void 0 : arguments[1]), e3 = arguments.length <= 2 ? void 0 : arguments[2], t3 = arguments.length <= 3 ? void 0 : arguments[3];
            else {
              for (var u, c = "GET", d = 1; d < arguments.length; d++) {
                var f = d < 0 || arguments.length <= d ? void 0 : arguments[d];
                if ("string" == typeof f)
                  "GET" === f || "POST" === f || "PUT" === f || "DELETE" === f ? c = f : "json" === f || "jsonp" === f || "binary" === f || "arrayBuffer" === f || "xml" === f || "text" === f || "table" === f ? r2 = f : u = f;
                else if ("number" == typeof f)
                  u = f.toString();
                else if ("object" === y(f))
                  if (f.hasOwnProperty("jsonpCallback") || f.hasOwnProperty("jsonpCallbackFunction"))
                    for (var h in f)
                      o2[h] = f[h];
                  else
                    s3 = f instanceof v.default.XML ? (u = f.serialize(), "application/xml") : (u = JSON.stringify(f), "application/json");
                else
                  "function" == typeof f && (e3 ? t3 = f : e3 = f);
              }
              var a = "GET" === c ? new Headers() : new Headers({ "Content-Type": s3 }), p = new Request(l, { method: c, mode: "cors", body: u, headers: a });
            }
            return (a = (a = "jsonp" === (r2 = r2 || (l.includes("json") ? "json" : l.includes("xml") ? "xml" : "text")) ? (0, m.default)(l, o2) : fetch(p)).then(function(e4) {
              if (!e4.ok)
                throw (t4 = new Error(e4.body)).status = e4.status, t4.ok = false, t4;
              var t4 = 0;
              switch ((t4 = "jsonp" !== r2 ? e4.headers.get("content-length") : t4) && 64e6 < t4 && v.default._friendlyFileLoadError(7, l), r2) {
                case "json":
                case "jsonp":
                  return e4.json();
                case "binary":
                  return e4.blob();
                case "arrayBuffer":
                  return e4.arrayBuffer();
                case "xml":
                  return e4.text().then(function(e5) {
                    e5 = new DOMParser().parseFromString(e5, "text/xml");
                    return new v.default.XML(e5.documentElement);
                  });
                default:
                  return e4.text();
              }
            })).then(e3 || function() {
            }), a.catch(t3 || console.error), a;
          }, window.URL = window.URL || window.webkitURL, v.default.prototype._pWriters = [], v.default.prototype.createWriter = function(e3, t3) {
            var r2, o2;
            for (o2 in v.default.prototype._pWriters)
              if (v.default.prototype._pWriters[o2].name === e3)
                return r2 = new v.default.PrintWriter(e3 + this.millis(), t3), v.default.prototype._pWriters.push(r2), r2;
            return r2 = new v.default.PrintWriter(e3, t3), v.default.prototype._pWriters.push(r2), r2;
          }, v.default.PrintWriter = function(r2, o2) {
            var n2 = this;
            this.name = r2, this.content = "", this.write = function(e3) {
              this.content += e3;
            }, this.print = function(e3) {
              this.content += "".concat(e3, "\n");
            }, this.clear = function() {
              this.content = "";
            }, this.close = function() {
              var e3, t3 = [];
              for (e3 in t3.push(this.content), v.default.prototype.writeFile(t3, r2, o2), v.default.prototype._pWriters)
                v.default.prototype._pWriters[e3].name === this.name && v.default.prototype._pWriters.splice(e3, 1);
              n2.clear(), n2 = {};
            };
          }, v.default.prototype.save = function(e3, t3, r2) {
            var o2 = arguments, n2 = (this._curElement || this).elt;
            if (0 === o2.length)
              v.default.prototype.saveCanvas(n2);
            else if (o2[0] instanceof v.default.Renderer || o2[0] instanceof v.default.Graphics)
              v.default.prototype.saveCanvas(o2[0].elt, o2[1], o2[2]);
            else if (1 === o2.length && "string" == typeof o2[0])
              v.default.prototype.saveCanvas(n2, o2[0]);
            else
              switch (i(o2[1], o2[2])[1]) {
                case "json":
                  return void v.default.prototype.saveJSON(o2[0], o2[1], o2[2]);
                case "txt":
                  return void v.default.prototype.saveStrings(o2[0], o2[1], o2[2]);
                default:
                  o2[0] instanceof Array ? v.default.prototype.saveStrings(o2[0], o2[1], o2[2]) : o2[0] instanceof v.default.Table ? v.default.prototype.saveTable(o2[0], o2[1], o2[2]) : o2[0] instanceof v.default.Image ? v.default.prototype.saveCanvas(o2[0].canvas, o2[1]) : o2[0] instanceof v.default.SoundFile && v.default.prototype.saveSound(o2[0], o2[1], o2[2], o2[3]);
              }
          }, v.default.prototype.saveJSON = function(e3, t3, r2) {
            v.default._validateParameters("saveJSON", arguments), r2 = r2 ? JSON.stringify(e3) : JSON.stringify(e3, void 0, 2), this.saveStrings(r2.split("\n"), t3, "json");
          }, v.default.prototype.saveJSONObject = v.default.prototype.saveJSON, v.default.prototype.saveJSONArray = v.default.prototype.saveJSON, v.default.prototype.saveStrings = function(e3, t3, r2, o2) {
            v.default._validateParameters("saveStrings", arguments);
            for (var n2 = this.createWriter(t3, r2 || "txt"), s3 = 0; s3 < e3.length; s3++)
              o2 ? n2.write(e3[s3] + "\r\n") : n2.write(e3[s3] + "\n");
            n2.close(), n2.clear();
          }, v.default.prototype.saveTable = function(e3, t3, r2) {
            v.default._validateParameters("saveTable", arguments), o2 = void 0 === r2 ? t3.substring(t3.lastIndexOf(".") + 1, t3.length) : r2;
            var o2, n2 = this.createWriter(t3, o2), s3 = e3.columns, i2 = "tsv" === o2 ? "	" : ",";
            if ("html" !== o2) {
              if ("0" !== s3[0]) {
                for (var a = 0; a < s3.length; a++)
                  a < s3.length - 1 ? n2.write(s3[a] + i2) : n2.write(s3[a]);
                n2.write("\n");
              }
              for (var l = 0; l < e3.rows.length; l++) {
                for (var u = void 0, u = 0; u < e3.rows[l].arr.length; u++)
                  u < e3.rows[l].arr.length - 1 ? "csv" === o2 && String(e3.rows[l].arr[u]).includes(",") ? n2.write('"' + e3.rows[l].arr[u] + '"' + i2) : n2.write(e3.rows[l].arr[u] + i2) : "csv" === o2 && String(e3.rows[l].arr[u]).includes(",") ? n2.write('"' + e3.rows[l].arr[u] + '"') : n2.write(e3.rows[l].arr[u]);
                n2.write("\n");
              }
            } else {
              n2.print("<html>"), n2.print("<head>");
              if (n2.print('  <meta http-equiv="content-type" content="text/html;charset=utf-8" />'), n2.print("</head>"), n2.print("<body>"), n2.print("  <table>"), "0" !== s3[0]) {
                n2.print("    <tr>");
                for (var c = 0; c < s3.length; c++) {
                  var d = g(s3[c]);
                  n2.print("      <td>".concat(d)), n2.print("      </td>");
                }
                n2.print("    </tr>");
              }
              for (var f = 0; f < e3.rows.length; f++) {
                n2.print("    <tr>");
                for (var h = 0; h < e3.columns.length; h++) {
                  var p = g(e3.rows[f].getString(h));
                  n2.print("      <td>".concat(p)), n2.print("      </td>");
                }
                n2.print("    </tr>");
              }
              n2.print("  </table>"), n2.print("</body>"), n2.print("</html>");
            }
            n2.close(), n2.clear();
          }, v.default.prototype.writeFile = function(e3, t3, r2) {
            var o2 = "application/octet-stream", e3 = (v.default.prototype._isSafari() && (o2 = "text/plain"), new Blob(e3, { type: o2 }));
            v.default.prototype.downloadFile(e3, t3, r2);
          }, v.default.prototype.downloadFile = function(e3, t3, r2) {
            var o2, t3 = i(t3, r2), r2 = t3[0];
            e3 instanceof Blob ? n.default.saveAs(e3, r2) : ((o2 = document.createElement("a")).href = e3, o2.download = r2, o2.onclick = function(e4) {
              document.body.removeChild(e4.target), e4.stopPropagation();
            }, o2.style.display = "none", document.body.appendChild(o2), v.default.prototype._isSafari() && (e3 = (e3 = 'Hello, Safari user! To download this file...\n1. Go to File --> Save As.\n2. Choose "Page Source" as the Format.\n') + '3. Name it with this extension: ."'.concat(t3[1], '"'), alert(e3)), o2.click());
          }, v.default.prototype._checkFileExtension = i, v.default.prototype._isSafari = function() {
            return 0 < Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor");
          };
          e2 = v.default;
          r.default = e2;
        }, { "../core/friendly_errors/fes_core": 258, "../core/friendly_errors/file_errors": 259, "../core/friendly_errors/validate_params": 262, "../core/main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.includes": 156, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.last-index-of": 160, "core-js/modules/es.array.slice": 162, "core-js/modules/es.array.splice": 164, "core-js/modules/es.function.name": 165, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.promise": 178, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.includes": 185, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.replace": 189, "core-js/modules/es.string.split": 191, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.typed-array.copy-within": 197, "core-js/modules/es.typed-array.every": 198, "core-js/modules/es.typed-array.fill": 199, "core-js/modules/es.typed-array.filter": 200, "core-js/modules/es.typed-array.find": 202, "core-js/modules/es.typed-array.find-index": 201, "core-js/modules/es.typed-array.for-each": 205, "core-js/modules/es.typed-array.includes": 206, "core-js/modules/es.typed-array.index-of": 207, "core-js/modules/es.typed-array.iterator": 210, "core-js/modules/es.typed-array.join": 211, "core-js/modules/es.typed-array.last-index-of": 212, "core-js/modules/es.typed-array.map": 213, "core-js/modules/es.typed-array.reduce": 215, "core-js/modules/es.typed-array.reduce-right": 214, "core-js/modules/es.typed-array.reverse": 216, "core-js/modules/es.typed-array.set": 217, "core-js/modules/es.typed-array.slice": 218, "core-js/modules/es.typed-array.some": 219, "core-js/modules/es.typed-array.sort": 220, "core-js/modules/es.typed-array.subarray": 221, "core-js/modules/es.typed-array.to-locale-string": 222, "core-js/modules/es.typed-array.to-string": 223, "core-js/modules/es.typed-array.uint8-array": 226, "core-js/modules/web.dom-collections.iterator": 230, "core-js/modules/web.url": 232, "es6-promise/auto": 233, "fetch-jsonp": 235, "file-saver": 236, "whatwg-fetch": 245 }], 294: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.regexp.constructor"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.match"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.trim"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.regexp.constructor"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.match"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.trim"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var o = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          o.default.Table = function(e3) {
            this.columns = [], this.rows = [];
          }, o.default.Table.prototype.addRow = function(e3) {
            e3 = e3 || new o.default.TableRow();
            if (void 0 === e3.arr || void 0 === e3.obj)
              throw new Error("invalid TableRow: ".concat(e3));
            return (e3.table = this).rows.push(e3), e3;
          }, o.default.Table.prototype.removeRow = function(e3) {
            this.rows[e3].table = null;
            e3 = this.rows.splice(e3 + 1, this.rows.length);
            this.rows.pop(), this.rows = this.rows.concat(e3);
          }, o.default.Table.prototype.getRow = function(e3) {
            return this.rows[e3];
          }, o.default.Table.prototype.getRows = function() {
            return this.rows;
          }, o.default.Table.prototype.findRow = function(e3, t3) {
            if ("string" == typeof t3) {
              for (var r2 = 0; r2 < this.rows.length; r2++)
                if (this.rows[r2].obj[t3] === e3)
                  return this.rows[r2];
            } else
              for (var o2 = 0; o2 < this.rows.length; o2++)
                if (this.rows[o2].arr[t3] === e3)
                  return this.rows[o2];
            return null;
          }, o.default.Table.prototype.findRows = function(e3, t3) {
            var r2 = [];
            if ("string" == typeof t3)
              for (var o2 = 0; o2 < this.rows.length; o2++)
                this.rows[o2].obj[t3] === e3 && r2.push(this.rows[o2]);
            else
              for (var n = 0; n < this.rows.length; n++)
                this.rows[n].arr[t3] === e3 && r2.push(this.rows[n]);
            return r2;
          }, o.default.Table.prototype.matchRow = function(e3, t3) {
            if ("number" == typeof t3) {
              for (var r2 = 0; r2 < this.rows.length; r2++)
                if (this.rows[r2].arr[t3].match(e3))
                  return this.rows[r2];
            } else
              for (var o2 = 0; o2 < this.rows.length; o2++)
                if (this.rows[o2].obj[t3].match(e3))
                  return this.rows[o2];
            return null;
          }, o.default.Table.prototype.matchRows = function(e3, t3) {
            var r2 = [];
            if ("number" == typeof t3)
              for (var o2 = 0; o2 < this.rows.length; o2++)
                this.rows[o2].arr[t3].match(e3) && r2.push(this.rows[o2]);
            else
              for (var n = 0; n < this.rows.length; n++)
                this.rows[n].obj[t3].match(e3) && r2.push(this.rows[n]);
            return r2;
          }, o.default.Table.prototype.getColumn = function(e3) {
            var t3 = [];
            if ("string" == typeof e3)
              for (var r2 = 0; r2 < this.rows.length; r2++)
                t3.push(this.rows[r2].obj[e3]);
            else
              for (var o2 = 0; o2 < this.rows.length; o2++)
                t3.push(this.rows[o2].arr[e3]);
            return t3;
          }, o.default.Table.prototype.clearRows = function() {
            delete this.rows, this.rows = [];
          }, o.default.Table.prototype.addColumn = function(e3) {
            this.columns.push(e3 || null);
          }, o.default.Table.prototype.getColumnCount = function() {
            return this.columns.length;
          }, o.default.Table.prototype.getRowCount = function() {
            return this.rows.length;
          }, o.default.Table.prototype.removeTokens = function(e3, t3) {
            for (var r2 = [], o2 = 0; o2 < e3.length; o2++)
              r2.push(e3.charAt(o2).replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"));
            var n = new RegExp(r2.join("|"), "g");
            if (void 0 === t3)
              for (var s2 = 0; s2 < this.columns.length; s2++)
                for (var i = 0; i < this.rows.length; i++) {
                  var a = (a = this.rows[i].arr[s2]).replace(n, "");
                  this.rows[i].arr[s2] = a, this.rows[i].obj[this.columns[s2]] = a;
                }
            else if ("string" == typeof t3)
              for (var l = 0; l < this.rows.length; l++) {
                var u = (u = this.rows[l].obj[t3]).replace(n, ""), c = (this.rows[l].obj[t3] = u, this.columns.indexOf(t3));
                this.rows[l].arr[c] = u;
              }
            else
              for (var d = 0; d < this.rows.length; d++) {
                var f = (f = this.rows[d].arr[t3]).replace(n, "");
                this.rows[d].arr[t3] = f, this.rows[d].obj[this.columns[t3]] = f;
              }
          }, o.default.Table.prototype.trim = function(e3) {
            var t3 = new RegExp(" ", "g");
            if (void 0 === e3)
              for (var r2 = 0; r2 < this.columns.length; r2++)
                for (var o2 = 0; o2 < this.rows.length; o2++) {
                  var n = (n = this.rows[o2].arr[r2]).replace(t3, "");
                  this.rows[o2].arr[r2] = n, this.rows[o2].obj[this.columns[r2]] = n;
                }
            else if ("string" == typeof e3)
              for (var s2 = 0; s2 < this.rows.length; s2++) {
                var i = (i = this.rows[s2].obj[e3]).replace(t3, ""), a = (this.rows[s2].obj[e3] = i, this.columns.indexOf(e3));
                this.rows[s2].arr[a] = i;
              }
            else
              for (var l = 0; l < this.rows.length; l++) {
                var u = (u = this.rows[l].arr[e3]).replace(t3, "");
                this.rows[l].arr[e3] = u, this.rows[l].obj[this.columns[e3]] = u;
              }
          }, o.default.Table.prototype.removeColumn = function(e3) {
            "string" == typeof e3 ? r2 = this.columns.indexOf(t3 = e3) : t3 = this.columns[r2 = e3];
            var t3, r2, e3 = this.columns.splice(r2 + 1, this.columns.length);
            this.columns.pop(), this.columns = this.columns.concat(e3);
            for (var o2 = 0; o2 < this.rows.length; o2++) {
              var n = this.rows[o2].arr, s2 = n.splice(r2 + 1, n.length);
              n.pop(), this.rows[o2].arr = n.concat(s2), delete this.rows[o2].obj[t3];
            }
          }, o.default.Table.prototype.set = function(e3, t3, r2) {
            this.rows[e3].set(t3, r2);
          }, o.default.Table.prototype.setNum = function(e3, t3, r2) {
            this.rows[e3].setNum(t3, r2);
          }, o.default.Table.prototype.setString = function(e3, t3, r2) {
            this.rows[e3].setString(t3, r2);
          }, o.default.Table.prototype.get = function(e3, t3) {
            return this.rows[e3].get(t3);
          }, o.default.Table.prototype.getNum = function(e3, t3) {
            return this.rows[e3].getNum(t3);
          }, o.default.Table.prototype.getString = function(e3, t3) {
            return this.rows[e3].getString(t3);
          }, o.default.Table.prototype.getObject = function(e3) {
            for (var t3, r2 = {}, o2 = 0; o2 < this.rows.length; o2++)
              if (t3 = this.rows[o2].obj, "string" == typeof e3) {
                if (!(0 <= this.columns.indexOf(e3)))
                  throw new Error('This table has no column named "'.concat(e3, '"'));
                r2[t3[e3]] = t3;
              } else
                r2[o2] = this.rows[o2].obj;
            return r2;
          }, o.default.Table.prototype.getArray = function() {
            for (var e3 = [], t3 = 0; t3 < this.rows.length; t3++)
              e3.push(this.rows[t3].arr);
            return e3;
          };
          e2 = o.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.join": 159, "core-js/modules/es.array.splice": 164, "core-js/modules/es.regexp.constructor": 180, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.match": 187, "core-js/modules/es.string.replace": 189, "core-js/modules/es.string.trim": 193 }], 295: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.split"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          e2.default.TableRow = function(e3, t3) {
            var r2 = [], o = {};
            e3 && (r2 = e3.split(t3 = t3 || ","));
            for (var n = 0; n < r2.length; n++) {
              var s2 = n, i = r2[n];
              o[s2] = i;
            }
            this.arr = r2, this.obj = o, this.table = null;
          }, e2.default.TableRow.prototype.set = function(e3, t3) {
            if ("string" == typeof e3) {
              var r2 = this.table.columns.indexOf(e3);
              if (!(0 <= r2))
                throw new Error('This table has no column named "'.concat(e3, '"'));
              this.obj[e3] = t3, this.arr[r2] = t3;
            } else {
              if (!(e3 < this.table.columns.length))
                throw new Error("Column #".concat(e3, " is out of the range of this table"));
              this.arr[e3] = t3;
              r2 = this.table.columns[e3];
              this.obj[r2] = t3;
            }
          }, e2.default.TableRow.prototype.setNum = function(e3, t3) {
            t3 = parseFloat(t3);
            this.set(e3, t3);
          }, e2.default.TableRow.prototype.setString = function(e3, t3) {
            t3 = t3.toString();
            this.set(e3, t3);
          }, e2.default.TableRow.prototype.get = function(e3) {
            return ("string" == typeof e3 ? this.obj : this.arr)[e3];
          }, e2.default.TableRow.prototype.getNum = function(e3) {
            var t3 = "string" == typeof e3 ? parseFloat(this.obj[e3]) : parseFloat(this.arr[e3]);
            if ("NaN" === t3.toString())
              throw "Error: ".concat(this.obj[e3], " is NaN (Not a Number)");
            return t3;
          }, e2.default.TableRow.prototype.getString = function(e3) {
            return ("string" == typeof e3 ? this.obj : this.arr)[e3].toString();
          };
          e2 = e2.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.split": 191 }], 296: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var a = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          function o(e3) {
            for (var t3 = [], r2 = 0; r2 < e3.length; r2++)
              t3.push(new a.default.XML(e3[r2]));
            return t3;
          }
          a.default.XML = function(e3) {
            e3 ? this.DOM = e3 : (e3 = document.implementation.createDocument(null, "doc"), this.DOM = e3.createElement("root"));
          }, a.default.XML.prototype.getParent = function() {
            return new a.default.XML(this.DOM.parentElement);
          }, a.default.XML.prototype.getName = function() {
            return this.DOM.tagName;
          }, a.default.XML.prototype.setName = function(e3) {
            var t3 = this.DOM.innerHTML, r2 = this.DOM.attributes, o2 = document.implementation.createDocument(null, "default").createElement(e3);
            o2.innerHTML = t3;
            for (var n = 0; n < r2.length; n++)
              o2.setAttribute(r2[n].nodeName, r2.nodeValue);
            this.DOM = o2;
          }, a.default.XML.prototype.hasChildren = function() {
            return 0 < this.DOM.children.length;
          }, a.default.XML.prototype.listChildren = function() {
            for (var e3 = [], t3 = 0; t3 < this.DOM.childNodes.length; t3++)
              e3.push(this.DOM.childNodes[t3].nodeName);
            return e3;
          }, a.default.XML.prototype.getChildren = function(e3) {
            return o(e3 ? this.DOM.getElementsByTagName(e3) : this.DOM.children);
          }, a.default.XML.prototype.getChild = function(e3) {
            if ("string" != typeof e3)
              return new a.default.XML(this.DOM.children[e3]);
            var t3 = true, r2 = false, o2 = void 0;
            try {
              for (var n, s2 = this.DOM.children[Symbol.iterator](); !(t3 = (n = s2.next()).done); t3 = true) {
                var i = n.value;
                if (i.tagName === e3)
                  return new a.default.XML(i);
              }
            } catch (e4) {
              r2 = true, o2 = e4;
            } finally {
              try {
                t3 || null == s2.return || s2.return();
              } finally {
                if (r2)
                  throw o2;
              }
            }
          }, a.default.XML.prototype.addChild = function(e3) {
            e3 instanceof a.default.XML && this.DOM.appendChild(e3.DOM);
          }, a.default.XML.prototype.removeChild = function(e3) {
            var t3 = -1;
            if ("string" == typeof e3) {
              for (var r2 = 0; r2 < this.DOM.children.length; r2++)
                if (this.DOM.children[r2].tagName === e3) {
                  t3 = r2;
                  break;
                }
            } else
              t3 = e3;
            -1 !== t3 && this.DOM.removeChild(this.DOM.children[t3]);
          }, a.default.XML.prototype.getAttributeCount = function() {
            return this.DOM.attributes.length;
          }, a.default.XML.prototype.listAttributes = function() {
            var e3 = [], t3 = true, r2 = false, o2 = void 0;
            try {
              for (var n, s2 = this.DOM.attributes[Symbol.iterator](); !(t3 = (n = s2.next()).done); t3 = true) {
                var i = n.value;
                e3.push(i.nodeName);
              }
            } catch (e4) {
              r2 = true, o2 = e4;
            } finally {
              try {
                t3 || null == s2.return || s2.return();
              } finally {
                if (r2)
                  throw o2;
              }
            }
            return e3;
          }, a.default.XML.prototype.hasAttribute = function(e3) {
            var t3 = {}, r2 = true, o2 = false, n = void 0;
            try {
              for (var s2, i = this.DOM.attributes[Symbol.iterator](); !(r2 = (s2 = i.next()).done); r2 = true) {
                var a2 = s2.value;
                t3[a2.nodeName] = a2.nodeValue;
              }
            } catch (e4) {
              o2 = true, n = e4;
            } finally {
              try {
                r2 || null == i.return || i.return();
              } finally {
                if (o2)
                  throw n;
              }
            }
            return !!t3[e3];
          }, a.default.XML.prototype.getNum = function(e3, t3) {
            var r2 = {}, o2 = true, n = false, s2 = void 0;
            try {
              for (var i, a2 = this.DOM.attributes[Symbol.iterator](); !(o2 = (i = a2.next()).done); o2 = true) {
                var l = i.value;
                r2[l.nodeName] = l.nodeValue;
              }
            } catch (e4) {
              n = true, s2 = e4;
            } finally {
              try {
                o2 || null == a2.return || a2.return();
              } finally {
                if (n)
                  throw s2;
              }
            }
            return Number(r2[e3]) || t3 || 0;
          }, a.default.XML.prototype.getString = function(e3, t3) {
            var r2 = {}, o2 = true, n = false, s2 = void 0;
            try {
              for (var i, a2 = this.DOM.attributes[Symbol.iterator](); !(o2 = (i = a2.next()).done); o2 = true) {
                var l = i.value;
                r2[l.nodeName] = l.nodeValue;
              }
            } catch (e4) {
              n = true, s2 = e4;
            } finally {
              try {
                o2 || null == a2.return || a2.return();
              } finally {
                if (n)
                  throw s2;
              }
            }
            return r2[e3] ? String(r2[e3]) : t3 || null;
          }, a.default.XML.prototype.setAttribute = function(e3, t3) {
            this.DOM.setAttribute(e3, t3);
          }, a.default.XML.prototype.getContent = function(e3) {
            var t3 = this.DOM.textContent;
            return (t3 = t3.replace(/\s\s+/g, ",")) || e3 || null;
          }, a.default.XML.prototype.setContent = function(e3) {
            this.DOM.children.length || (this.DOM.textContent = e3);
          }, a.default.XML.prototype.serialize = function() {
            return new XMLSerializer().serializeToString(this.DOM);
          };
          e2 = a.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.number.constructor": 169, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.replace": 189, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/web.dom-collections.iterator": 230 }], 297: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.math.hypot"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.math.hypot"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.string.includes"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var i = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          function o() {
            if ("function" == typeof Math.hypot)
              return Math.hypot.apply(null, arguments);
            for (var e3 = arguments.length, t3 = [], r2 = 0, o2 = 0; o2 < e3; o2++) {
              var n = arguments[o2];
              if ((n = +n) === 1 / 0 || n === -1 / 0)
                return 1 / 0;
              r2 < (n = Math.abs(n)) && (r2 = n), t3[o2] = n;
            }
            0 === r2 && (r2 = 1);
            for (var s2 = 0, i2 = 0, a = 0; a < e3; a++)
              var l = t3[a] / r2, l = l * l - i2, u = s2 + l, i2 = u - s2 - l, s2 = u;
            return Math.sqrt(s2) * r2;
          }
          i.default.prototype.abs = Math.abs, i.default.prototype.ceil = Math.ceil, i.default.prototype.constrain = function(e3, t3, r2) {
            return i.default._validateParameters("constrain", arguments), Math.max(Math.min(e3, r2), t3);
          }, i.default.prototype.dist = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            return i.default._validateParameters("dist", t3), 4 === t3.length ? o(t3[2] - t3[0], t3[3] - t3[1]) : 6 === t3.length ? o(t3[3] - t3[0], t3[4] - t3[1], t3[5] - t3[2]) : void 0;
          }, i.default.prototype.exp = Math.exp, i.default.prototype.floor = Math.floor, i.default.prototype.lerp = function(e3, t3, r2) {
            return i.default._validateParameters("lerp", arguments), r2 * (t3 - e3) + e3;
          }, i.default.prototype.log = Math.log, i.default.prototype.mag = function(e3, t3) {
            return i.default._validateParameters("mag", arguments), o(e3, t3);
          }, i.default.prototype.map = function(e3, t3, r2, o2, n, s2) {
            i.default._validateParameters("map", arguments);
            e3 = (e3 - t3) / (r2 - t3) * (n - o2) + o2;
            return s2 ? o2 < n ? this.constrain(e3, o2, n) : this.constrain(e3, n, o2) : e3;
          }, i.default.prototype.max = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            return t3[0] instanceof Array ? Math.max.apply(null, t3[0]) : Math.max.apply(null, t3);
          }, i.default.prototype.min = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            return t3[0] instanceof Array ? Math.min.apply(null, t3[0]) : Math.min.apply(null, t3);
          }, i.default.prototype.norm = function(e3, t3, r2) {
            return i.default._validateParameters("norm", arguments), this.map(e3, t3, r2, 0, 1);
          }, i.default.prototype.pow = Math.pow, i.default.prototype.round = function(e3, t3) {
            return t3 ? (t3 = Math.pow(10, t3), Math.round(e3 * t3) / t3) : Math.round(e3);
          }, i.default.prototype.sq = function(e3) {
            return e3 * e3;
          }, i.default.prototype.sqrt = Math.sqrt, i.default.prototype.fract = function(e3) {
            i.default._validateParameters("fract", arguments);
            var t3, r2 = 0, e3 = Number(e3);
            return isNaN(e3) || Math.abs(e3) === 1 / 0 ? e3 : (e3 < 0 && (e3 = -e3, r2 = 1), String(e3).includes(".") && !String(e3).includes("e") ? (t3 = String(e3), t3 = Number("0" + t3.slice(t3.indexOf("."))), Math.abs(r2 - t3)) : e3 < 1 ? Math.abs(r2 - e3) : 0);
          };
          e2 = i.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.includes": 156, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.map": 161, "core-js/modules/es.array.slice": 162, "core-js/modules/es.math.hypot": 167, "core-js/modules/es.number.constructor": 169, "core-js/modules/es.string.includes": 185 }], 298: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.reflect.construct"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.reflect.construct"), e2("core-js/modules/es.regexp.to-string"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var o = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          function n(e3, t3, r2) {
            return (n = function() {
              if ("undefined" != typeof Reflect && Reflect.construct && !Reflect.construct.sham) {
                if ("function" == typeof Proxy)
                  return 1;
                try {
                  return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                  })), 1;
                } catch (e4) {
                }
              }
            }() ? Reflect.construct : function(e4, t4, r3) {
              var o2 = [null];
              o2.push.apply(o2, t4);
              t4 = new (Function.bind.apply(e4, o2))();
              return r3 && s2(t4, r3.prototype), t4;
            }).apply(null, arguments);
          }
          function s2(e3, t3) {
            return (s2 = Object.setPrototypeOf || function(e4, t4) {
              return e4.__proto__ = t4, e4;
            })(e3, t3);
          }
          o.default.prototype.createVector = function(e3, t3, r2) {
            return this instanceof o.default ? n(o.default.Vector, [this._fromRadians.bind(this), this._toRadians.bind(this)].concat(Array.prototype.slice.call(arguments))) : new o.default.Vector(e3, t3, r2);
          };
          e2 = o.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.reflect.construct": 179, "core-js/modules/es.regexp.to-string": 182 }], 299: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          function b(e3) {
            return 0.5 * (1 - Math.cos(e3 * Math.PI));
          }
          var j, _ = 4095, x = 4, w = 0.5, e2 = (e2.default.prototype.noise = function(e3) {
            var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0;
            if (null == j) {
              j = new Array(4096);
              for (var o = 0; o < 4096; o++)
                j[o] = Math.random();
            }
            e3 < 0 && (e3 = -e3), t3 < 0 && (t3 = -t3), r2 < 0 && (r2 = -r2);
            for (var n, s2, i = Math.floor(e3), a = Math.floor(t3), l = Math.floor(r2), u = e3 - i, c = t3 - a, d = r2 - l, f = 0, h = 0.5, p = 0; p < x; p++) {
              var m = i + (a << 4) + (l << 8), y = b(u), g = b(c), v = j[m & _];
              v += y * (j[m + 1 & _] - v), n = j[m + 16 & _], v += g * ((n += y * (j[m + 16 + 1 & _] - n)) - v), n = j[(m += 256) & _], n += y * (j[m + 1 & _] - n), s2 = j[m + 16 & _], n += g * ((s2 += y * (j[m + 16 + 1 & _] - s2)) - n), f += (v += b(d) * (n - v)) * h, h *= w, i <<= 1, a <<= 1, l <<= 1, 1 <= (u *= 2) && (i++, u--), 1 <= (c *= 2) && (a++, c--), 1 <= (d *= 2) && (l++, d--);
            }
            return f;
          }, e2.default.prototype.noiseDetail = function(e3, t3) {
            0 < e3 && (x = e3), 0 < t3 && (w = t3);
          }, e2.default.prototype.noiseSeed = function(e3) {
            o = 4294967296;
            var t3, r2, o, n = { setSeed: function(e4) {
              r2 = t3 = (null == e4 ? Math.random() * o : e4) >>> 0;
            }, getSeed: function() {
              return t3;
            }, rand: function() {
              return (r2 = (1664525 * r2 + 1013904223) % o) / o;
            } };
            n.setSeed(e3), j = new Array(4096);
            for (var s2 = 0; s2 < 4096; s2++)
              j[s2] = n.rand();
          }, e2.default);
          r.default = e2;
        }, { "../core/main": 267 }], 300: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.every"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.some"), e2("core-js/modules/es.math.sign"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.number.is-finite"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.sub"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.every"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.some"), e2("core-js/modules/es.math.sign"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.number.is-finite"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.sub"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var a = (s2 = e2("../core/main")) && s2.__esModule ? s2 : { default: s2 }, n = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = l();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function l() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), l = function() {
              return e3;
            }, e3);
          }
          a.default.Vector = function() {
            var e3, t3, r2 = "[object Function]" === {}.toString.call(arguments[0]) ? (this.isPInst = true, this._fromRadians = arguments[0], this._toRadians = arguments[1], e3 = arguments[2] || 0, t3 = arguments[3] || 0, arguments[4] || 0) : (e3 = arguments[0] || 0, t3 = arguments[1] || 0, arguments[2] || 0);
            this.x = e3, this.y = t3, this.z = r2;
          }, a.default.Vector.prototype.toString = function() {
            return "p5.Vector Object : [".concat(this.x, ", ").concat(this.y, ", ").concat(this.z, "]");
          }, a.default.Vector.prototype.set = function(e3, t3, r2) {
            return e3 instanceof a.default.Vector ? (this.x = e3.x || 0, this.y = e3.y || 0, this.z = e3.z || 0) : e3 instanceof Array ? (this.x = e3[0] || 0, this.y = e3[1] || 0, this.z = e3[2] || 0) : (this.x = e3 || 0, this.y = t3 || 0, this.z = r2 || 0), this;
          }, a.default.Vector.prototype.copy = function() {
            return this.isPInst ? new a.default.Vector(this._fromRadians, this._toRadians, this.x, this.y, this.z) : new a.default.Vector(this.x, this.y, this.z);
          }, a.default.Vector.prototype.add = function(e3, t3, r2) {
            return e3 instanceof a.default.Vector ? (this.x += e3.x || 0, this.y += e3.y || 0, this.z += e3.z || 0) : e3 instanceof Array ? (this.x += e3[0] || 0, this.y += e3[1] || 0, this.z += e3[2] || 0) : (this.x += e3 || 0, this.y += t3 || 0, this.z += r2 || 0), this;
          };
          function u(e3, t3) {
            return 0 !== e3 && (this.x = this.x % e3), 0 !== t3 && (this.y = this.y % t3), this;
          }
          function c(e3, t3, r2) {
            return 0 !== e3 && (this.x = this.x % e3), 0 !== t3 && (this.y = this.y % t3), 0 !== r2 && (this.z = this.z % r2), this;
          }
          a.default.Vector.prototype.rem = function(e3, t3, r2) {
            var o2;
            if (e3 instanceof a.default.Vector) {
              if (Number.isFinite(e3.x) && Number.isFinite(e3.y) && Number.isFinite(e3.z))
                return n2 = parseFloat(e3.x), s3 = parseFloat(e3.y), o2 = parseFloat(e3.z), c.call(this, n2, s3, o2);
            } else if (e3 instanceof Array) {
              if (e3.every(function(e4) {
                return Number.isFinite(e4);
              }))
                return 2 === e3.length ? u.call(this, e3[0], e3[1]) : 3 === e3.length ? c.call(this, e3[0], e3[1], e3[2]) : void 0;
            } else if (1 === arguments.length) {
              if (Number.isFinite(e3) && 0 !== e3)
                return this.x = this.x % e3, this.y = this.y % e3, this.z = this.z % e3, this;
            } else if (2 === arguments.length) {
              var n2 = Array.prototype.slice.call(arguments);
              if (n2.every(function(e4) {
                return Number.isFinite(e4);
              }) && 2 === n2.length)
                return u.call(this, n2[0], n2[1]);
            } else if (3 === arguments.length) {
              var s3 = Array.prototype.slice.call(arguments);
              if (s3.every(function(e4) {
                return Number.isFinite(e4);
              }) && 3 === s3.length)
                return c.call(this, s3[0], s3[1], s3[2]);
            }
          }, a.default.Vector.prototype.sub = function(e3, t3, r2) {
            return e3 instanceof a.default.Vector ? (this.x -= e3.x || 0, this.y -= e3.y || 0, this.z -= e3.z || 0) : e3 instanceof Array ? (this.x -= e3[0] || 0, this.y -= e3[1] || 0, this.z -= e3[2] || 0) : (this.x -= e3 || 0, this.y -= t3 || 0, this.z -= r2 || 0), this;
          }, a.default.Vector.prototype.mult = function(e3, t3, r2) {
            var o2;
            return e3 instanceof a.default.Vector ? Number.isFinite(e3.x) && Number.isFinite(e3.y) && Number.isFinite(e3.z) && "number" == typeof e3.x && "number" == typeof e3.y && "number" == typeof e3.z ? (this.x *= e3.x, this.y *= e3.y, this.z *= e3.z) : console.warn("p5.Vector.prototype.mult:", "x contains components that are either undefined or not finite numbers") : e3 instanceof Array ? e3.every(function(e4) {
              return Number.isFinite(e4);
            }) && e3.every(function(e4) {
              return "number" == typeof e4;
            }) ? 1 === e3.length ? (this.x *= e3[0], this.y *= e3[0], this.z *= e3[0]) : 2 === e3.length ? (this.x *= e3[0], this.y *= e3[1]) : 3 === e3.length && (this.x *= e3[0], this.y *= e3[1], this.z *= e3[2]) : console.warn("p5.Vector.prototype.mult:", "x contains elements that are either undefined or not finite numbers") : (o2 = Array.prototype.slice.call(arguments)).every(function(e4) {
              return Number.isFinite(e4);
            }) && o2.every(function(e4) {
              return "number" == typeof e4;
            }) ? (1 === arguments.length && (this.x *= e3, this.y *= e3, this.z *= e3), 2 === arguments.length && (this.x *= e3, this.y *= t3), 3 === arguments.length && (this.x *= e3, this.y *= t3, this.z *= r2)) : console.warn("p5.Vector.prototype.mult:", "x, y, or z arguments are either undefined or not a finite number"), this;
          }, a.default.Vector.prototype.div = function(e3, t3, r2) {
            if (e3 instanceof a.default.Vector)
              if (Number.isFinite(e3.x) && Number.isFinite(e3.y) && Number.isFinite(e3.z) && "number" == typeof e3.x && "number" == typeof e3.y && "number" == typeof e3.z) {
                if (0 === e3.x || 0 === e3.y || 0 === e3.z)
                  return console.warn("p5.Vector.prototype.div:", "divide by 0"), this;
                this.x /= e3.x, this.y /= e3.y, this.z /= e3.z;
              } else
                console.warn("p5.Vector.prototype.div:", "x contains components that are either undefined or not finite numbers");
            else if (e3 instanceof Array)
              if (e3.every(function(e4) {
                return Number.isFinite(e4);
              }) && e3.every(function(e4) {
                return "number" == typeof e4;
              })) {
                if (e3.some(function(e4) {
                  return 0 === e4;
                }))
                  return console.warn("p5.Vector.prototype.div:", "divide by 0"), this;
                1 === e3.length ? (this.x /= e3[0], this.y /= e3[0], this.z /= e3[0]) : 2 === e3.length ? (this.x /= e3[0], this.y /= e3[1]) : 3 === e3.length && (this.x /= e3[0], this.y /= e3[1], this.z /= e3[2]);
              } else
                console.warn("p5.Vector.prototype.div:", "x contains components that are either undefined or not finite numbers");
            else {
              var o2 = Array.prototype.slice.call(arguments);
              if (o2.every(function(e4) {
                return Number.isFinite(e4);
              }) && o2.every(function(e4) {
                return "number" == typeof e4;
              })) {
                if (o2.some(function(e4) {
                  return 0 === e4;
                }))
                  return console.warn("p5.Vector.prototype.div:", "divide by 0"), this;
                1 === arguments.length && (this.x /= e3, this.y /= e3, this.z /= e3), 2 === arguments.length && (this.x /= e3, this.y /= t3), 3 === arguments.length && (this.x /= e3, this.y /= t3, this.z /= r2);
              } else
                console.warn("p5.Vector.prototype.div:", "x, y, or z arguments are either undefined or not a finite number");
            }
            return this;
          }, a.default.Vector.prototype.mag = function() {
            return Math.sqrt(this.magSq());
          }, a.default.Vector.prototype.magSq = function() {
            var e3 = this.x, t3 = this.y, r2 = this.z;
            return e3 * e3 + t3 * t3 + r2 * r2;
          }, a.default.Vector.prototype.dot = function(e3, t3, r2) {
            return e3 instanceof a.default.Vector ? this.dot(e3.x, e3.y, e3.z) : this.x * (e3 || 0) + this.y * (t3 || 0) + this.z * (r2 || 0);
          }, a.default.Vector.prototype.cross = function(e3) {
            var t3 = this.y * e3.z - this.z * e3.y, r2 = this.z * e3.x - this.x * e3.z, e3 = this.x * e3.y - this.y * e3.x;
            return this.isPInst ? new a.default.Vector(this._fromRadians, this._toRadians, t3, r2, e3) : new a.default.Vector(t3, r2, e3);
          }, a.default.Vector.prototype.dist = function(e3) {
            return e3.copy().sub(this).mag();
          }, a.default.Vector.prototype.normalize = function() {
            var e3 = this.mag();
            return 0 !== e3 && this.mult(1 / e3), this;
          }, a.default.Vector.prototype.limit = function(e3) {
            var t3 = this.magSq();
            return e3 * e3 < t3 && this.div(Math.sqrt(t3)).mult(e3), this;
          }, a.default.Vector.prototype.setMag = function(e3) {
            return this.normalize().mult(e3);
          }, a.default.Vector.prototype.heading = function() {
            var e3 = Math.atan2(this.y, this.x);
            return this.isPInst ? this._fromRadians(e3) : e3;
          }, a.default.Vector.prototype.setHeading = function(e3) {
            this.isPInst && (e3 = this._toRadians(e3));
            var t3 = this.mag();
            return this.x = t3 * Math.cos(e3), this.y = t3 * Math.sin(e3), this;
          }, a.default.Vector.prototype.rotate = function(e3) {
            var e3 = this.heading() + e3, t3 = (this.isPInst && (e3 = this._toRadians(e3)), this.mag());
            return this.x = Math.cos(e3) * t3, this.y = Math.sin(e3) * t3, this;
          }, a.default.Vector.prototype.angleBetween = function(e3) {
            var t3 = this.dot(e3) / (this.mag() * e3.mag()), t3 = Math.acos(Math.min(1, Math.max(-1, t3)));
            return t3 *= Math.sign(this.cross(e3).z || 1), t3 = this.isPInst ? this._fromRadians(t3) : t3;
          }, a.default.Vector.prototype.lerp = function(e3, t3, r2, o2) {
            return e3 instanceof a.default.Vector ? this.lerp(e3.x, e3.y, e3.z, t3) : (this.x += (e3 - this.x) * o2 || 0, this.y += (t3 - this.y) * o2 || 0, this.z += (r2 - this.z) * o2 || 0, this);
          }, a.default.Vector.prototype.reflect = function(e3) {
            return e3.normalize(), this.sub(e3.mult(2 * this.dot(e3)));
          }, a.default.Vector.prototype.array = function() {
            return [this.x || 0, this.y || 0, this.z || 0];
          }, a.default.Vector.prototype.equals = function(e3, t3, r2) {
            var o2, n2, e3 = e3 instanceof a.default.Vector ? (o2 = e3.x || 0, n2 = e3.y || 0, e3.z || 0) : e3 instanceof Array ? (o2 = e3[0] || 0, n2 = e3[1] || 0, e3[2] || 0) : (o2 = e3 || 0, n2 = t3 || 0, r2 || 0);
            return this.x === o2 && this.y === n2 && this.z === e3;
          }, a.default.Vector.fromAngle = function(e3, t3) {
            return new a.default.Vector((t3 = void 0 === t3 ? 1 : t3) * Math.cos(e3), t3 * Math.sin(e3), 0);
          }, a.default.Vector.fromAngles = function(e3, t3, r2) {
            void 0 === r2 && (r2 = 1);
            var o2 = Math.cos(t3), t3 = Math.sin(t3), n2 = Math.cos(e3), e3 = Math.sin(e3);
            return new a.default.Vector(r2 * e3 * t3, -r2 * n2, r2 * e3 * o2);
          }, a.default.Vector.random2D = function() {
            return this.fromAngle(Math.random() * n.TWO_PI);
          }, a.default.Vector.random3D = function() {
            var e3 = Math.random() * n.TWO_PI, t3 = 2 * Math.random() - 1, r2 = Math.sqrt(1 - t3 * t3), o2 = r2 * Math.cos(e3), r2 = r2 * Math.sin(e3);
            return new a.default.Vector(o2, r2, t3);
          }, a.default.Vector.add = function(e3, t3, r2) {
            return r2 ? r2.set(e3) : (r2 = e3.copy(), 3 === arguments.length && a.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.add")), r2.add(t3), r2;
          }, a.default.Vector.rem = function(e3, t3) {
            if (e3 instanceof a.default.Vector && t3 instanceof a.default.Vector)
              return (e3 = e3.copy()).rem(t3), e3;
          }, a.default.Vector.sub = function(e3, t3, r2) {
            return r2 ? r2.set(e3) : (r2 = e3.copy(), 3 === arguments.length && a.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.sub")), r2.sub(t3), r2;
          }, a.default.Vector.mult = function(e3, t3, r2) {
            return r2 ? r2.set(e3) : (r2 = e3.copy(), 3 === arguments.length && a.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.mult")), r2.mult(t3), r2;
          }, a.default.Vector.rotate = function(e3, t3, r2) {
            return 2 === arguments.length ? r2 = e3.copy() : (r2 instanceof a.default.Vector || a.default._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.rotate"), r2.set(e3)), r2.rotate(t3), r2;
          }, a.default.Vector.div = function(e3, t3, r2) {
            return r2 ? r2.set(e3) : (r2 = e3.copy(), 3 === arguments.length && a.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.div")), r2.div(t3), r2;
          }, a.default.Vector.dot = function(e3, t3) {
            return e3.dot(t3);
          }, a.default.Vector.cross = function(e3, t3) {
            return e3.cross(t3);
          }, a.default.Vector.dist = function(e3, t3) {
            return e3.dist(t3);
          }, a.default.Vector.lerp = function(e3, t3, r2, o2) {
            return o2 ? o2.set(e3) : (o2 = e3.copy(), 4 === arguments.length && a.default._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.lerp")), o2.lerp(t3, r2), o2;
          }, a.default.Vector.mag = function(e3) {
            var t3 = e3.x, r2 = e3.y, e3 = e3.z;
            return Math.sqrt(t3 * t3 + r2 * r2 + e3 * e3);
          }, a.default.Vector.normalize = function(e3, t3) {
            return arguments.length < 2 ? t3 = e3.copy() : (t3 instanceof a.default.Vector || a.default._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.normalize"), t3.set(e3)), t3.normalize();
          };
          var s2 = a.default.Vector;
          r.default = s2;
        }, { "../core/constants": 256, "../core/main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.every": 151, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.slice": 162, "core-js/modules/es.array.some": 163, "core-js/modules/es.math.sign": 168, "core-js/modules/es.number.constructor": 169, "core-js/modules/es.number.is-finite": 170, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.sub": 192, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 301: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          var s2 = "_lcg_random_state", o = 4294967296, i = 0, e2 = (n.default.prototype._lcg = function(e3) {
            return this[e3] = (1664525 * this[e3] + 1013904223) % o, this[e3] / o;
          }, n.default.prototype._lcgSetSeed = function(e3, t3) {
            this[e3] = (null == t3 ? Math.random() * o : t3) >>> 0;
          }, n.default.prototype.randomSeed = function(e3) {
            this._lcgSetSeed(s2, e3), this._gaussian_previous = false;
          }, n.default.prototype.random = function(e3, t3) {
            var r2, o2;
            return n.default._validateParameters("random", arguments), r2 = null != this[s2] ? this._lcg(s2) : Math.random(), void 0 === e3 ? r2 : void 0 === t3 ? e3 instanceof Array ? e3[Math.floor(r2 * e3.length)] : r2 * e3 : (t3 < e3 && (o2 = e3, e3 = t3, t3 = o2), r2 * (t3 - e3) + e3);
          }, n.default.prototype.randomGaussian = function(e3) {
            var t3, r2, o2, n2, s3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1;
            if (this._gaussian_previous)
              t3 = i, this._gaussian_previous = false;
            else {
              for (; 1 <= (n2 = (r2 = this.random(2) - 1) * r2 + (o2 = this.random(2) - 1) * o2); )
                ;
              t3 = r2 * (n2 = Math.sqrt(-2 * Math.log(n2) / n2)), i = o2 * n2, this._gaussian_previous = true;
            }
            return t3 * s3 + (e3 || 0);
          }, n.default);
          r.default = e2;
        }, { "../core/main": 267 }], 302: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (l = e2("../core/main")) && l.__esModule ? l : { default: l }, s2 = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          n.default.prototype._angleMode = s2.RADIANS, n.default.prototype.acos = function(e3) {
            return this._fromRadians(Math.acos(e3));
          }, n.default.prototype.asin = function(e3) {
            return this._fromRadians(Math.asin(e3));
          }, n.default.prototype.atan = function(e3) {
            return this._fromRadians(Math.atan(e3));
          }, n.default.prototype.atan2 = function(e3, t3) {
            return this._fromRadians(Math.atan2(e3, t3));
          }, n.default.prototype.cos = function(e3) {
            return Math.cos(this._toRadians(e3));
          }, n.default.prototype.sin = function(e3) {
            return Math.sin(this._toRadians(e3));
          }, n.default.prototype.tan = function(e3) {
            return Math.tan(this._toRadians(e3));
          }, n.default.prototype.degrees = function(e3) {
            return e3 * s2.RAD_TO_DEG;
          }, n.default.prototype.radians = function(e3) {
            return e3 * s2.DEG_TO_RAD;
          }, n.default.prototype.angleMode = function(e3) {
            if (n.default._validateParameters("angleMode", arguments), void 0 === e3)
              return this._angleMode;
            e3 !== s2.DEGREES && e3 !== s2.RADIANS || (this._angleMode = e3);
          }, n.default.prototype._toRadians = function(e3) {
            return this._angleMode === s2.DEGREES ? e3 * s2.DEG_TO_RAD : e3;
          }, n.default.prototype._toDegrees = function(e3) {
            return this._angleMode === s2.RADIANS ? e3 * s2.RAD_TO_DEG : e3;
          }, n.default.prototype._fromRadians = function(e3) {
            return this._angleMode === s2.DEGREES ? e3 * s2.RAD_TO_DEG : e3;
          };
          var l = n.default;
          r.default = l;
        }, { "../core/constants": 256, "../core/main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 303: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          n.default.prototype.textAlign = function(e3, t3) {
            var r2;
            return n.default._validateParameters("textAlign", arguments), (r2 = this._renderer).textAlign.apply(r2, arguments);
          }, n.default.prototype.textLeading = function(e3) {
            var t3;
            return n.default._validateParameters("textLeading", arguments), (t3 = this._renderer).textLeading.apply(t3, arguments);
          }, n.default.prototype.textSize = function(e3) {
            var t3;
            return n.default._validateParameters("textSize", arguments), (t3 = this._renderer).textSize.apply(t3, arguments);
          }, n.default.prototype.textStyle = function(e3) {
            var t3;
            return n.default._validateParameters("textStyle", arguments), (t3 = this._renderer).textStyle.apply(t3, arguments);
          }, n.default.prototype.textWidth = function() {
            for (var e3, t3 = arguments.length, r2 = new Array(t3), o = 0; o < t3; o++)
              r2[o] = arguments[o];
            return r2[0] += "", n.default._validateParameters("textWidth", r2), 0 === r2[0].length ? 0 : (e3 = this._renderer).textWidth.apply(e3, r2);
          }, n.default.prototype.textAscent = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            return n.default._validateParameters("textAscent", t3), this._renderer.textAscent();
          }, n.default.prototype.textDescent = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            return n.default._validateParameters("textDescent", t3), this._renderer.textDescent();
          }, n.default.prototype._updateTextMetrics = function() {
            return this._renderer._updateTextMetrics();
          }, n.default.prototype.textWrap = function(e3) {
            if ("WORD" !== e3 && "CHAR" !== e3)
              throw "Error: textWrap accepts only WORD or CHAR";
            return this._renderer.textWrap(e3);
          };
          e2 = n.default;
          r.default = e2;
        }, { "../core/main": 267 }], 304: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.last-index-of"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.last-index-of"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.split"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var l = (c = e2("../core/main")) && c.__esModule ? c : { default: c }, n = s2(e2("../core/constants")), u = s2(e2("opentype.js"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          function s2(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2, n2 = {}, s3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3)
              Object.prototype.hasOwnProperty.call(e3, r2) && ((o2 = s3 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (o2.get || o2.set) ? Object.defineProperty(n2, r2, o2) : n2[r2] = e3[r2]);
            return n2.default = e3, t3 && t3.set(e3, n2), n2;
          }
          e2("../core/friendly_errors/validate_params"), e2("../core/friendly_errors/file_errors"), e2("../core/friendly_errors/fes_core"), l.default.prototype.loadFont = function(o2, n2, s3) {
            l.default._validateParameters("loadFont", arguments);
            var i2 = new l.default.Font(this), a2 = this;
            return u.load(o2, function(e3, t3) {
              if (e3)
                return l.default._friendlyFileLoadError(4, o2), void 0 !== s3 ? s3(e3) : void console.error(e3, o2);
              i2.font = t3, void 0 !== n2 && n2(i2), a2._decrementPreload();
              var e3 = o2.split("\\").pop().split("/").pop(), t3 = e3.lastIndexOf("."), r2 = t3 < 1 ? null : e3.slice(t3 + 1);
              ["ttf", "otf", "woff", "woff2"].includes(r2) && (r2 = e3.slice(0, -1 !== t3 ? t3 : 0), (e3 = document.createElement("style")).appendChild(document.createTextNode("\n@font-face {\nfont-family: ".concat(r2, ";\nsrc: url(").concat(o2, ");\n}\n"))), document.head.appendChild(e3));
            }), i2;
          }, l.default.prototype.text = function(e3, t3, r2, o2, n2) {
            var s3;
            return l.default._validateParameters("text", arguments), this._renderer._doFill || this._renderer._doStroke ? (s3 = this._renderer).text.apply(s3, arguments) : this;
          }, l.default.prototype.textFont = function(e3, t3) {
            if (l.default._validateParameters("textFont", arguments), arguments.length) {
              if (e3)
                return this._renderer._setProperty("_textFont", e3), t3 && (this._renderer._setProperty("_textSize", t3), this._renderer._leadingSet || this._renderer._setProperty("_textLeading", t3 * n._DEFAULT_LEADMULT)), this._renderer._applyTextProperties();
              throw new Error("null font passed to textFont");
            }
            return this._renderer._textFont;
          };
          var c = l.default;
          r.default = c;
        }, { "../core/constants": 256, "../core/friendly_errors/fes_core": 258, "../core/friendly_errors/file_errors": 259, "../core/friendly_errors/validate_params": 262, "../core/main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.includes": 156, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.last-index-of": 160, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.split": 191, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230, "opentype.js": 241 }], 305: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.number.to-fixed"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.number.to-fixed"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.split"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (n = e2("../core/main")) && n.__esModule ? n : { default: n }, v = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== p(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = i();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s2;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s2 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s2.get || s2.set) ? Object.defineProperty(o2, r2, s2) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function i() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), i = function() {
              return e3;
            }, e3);
          }
          function p(e3) {
            return (p = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          function m(e3, t3) {
            var r2 = e3.length;
            return e3[t3 < 0 ? t3 % r2 + r2 : t3 % r2];
          }
          function y(e3, t3, r2, o2) {
            var n2, s2, i2;
            return o2 ? (void 0 === y.tmpPoint1 && (y.tmpPoint1 = [], y.tmpPoint2 = []), s2 = y.tmpPoint1, i2 = y.tmpPoint2, s2.x = t3.x - e3.x, s2.y = t3.y - e3.y, i2.x = r2.x - t3.x, i2.y = r2.y - t3.y, n2 = s2.x * i2.x + s2.y * i2.y, s2 = Math.sqrt(s2.x * s2.x + s2.y * s2.y), i2 = Math.sqrt(i2.x * i2.x + i2.y * i2.y), Math.acos(n2 / (s2 * i2)) < o2) : 0 == (t3[0] - e3[0]) * (r2[1] - e3[1]) - (r2[0] - e3[0]) * (t3[1] - e3[1]);
          }
          function d(e3, t3, r2, o2, n2, s2, i2, a, l) {
            var u = 1 - l, c = Math.pow(u, 3), d2 = Math.pow(u, 2), f2 = l * l, h2 = f2 * l, p2 = c * e3 + 3 * d2 * l * r2 + 3 * u * l * l * n2 + h2 * i2, c = c * t3 + 3 * d2 * l * o2 + 3 * u * l * l * s2 + h2 * a, d2 = e3 + 2 * l * (r2 - e3) + f2 * (n2 - 2 * r2 + e3), h2 = t3 + 2 * l * (o2 - t3) + f2 * (s2 - 2 * o2 + t3), m2 = r2 + 2 * l * (n2 - r2) + f2 * (i2 - 2 * n2 + r2), f2 = o2 + 2 * l * (s2 - o2) + f2 * (a - 2 * s2 + o2), e3 = u * e3 + l * r2, r2 = u * t3 + l * o2, t3 = u * n2 + l * i2, o2 = u * s2 + l * a, n2 = 90 - 180 * Math.atan2(d2 - m2, h2 - f2) / Math.PI;
            return (m2 < d2 || h2 < f2) && (n2 += 180), { x: p2, y: c, m: { x: d2, y: h2 }, n: { x: m2, y: f2 }, start: { x: e3, y: r2 }, end: { x: t3, y: o2 }, alpha: n2 };
          }
          function f(e3, t3, r2, o2, n2, s2, i2, a, l) {
            return null == l ? h(e3, t3, r2, o2, n2, s2, i2, a) : d(e3, t3, r2, o2, n2, s2, i2, a, function(e4, t4, r3, o3, n3, s3, i3, a2, l2) {
              if (!(l2 < 0 || h(e4, t4, r3, o3, n3, s3, i3, a2) < l2)) {
                var u, c = 0.5, d2 = 1 - c;
                for (u = h(e4, t4, r3, o3, n3, s3, i3, a2, d2); 0.01 < Math.abs(u - l2); )
                  u = h(e4, t4, r3, o3, n3, s3, i3, a2, d2 += (u < l2 ? 1 : -1) * (c /= 2));
                return d2;
              }
            }(e3, t3, r2, o2, n2, s2, i2, a, l));
          }
          function g(e3, t3, r2) {
            for (var o2, n2, s2, i2, a, l = 0, u = 0, c = (e3 = function(e4, t4) {
              function r3(e5, t5, r4) {
                var o4, n4;
                if (!e5)
                  return ["C", t5.x, t5.y, t5.x, t5.y, t5.x, t5.y];
                switch (e5[0] in { T: 1, Q: 1 } || (t5.qx = t5.qy = null), e5[0]) {
                  case "M":
                    t5.X = e5[1], t5.Y = e5[2];
                    break;
                  case "A":
                    e5 = ["C"].concat(E.apply(0, [t5.x, t5.y].concat(e5.slice(1))));
                    break;
                  case "S":
                    n4 = "C" === r4 || "S" === r4 ? (o4 = 2 * t5.x - t5.bx, 2 * t5.y - t5.by) : (o4 = t5.x, t5.y), e5 = ["C", o4, n4].concat(e5.slice(1));
                    break;
                  case "T":
                    "Q" === r4 || "T" === r4 ? (t5.qx = 2 * t5.x - t5.qx, t5.qy = 2 * t5.y - t5.qy) : (t5.qx = t5.x, t5.qy = t5.y), e5 = ["C"].concat(x(t5.x, t5.y, t5.qx, t5.qy, e5[1], e5[2]));
                    break;
                  case "Q":
                    t5.qx = e5[1], t5.qy = e5[2], e5 = ["C"].concat(x(t5.x, t5.y, e5[1], e5[2], e5[3], e5[4]));
                    break;
                  case "L":
                    e5 = ["C"].concat(_(t5.x, t5.y, e5[1], e5[2]));
                    break;
                  case "H":
                    e5 = ["C"].concat(_(t5.x, t5.y, e5[1], t5.y));
                    break;
                  case "V":
                    e5 = ["C"].concat(_(t5.x, t5.y, t5.x, e5[1]));
                    break;
                  case "Z":
                    e5 = ["C"].concat(_(t5.x, t5.y, t5.X, t5.Y));
                }
                return e5;
              }
              function o3(e5, t5) {
                if (7 < e5[t5].length) {
                  e5[t5].shift();
                  for (var r4 = e5[t5]; r4.length; )
                    c2[t5] = "A", a2 && (d2[t5] = "A"), e5.splice(t5++, 0, ["C"].concat(r4.splice(0, 6)));
                  e5.splice(t5, 1), s3 = Math.max(i3.length, a2 && a2.length || 0);
                }
              }
              function n3(e5, t5, r4, o4, n4) {
                e5 && t5 && "M" === e5[n4][0] && "M" !== t5[n4][0] && (t5.splice(n4, 0, ["M", o4.x, o4.y]), r4.bx = 0, r4.by = 0, r4.x = e5[n4][1], r4.y = e5[n4][2], s3 = Math.max(i3.length, a2 && a2.length || 0));
              }
              var s3, i3 = b(e4), a2 = t4 && b(t4), l2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, u2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, c2 = [], d2 = [], f2 = "", h2 = "";
              s3 = Math.max(i3.length, a2 && a2.length || 0);
              for (var p2 = 0; p2 < s3; p2++) {
                "C" !== (f2 = i3[p2] ? i3[p2][0] : f2) && (c2[p2] = f2, p2 && (h2 = c2[p2 - 1])), i3[p2] = r3(i3[p2], l2, h2), "A" !== c2[p2] && "C" === f2 && (c2[p2] = "C"), o3(i3, p2), a2 && ("C" !== (f2 = a2[p2] ? a2[p2][0] : f2) && (d2[p2] = f2, p2 && (h2 = d2[p2 - 1])), a2[p2] = r3(a2[p2], u2, h2), "A" !== d2[p2] && "C" === f2 && (d2[p2] = "C"), o3(a2, p2)), n3(i3, a2, l2, u2, p2), n3(a2, i3, u2, l2, p2);
                var m2 = i3[p2], y2 = a2 && a2[p2], g2 = m2.length, v2 = a2 && y2.length;
                l2.x = m2[g2 - 2], l2.y = m2[g2 - 1], l2.bx = parseFloat(m2[g2 - 4]) || l2.x, l2.by = parseFloat(m2[g2 - 3]) || l2.y, u2.bx = a2 && (parseFloat(y2[v2 - 4]) || u2.x), u2.by = a2 && (parseFloat(y2[v2 - 3]) || u2.y), u2.x = a2 && y2[v2 - 2], u2.y = a2 && y2[v2 - 1];
              }
              return a2 ? [i3, a2] : i3;
            }(e3)).length; u < c; u++) {
              if ("M" === (s2 = e3[u])[0])
                o2 = +s2[1], n2 = +s2[2];
              else {
                if (t3 < l + (i2 = f(o2, n2, s2[1], s2[2], s2[3], s2[4], s2[5], s2[6])) && !r2)
                  return { x: (a = f(o2, n2, s2[1], s2[2], s2[3], s2[4], s2[5], s2[6], t3 - l)).x, y: a.y, alpha: a.alpha };
                l += i2, o2 = +s2[5], n2 = +s2[6];
              }
              s2.shift();
            }
            return a = (a = r2 ? l : d(o2, n2, s2[0], s2[1], s2[2], s2[3], s2[4], s2[5], 1)).alpha ? { x: a.x, y: a.y, alpha: a.alpha } : a;
          }
          function b(e3) {
            var t3 = [], r2 = 0, o2 = 0, n2 = 0, s2 = 0, i2 = 0;
            if (e3) {
              "M" === e3[0][0] && (n2 = r2 = +e3[0][1], s2 = o2 = +e3[0][2], i2++, t3[0] = ["M", r2, o2]);
              for (var a, l, u = 3 === e3.length && "M" === e3[0][0] && "R" === e3[1][0].toUpperCase() && "Z" === e3[2][0].toUpperCase(), c = i2, d2 = e3.length; c < d2; c++) {
                if (t3.push(a = []), (l = e3[c])[0] !== String.prototype.toUpperCase.call(l[0]))
                  switch (a[0] = String.prototype.toUpperCase.call(l[0]), a[0]) {
                    case "A":
                      a[1] = l[1], a[2] = l[2], a[3] = l[3], a[4] = l[4], a[5] = l[5], a[6] = +(l[6] + r2), a[7] = +(l[7] + o2);
                      break;
                    case "V":
                      a[1] = +l[1] + o2;
                      break;
                    case "H":
                      a[1] = +l[1] + r2;
                      break;
                    case "R":
                      for (var f2, h2 = 2, p2 = (f2 = [r2, o2].concat(l.slice(1))).length; h2 < p2; h2++)
                        f2[h2] = +f2[h2] + r2, f2[++h2] = +f2[h2] + o2;
                      t3.pop(), t3 = t3.concat(j(f2, u));
                      break;
                    case "M":
                      n2 = +l[1] + r2, s2 = +l[2] + o2;
                      break;
                    default:
                      for (var m2 = 1, y2 = l.length; m2 < y2; m2++)
                        a[m2] = +l[m2] + (m2 % 2 ? r2 : o2);
                  }
                else if ("R" === l[0])
                  f2 = [r2, o2].concat(l.slice(1)), t3.pop(), t3 = t3.concat(j(f2, u)), a = ["R"].concat(l.slice(-2));
                else
                  for (var g2 = 0, v2 = l.length; g2 < v2; g2++)
                    a[g2] = l[g2];
                switch (a[0]) {
                  case "Z":
                    r2 = n2, o2 = s2;
                    break;
                  case "H":
                    r2 = a[1];
                    break;
                  case "V":
                    o2 = a[1];
                    break;
                  case "M":
                    n2 = a[a.length - 2], s2 = a[a.length - 1];
                    break;
                  default:
                    r2 = a[a.length - 2], o2 = a[a.length - 1];
                }
              }
            }
            return t3;
          }
          function E(e3, t3, r2, o2, n2, s2, i2, a, l, u) {
            function c(e4, t4, r3) {
              return { x: e4 * Math.cos(r3) - t4 * Math.sin(r3), y: e4 * Math.sin(r3) + t4 * Math.cos(r3) };
            }
            var d2, f2 = Math.PI, h2 = 120 * f2 / 180, p2 = f2 / 180 * (+n2 || 0), m2 = [], y2 = (u ? (x2 = u[0], d2 = u[1], j2 = u[2], _2 = u[3]) : (e3 = (v2 = c(e3, t3, -p2)).x, t3 = v2.y, 1 < (y2 = (g2 = (e3 - (a = (v2 = c(a, l, -p2)).x)) / 2) * g2 / (r2 * r2) + (v2 = (t3 - (l = v2.y)) / 2) * v2 / (o2 * o2)) && (r2 *= y2 = Math.sqrt(y2), o2 *= y2), y2 = r2 * r2, b2 = o2 * o2, j2 = (s2 = (s2 === i2 ? -1 : 1) * Math.sqrt(Math.abs((y2 * b2 - y2 * v2 * v2 - b2 * g2 * g2) / (y2 * v2 * v2 + b2 * g2 * g2)))) * r2 * v2 / o2 + (e3 + a) / 2, _2 = s2 * -o2 * g2 / r2 + (t3 + l) / 2, x2 = Math.asin(((t3 - _2) / o2).toFixed(9)), d2 = Math.asin(((l - _2) / o2).toFixed(9)), (x2 = e3 < j2 ? f2 - x2 : x2) < 0 && (x2 = 2 * f2 + x2), (d2 = a < j2 ? f2 - d2 : d2) < 0 && (d2 = 2 * f2 + d2), i2 && d2 < x2 && (x2 -= 2 * f2), !i2 && x2 < d2 && (d2 -= 2 * f2)), d2 - x2), g2 = (Math.abs(y2) > h2 && (b2 = d2, v2 = a, s2 = l, d2 = x2 + h2 * (i2 && x2 < d2 ? 1 : -1), m2 = E(a = j2 + r2 * Math.cos(d2), l = _2 + o2 * Math.sin(d2), r2, o2, n2, 0, i2, v2, s2, [d2, b2, j2, _2])), y2 = d2 - x2, Math.cos(x2)), f2 = Math.sin(x2), h2 = Math.cos(d2), n2 = Math.sin(d2), i2 = Math.tan(y2 / 4), v2 = 4 / 3 * r2 * i2, s2 = 4 / 3 * o2 * i2, b2 = [e3, t3], j2 = [e3 + v2 * f2, t3 - s2 * g2], _2 = [a + v2 * n2, l - s2 * h2], x2 = [a, l];
            if (j2[0] = 2 * b2[0] - j2[0], j2[1] = 2 * b2[1] - j2[1], u)
              return [j2, _2, x2].concat(m2);
            for (var w2 = [], S = 0, M = (m2 = [j2, _2, x2].concat(m2).join().split(",")).length; S < M; S++)
              w2[S] = S % 2 ? c(m2[S - 1], m2[S], p2).y : c(m2[S], m2[S + 1], p2).x;
            return w2;
          }
          function j(e3, t3) {
            for (var r2 = [], o2 = 0, n2 = e3.length; o2 < n2 - 2 * !t3; o2 += 2) {
              var s2 = [{ x: +e3[o2 - 2], y: +e3[o2 - 1] }, { x: +e3[o2], y: +e3[o2 + 1] }, { x: +e3[o2 + 2], y: +e3[o2 + 3] }, { x: +e3[o2 + 4], y: +e3[o2 + 5] }];
              t3 ? o2 ? n2 - 4 === o2 ? s2[3] = { x: +e3[0], y: +e3[1] } : n2 - 2 === o2 && (s2[2] = { x: +e3[0], y: +e3[1] }, s2[3] = { x: +e3[2], y: +e3[3] }) : s2[0] = { x: +e3[n2 - 2], y: +e3[n2 - 1] } : n2 - 4 === o2 ? s2[3] = s2[2] : o2 || (s2[0] = { x: +e3[o2], y: +e3[o2 + 1] }), r2.push(["C", (-s2[0].x + 6 * s2[1].x + s2[2].x) / 6, (-s2[0].y + 6 * s2[1].y + s2[2].y) / 6, (s2[1].x + 6 * s2[2].x - s2[3].x) / 6, (s2[1].y + 6 * s2[2].y - s2[3].y) / 6, s2[2].x, s2[2].y]);
            }
            return r2;
          }
          function _(e3, t3, r2, o2) {
            return [e3, t3, r2, o2, r2, o2];
          }
          function x(e3, t3, r2, o2, n2, s2) {
            return [1 / 3 * e3 + 2 / 3 * r2, 1 / 3 * t3 + 2 / 3 * o2, 1 / 3 * n2 + 2 / 3 * r2, 1 / 3 * s2 + 2 / 3 * o2, n2, s2];
          }
          function h(e3, t3, r2, o2, n2, s2, i2, a, l) {
            for (var u = (l = 1 < (l = null == l ? 1 : l) ? 1 : l < 0 ? 0 : l) / 2, c = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816], d2 = 0, f2 = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472], h2 = 0; h2 < 12; h2++) {
              var p2 = u * c[h2] + u, m2 = w(p2, e3, r2, n2, i2), p2 = w(p2, t3, o2, s2, a);
              d2 += f2[h2] * Math.sqrt(m2 * m2 + p2 * p2);
            }
            return u * d2;
          }
          function w(e3, t3, r2, o2, n2) {
            return e3 * (e3 * (-3 * t3 + 9 * r2 - 9 * o2 + 3 * n2) + 6 * t3 - 12 * r2 + 6 * o2) - 3 * t3 + 3 * r2;
          }
          n.default.Font = function(e3) {
            this.parent = e3, this.cache = {}, this.font = void 0;
          }, n.default.Font.prototype.textBounds = function(e3) {
            var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, o2 = 3 < arguments.length ? arguments[3] : void 0, n2 = 4 < arguments.length ? arguments[4] : void 0, s2 = n2 && n2.renderer && n2.renderer._pInst || this.parent, i2 = s2._renderer.drawingContext, o2 = (i2.textAlign || v.LEFT, i2.textBaseline || v.BASELINE, o2 || s2._renderer._textSize);
            if (!g2) {
              for (var a = [], l = [], u = [], c = (u[0] = [], []), d2 = this._scale(o2), f2 = s2._renderer.textLeading(), h2 = 0, p2 = (this.font.forEachGlyph(e3, t3, r2, o2, n2, function(e4, t4, r3, o3) {
                var n3 = e4.getMetrics();
                0 === e4.index || 10 === e4.index ? u[h2 += 1] = [] : (u[h2].push(t4 + n3.xMin * d2), u[h2].push(t4 + n3.xMax * d2), c.push(r3 + h2 * f2 + -n3.yMin * d2), c.push(r3 + h2 * f2 + -n3.yMax * d2));
              }), 0 < u[h2].length && (a[h2] = Math.min.apply(null, u[h2]), l[h2] = Math.max.apply(null, u[h2])), 0), m2 = 0; m2 <= h2; m2++) {
                a[m2] = Math.min.apply(null, u[m2]), l[m2] = Math.max.apply(null, u[m2]);
                var y2 = l[m2] - a[m2];
                p2 < y2 && (p2 = y2);
              }
              var i2 = Math.min.apply(null, a), g2 = { x: i2, y: r2 = Math.min.apply(null, c), h: Math.max.apply(null, c) - r2, w: p2, advance: i2 - t3 }, o2 = this._handleAlignment(s2._renderer, e3, g2.x, g2.y, g2.w + g2.advance);
              g2.x = o2.x, g2.y = o2.y;
            }
            return g2;
          }, n.default.Font.prototype.textToPoints = function(e3, t3, r2, o2, n2) {
            var s2 = 0, i2 = [], a = this._getGlyphs(e3);
            o2 = o2 || this.parent._renderer._textSize;
            for (var l, u = 0; u < a.length; u++) {
              if (!(a[l = u].name && "space" === a[l].name || e3.length === a.length && " " === e3[l]))
                for (var c = function(e4) {
                  for (var t4, r3 = [], o3 = 0; o3 < e4.length; o3++)
                    "M" === e4[o3].type && (t4 && r3.push(t4), t4 = []), t4.push(function(e5) {
                      var t5 = [e5.type];
                      "M" === e5.type || "L" === e5.type ? t5.push(e5.x, e5.y) : "C" === e5.type ? t5.push(e5.x1, e5.y1, e5.x2, e5.y2, e5.x, e5.y) : "Q" === e5.type && t5.push(e5.x1, e5.y1, e5.x, e5.y);
                      return t5;
                    }(e4[o3]));
                  return r3.push(t4), r3;
                }(a[u].getPath(t3, r2, o2).commands), d2 = 0; d2 < c.length; d2++)
                  for (var f2 = function(e4, t4) {
                    for (var t4 = function(e5, t5) {
                      if ("object" !== p(e5))
                        e5 = t5;
                      else
                        for (var r4 in t5)
                          void 0 === e5[r4] && (e5[r4] = t5[r4]);
                      return e5;
                    }(t4, { sampleFactor: 0.1, simplifyThreshold: 0 }), r3 = g(e4, 0, 1), o3 = r3 / (r3 * t4.sampleFactor), n3 = [], s3 = 0; s3 < r3; s3 += o3)
                      n3.push(g(e4, s3));
                    t4.simplifyThreshold && !function(e5) {
                      for (var t5 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, r4 = 0, o4 = e5.length - 1; 3 < e5.length && 0 <= o4; --o4)
                        y(m(e5, o4 - 1), m(e5, o4), m(e5, o4 + 1), t5) && (e5.splice(o4 % e5.length, 1), r4++);
                    }(n3, t4.simplifyThreshold);
                    return n3;
                  }(c[d2], n2), h2 = 0; h2 < f2.length; h2++)
                    f2[h2].x += s2, i2.push(f2[h2]);
              s2 += a[u].advanceWidth * this._scale(o2);
            }
            return i2;
          }, n.default.Font.prototype._getGlyphs = function(e3) {
            return this.font.stringToGlyphs(e3);
          }, n.default.Font.prototype._getPath = function(e3, t3, r2, o2) {
            var n2 = (o2 && o2.renderer && o2.renderer._pInst || this.parent)._renderer, t3 = this._handleAlignment(n2, e3, t3, r2);
            return this.font.getPath(e3, t3.x, t3.y, n2._textSize, o2);
          }, n.default.Font.prototype._getPathData = function(e3, t3, r2, o2) {
            var n2 = 3;
            return "string" == typeof e3 && 2 < arguments.length ? e3 = this._getPath(e3, t3, r2, o2) : "object" === p(t3) && (o2 = t3), o2 && "number" == typeof o2.decimals && (n2 = o2.decimals), e3.toPathData(n2);
          }, n.default.Font.prototype._getSVG = function(e3, t3, r2, o2) {
            var n2 = 3;
            return "string" == typeof e3 && 2 < arguments.length ? e3 = this._getPath(e3, t3, r2, o2) : "object" === p(t3) && (o2 = t3), o2 && ("number" == typeof o2.decimals && (n2 = o2.decimals), "number" == typeof o2.strokeWidth && (e3.strokeWidth = o2.strokeWidth), void 0 !== o2.fill && (e3.fill = o2.fill), void 0 !== o2.stroke && (e3.stroke = o2.stroke)), e3.toSVG(n2);
          }, n.default.Font.prototype._renderPath = function(e3, t3, r2, o2) {
            var n2 = o2 && o2.renderer || this.parent._renderer, s2 = n2.drawingContext, e3 = ("object" === p(e3) && e3.commands ? e3 : this._getPath(e3, t3, r2, o2)).commands, i2 = (s2.beginPath(), true), t3 = false, r2 = void 0;
            try {
              for (var a, l = e3[Symbol.iterator](); !(i2 = (a = l.next()).done); i2 = true) {
                var u = a.value;
                "M" === u.type ? s2.moveTo(u.x, u.y) : "L" === u.type ? s2.lineTo(u.x, u.y) : "C" === u.type ? s2.bezierCurveTo(u.x1, u.y1, u.x2, u.y2, u.x, u.y) : "Q" === u.type ? s2.quadraticCurveTo(u.x1, u.y1, u.x, u.y) : "Z" === u.type && s2.closePath();
              }
            } catch (e4) {
              t3 = true, r2 = e4;
            } finally {
              try {
                i2 || null == l.return || l.return();
              } finally {
                if (t3)
                  throw r2;
              }
            }
            return n2._doStroke && n2._strokeSet && s2.stroke(), n2._doFill && (n2._fillSet || n2._setFill(v._DEFAULT_TEXT_FILL), s2.fill()), this;
          }, n.default.Font.prototype._textWidth = function(e3, t3) {
            return this.font.getAdvanceWidth(e3, t3);
          }, n.default.Font.prototype._textAscent = function(e3) {
            return this.font.ascender * this._scale(e3);
          }, n.default.Font.prototype._textDescent = function(e3) {
            return -this.font.descender * this._scale(e3);
          }, n.default.Font.prototype._scale = function(e3) {
            return 1 / this.font.unitsPerEm * (e3 || this.parent._renderer._textSize);
          }, n.default.Font.prototype._handleAlignment = function(e3, t3, r2, o2, n2) {
            var s2 = e3._textSize;
            switch (void 0 === n2 && (n2 = this._textWidth(t3, s2)), e3._textAlign) {
              case v.CENTER:
                r2 -= n2 / 2;
                break;
              case v.RIGHT:
                r2 -= n2;
            }
            switch (e3._textBaseline) {
              case v.TOP:
                o2 += this._textAscent(s2);
                break;
              case v.CENTER:
                o2 += this._textAscent(s2) / 2;
                break;
              case v.BOTTOM:
                o2 -= this._textDescent(s2);
            }
            return { x: r2, y: o2 };
          };
          e2 = n.default;
          r.default = e2;
        }, { "../core/constants": 256, "../core/main": 267, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.fill": 152, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.join": 159, "core-js/modules/es.array.slice": 162, "core-js/modules/es.array.splice": 164, "core-js/modules/es.function.name": 165, "core-js/modules/es.number.to-fixed": 171, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.split": 191, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 306: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.array-buffer.constructor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.array-buffer.constructor"), e2("core-js/modules/es.object.to-string"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          e2.default.prototype.append = function(e3, t3) {
            return e3.push(t3), e3;
          }, e2.default.prototype.arrayCopy = function(e3, t3, r2, o, n) {
            var s2, i;
            e3 = void 0 !== n ? (i = Math.min(n, e3.length), s2 = o, e3.slice(t3, i + t3)) : (i = void 0 !== r2 ? (i = r2, Math.min(i, e3.length)) : e3.length, r2 = t3, e3.slice(s2 = 0, i)), Array.prototype.splice.apply(r2, [s2, i].concat(e3));
          }, e2.default.prototype.concat = function(e3, t3) {
            return e3.concat(t3);
          }, e2.default.prototype.reverse = function(e3) {
            return e3.reverse();
          }, e2.default.prototype.shorten = function(e3) {
            return e3.pop(), e3;
          }, e2.default.prototype.shuffle = function(e3, t3) {
            for (var r2, o, n = ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(e3), s2 = (e3 = t3 || n ? e3 : e3.slice()).length; 1 < s2; )
              r2 = this.random(0, 1) * s2 | 0, o = e3[--s2], e3[s2] = e3[r2], e3[r2] = o;
            return e3;
          }, e2.default.prototype.sort = function(e3, t3) {
            var r2 = t3 ? e3.slice(0, Math.min(t3, e3.length)) : e3, t3 = t3 ? e3.slice(Math.min(t3, e3.length)) : [];
            return (r2 = "string" == typeof r2[0] ? r2.sort() : r2.sort(function(e4, t4) {
              return e4 - t4;
            })).concat(t3);
          }, e2.default.prototype.splice = function(e3, t3, r2) {
            return Array.prototype.splice.apply(e3, [r2, 0].concat(t3)), e3;
          }, e2.default.prototype.subset = function(e3, t3, r2) {
            return void 0 !== r2 ? e3.slice(t3, t3 + r2) : e3.slice(t3, e3.length);
          };
          e2 = e2.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array-buffer.constructor": 148, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.slice": 162, "core-js/modules/es.array.splice": 164, "core-js/modules/es.object.to-string": 177 }], 307: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.map"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.repeat"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.number.constructor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.repeat"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var o = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          o.default.prototype.float = function(e3) {
            return e3 instanceof Array ? e3.map(parseFloat) : parseFloat(e3);
          }, o.default.prototype.int = function(e3) {
            var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 10;
            return e3 === 1 / 0 || "Infinity" === e3 ? 1 / 0 : e3 === -1 / 0 || "-Infinity" === e3 ? -1 / 0 : "string" == typeof e3 ? parseInt(e3, t3) : "number" == typeof e3 ? 0 | e3 : "boolean" == typeof e3 ? e3 ? 1 : 0 : e3 instanceof Array ? e3.map(function(e4) {
              return o.default.prototype.int(e4, t3);
            }) : void 0;
          }, o.default.prototype.str = function(e3) {
            return e3 instanceof Array ? e3.map(o.default.prototype.str) : String(e3);
          }, o.default.prototype.boolean = function(e3) {
            return "number" == typeof e3 ? 0 !== e3 : "string" == typeof e3 ? "true" === e3.toLowerCase() : "boolean" == typeof e3 ? e3 : e3 instanceof Array ? e3.map(o.default.prototype.boolean) : void 0;
          }, o.default.prototype.byte = function(e3) {
            e3 = o.default.prototype.int(e3, 10);
            return "number" == typeof e3 ? (e3 + 128) % 256 - 128 : e3 instanceof Array ? e3.map(o.default.prototype.byte) : void 0;
          }, o.default.prototype.char = function(e3) {
            return "number" != typeof e3 || isNaN(e3) ? e3 instanceof Array ? e3.map(o.default.prototype.char) : "string" == typeof e3 ? o.default.prototype.char(parseInt(e3, 10)) : void 0 : String.fromCharCode(e3);
          }, o.default.prototype.unchar = function(e3) {
            return "string" == typeof e3 && 1 === e3.length ? e3.charCodeAt(0) : e3 instanceof Array ? e3.map(o.default.prototype.unchar) : void 0;
          }, o.default.prototype.hex = function(e3, t3) {
            if (t3 = null == t3 ? 8 : t3, e3 instanceof Array)
              return e3.map(function(e4) {
                return o.default.prototype.hex(e4, t3);
              });
            if (e3 === 1 / 0 || e3 === -1 / 0)
              return (e3 === 1 / 0 ? "F" : "0").repeat(t3);
            if ("number" == typeof e3) {
              e3 < 0 && (e3 = 4294967295 + e3 + 1);
              for (var r2 = Number(e3).toString(16).toUpperCase(); r2.length < t3; )
                r2 = "0".concat(r2);
              return r2 = r2.length >= t3 ? r2.substring(r2.length - t3, r2.length) : r2;
            }
          }, o.default.prototype.unhex = function(e3) {
            return e3 instanceof Array ? e3.map(o.default.prototype.unhex) : parseInt("0x".concat(e3), 16);
          };
          e2 = o.default;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.map": 161, "core-js/modules/es.number.constructor": 169, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.repeat": 188 }], 308: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.constructor"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.match"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.trim"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.constructor"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.match"), e2("core-js/modules/es.string.replace"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.trim"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var s2 = (l = e2("../core/main")) && l.__esModule ? l : { default: l };
          function o(e3, t3, r2) {
            var o2 = e3 < 0, e3 = o2 ? e3.toString().substring(1) : e3.toString(), n2 = e3.indexOf("."), s3 = -1 !== n2 ? e3.substring(0, n2) : e3, i2 = -1 !== n2 ? e3.substring(n2 + 1) : "", a2 = o2 ? "-" : "";
            if (void 0 !== r2) {
              o2 = "";
              (-1 !== n2 || 0 < r2 - i2.length) && (o2 = "."), i2.length > r2 && (i2 = i2.substring(0, r2));
              for (var l2 = 0; l2 < t3 - s3.length; l2++)
                a2 += "0";
              for (var a2 = (a2 += s3) + o2 + i2, u = 0; u < r2 - i2.length; u++)
                a2 += "0";
              return a2;
            }
            for (var c = 0; c < Math.max(t3 - s3.length, 0); c++)
              a2 += "0";
            return a2 += e3;
          }
          function n(e3, t3) {
            var r2 = (e3 = e3.toString()).indexOf("."), o2 = -1 !== r2 ? e3.substring(r2) : "", e3 = (e3 = -1 !== r2 ? e3.substring(0, r2) : e3).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            if (0 === t3)
              o2 = "";
            else if (void 0 !== t3)
              if (t3 > o2.length)
                for (var n2 = t3 - (o2 += -1 === r2 ? "." : "").length + 1, s3 = 0; s3 < n2; s3++)
                  o2 += "0";
              else
                o2 = o2.substring(0, t3 + 1);
            return e3 + o2;
          }
          function i(e3) {
            return 0 < parseFloat(e3) ? "+".concat(e3.toString()) : e3.toString();
          }
          function a(e3) {
            return 0 <= parseFloat(e3) ? " ".concat(e3.toString()) : e3.toString();
          }
          e2("../core/friendly_errors/validate_params"), e2("../core/friendly_errors/file_errors"), e2("../core/friendly_errors/fes_core"), s2.default.prototype.join = function(e3, t3) {
            return s2.default._validateParameters("join", arguments), e3.join(t3);
          }, s2.default.prototype.match = function(e3, t3) {
            return s2.default._validateParameters("match", arguments), e3.match(t3);
          }, s2.default.prototype.matchAll = function(e3, t3) {
            s2.default._validateParameters("matchAll", arguments);
            for (var r2 = new RegExp(t3, "g"), o2 = r2.exec(e3), n2 = []; null !== o2; )
              n2.push(o2), o2 = r2.exec(e3);
            return n2;
          }, s2.default.prototype.nf = function(e3, t3, r2) {
            return s2.default._validateParameters("nf", arguments), e3 instanceof Array ? e3.map(function(e4) {
              return o(e4, t3, r2);
            }) : "[object Arguments]" === Object.prototype.toString.call(e3) ? 3 === e3.length ? this.nf(e3[0], e3[1], e3[2]) : 2 === e3.length ? this.nf(e3[0], e3[1]) : this.nf(e3[0]) : o(e3, t3, r2);
          }, s2.default.prototype.nfc = function(e3, t3) {
            return s2.default._validateParameters("nfc", arguments), e3 instanceof Array ? e3.map(function(e4) {
              return n(e4, t3);
            }) : n(e3, t3);
          }, s2.default.prototype.nfp = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            s2.default._validateParameters("nfp", t3);
            var o2 = s2.default.prototype.nf.apply(this, t3);
            return o2 instanceof Array ? o2.map(i) : i(o2);
          }, s2.default.prototype.nfs = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            s2.default._validateParameters("nfs", t3);
            var o2 = s2.default.prototype.nf.apply(this, t3);
            return o2 instanceof Array ? o2.map(a) : a(o2);
          }, s2.default.prototype.split = function(e3, t3) {
            return s2.default._validateParameters("split", arguments), e3.split(t3);
          }, s2.default.prototype.splitTokens = function(e3, t3) {
            var r2, o2;
            return s2.default._validateParameters("splitTokens", arguments), o2 = void 0 !== t3 ? (o2 = /\]/g.exec(t3 = t3), (r2 = /\[/g.exec(t3)) && o2 ? (t3 = t3.slice(0, o2.index) + t3.slice(o2.index + 1), r2 = /\[/g.exec(t3), t3 = t3.slice(0, r2.index) + t3.slice(r2.index + 1), new RegExp("[\\[".concat(t3, "\\]]"), "g")) : o2 ? (t3 = t3.slice(0, o2.index) + t3.slice(o2.index + 1), new RegExp("[".concat(t3, "\\]]"), "g")) : r2 ? (t3 = t3.slice(0, r2.index) + t3.slice(r2.index + 1), new RegExp("[".concat(t3, "\\[]"), "g")) : new RegExp("[".concat(t3, "]"), "g")) : /\s/g, e3.split(o2).filter(function(e4) {
              return e4;
            });
          }, s2.default.prototype.trim = function(e3) {
            return s2.default._validateParameters("trim", arguments), e3 instanceof Array ? e3.map(this.trim) : e3.trim();
          };
          var l = s2.default;
          r.default = l;
        }, { "../core/friendly_errors/fes_core": 258, "../core/friendly_errors/file_errors": 259, "../core/friendly_errors/validate_params": 262, "../core/main": 267, "core-js/modules/es.array.filter": 153, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.join": 159, "core-js/modules/es.array.map": 161, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.constructor": 180, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.match": 187, "core-js/modules/es.string.replace": 189, "core-js/modules/es.string.split": 191, "core-js/modules/es.string.trim": 193 }], 309: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          e2.default.prototype.day = function() {
            return new Date().getDate();
          }, e2.default.prototype.hour = function() {
            return new Date().getHours();
          }, e2.default.prototype.minute = function() {
            return new Date().getMinutes();
          }, e2.default.prototype.millis = function() {
            return -1 === this._millisStart ? 0 : window.performance.now() - this._millisStart;
          }, e2.default.prototype.month = function() {
            return new Date().getMonth() + 1;
          }, e2.default.prototype.second = function() {
            return new Date().getSeconds();
          }, e2.default.prototype.year = function() {
            return new Date().getFullYear();
          };
          e2 = e2.default;
          r.default = e2;
        }, { "../core/main": 267 }], 310: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.number.to-fixed"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.number.to-fixed"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var S = (n = e2("../core/main")) && n.__esModule ? n : { default: n }, _ = (e2("./p5.Geometry"), function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s2;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s2 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s2.get || s2.set) ? Object.defineProperty(o2, r2, s2) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants")));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          S.default.prototype.plane = function(e3, t3, r2, o2) {
            this._assert3d("plane"), S.default._validateParameters("plane", arguments), void 0 === e3 && (e3 = 50), void 0 === t3 && (t3 = e3), void 0 === o2 && (o2 = 1);
            var n2, s2 = "plane|".concat(r2 = void 0 === r2 ? 1 : r2, "|").concat(o2);
            return this._renderer.geometryInHash(s2) || ((n2 = new S.default.Geometry(r2, o2, function() {
              for (var e4, t4, r3 = 0; r3 <= this.detailY; r3++)
                for (var o3 = r3 / this.detailY, n3 = 0; n3 <= this.detailX; n3++)
                  e4 = n3 / this.detailX, t4 = new S.default.Vector(e4 - 0.5, o3 - 0.5, 0), this.vertices.push(t4), this.uvs.push(e4, o3);
            })).computeFaces().computeNormals(), r2 <= 1 && o2 <= 1 ? n2._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw stroke on plane objects with more than 1 detailX or 1 detailY"), this._renderer.createBuffers(s2, n2)), this._renderer.drawBuffersScaled(s2, e3, t3, 1), this;
          }, S.default.prototype.box = function(e3, t3, r2, o2, n2) {
            this._assert3d("box"), S.default._validateParameters("box", arguments), void 0 === e3 && (e3 = 50), void 0 === t3 && (t3 = e3), void 0 === r2 && (r2 = t3);
            var s2, i2 = this._renderer.attributes && this._renderer.attributes.perPixelLighting, i2 = (void 0 === n2 && (n2 = i2 ? 1 : 4), "box|".concat(o2 = void 0 === o2 ? i2 ? 1 : 4 : o2, "|").concat(n2));
            return this._renderer.geometryInHash(i2) || ((s2 = new S.default.Geometry(o2, n2, function() {
              var e4 = [[0, 4, 2, 6], [1, 3, 5, 7], [0, 1, 4, 5], [2, 6, 3, 7], [0, 2, 1, 3], [4, 5, 6, 7]];
              this.strokeIndices = [[0, 1], [1, 3], [3, 2], [6, 7], [8, 9], [9, 11], [14, 15], [16, 17], [17, 19], [18, 19], [20, 21], [22, 23]];
              for (var t4 = 0; t4 < e4.length; t4++) {
                for (var r3 = e4[t4], o3 = 4 * t4, n3 = 0; n3 < 4; n3++) {
                  var s3 = r3[n3], s3 = new S.default.Vector((2 * (1 & s3) - 1) / 2, ((2 & s3) - 1) / 2, ((4 & s3) / 2 - 1) / 2);
                  this.vertices.push(s3), this.uvs.push(1 & n3, (2 & n3) / 2);
                }
                this.faces.push([o3, 1 + o3, 2 + o3]), this.faces.push([2 + o3, 1 + o3, 3 + o3]);
              }
            })).computeNormals(), o2 <= 4 && n2 <= 4 ? s2._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw stroke on box objects with more than 4 detailX or 4 detailY"), this._renderer.createBuffers(i2, s2)), this._renderer.drawBuffersScaled(i2, e3, t3, r2), this;
          }, S.default.prototype.sphere = function(e3, t3, r2) {
            return this._assert3d("sphere"), S.default._validateParameters("sphere", arguments), this.ellipsoid(e3 = void 0 === e3 ? 50 : e3, e3, e3, t3 = void 0 === t3 ? 24 : t3, r2 = void 0 === r2 ? 16 : r2), this;
          };
          function l(e3, t3, r2, o2, n2, s2, i2) {
            e3 = e3 <= 0 ? 1 : e3, t3 = t3 < 0 ? 0 : t3, r2 = r2 <= 0 ? e3 : r2, o2 = o2 < 3 ? 3 : o2;
            for (var a2, l2, u = (s2 = void 0 === s2 || s2) ? -2 : 0, c = (n2 = n2 < 1 ? 1 : n2) + ((i2 = void 0 === i2 ? 0 !== t3 : i2) ? 2 : 0), d = Math.atan2(e3 - t3, r2), f = Math.sin(d), h = Math.cos(d), p = u; p <= c; ++p) {
              var m = p / n2, y = r2 * m, g = void 0, g = p < 0 ? (m = y = 0, e3) : n2 < p ? (y = r2, m = 1, t3) : e3 + (t3 - e3) * m;
              for (-2 !== p && p !== n2 + 2 || (g = 0), y -= r2 / 2, a2 = 0; a2 < o2; ++a2) {
                var v = a2 / (o2 - 1), b = 2 * Math.PI * v, j = Math.sin(b), b = Math.cos(b), _2 = (this.vertices.push(new S.default.Vector(j * g, y, b * g)), void 0), _2 = p < 0 ? new S.default.Vector(0, -1, 0) : n2 < p && t3 ? new S.default.Vector(0, 1, 0) : new S.default.Vector(j * h, f, b * h);
                this.vertexNormals.push(_2), this.uvs.push(v, m);
              }
            }
            var x = 0;
            if (s2) {
              for (l2 = 0; l2 < o2; ++l2)
                this.faces.push([x + l2, x + o2 + (l2 + 1) % o2, x + o2 + l2]);
              x += 2 * o2;
            }
            for (p = 0; p < n2; ++p) {
              for (a2 = 0; a2 < o2; ++a2) {
                var w = (a2 + 1) % o2;
                this.faces.push([x + a2, x + w, x + o2 + w]), this.faces.push([x + a2, x + o2 + w, x + o2 + a2]);
              }
              x += o2;
            }
            if (i2)
              for (x += o2, a2 = 0; a2 < o2; ++a2)
                this.faces.push([x + a2, x + (a2 + 1) % o2, x + o2]);
          }
          S.default.prototype.cylinder = function(e3, t3, r2, o2, n2, s2) {
            this._assert3d("cylinder"), S.default._validateParameters("cylinder", arguments), void 0 === e3 && (e3 = 50), void 0 === t3 && (t3 = e3), void 0 === o2 && (o2 = 1), void 0 === s2 && (s2 = true), void 0 === n2 && (n2 = true);
            var i2, a2 = "cylinder|".concat(r2 = void 0 === r2 ? 24 : r2, "|").concat(o2, "|").concat(n2, "|").concat(s2);
            return this._renderer.geometryInHash(a2) || (i2 = new S.default.Geometry(r2, o2), l.call(i2, 1, 1, 1, r2, o2, n2, s2), r2 <= 24 && o2 <= 16 ? i2._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw stroke on cylinder objects with more than 24 detailX or 16 detailY"), this._renderer.createBuffers(a2, i2)), this._renderer.drawBuffersScaled(a2, e3, t3, e3), this;
          }, S.default.prototype.cone = function(e3, t3, r2, o2, n2) {
            this._assert3d("cone"), S.default._validateParameters("cone", arguments), void 0 === e3 && (e3 = 50), void 0 === t3 && (t3 = e3), void 0 === o2 && (o2 = 1), void 0 === n2 && (n2 = true);
            var s2, i2 = "cone|".concat(r2 = void 0 === r2 ? 24 : r2, "|").concat(o2, "|").concat(n2);
            return this._renderer.geometryInHash(i2) || (s2 = new S.default.Geometry(r2, o2), l.call(s2, 1, 0, 1, r2, o2, n2, false), r2 <= 24 && o2 <= 16 ? s2._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw stroke on cone objects with more than 24 detailX or 16 detailY"), this._renderer.createBuffers(i2, s2)), this._renderer.drawBuffersScaled(i2, e3, t3, e3), this;
          }, S.default.prototype.ellipsoid = function(e3, t3, r2, o2, n2) {
            this._assert3d("ellipsoid"), S.default._validateParameters("ellipsoid", arguments), void 0 === e3 && (e3 = 50), void 0 === t3 && (t3 = e3), void 0 === r2 && (r2 = e3), void 0 === n2 && (n2 = 16);
            var s2, i2 = "ellipsoid|".concat(o2 = void 0 === o2 ? 24 : o2, "|").concat(n2);
            return this._renderer.geometryInHash(i2) || ((s2 = new S.default.Geometry(o2, n2, function() {
              for (var e4 = 0; e4 <= this.detailY; e4++)
                for (var t4 = e4 / this.detailY, r3 = Math.PI * t4 - Math.PI / 2, o3 = Math.cos(r3), n3 = Math.sin(r3), s3 = 0; s3 <= this.detailX; s3++) {
                  var i3 = s3 / this.detailX, a2 = 2 * Math.PI * i3, l2 = Math.cos(a2), a2 = Math.sin(a2), a2 = new S.default.Vector(o3 * a2, n3, o3 * l2);
                  this.vertices.push(a2), this.vertexNormals.push(a2), this.uvs.push(i3, t4);
                }
            })).computeFaces(), o2 <= 24 && n2 <= 24 ? s2._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw stroke on ellipsoids with more than 24 detailX or 24 detailY"), this._renderer.createBuffers(i2, s2)), this._renderer.drawBuffersScaled(i2, e3, t3, r2), this;
          }, S.default.prototype.torus = function(e3, t3, r2, o2) {
            if (this._assert3d("torus"), S.default._validateParameters("torus", arguments), void 0 === e3)
              e3 = 50;
            else if (!e3)
              return;
            if (void 0 === t3)
              t3 = 10;
            else if (!t3)
              return;
            void 0 === r2 && (r2 = 24), void 0 === o2 && (o2 = 16);
            var n2, d = (t3 / e3).toPrecision(4), t3 = "torus|".concat(d, "|").concat(r2, "|").concat(o2);
            return this._renderer.geometryInHash(t3) || ((n2 = new S.default.Geometry(r2, o2, function() {
              for (var e4 = 0; e4 <= this.detailY; e4++)
                for (var t4 = e4 / this.detailY, r3 = 2 * Math.PI * t4, o3 = Math.cos(r3), n3 = Math.sin(r3), s2 = 1 + d * o3, i2 = 0; i2 <= this.detailX; i2++) {
                  var a2 = i2 / this.detailX, l2 = 2 * Math.PI * a2, u = Math.cos(l2), l2 = Math.sin(l2), c = new S.default.Vector(s2 * u, s2 * l2, d * n3), u = new S.default.Vector(o3 * u, o3 * l2, n3);
                  this.vertices.push(c), this.vertexNormals.push(u), this.uvs.push(a2, t4);
                }
            })).computeFaces(), r2 <= 24 && o2 <= 16 ? n2._makeTriangleEdges()._edgesToVertices() : this._renderer._doStroke && console.log("Cannot draw strokes on torus object with more than 24 detailX or 16 detailY"), this._renderer.createBuffers(t3, n2)), this._renderer.drawBuffersScaled(t3, e3, e3, e3), this;
          }, S.default.RendererGL.prototype.point = function(e3, t3, r2) {
            var o2 = [];
            return o2.push(new S.default.Vector(e3, t3, r2 = void 0 === r2 ? 0 : r2)), this._drawPoints(o2, this.immediateMode.buffers.point), this;
          }, S.default.RendererGL.prototype.triangle = function(e3) {
            var t3 = e3[0], r2 = e3[1], o2 = e3[2], n2 = e3[3], s2 = e3[4], e3 = e3[5], i2 = (this.geometryInHash("tri") || ((i2 = new S.default.Geometry(1, 1, function() {
              var e4 = [];
              e4.push(new S.default.Vector(0, 0, 0)), e4.push(new S.default.Vector(0, 1, 0)), e4.push(new S.default.Vector(1, 0, 0)), this.strokeIndices = [[0, 1], [1, 2], [2, 0]], this.vertices = e4, this.faces = [[0, 1, 2]], this.uvs = [0, 0, 0, 1, 1, 1];
            }))._makeTriangleEdges()._edgesToVertices(), i2.computeNormals(), this.createBuffers("tri", i2)), this.uMVMatrix.copy());
            try {
              var a2 = new S.default.Matrix([o2 - t3, n2 - r2, 0, 0, s2 - t3, e3 - r2, 0, 0, 0, 0, 1, 0, t3, r2, 0, 1]).mult(this.uMVMatrix);
              this.uMVMatrix = a2, this.drawBuffers("tri");
            } finally {
              this.uMVMatrix = i2;
            }
            return this;
          }, S.default.RendererGL.prototype.ellipse = function(e3) {
            this.arc(e3[0], e3[1], e3[2], e3[3], 0, _.TWO_PI, _.OPEN, e3[4]);
          }, S.default.RendererGL.prototype.arc = function(e3) {
            var t3, r2 = arguments[1], o2 = arguments[2], n2 = arguments[3], s2 = arguments[4], i2 = arguments[5], a2 = arguments[6], l2 = arguments[7] || 25, u = (Math.abs(i2 - s2) >= _.TWO_PI ? "".concat(c = "ellipse", "|") : "".concat(c = "arc", "|").concat(s2, "|").concat(i2, "|").concat(a2, "|")).concat(l2, "|"), c = (this.geometryInHash(u) || ((t3 = new S.default.Geometry(l2, 1, function() {
              if (this.strokeIndices = [], s2.toFixed(10) !== i2.toFixed(10)) {
                a2 !== _.PIE && void 0 !== a2 || (this.vertices.push(new S.default.Vector(0.5, 0.5, 0)), this.uvs.push([0.5, 0.5]));
                for (var e4 = 0; e4 <= l2; e4++) {
                  var t4 = (i2 - s2) * (e4 / l2) + s2, r3 = 0.5 + Math.cos(t4) / 2, t4 = 0.5 + Math.sin(t4) / 2;
                  this.vertices.push(new S.default.Vector(r3, t4, 0)), this.uvs.push([r3, t4]), e4 < l2 - 1 && (this.faces.push([0, e4 + 1, e4 + 2]), this.strokeIndices.push([e4 + 1, e4 + 2]));
                }
                switch (a2) {
                  case _.PIE:
                    this.faces.push([0, this.vertices.length - 2, this.vertices.length - 1]), this.strokeIndices.push([0, 1]), this.strokeIndices.push([this.vertices.length - 2, this.vertices.length - 1]), this.strokeIndices.push([0, this.vertices.length - 1]);
                    break;
                  case _.CHORD:
                    this.strokeIndices.push([0, 1]), this.strokeIndices.push([0, this.vertices.length - 1]);
                    break;
                  case _.OPEN:
                    this.strokeIndices.push([0, 1]);
                    break;
                  default:
                    this.faces.push([0, this.vertices.length - 2, this.vertices.length - 1]), this.strokeIndices.push([this.vertices.length - 2, this.vertices.length - 1]);
                }
              }
            })).computeNormals(), l2 <= 50 ? t3._makeTriangleEdges()._edgesToVertices(t3) : this._doStroke && console.log("Cannot apply a stroke to an ".concat(c, " with more than 50 detail")), this.createBuffers(u, t3)), this.uMVMatrix.copy());
            try {
              this.uMVMatrix.translate([e3, r2, 0]), this.uMVMatrix.scale(o2, n2, 1), this.drawBuffers(u);
            } finally {
              this.uMVMatrix = c;
            }
            return this;
          }, S.default.RendererGL.prototype.rect = function(e3) {
            var t3 = e3[0], r2 = e3[1], o2 = e3[2], n2 = e3[3];
            if (void 0 === e3[4]) {
              var s2 = this._pInst._glAttributes.perPixelLighting, i2 = e3[4] || (s2 ? 1 : 24), a2 = e3[5] || (s2 ? 1 : 16), s2 = "rect|".concat(i2, "|").concat(a2), l2 = (this.geometryInHash(s2) || ((l2 = new S.default.Geometry(i2, a2, function() {
                for (var e4 = 0; e4 <= this.detailY; e4++)
                  for (var t4 = e4 / this.detailY, r3 = 0; r3 <= this.detailX; r3++) {
                    var o3 = r3 / this.detailX, n3 = new S.default.Vector(o3, t4, 0);
                    this.vertices.push(n3), this.uvs.push(o3, t4);
                  }
                0 < i2 && 0 < a2 && (this.strokeIndices = [[0, i2], [i2, (i2 + 1) * (a2 + 1) - 1], [(i2 + 1) * (a2 + 1) - 1, (i2 + 1) * a2], [(i2 + 1) * a2, 0]]);
              })).computeFaces().computeNormals()._makeTriangleEdges()._edgesToVertices(), this.createBuffers(s2, l2)), this.uMVMatrix.copy());
              try {
                this.uMVMatrix.translate([t3, r2, 0]), this.uMVMatrix.scale(o2, n2, 1), this.drawBuffers(s2);
              } finally {
                this.uMVMatrix = l2;
              }
            } else {
              var s2 = e3[4], l2 = void 0 === e3[5] ? s2 : e3[5], u = void 0 === e3[6] ? l2 : e3[6], e3 = void 0 === e3[7] ? u : e3[7], c = o2, d = n2, f = ((c += t3) < t3 && (f = t3, t3 = c, c = f), (d += r2) < r2 && (f = r2, r2 = d, d = f), Math.min((c - t3) / 2, (d - r2) / 2)), h = (f < s2 && (s2 = f), f < l2 && (l2 = f), f < u && (u = f), f < e3 && (e3 = f), t3), p = r2, f = c, t3 = d, m = (this.beginShape(), 0 !== l2 ? (this.vertex(f - l2, p), this.quadraticVertex(f, p, f, p + l2)) : this.vertex(f, p), 0 !== u ? (this.vertex(f, t3 - u), this.quadraticVertex(f, t3, f - u, t3)) : this.vertex(f, t3), 0 !== e3 ? (this.vertex(h + e3, t3), this.quadraticVertex(h, t3, h, t3 - e3)) : this.vertex(h, t3), 0 !== s2 ? (this.vertex(h, p + s2), this.quadraticVertex(h, p, h + s2, p)) : this.vertex(h, p), !(this.immediateMode.geometry.uvs.length = 0)), r2 = false, c = void 0;
              try {
                for (var y, g = this.immediateMode.geometry.vertices[Symbol.iterator](); !(m = (y = g.next()).done); m = true) {
                  var v = y.value, b = (v.x - h) / o2, j = (v.y - p) / n2;
                  this.immediateMode.geometry.uvs.push(b, j);
                }
              } catch (e4) {
                r2 = true, c = e4;
              } finally {
                try {
                  m || null == g.return || g.return();
                } finally {
                  if (r2)
                    throw c;
                }
              }
              this.endShape(_.CLOSE);
            }
            return this;
          }, S.default.RendererGL.prototype.quad = function(i2, a2, l2, u, c, d, f, h, p, m, y, g, e3, t3) {
            void 0 === e3 && (e3 = 2), void 0 === t3 && (t3 = 2);
            var r2 = "quad|".concat(i2, "|").concat(a2, "|").concat(l2, "|").concat(u, "|").concat(c, "|").concat(d, "|").concat(f, "|").concat(h, "|").concat(p, "|").concat(m, "|").concat(y, "|").concat(g, "|").concat(e3, "|").concat(t3);
            if (!this.geometryInHash(r2)) {
              var o2 = new S.default.Geometry(e3, t3, function() {
                for (var e4 = 1 / (this.detailX - 1), t4 = 1 / (this.detailY - 1), r3 = 0; r3 < this.detailY; r3++)
                  for (var o3 = 0; o3 < this.detailX; o3++) {
                    var n3 = o3 * e4, s3 = r3 * t4;
                    this.vertices.push(new S.default.Vector((1 - n3) * ((1 - s3) * i2 + s3 * m) + n3 * ((1 - s3) * u + s3 * f), (1 - n3) * ((1 - s3) * a2 + s3 * y) + n3 * ((1 - s3) * c + s3 * h), (1 - n3) * ((1 - s3) * l2 + s3 * g) + n3 * ((1 - s3) * d + s3 * p))), this.uvs.push([n3, s3]);
                  }
              });
              o2.faces = [];
              for (var n2 = 0; n2 < t3 - 1; n2++)
                for (var s2 = 0; s2 < e3 - 1; s2++) {
                  var v = s2 + n2 * e3, b = s2 + 1 + (n2 + 1) * e3, j = s2 + (n2 + 1) * e3;
                  o2.faces.push([v, s2 + 1 + n2 * e3, b]), o2.faces.push([v, b, j]);
                }
              o2.computeNormals()._makeTriangleEdges()._edgesToVertices(), this.createBuffers(r2, o2);
            }
            return this.drawBuffers(r2), this;
          }, S.default.RendererGL.prototype.bezier = function(e3, t3, r2, o2, n2, s2, i2, a2, l2, u, c, d) {
            8 === arguments.length && (c = a2, u = i2, a2 = s2, i2 = n2, n2 = o2, o2 = r2, r2 = s2 = l2 = d = 0);
            var f = this._pInst._bezierDetail || 20;
            this.beginShape();
            for (var h = 0; h <= f; h++) {
              var p = Math.pow(1 - h / f, 3), m = h / f * 3 * Math.pow(1 - h / f, 2), y = 3 * Math.pow(h / f, 2) * (1 - h / f), g = Math.pow(h / f, 3);
              this.vertex(e3 * p + o2 * m + i2 * y + u * g, t3 * p + n2 * m + a2 * y + c * g, r2 * p + s2 * m + l2 * y + d * g);
            }
            return this.endShape(), this;
          }, S.default.RendererGL.prototype.curve = function(e3, t3, r2, o2, n2, s2, i2, a2, l2, u, c, d) {
            8 === arguments.length && (u = i2, c = a2, i2 = n2, a2 = o2, n2 = o2 = r2, r2 = s2 = l2 = d = 0);
            var f = this._pInst._curveDetail;
            this.beginShape();
            for (var h = 0; h <= f; h++) {
              var p = 0.5 * Math.pow(h / f, 3), m = 0.5 * Math.pow(h / f, 2), y = h / f * 0.5;
              this.vertex(p * (3 * o2 - e3 - 3 * i2 + u) + m * (2 * e3 - 5 * o2 + 4 * i2 - u) + y * (-e3 + i2) + 2 * o2 * 0.5, p * (3 * n2 - t3 - 3 * a2 + c) + m * (2 * t3 - 5 * n2 + 4 * a2 - c) + y * (-t3 + a2) + 2 * n2 * 0.5, p * (3 * s2 - r2 - 3 * l2 + d) + m * (2 * r2 - 5 * s2 + 4 * l2 - d) + y * (-r2 + l2) + 2 * s2 * 0.5);
            }
            return this.endShape(), this;
          }, S.default.RendererGL.prototype.line = function() {
            return 6 === arguments.length ? (this.beginShape(_.LINES), this.vertex(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 2 ? void 0 : arguments[2]), this.vertex(arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 4 ? void 0 : arguments[4], arguments.length <= 5 ? void 0 : arguments[5]), this.endShape()) : 4 === arguments.length && (this.beginShape(_.LINES), this.vertex(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], 0), this.vertex(arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 3 ? void 0 : arguments[3], 0), this.endShape()), this;
          }, S.default.RendererGL.prototype.bezierVertex = function() {
            if (0 === this.immediateMode._bezierVertex.length)
              throw Error("vertex() must be used once before calling bezierVertex()");
            var e3, t3, r2, o2, n2, s2, i2 = [], a2 = [], l2 = arguments.length;
            if (0 === this._lookUpTableBezier.length || this._lutBezierDetail !== this._pInst._curveDetail) {
              this._lookUpTableBezier = [], this._lutBezierDetail = this._pInst._curveDetail;
              for (var u = 1 / this._lutBezierDetail, c = 0, d = 1, f = 0; c < 1; ) {
                if (s2 = parseFloat(c.toFixed(6)), this._lookUpTableBezier[f] = this._bezierCoefficients(s2), d.toFixed(6) === u.toFixed(6)) {
                  s2 = parseFloat(d.toFixed(6)) + parseFloat(c.toFixed(6)), ++f, this._lookUpTableBezier[f] = this._bezierCoefficients(s2);
                  break;
                }
                c += u, d -= u, ++f;
              }
            }
            var h = this._lookUpTableBezier.length;
            if (6 === l2) {
              for (this.isBezier = true, i2 = [this.immediateMode._bezierVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 4 ? void 0 : arguments[4]], a2 = [this.immediateMode._bezierVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 5 ? void 0 : arguments[5]], n2 = 0; n2 < h; n2++)
                t3 = i2[0] * this._lookUpTableBezier[n2][0] + i2[1] * this._lookUpTableBezier[n2][1] + i2[2] * this._lookUpTableBezier[n2][2] + i2[3] * this._lookUpTableBezier[n2][3], r2 = a2[0] * this._lookUpTableBezier[n2][0] + a2[1] * this._lookUpTableBezier[n2][1] + a2[2] * this._lookUpTableBezier[n2][2] + a2[3] * this._lookUpTableBezier[n2][3], this.vertex(t3, r2);
              this.immediateMode._bezierVertex[0] = arguments.length <= 4 ? void 0 : arguments[4], this.immediateMode._bezierVertex[1] = arguments.length <= 5 ? void 0 : arguments[5];
            } else if (9 === l2) {
              for (this.isBezier = true, i2 = [this.immediateMode._bezierVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 6 ? void 0 : arguments[6]], a2 = [this.immediateMode._bezierVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 4 ? void 0 : arguments[4], arguments.length <= 7 ? void 0 : arguments[7]], e3 = [this.immediateMode._bezierVertex[2], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 5 ? void 0 : arguments[5], arguments.length <= 8 ? void 0 : arguments[8]], n2 = 0; n2 < h; n2++)
                t3 = i2[0] * this._lookUpTableBezier[n2][0] + i2[1] * this._lookUpTableBezier[n2][1] + i2[2] * this._lookUpTableBezier[n2][2] + i2[3] * this._lookUpTableBezier[n2][3], r2 = a2[0] * this._lookUpTableBezier[n2][0] + a2[1] * this._lookUpTableBezier[n2][1] + a2[2] * this._lookUpTableBezier[n2][2] + a2[3] * this._lookUpTableBezier[n2][3], o2 = e3[0] * this._lookUpTableBezier[n2][0] + e3[1] * this._lookUpTableBezier[n2][1] + e3[2] * this._lookUpTableBezier[n2][2] + e3[3] * this._lookUpTableBezier[n2][3], this.vertex(t3, r2, o2);
              this.immediateMode._bezierVertex[0] = arguments.length <= 6 ? void 0 : arguments[6], this.immediateMode._bezierVertex[1] = arguments.length <= 7 ? void 0 : arguments[7], this.immediateMode._bezierVertex[2] = arguments.length <= 8 ? void 0 : arguments[8];
            }
          }, S.default.RendererGL.prototype.quadraticVertex = function() {
            if (0 === this.immediateMode._quadraticVertex.length)
              throw Error("vertex() must be used once before calling quadraticVertex()");
            var e3, t3, r2, o2, n2, s2, i2 = [], a2 = [], l2 = arguments.length;
            if (0 === this._lookUpTableQuadratic.length || this._lutQuadraticDetail !== this._pInst._curveDetail) {
              this._lookUpTableQuadratic = [], this._lutQuadraticDetail = this._pInst._curveDetail;
              for (var u = 1 / this._lutQuadraticDetail, c = 0, d = 1, f = 0; c < 1; ) {
                if (s2 = parseFloat(c.toFixed(6)), this._lookUpTableQuadratic[f] = this._quadraticCoefficients(s2), d.toFixed(6) === u.toFixed(6)) {
                  s2 = parseFloat(d.toFixed(6)) + parseFloat(c.toFixed(6)), ++f, this._lookUpTableQuadratic[f] = this._quadraticCoefficients(s2);
                  break;
                }
                c += u, d -= u, ++f;
              }
            }
            var h = this._lookUpTableQuadratic.length;
            if (4 === l2) {
              for (this.isQuadratic = true, i2 = [this.immediateMode._quadraticVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 2 ? void 0 : arguments[2]], a2 = [this.immediateMode._quadraticVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 3 ? void 0 : arguments[3]], n2 = 0; n2 < h; n2++)
                t3 = i2[0] * this._lookUpTableQuadratic[n2][0] + i2[1] * this._lookUpTableQuadratic[n2][1] + i2[2] * this._lookUpTableQuadratic[n2][2], r2 = a2[0] * this._lookUpTableQuadratic[n2][0] + a2[1] * this._lookUpTableQuadratic[n2][1] + a2[2] * this._lookUpTableQuadratic[n2][2], this.vertex(t3, r2);
              this.immediateMode._quadraticVertex[0] = arguments.length <= 2 ? void 0 : arguments[2], this.immediateMode._quadraticVertex[1] = arguments.length <= 3 ? void 0 : arguments[3];
            } else if (6 === l2) {
              for (this.isQuadratic = true, i2 = [this.immediateMode._quadraticVertex[0], arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 3 ? void 0 : arguments[3]], a2 = [this.immediateMode._quadraticVertex[1], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 4 ? void 0 : arguments[4]], e3 = [this.immediateMode._quadraticVertex[2], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 5 ? void 0 : arguments[5]], n2 = 0; n2 < h; n2++)
                t3 = i2[0] * this._lookUpTableQuadratic[n2][0] + i2[1] * this._lookUpTableQuadratic[n2][1] + i2[2] * this._lookUpTableQuadratic[n2][2], r2 = a2[0] * this._lookUpTableQuadratic[n2][0] + a2[1] * this._lookUpTableQuadratic[n2][1] + a2[2] * this._lookUpTableQuadratic[n2][2], o2 = e3[0] * this._lookUpTableQuadratic[n2][0] + e3[1] * this._lookUpTableQuadratic[n2][1] + e3[2] * this._lookUpTableQuadratic[n2][2], this.vertex(t3, r2, o2);
              this.immediateMode._quadraticVertex[0] = arguments.length <= 3 ? void 0 : arguments[3], this.immediateMode._quadraticVertex[1] = arguments.length <= 4 ? void 0 : arguments[4], this.immediateMode._quadraticVertex[2] = arguments.length <= 5 ? void 0 : arguments[5];
            }
          }, S.default.RendererGL.prototype.curveVertex = function() {
            var e3, t3, r2, o2, n2, s2, i2 = [], a2 = [], l2 = arguments.length;
            if (0 === this._lookUpTableBezier.length || this._lutBezierDetail !== this._pInst._curveDetail) {
              this._lookUpTableBezier = [], this._lutBezierDetail = this._pInst._curveDetail;
              for (var u = 1 / this._lutBezierDetail, c = 0, d = 1, f = 0; c < 1; ) {
                if (s2 = parseFloat(c.toFixed(6)), this._lookUpTableBezier[f] = this._bezierCoefficients(s2), d.toFixed(6) === u.toFixed(6)) {
                  s2 = parseFloat(d.toFixed(6)) + parseFloat(c.toFixed(6)), ++f, this._lookUpTableBezier[f] = this._bezierCoefficients(s2);
                  break;
                }
                c += u, d -= u, ++f;
              }
            }
            var h = this._lookUpTableBezier.length;
            if (2 === l2) {
              if (this.immediateMode._curveVertex.push(arguments.length <= 0 ? void 0 : arguments[0]), this.immediateMode._curveVertex.push(arguments.length <= 1 ? void 0 : arguments[1]), 8 === this.immediateMode._curveVertex.length) {
                for (this.isCurve = true, i2 = this._bezierToCatmull([this.immediateMode._curveVertex[0], this.immediateMode._curveVertex[2], this.immediateMode._curveVertex[4], this.immediateMode._curveVertex[6]]), a2 = this._bezierToCatmull([this.immediateMode._curveVertex[1], this.immediateMode._curveVertex[3], this.immediateMode._curveVertex[5], this.immediateMode._curveVertex[7]]), n2 = 0; n2 < h; n2++)
                  t3 = i2[0] * this._lookUpTableBezier[n2][0] + i2[1] * this._lookUpTableBezier[n2][1] + i2[2] * this._lookUpTableBezier[n2][2] + i2[3] * this._lookUpTableBezier[n2][3], r2 = a2[0] * this._lookUpTableBezier[n2][0] + a2[1] * this._lookUpTableBezier[n2][1] + a2[2] * this._lookUpTableBezier[n2][2] + a2[3] * this._lookUpTableBezier[n2][3], this.vertex(t3, r2);
                for (n2 = 0; n2 < l2; n2++)
                  this.immediateMode._curveVertex.shift();
              }
            } else if (3 === l2 && (this.immediateMode._curveVertex.push(arguments.length <= 0 ? void 0 : arguments[0]), this.immediateMode._curveVertex.push(arguments.length <= 1 ? void 0 : arguments[1]), this.immediateMode._curveVertex.push(arguments.length <= 2 ? void 0 : arguments[2]), 12 === this.immediateMode._curveVertex.length)) {
              for (this.isCurve = true, i2 = this._bezierToCatmull([this.immediateMode._curveVertex[0], this.immediateMode._curveVertex[3], this.immediateMode._curveVertex[6], this.immediateMode._curveVertex[9]]), a2 = this._bezierToCatmull([this.immediateMode._curveVertex[1], this.immediateMode._curveVertex[4], this.immediateMode._curveVertex[7], this.immediateMode._curveVertex[10]]), e3 = this._bezierToCatmull([this.immediateMode._curveVertex[2], this.immediateMode._curveVertex[5], this.immediateMode._curveVertex[8], this.immediateMode._curveVertex[11]]), n2 = 0; n2 < h; n2++)
                t3 = i2[0] * this._lookUpTableBezier[n2][0] + i2[1] * this._lookUpTableBezier[n2][1] + i2[2] * this._lookUpTableBezier[n2][2] + i2[3] * this._lookUpTableBezier[n2][3], r2 = a2[0] * this._lookUpTableBezier[n2][0] + a2[1] * this._lookUpTableBezier[n2][1] + a2[2] * this._lookUpTableBezier[n2][2] + a2[3] * this._lookUpTableBezier[n2][3], o2 = e3[0] * this._lookUpTableBezier[n2][0] + e3[1] * this._lookUpTableBezier[n2][1] + e3[2] * this._lookUpTableBezier[n2][2] + e3[3] * this._lookUpTableBezier[n2][3], this.vertex(t3, r2, o2);
              for (n2 = 0; n2 < l2; n2++)
                this.immediateMode._curveVertex.shift();
            }
          }, S.default.RendererGL.prototype.image = function(e3, t3, r2, o2, n2, s2, i2, a2, l2) {
            this._isErasing && this.blendMode(this._cachedBlendMode), this._pInst.push(), this._pInst.noLights(), this._pInst.texture(e3), this._pInst.textureMode(_.NORMAL);
            var u = 0, c = (t3 <= e3.width && (u = t3 / e3.width), 1), t3 = (t3 + o2 <= e3.width && (c = (t3 + o2) / e3.width), 0), o2 = (r2 <= e3.height && (t3 = r2 / e3.height), 1);
            r2 + n2 <= e3.height && (o2 = (r2 + n2) / e3.height), this.beginShape(), this.vertex(s2, i2, 0, u, t3), this.vertex(s2 + a2, i2, 0, c, t3), this.vertex(s2 + a2, i2 + l2, 0, c, o2), this.vertex(s2, i2 + l2, 0, u, o2), this.endShape(_.CLOSE), this._pInst.pop(), this._isErasing && this.blendMode(_.REMOVE);
          };
          var n = S.default;
          r.default = n;
        }, { "../core/constants": 256, "../core/main": 267, "./p5.Geometry": 316, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.number.to-fixed": 171, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 311: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var s2 = (l = e2("../core/main")) && l.__esModule ? l : { default: l }, n = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          s2.default.prototype.orbitControl = function(e3, t3, r2) {
            var o2, n2;
            if (this._assert3d("orbitControl"), s2.default._validateParameters("orbitControl", arguments), this.mouseX < this.width && 0 < this.mouseX && this.mouseY < this.height && 0 < this.mouseY)
              return o2 = this._renderer._curCamera, void 0 === e3 && (e3 = 1), void 0 === t3 && (t3 = e3), void 0 === r2 && (r2 = 0.5), true !== this.contextMenuDisabled && (this.canvas.oncontextmenu = function() {
                return false;
              }, this._setProperty("contextMenuDisabled", true)), true !== this.wheelDefaultDisabled && (this.canvas.onwheel = function() {
                return false;
              }, this._setProperty("wheelDefaultDisabled", true)), n2 = this.height < this.width ? this.height : this.width, this._mouseWheelDeltaY !== this._pmouseWheelDeltaY && (0 < this._mouseWheelDeltaY ? this._renderer._curCamera._orbit(0, 0, r2 * n2) : this._renderer._curCamera._orbit(0, 0, -r2 * n2)), this.mouseIsPressed && (this.mouseButton === this.LEFT ? (r2 = -e3 * (this.mouseX - this.pmouseX) / n2, n2 = t3 * (this.mouseY - this.pmouseY) / n2, this._renderer._curCamera._orbit(r2, n2, 0)) : this.mouseButton === this.RIGHT && (r2 = o2._getLocalAxes(), 0 !== (n2 = Math.sqrt(r2.x[0] * r2.x[0] + r2.x[2] * r2.x[2])) && (r2.x[0] /= n2, r2.x[2] /= n2), 0 !== (n2 = Math.sqrt(r2.y[0] * r2.y[0] + r2.y[2] * r2.y[2])) && (r2.y[0] /= n2, r2.y[2] /= n2), n2 = -1 * e3 * (this.mouseX - this.pmouseX), e3 = -1 * t3 * (this.mouseY - this.pmouseY), o2.setPosition(o2.eyeX + n2 * r2.x[0] + e3 * r2.z[0], o2.eyeY, o2.eyeZ + n2 * r2.x[2] + e3 * r2.z[2]))), this;
          }, s2.default.prototype.debugMode = function() {
            this._assert3d("debugMode");
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            s2.default._validateParameters("debugMode", t3);
            for (var o2 = this._registeredMethods.post.length - 1; 0 <= o2; o2--)
              this._registeredMethods.post[o2].toString() !== this._grid().toString() && this._registeredMethods.post[o2].toString() !== this._axesIcon().toString() || this._registeredMethods.post.splice(o2, 1);
            t3[0] === n.GRID ? this.registerMethod("post", this._grid.call(this, t3[1], t3[2], t3[3], t3[4], t3[5])) : t3[0] === n.AXES ? this.registerMethod("post", this._axesIcon.call(this, t3[1], t3[2], t3[3], t3[4])) : (this.registerMethod("post", this._grid.call(this, t3[0], t3[1], t3[2], t3[3], t3[4])), this.registerMethod("post", this._axesIcon.call(this, t3[5], t3[6], t3[7], t3[8])));
          }, s2.default.prototype.noDebugMode = function() {
            this._assert3d("noDebugMode");
            for (var e3 = this._registeredMethods.post.length - 1; 0 <= e3; e3--)
              this._registeredMethods.post[e3].toString() !== this._grid().toString() && this._registeredMethods.post[e3].toString() !== this._axesIcon().toString() || this._registeredMethods.post.splice(e3, 1);
          }, s2.default.prototype._grid = function(e3, r2, o2, n2, s3) {
            void 0 === e3 && (e3 = this.width / 2), void 0 === r2 && (r2 = Math.round(e3 / 30) < 4 ? 4 : Math.round(e3 / 30)), void 0 === o2 && (o2 = 0), void 0 === n2 && (n2 = 0), void 0 === s3 && (s3 = 0);
            var i2 = e3 / r2, a2 = e3 / 2;
            return function() {
              this.push(), this.stroke(255 * this._renderer.curStrokeColor[0], 255 * this._renderer.curStrokeColor[1], 255 * this._renderer.curStrokeColor[2]), this._renderer.uMVMatrix.set(this._renderer._curCamera.cameraMatrix.mat4[0], this._renderer._curCamera.cameraMatrix.mat4[1], this._renderer._curCamera.cameraMatrix.mat4[2], this._renderer._curCamera.cameraMatrix.mat4[3], this._renderer._curCamera.cameraMatrix.mat4[4], this._renderer._curCamera.cameraMatrix.mat4[5], this._renderer._curCamera.cameraMatrix.mat4[6], this._renderer._curCamera.cameraMatrix.mat4[7], this._renderer._curCamera.cameraMatrix.mat4[8], this._renderer._curCamera.cameraMatrix.mat4[9], this._renderer._curCamera.cameraMatrix.mat4[10], this._renderer._curCamera.cameraMatrix.mat4[11], this._renderer._curCamera.cameraMatrix.mat4[12], this._renderer._curCamera.cameraMatrix.mat4[13], this._renderer._curCamera.cameraMatrix.mat4[14], this._renderer._curCamera.cameraMatrix.mat4[15]);
              for (var e4 = 0; e4 <= r2; e4++)
                this.beginShape(this.LINES), this.vertex(-a2 + o2, n2, e4 * i2 - a2 + s3), this.vertex(a2 + o2, n2, e4 * i2 - a2 + s3), this.endShape();
              for (var t3 = 0; t3 <= r2; t3++)
                this.beginShape(this.LINES), this.vertex(t3 * i2 - a2 + o2, n2, -a2 + s3), this.vertex(t3 * i2 - a2 + o2, n2, a2 + s3), this.endShape();
              this.pop();
            };
          }, s2.default.prototype._axesIcon = function(e3, t3, r2, o2) {
            return void 0 === e3 && (e3 = 40 < this.width / 20 ? this.width / 20 : 40), void 0 === t3 && (t3 = -this.width / 4), void 0 === r2 && (r2 = t3), void 0 === o2 && (o2 = t3), function() {
              this.push(), this._renderer.uMVMatrix.set(this._renderer._curCamera.cameraMatrix.mat4[0], this._renderer._curCamera.cameraMatrix.mat4[1], this._renderer._curCamera.cameraMatrix.mat4[2], this._renderer._curCamera.cameraMatrix.mat4[3], this._renderer._curCamera.cameraMatrix.mat4[4], this._renderer._curCamera.cameraMatrix.mat4[5], this._renderer._curCamera.cameraMatrix.mat4[6], this._renderer._curCamera.cameraMatrix.mat4[7], this._renderer._curCamera.cameraMatrix.mat4[8], this._renderer._curCamera.cameraMatrix.mat4[9], this._renderer._curCamera.cameraMatrix.mat4[10], this._renderer._curCamera.cameraMatrix.mat4[11], this._renderer._curCamera.cameraMatrix.mat4[12], this._renderer._curCamera.cameraMatrix.mat4[13], this._renderer._curCamera.cameraMatrix.mat4[14], this._renderer._curCamera.cameraMatrix.mat4[15]), this.strokeWeight(2), this.stroke(255, 0, 0), this.beginShape(this.LINES), this.vertex(t3, r2, o2), this.vertex(t3 + e3, r2, o2), this.endShape(), this.stroke(0, 255, 0), this.beginShape(this.LINES), this.vertex(t3, r2, o2), this.vertex(t3, r2 + e3, o2), this.endShape(), this.stroke(0, 0, 255), this.beginShape(this.LINES), this.vertex(t3, r2, o2), this.vertex(t3, r2, o2 + e3), this.endShape(), this.pop();
            };
          };
          var l = s2.default;
          r.default = l;
        }, { "../core/constants": 256, "../core/main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.splice": 164, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 312: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var m = (s2 = e2("../core/main")) && s2.__esModule ? s2 : { default: s2 }, n = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          m.default.prototype.ambientLight = function(e3, t3, r2, o2) {
            this._assert3d("ambientLight"), m.default._validateParameters("ambientLight", arguments);
            var n2 = this.color.apply(this, arguments);
            return this._renderer.ambientLightColors.push(n2._array[0], n2._array[1], n2._array[2]), this._renderer._enableLighting = true, this;
          }, m.default.prototype.specularColor = function(e3, t3, r2) {
            this._assert3d("specularColor"), m.default._validateParameters("specularColor", arguments);
            var o2 = this.color.apply(this, arguments);
            return this._renderer.specularColors = [o2._array[0], o2._array[1], o2._array[2]], this;
          }, m.default.prototype.directionalLight = function(e3, t3, r2, o2, n2, s3) {
            this._assert3d("directionalLight"), m.default._validateParameters("directionalLight", arguments), e3 = e3 instanceof m.default.Color ? e3 : this.color(e3, t3, r2);
            var i2, a2, t3 = arguments[arguments.length - 1], r2 = "number" == typeof t3 ? (i2 = arguments[arguments.length - 3], a2 = arguments[arguments.length - 2], arguments[arguments.length - 1]) : (i2 = t3.x, a2 = t3.y, t3.z), t3 = Math.sqrt(i2 * i2 + a2 * a2 + r2 * r2);
            return this._renderer.directionalLightDirections.push(i2 / t3, a2 / t3, r2 / t3), this._renderer.directionalLightDiffuseColors.push(e3._array[0], e3._array[1], e3._array[2]), Array.prototype.push.apply(this._renderer.directionalLightSpecularColors, this._renderer.specularColors), this._renderer._enableLighting = true, this;
          }, m.default.prototype.pointLight = function(e3, t3, r2, o2, n2, s3) {
            this._assert3d("pointLight"), m.default._validateParameters("pointLight", arguments), e3 = e3 instanceof m.default.Color ? e3 : this.color(e3, t3, r2);
            var i2, a2, t3 = arguments[arguments.length - 1], r2 = "number" == typeof t3 ? (i2 = arguments[arguments.length - 3], a2 = arguments[arguments.length - 2], arguments[arguments.length - 1]) : (i2 = t3.x, a2 = t3.y, t3.z);
            return this._renderer.pointLightPositions.push(i2, a2, r2), this._renderer.pointLightDiffuseColors.push(e3._array[0], e3._array[1], e3._array[2]), Array.prototype.push.apply(this._renderer.pointLightSpecularColors, this._renderer.specularColors), this._renderer._enableLighting = true, this;
          }, m.default.prototype.lights = function() {
            var e3;
            return this._assert3d("lights"), this._colorMode === n.RGB ? (this.ambientLight(128, 128, 128), this.directionalLight(128, 128, 128, 0, 0, -1)) : (e3 = this._colorMaxes[this._colorMode][2], this.ambientLight(0, 0, e3), this.directionalLight(0, 0, e3, 0, 0, -1)), this;
          }, m.default.prototype.lightFalloff = function(e3, t3, r2) {
            return this._assert3d("lightFalloff"), m.default._validateParameters("lightFalloff", arguments), e3 < 0 && (e3 = 0, console.warn("Value of constant argument in lightFalloff() should be never be negative. Set to 0.")), t3 < 0 && (t3 = 0, console.warn("Value of linear argument in lightFalloff() should be never be negative. Set to 0.")), r2 < 0 && (r2 = 0, console.warn("Value of quadratic argument in lightFalloff() should be never be negative. Set to 0.")), 0 === e3 && 0 === t3 && 0 === r2 && (e3 = 1, console.warn("Either one of the three arguments in lightFalloff() should be greater than zero. Set constant argument to 1.")), this._renderer.constantAttenuation = e3, this._renderer.linearAttenuation = t3, this._renderer.quadraticAttenuation = r2, this;
          }, m.default.prototype.spotLight = function(e3, t3, r2, o2, n2, s3, i2, a2, l, u, c) {
            this._assert3d("spotLight"), m.default._validateParameters("spotLight", arguments);
            var d, f, h, p = arguments.length;
            switch (p) {
              case 11:
              case 10:
                d = this.color(e3, t3, r2), f = new m.default.Vector(o2, n2, s3), h = new m.default.Vector(i2, a2, l);
                break;
              case 9:
                e3 instanceof m.default.Color ? (d = e3, f = new m.default.Vector(t3, r2, o2), h = new m.default.Vector(n2, s3, i2), u = a2, c = l) : o2 instanceof m.default.Vector ? (d = this.color(e3, t3, r2), f = o2, h = new m.default.Vector(n2, s3, i2), u = a2, c = l) : i2 instanceof m.default.Vector ? (d = this.color(e3, t3, r2), f = new m.default.Vector(o2, n2, s3), h = i2, u = a2, c = l) : (d = this.color(e3, t3, r2), f = new m.default.Vector(o2, n2, s3), h = new m.default.Vector(i2, a2, l));
                break;
              case 8:
                u = (h = e3 instanceof m.default.Color ? (d = e3, f = new m.default.Vector(t3, r2, o2), new m.default.Vector(n2, s3, i2)) : o2 instanceof m.default.Vector ? (d = this.color(e3, t3, r2), f = o2, new m.default.Vector(n2, s3, i2)) : (d = this.color(e3, t3, r2), f = new m.default.Vector(o2, n2, s3), i2), a2);
                break;
              case 7:
                e3 instanceof m.default.Color && t3 instanceof m.default.Vector ? (d = e3, f = t3, h = new m.default.Vector(r2, o2, n2), u = s3, c = i2) : e3 instanceof m.default.Color && n2 instanceof m.default.Vector ? (d = e3, f = new m.default.Vector(t3, r2, o2), h = n2, u = s3, c = i2) : o2 instanceof m.default.Vector && n2 instanceof m.default.Vector ? (d = this.color(e3, t3, r2), f = o2, h = n2, u = s3, c = i2) : h = e3 instanceof m.default.Color ? (d = e3, f = new m.default.Vector(t3, r2, o2), new m.default.Vector(n2, s3, i2)) : o2 instanceof m.default.Vector ? (d = this.color(e3, t3, r2), f = o2, new m.default.Vector(n2, s3, i2)) : (d = this.color(e3, t3, r2), f = new m.default.Vector(o2, n2, s3), i2);
                break;
              case 6:
                o2 instanceof m.default.Vector && n2 instanceof m.default.Vector ? (d = this.color(e3, t3, r2), f = o2, h = n2, u = s3) : e3 instanceof m.default.Color && n2 instanceof m.default.Vector ? (d = e3, f = new m.default.Vector(t3, r2, o2), h = n2, u = s3) : e3 instanceof m.default.Color && t3 instanceof m.default.Vector && (d = e3, f = t3, h = new m.default.Vector(r2, o2, n2), u = s3);
                break;
              case 5:
                e3 instanceof m.default.Color && t3 instanceof m.default.Vector && r2 instanceof m.default.Vector ? (d = e3, f = t3, h = r2, u = o2, c = n2) : o2 instanceof m.default.Vector && n2 instanceof m.default.Vector ? (d = this.color(e3, t3, r2), f = o2, h = n2) : e3 instanceof m.default.Color && n2 instanceof m.default.Vector ? (d = e3, f = new m.default.Vector(t3, r2, o2), h = n2) : e3 instanceof m.default.Color && t3 instanceof m.default.Vector && (d = e3, f = t3, h = new m.default.Vector(r2, o2, n2));
                break;
              case 4:
                d = e3, f = t3, h = r2, u = o2;
                break;
              case 3:
                d = e3, f = t3, h = r2;
                break;
              default:
                return console.warn("Sorry, input for spotlight() is not in prescribed format. Too ".concat(p < 3 ? "few" : "many", " arguments were provided")), this;
            }
            return this._renderer.spotLightDiffuseColors.push(d._array[0], d._array[1], d._array[2]), Array.prototype.push.apply(this._renderer.spotLightSpecularColors, this._renderer.specularColors), this._renderer.spotLightPositions.push(f.x, f.y, f.z), h.normalize(), this._renderer.spotLightDirections.push(h.x, h.y, h.z), void 0 === u && (u = Math.PI / 3), void 0 !== c && c < 1 ? (c = 1, console.warn("Value of concentration needs to be greater than 1. Setting it to 1")) : void 0 === c && (c = 100), u = this._renderer._pInst._toRadians(u), this._renderer.spotLightAngle.push(Math.cos(u)), this._renderer.spotLightConc.push(c), this._renderer._enableLighting = true, this;
          }, m.default.prototype.noLights = function() {
            return this._assert3d("noLights"), m.default._validateParameters("noLights", arguments), this._renderer._enableLighting = false, this._renderer.ambientLightColors.length = 0, this._renderer.specularColors = [1, 1, 1], this._renderer.directionalLightDirections.length = 0, this._renderer.directionalLightDiffuseColors.length = 0, this._renderer.directionalLightSpecularColors.length = 0, this._renderer.pointLightPositions.length = 0, this._renderer.pointLightDiffuseColors.length = 0, this._renderer.pointLightSpecularColors.length = 0, this._renderer.spotLightPositions.length = 0, this._renderer.spotLightDirections.length = 0, this._renderer.spotLightDiffuseColors.length = 0, this._renderer.spotLightSpecularColors.length = 0, this._renderer.spotLightAngle.length = 0, this._renderer.spotLightConc.length = 0, this._renderer.constantAttenuation = 1, this._renderer.linearAttenuation = 0, this._renderer.quadraticAttenuation = 0, this._renderer._useShininess = 1, this;
          };
          var s2 = m.default;
          r.default = s2;
        }, { "../core/constants": 256, "../core/main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 313: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.match"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.trim"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.array.splice"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.match"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.trim"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var x = (o = e2("../core/main")) && o.__esModule ? o : { default: o };
          e2("./p5.Geometry"), x.default.prototype.loadModel = function(e3) {
            x.default._validateParameters("loadModel", arguments);
            var y, g, t3, r2 = e3.slice(-4), v = ("boolean" == typeof arguments[1] ? (y = arguments[1], g = arguments[2], t3 = arguments[3], void 0 !== arguments[4] && (r2 = arguments[4])) : (y = false, g = arguments[1], t3 = arguments[2], void 0 !== arguments[3] && (r2 = arguments[3])), new x.default.Geometry()), b = (v.gid = "".concat(e3, "|").concat(y), this);
            return r2.match(/\.stl$/i) ? this.httpDo(e3, "GET", "arrayBuffer", function(e4) {
              !function(e5, t4) {
                if (function(e6) {
                  for (var t5 = new DataView(e6), r3 = [115, 111, 108, 105, 100], o2 = 0; o2 < 5; o2++)
                    if (function(e7, t6, r4) {
                      for (var o3 = 0, n = e7.length; o3 < n; o3++)
                        if (e7[o3] !== t6.getUint8(r4 + o3, false))
                          return;
                      return 1;
                    }(r3, t5, o2))
                      return;
                  return 1;
                }(t4))
                  !function(e6, t5) {
                    for (var r3, o2, n, s2, i, a, l, u = new DataView(t5), c = u.getUint32(80, true), d = false, f = 0; f < 70; f++)
                      1129270351 === u.getUint32(f, false) && 82 === u.getUint8(f + 4) && 61 === u.getUint8(f + 5) && (d = true, s2 = [], i = u.getUint8(f + 6) / 255, a = u.getUint8(f + 7) / 255, l = u.getUint8(f + 8) / 255);
                    for (var h = 0; h < c; h++) {
                      for (var p, m = 84 + 50 * h, y2 = u.getFloat32(m, true), g2 = u.getFloat32(4 + m, true), v2 = u.getFloat32(8 + m, true), b2 = (d && (p = u.getUint16(48 + m, true), n = 0 == (32768 & p) ? (r3 = (31 & p) / 31, o2 = (p >> 5 & 31) / 31, (p >> 10 & 31) / 31) : (r3 = i, o2 = a, l)), new x.default.Vector(y2, g2, v2)), j = 1; j <= 3; j++) {
                        var _ = m + 12 * j, _ = new x.default.Vector(u.getFloat32(_, true), u.getFloat32(4 + _, true), u.getFloat32(8 + _, true));
                        e6.vertices.push(_), e6.vertexNormals.push(b2), d && s2.push(r3, o2, n);
                      }
                      e6.faces.push([3 * h, 3 * h + 1, 3 * h + 2]), e6.uvs.push([0, 0], [0, 0], [0, 0]);
                    }
                  }(e5, t4);
                else {
                  t4 = new DataView(t4);
                  if (!("TextDecoder" in window))
                    return console.warn("Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)");
                  t4 = new TextDecoder("utf-8").decode(t4).split("\n");
                  !function(e6, t5) {
                    for (var r3, o2, n = "", s2 = [], i = 0; i < t5.length; ++i) {
                      for (var a = t5[i].trim(), l = a.split(" "), u = 0; u < l.length; ++u)
                        "" === l[u] && l.splice(u, 1);
                      if (0 !== l.length)
                        switch (n) {
                          case "":
                            if ("solid" !== l[0])
                              return console.error(a), console.error('Invalid state "'.concat(l[0], '", should be "solid"'));
                            n = "solid";
                            break;
                          case "solid":
                            if ("facet" !== l[0] || "normal" !== l[1])
                              return console.error(a), console.error('Invalid state "'.concat(l[0], '", should be "facet normal"'));
                            r3 = new x.default.Vector(parseFloat(l[2]), parseFloat(l[3]), parseFloat(l[4])), e6.vertexNormals.push(r3, r3, r3), n = "facet normal";
                            break;
                          case "facet normal":
                            if ("outer" !== l[0] || "loop" !== l[1])
                              return console.error(a), console.error('Invalid state "'.concat(l[0], '", should be "outer loop"'));
                            n = "vertex";
                            break;
                          case "vertex":
                            if ("vertex" === l[0])
                              o2 = new x.default.Vector(parseFloat(l[1]), parseFloat(l[2]), parseFloat(l[3])), e6.vertices.push(o2), e6.uvs.push([0, 0]), s2.push(e6.vertices.indexOf(o2));
                            else {
                              if ("endloop" !== l[0])
                                return console.error(a), console.error('Invalid state "'.concat(l[0], '", should be "vertex" or "endloop"'));
                              e6.faces.push(s2), s2 = [], n = "endloop";
                            }
                            break;
                          case "endloop":
                            if ("endfacet" !== l[0])
                              return console.error(a), console.error('Invalid state "'.concat(l[0], '", should be "endfacet"'));
                            n = "endfacet";
                            break;
                          case "endfacet":
                            if ("endsolid" !== l[0]) {
                              if ("facet" !== l[0] || "normal" !== l[1])
                                return console.error(a), console.error('Invalid state "'.concat(l[0], '", should be "endsolid" or "facet normal"'));
                              r3 = new x.default.Vector(parseFloat(l[2]), parseFloat(l[3]), parseFloat(l[4])), e6.vertexNormals.push(r3, r3, r3), n = "facet normal";
                            }
                            break;
                          default:
                            console.error('Invalid state "'.concat(n, '"'));
                        }
                    }
                  }(e5, t4);
                }
              }(v, e4), y && v.normalize(), b._decrementPreload(), "function" == typeof g && g(v);
            }, t3) : r2.match(/\.obj$/i) ? this.loadStrings(e3, function(e4) {
              for (var t4 = v, r3 = e4, o2 = { v: [], vt: [], vn: [] }, n = {}, s2 = 0; s2 < r3.length; ++s2) {
                var i = r3[s2].trim().split(/\b\s+/);
                if (0 < i.length) {
                  if ("v" === i[0] || "vn" === i[0]) {
                    var a = new x.default.Vector(parseFloat(i[1]), parseFloat(i[2]), parseFloat(i[3]));
                    o2[i[0]].push(a);
                  } else if ("vt" === i[0]) {
                    a = [parseFloat(i[1]), 1 - parseFloat(i[2])];
                    o2[i[0]].push(a);
                  } else if ("f" === i[0])
                    for (var l = 3; l < i.length; ++l) {
                      for (var u = [], c = [1, l - 1, l], d = 0; d < c.length; ++d) {
                        var f = i[c[d]], h = 0;
                        if (void 0 !== n[f])
                          h = n[f];
                        else {
                          for (var p = f.split("/"), m = 0; m < p.length; m++)
                            p[m] = parseInt(p[m]) - 1;
                          h = n[f] = t4.vertices.length, t4.vertices.push(o2.v[p[0]].copy()), o2.vt[p[1]] ? t4.uvs.push(o2.vt[p[1]].slice()) : t4.uvs.push([0, 0]), o2.vn[p[2]] && t4.vertexNormals.push(o2.vn[p[2]].copy());
                        }
                        u.push(h);
                      }
                      u[0] !== u[1] && u[0] !== u[2] && u[1] !== u[2] && t4.faces.push(u);
                    }
                }
              }
              0 === t4.vertexNormals.length && t4.computeNormals(), y && v.normalize(), b._decrementPreload(), "function" == typeof g && g(v);
            }, t3) : (x.default._friendlyFileLoadError(3, e3), t3 ? t3() : console.error("Sorry, the file type is invalid. Only OBJ and STL files are supported.")), v;
          }, x.default.prototype.model = function(e3) {
            this._assert3d("model"), x.default._validateParameters("model", arguments), 0 < e3.vertices.length && (this._renderer.geometryInHash(e3.gid) || (e3._makeTriangleEdges()._edgesToVertices(), this._renderer.createBuffers(e3.gid, e3)), this._renderer.drawBuffers(e3.gid));
          };
          var o = x.default;
          r.default = o;
        }, { "../core/main": 267, "./p5.Geometry": 316, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.slice": 162, "core-js/modules/es.array.splice": 164, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.string.match": 187, "core-js/modules/es.string.split": 191, "core-js/modules/es.string.trim": 193 }], 314: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.join"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.join"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var u = (s2 = e2("../core/main")) && s2.__esModule ? s2 : { default: s2 }, n = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          e2("./p5.Texture"), u.default.prototype.loadShader = function(e3, t3, r2, o2) {
            u.default._validateParameters("loadShader", arguments), o2 = o2 || console.error;
            function n2() {
              i2._decrementPreload(), r2 && r2(s3);
            }
            var s3 = new u.default.Shader(), i2 = this, a2 = false, l = false;
            return this.loadStrings(e3, function(e4) {
              s3._vertSrc = e4.join("\n"), l = true, a2 && n2();
            }, o2), this.loadStrings(t3, function(e4) {
              s3._fragSrc = e4.join("\n"), a2 = true, l && n2();
            }, o2), s3;
          }, u.default.prototype.createShader = function(e3, t3) {
            return this._assert3d("createShader"), u.default._validateParameters("createShader", arguments), new u.default.Shader(this._renderer, e3, t3);
          }, u.default.prototype.shader = function(e3) {
            return this._assert3d("shader"), u.default._validateParameters("shader", arguments), void 0 === e3._renderer && (e3._renderer = this._renderer), e3.init(), e3.isStrokeShader() ? this._renderer.userStrokeShader = e3 : (this._renderer.userFillShader = e3, this._renderer._useNormalMaterial = false), this;
          }, u.default.prototype.resetShader = function() {
            return this._renderer.userFillShader = this._renderer.userStrokeShader = null, this;
          }, u.default.prototype.texture = function(e3) {
            return this._assert3d("texture"), u.default._validateParameters("texture", arguments), e3.gifProperties && e3._animateGif(this), this._renderer.drawMode = n.TEXTURE, this._renderer._useSpecularMaterial = false, this._renderer._useEmissiveMaterial = false, this._renderer._useNormalMaterial = false, this._renderer._tex = e3, this._renderer._setProperty("_doFill", true), this;
          }, u.default.prototype.textureMode = function(e3) {
            e3 !== n.IMAGE && e3 !== n.NORMAL ? console.warn("You tried to set ".concat(e3, " textureMode only supports IMAGE & NORMAL ")) : this._renderer.textureMode = e3;
          }, u.default.prototype.textureWrap = function(e3) {
            for (var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : e3, r2 = (this._renderer.textureWrapX = e3, this._renderer.textureWrapY = t3, this._renderer.textures), o2 = 0; o2 < r2.length; o2++)
              r2[o2].setWrapMode(e3, t3);
          }, u.default.prototype.normalMaterial = function() {
            this._assert3d("normalMaterial");
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            return u.default._validateParameters("normalMaterial", t3), this._renderer.drawMode = n.FILL, this._renderer._useSpecularMaterial = false, this._renderer._useEmissiveMaterial = false, this._renderer._useNormalMaterial = true, this._renderer.curFillColor = [1, 1, 1, 1], this._renderer._setProperty("_doFill", true), this.noStroke(), this;
          }, u.default.prototype.ambientMaterial = function(e3, t3, r2) {
            this._assert3d("ambientMaterial"), u.default._validateParameters("ambientMaterial", arguments);
            var o2 = u.default.prototype.color.apply(this, arguments);
            return this._renderer.curAmbientColor = o2._array, this._renderer._useNormalMaterial = false, this._renderer._enableLighting = true, this._renderer._tex = null, this._renderer._setProperty("_doFill", true), this;
          }, u.default.prototype.emissiveMaterial = function(e3, t3, r2, o2) {
            this._assert3d("emissiveMaterial"), u.default._validateParameters("emissiveMaterial", arguments);
            var n2 = u.default.prototype.color.apply(this, arguments);
            return this._renderer.curEmissiveColor = n2._array, this._renderer._useEmissiveMaterial = true, this._renderer._useNormalMaterial = false, this._renderer._enableLighting = true, this._renderer._tex = null, this;
          }, u.default.prototype.specularMaterial = function(e3, t3, r2, o2) {
            this._assert3d("specularMaterial"), u.default._validateParameters("specularMaterial", arguments);
            var n2 = u.default.prototype.color.apply(this, arguments);
            return this._renderer.curSpecularColor = n2._array, this._renderer._useSpecularMaterial = true, this._renderer._useNormalMaterial = false, this._renderer._enableLighting = true, this._renderer._tex = null, this;
          }, u.default.prototype.shininess = function(e3) {
            return this._assert3d("shininess"), u.default._validateParameters("shininess", arguments), this._renderer._useShininess = e3 = e3 < 1 ? 1 : e3, this;
          }, u.default.RendererGL.prototype._applyColorBlend = function(e3) {
            var t3 = this.GL, r2 = this.drawMode === n.TEXTURE || this.curBlendMode !== n.BLEND || e3[e3.length - 1] < 1 || this._isErasing;
            return r2 !== this._isBlending && (r2 || this.curBlendMode !== n.BLEND && this.curBlendMode !== n.ADD ? t3.enable(t3.BLEND) : t3.disable(t3.BLEND), t3.depthMask(true), this._isBlending = r2), this._applyBlendMode(), e3;
          }, u.default.RendererGL.prototype._applyBlendMode = function() {
            if (this._cachedBlendMode !== this.curBlendMode) {
              var e3 = this.GL;
              switch (this.curBlendMode) {
                case n.BLEND:
                  e3.blendEquation(e3.FUNC_ADD), e3.blendFunc(e3.SRC_ALPHA, e3.ONE_MINUS_SRC_ALPHA);
                  break;
                case n.ADD:
                  e3.blendEquation(e3.FUNC_ADD), e3.blendFunc(e3.SRC_ALPHA, e3.ONE);
                  break;
                case n.REMOVE:
                  e3.blendEquation(e3.FUNC_REVERSE_SUBTRACT), e3.blendFunc(e3.SRC_ALPHA, e3.DST_ALPHA);
                  break;
                case n.MULTIPLY:
                  e3.blendEquationSeparate(e3.FUNC_ADD, e3.FUNC_ADD), e3.blendFuncSeparate(e3.ZERO, e3.SRC_COLOR, e3.ONE, e3.ONE);
                  break;
                case n.SCREEN:
                  e3.blendEquationSeparate(e3.FUNC_ADD, e3.FUNC_ADD), e3.blendFuncSeparate(e3.ONE_MINUS_DST_COLOR, e3.ONE, e3.ONE, e3.ONE);
                  break;
                case n.EXCLUSION:
                  e3.blendEquationSeparate(e3.FUNC_ADD, e3.FUNC_ADD), e3.blendFuncSeparate(e3.ONE_MINUS_DST_COLOR, e3.ONE_MINUS_SRC_COLOR, e3.ONE, e3.ONE);
                  break;
                case n.REPLACE:
                  e3.blendEquation(e3.FUNC_ADD), e3.blendFunc(e3.ONE, e3.ZERO);
                  break;
                case n.SUBTRACT:
                  e3.blendEquationSeparate(e3.FUNC_REVERSE_SUBTRACT, e3.FUNC_ADD), e3.blendFuncSeparate(e3.SRC_ALPHA, e3.ONE, e3.ONE, e3.ONE);
                  break;
                case n.DARKEST:
                  this.blendExt ? (e3.blendEquationSeparate(this.blendExt.MIN_EXT, e3.FUNC_ADD), e3.blendFuncSeparate(e3.ONE, e3.ONE, e3.ONE, e3.ONE)) : console.warn("blendMode(DARKEST) does not work in your browser in WEBGL mode.");
                  break;
                case n.LIGHTEST:
                  this.blendExt ? (e3.blendEquationSeparate(this.blendExt.MAX_EXT, e3.FUNC_ADD), e3.blendFuncSeparate(e3.ONE, e3.ONE, e3.ONE, e3.ONE)) : console.warn("blendMode(LIGHTEST) does not work in your browser in WEBGL mode.");
                  break;
                default:
                  console.error("Oops! Somehow RendererGL set curBlendMode to an unsupported mode.");
              }
              this._isErasing || (this._cachedBlendMode = this.curBlendMode);
            }
          };
          var s2 = u.default;
          r.default = s2;
        }, { "../core/constants": 256, "../core/main": 267, "./p5.Texture": 323, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.join": 159, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 315: [function(e2, t2, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var f = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          f.default.prototype.camera = function() {
            var e3;
            this._assert3d("camera");
            for (var t3 = arguments.length, r2 = new Array(t3), o = 0; o < t3; o++)
              r2[o] = arguments[o];
            return f.default._validateParameters("camera", r2), (e3 = this._renderer._curCamera).camera.apply(e3, r2), this;
          }, f.default.prototype.perspective = function() {
            var e3;
            this._assert3d("perspective");
            for (var t3 = arguments.length, r2 = new Array(t3), o = 0; o < t3; o++)
              r2[o] = arguments[o];
            return f.default._validateParameters("perspective", r2), (e3 = this._renderer._curCamera).perspective.apply(e3, r2), this;
          }, f.default.prototype.ortho = function() {
            var e3;
            this._assert3d("ortho");
            for (var t3 = arguments.length, r2 = new Array(t3), o = 0; o < t3; o++)
              r2[o] = arguments[o];
            return f.default._validateParameters("ortho", r2), (e3 = this._renderer._curCamera).ortho.apply(e3, r2), this;
          }, f.default.prototype.frustum = function() {
            var e3;
            this._assert3d("frustum");
            for (var t3 = arguments.length, r2 = new Array(t3), o = 0; o < t3; o++)
              r2[o] = arguments[o];
            return f.default._validateParameters("frustum", r2), (e3 = this._renderer._curCamera).frustum.apply(e3, r2), this;
          }, f.default.prototype.createCamera = function() {
            this._assert3d("createCamera");
            var e3 = new f.default.Camera(this._renderer);
            return e3._computeCameraDefaultSettings(), e3._setDefaultCamera(), this._renderer._curCamera = e3;
          }, f.default.Camera = function(e3) {
            this._renderer = e3, this.cameraType = "default", this.cameraMatrix = new f.default.Matrix(), this.projMatrix = new f.default.Matrix();
          }, f.default.Camera.prototype.perspective = function(e3, t3, r2, o) {
            this.cameraType = 0 < arguments.length ? "custom" : "default", void 0 === e3 ? (e3 = this.defaultCameraFOV, this.cameraFOV = e3) : this.cameraFOV = this._renderer._pInst._toRadians(e3), void 0 === t3 && (t3 = this.defaultAspectRatio), void 0 === r2 && (r2 = this.defaultCameraNear), void 0 === o && (o = this.defaultCameraFar), r2 <= 1e-4 && (r2 = 0.01, console.log("Avoid perspective near plane values close to or below 0. Setting value to 0.01.")), o < r2 && console.log("Perspective far plane value is less than near plane value. Nothing will be shown."), this.aspectRatio = t3, this.cameraNear = r2, this.cameraFar = o, this.projMatrix = f.default.Matrix.identity();
            var e3 = 1 / Math.tan(this.cameraFOV / 2), n = 1 / (this.cameraNear - this.cameraFar);
            this.projMatrix.set(e3 / t3, 0, 0, 0, 0, -e3, 0, 0, 0, 0, (o + r2) * n, -1, 0, 0, 2 * o * r2 * n, 0), this._isActive() && this._renderer.uPMatrix.set(this.projMatrix.mat4[0], this.projMatrix.mat4[1], this.projMatrix.mat4[2], this.projMatrix.mat4[3], this.projMatrix.mat4[4], this.projMatrix.mat4[5], this.projMatrix.mat4[6], this.projMatrix.mat4[7], this.projMatrix.mat4[8], this.projMatrix.mat4[9], this.projMatrix.mat4[10], this.projMatrix.mat4[11], this.projMatrix.mat4[12], this.projMatrix.mat4[13], this.projMatrix.mat4[14], this.projMatrix.mat4[15]);
          }, f.default.Camera.prototype.ortho = function(e3, t3, r2, o, n, s2) {
            void 0 === e3 && (e3 = -this._renderer.width / 2), void 0 === t3 && (t3 = +this._renderer.width / 2), void 0 === r2 && (r2 = -this._renderer.height / 2), void 0 === n && (n = 0);
            var i = t3 - e3, a = (o = void 0 === o ? +this._renderer.height / 2 : o) - r2, l = (s2 = void 0 === s2 ? Math.max(this._renderer.width, this._renderer.height) : s2) - n, u = 2 / i, c = 2 / a, d = -2 / l, t3 = -(t3 + e3) / i, e3 = -(o + r2) / a, i = -(s2 + n) / l;
            this.projMatrix = f.default.Matrix.identity(), this.projMatrix.set(u, 0, 0, 0, 0, -c, 0, 0, 0, 0, d, 0, t3, e3, i, 1), this._isActive() && this._renderer.uPMatrix.set(this.projMatrix.mat4[0], this.projMatrix.mat4[1], this.projMatrix.mat4[2], this.projMatrix.mat4[3], this.projMatrix.mat4[4], this.projMatrix.mat4[5], this.projMatrix.mat4[6], this.projMatrix.mat4[7], this.projMatrix.mat4[8], this.projMatrix.mat4[9], this.projMatrix.mat4[10], this.projMatrix.mat4[11], this.projMatrix.mat4[12], this.projMatrix.mat4[13], this.projMatrix.mat4[14], this.projMatrix.mat4[15]), this.cameraType = "custom";
          }, f.default.Camera.prototype.frustum = function(e3, t3, r2, o, n, s2) {
            void 0 === e3 && (e3 = -this._renderer.width / 2), void 0 === t3 && (t3 = +this._renderer.width / 2), void 0 === r2 && (r2 = -this._renderer.height / 2), void 0 === n && (n = 0);
            var i = t3 - e3, a = (o = void 0 === o ? +this._renderer.height / 2 : o) - r2, l = (s2 = void 0 === s2 ? Math.max(this._renderer.width, this._renderer.height) : s2) - n, u = 2 * n / i, c = 2 * n / a, d = -2 * s2 * n / l, t3 = (t3 + e3) / i, e3 = (o + r2) / a, i = -(s2 + n) / l;
            this.projMatrix = f.default.Matrix.identity(), this.projMatrix.set(u, 0, 0, 0, 0, c, 0, 0, t3, e3, i, -1, 0, 0, d, 0), this._isActive() && this._renderer.uPMatrix.set(this.projMatrix.mat4[0], this.projMatrix.mat4[1], this.projMatrix.mat4[2], this.projMatrix.mat4[3], this.projMatrix.mat4[4], this.projMatrix.mat4[5], this.projMatrix.mat4[6], this.projMatrix.mat4[7], this.projMatrix.mat4[8], this.projMatrix.mat4[9], this.projMatrix.mat4[10], this.projMatrix.mat4[11], this.projMatrix.mat4[12], this.projMatrix.mat4[13], this.projMatrix.mat4[14], this.projMatrix.mat4[15]), this.cameraType = "custom";
          }, f.default.Camera.prototype._rotateView = function(e3, t3, r2, o) {
            var n = this.centerX, s2 = this.centerY, i = this.centerZ, a = (n -= this.eyeX, s2 -= this.eyeY, i -= this.eyeZ, f.default.Matrix.identity(this._renderer._pInst)), e3 = (a.rotate(this._renderer._pInst._toRadians(e3), t3, r2, o), [n * a.mat4[0] + s2 * a.mat4[4] + i * a.mat4[8], n * a.mat4[1] + s2 * a.mat4[5] + i * a.mat4[9], n * a.mat4[2] + s2 * a.mat4[6] + i * a.mat4[10]]);
            e3[0] += this.eyeX, e3[1] += this.eyeY, e3[2] += this.eyeZ, this.camera(this.eyeX, this.eyeY, this.eyeZ, e3[0], e3[1], e3[2], this.upX, this.upY, this.upZ);
          }, f.default.Camera.prototype.pan = function(e3) {
            var t3 = this._getLocalAxes();
            this._rotateView(e3, t3.y[0], t3.y[1], t3.y[2]);
          }, f.default.Camera.prototype.tilt = function(e3) {
            var t3 = this._getLocalAxes();
            this._rotateView(e3, t3.x[0], t3.x[1], t3.x[2]);
          }, f.default.Camera.prototype.lookAt = function(e3, t3, r2) {
            this.camera(this.eyeX, this.eyeY, this.eyeZ, e3, t3, r2, this.upX, this.upY, this.upZ);
          }, f.default.Camera.prototype.camera = function(e3, t3, r2, o, n, s2, i, a, l) {
            void 0 === e3 && (e3 = this.defaultEyeX, t3 = this.defaultEyeY, r2 = this.defaultEyeZ, o = e3, n = t3, a = 1, l = i = s2 = 0), this.eyeX = e3, this.eyeY = t3, this.eyeZ = r2, void 0 !== o && (this.centerX = o, this.centerY = n, this.centerZ = s2), void 0 !== i && (this.upX = i, this.upY = a, this.upZ = l);
            o = this._getLocalAxes(), this.cameraMatrix.set(o.x[0], o.y[0], o.z[0], 0, o.x[1], o.y[1], o.z[1], 0, o.x[2], o.y[2], o.z[2], 0, 0, 0, 0, 1), n = -e3;
            return this.cameraMatrix.translate([n, -t3, -r2]), this._isActive() && this._renderer.uMVMatrix.set(this.cameraMatrix.mat4[0], this.cameraMatrix.mat4[1], this.cameraMatrix.mat4[2], this.cameraMatrix.mat4[3], this.cameraMatrix.mat4[4], this.cameraMatrix.mat4[5], this.cameraMatrix.mat4[6], this.cameraMatrix.mat4[7], this.cameraMatrix.mat4[8], this.cameraMatrix.mat4[9], this.cameraMatrix.mat4[10], this.cameraMatrix.mat4[11], this.cameraMatrix.mat4[12], this.cameraMatrix.mat4[13], this.cameraMatrix.mat4[14], this.cameraMatrix.mat4[15]), this;
          }, f.default.Camera.prototype.move = function(e3, t3, r2) {
            var o = this._getLocalAxes(), e3 = [o.x[0] * e3, o.x[1] * e3, o.x[2] * e3], t3 = [o.y[0] * t3, o.y[1] * t3, o.y[2] * t3], o = [o.z[0] * r2, o.z[1] * r2, o.z[2] * r2];
            this.camera(this.eyeX + e3[0] + t3[0] + o[0], this.eyeY + e3[1] + t3[1] + o[1], this.eyeZ + e3[2] + t3[2] + o[2], this.centerX + e3[0] + t3[0] + o[0], this.centerY + e3[1] + t3[1] + o[1], this.centerZ + e3[2] + t3[2] + o[2], 0, 1, 0);
          }, f.default.Camera.prototype.setPosition = function(e3, t3, r2) {
            var o = e3 - this.eyeX, n = t3 - this.eyeY, s2 = r2 - this.eyeZ;
            this.camera(e3, t3, r2, this.centerX + o, this.centerY + n, this.centerZ + s2, 0, 1, 0);
          }, f.default.Camera.prototype._computeCameraDefaultSettings = function() {
            this.defaultCameraFOV = 60 / 180 * Math.PI, this.defaultAspectRatio = this._renderer.width / this._renderer.height, this.defaultEyeX = 0, this.defaultEyeY = 0, this.defaultEyeZ = this._renderer.height / 2 / Math.tan(this.defaultCameraFOV / 2), this.defaultCenterX = 0, this.defaultCenterY = 0, this.defaultCenterZ = 0, this.defaultCameraNear = 0.1 * this.defaultEyeZ, this.defaultCameraFar = 10 * this.defaultEyeZ;
          }, f.default.Camera.prototype._setDefaultCamera = function() {
            this.cameraFOV = this.defaultCameraFOV, this.aspectRatio = this.defaultAspectRatio, this.eyeX = this.defaultEyeX, this.eyeY = this.defaultEyeY, this.eyeZ = this.defaultEyeZ, this.centerX = this.defaultCenterX, this.centerY = this.defaultCenterY, this.centerZ = this.defaultCenterZ, this.upX = 0, this.upY = 1, this.upZ = 0, this.cameraNear = this.defaultCameraNear, this.cameraFar = this.defaultCameraFar, this.perspective(), this.camera(), this.cameraType = "default";
          }, f.default.Camera.prototype._resize = function() {
            "default" === this.cameraType ? (this._computeCameraDefaultSettings(), this._setDefaultCamera()) : this.perspective(this.cameraFOV, this._renderer.width / this._renderer.height);
          }, f.default.Camera.prototype.copy = function() {
            var e3 = new f.default.Camera(this._renderer);
            return e3.cameraFOV = this.cameraFOV, e3.aspectRatio = this.aspectRatio, e3.eyeX = this.eyeX, e3.eyeY = this.eyeY, e3.eyeZ = this.eyeZ, e3.centerX = this.centerX, e3.centerY = this.centerY, e3.centerZ = this.centerZ, e3.cameraNear = this.cameraNear, e3.cameraFar = this.cameraFar, e3.cameraType = this.cameraType, e3.cameraMatrix = this.cameraMatrix.copy(), e3.projMatrix = this.projMatrix.copy(), e3;
          }, f.default.Camera.prototype._getLocalAxes = function() {
            var e3 = this.eyeX - this.centerX, t3 = this.eyeY - this.centerY, r2 = this.eyeZ - this.centerZ, o = Math.sqrt(e3 * e3 + t3 * t3 + r2 * r2), o = (0 !== o && (e3 /= o, t3 /= o, r2 /= o), this.upX), n = (a = this.upY) * r2 - (l = this.upZ) * t3, s2 = -o * r2 + l * e3, i = o * t3 - a * e3, o = t3 * i - r2 * s2, a = -e3 * i + r2 * n, l = e3 * s2 - t3 * n, u = Math.sqrt(n * n + s2 * s2 + i * i), u = (0 !== u && (n /= u, s2 /= u, i /= u), Math.sqrt(o * o + a * a + l * l));
            return 0 !== u && (o /= u, a /= u, l /= u), { x: [n, s2, i], y: [o, a, l], z: [e3, t3, r2] };
          }, f.default.Camera.prototype._orbit = function(e3, t3, r2) {
            var o = this.eyeX - this.centerX, n = this.eyeY - this.centerY, s2 = this.eyeZ - this.centerZ, i = Math.sqrt(o * o + n * n + s2 * s2), o = Math.atan2(o, s2), s2 = Math.acos(Math.max(-1, Math.min(1, n / i))), n = (o += e3, (i += r2) < 0 && (i = 0.1), (s2 += t3) > Math.PI ? s2 = Math.PI : s2 <= 0 && (s2 = 1e-3), Math.sin(s2) * i * Math.sin(o)), e3 = Math.cos(s2) * i, r2 = Math.sin(s2) * i * Math.cos(o);
            this.camera(n + this.centerX, e3 + this.centerY, r2 + this.centerZ, this.centerX, this.centerY, this.centerZ, 0, 1, 0);
          }, f.default.Camera.prototype._isActive = function() {
            return this === this._renderer._curCamera;
          }, f.default.prototype.setCamera = function(e3) {
            this._renderer._curCamera = e3, this._renderer.uPMatrix.set(e3.projMatrix.mat4[0], e3.projMatrix.mat4[1], e3.projMatrix.mat4[2], e3.projMatrix.mat4[3], e3.projMatrix.mat4[4], e3.projMatrix.mat4[5], e3.projMatrix.mat4[6], e3.projMatrix.mat4[7], e3.projMatrix.mat4[8], e3.projMatrix.mat4[9], e3.projMatrix.mat4[10], e3.projMatrix.mat4[11], e3.projMatrix.mat4[12], e3.projMatrix.mat4[13], e3.projMatrix.mat4[14], e3.projMatrix.mat4[15]);
          };
          e2 = f.default.Camera;
          r.default = e2;
        }, { "../core/main": 267 }], 316: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.string.sub"), e2("core-js/modules/es.string.sub"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var l = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          l.default.Geometry = function(e3, t3, r2) {
            return this.vertices = [], this.lineVertices = [], this.lineNormals = [], this.vertexNormals = [], this.faces = [], this.uvs = [], this.edges = [], this.vertexColors = [], this.detailX = void 0 !== e3 ? e3 : 1, this.detailY = void 0 !== t3 ? t3 : 1, this.dirtyFlags = {}, r2 instanceof Function && r2.call(this), this;
          }, l.default.Geometry.prototype.reset = function() {
            this.lineVertices.length = 0, this.lineNormals.length = 0, this.vertices.length = 0, this.edges.length = 0, this.vertexColors.length = 0, this.vertexNormals.length = 0, this.uvs.length = 0, this.dirtyFlags = {};
          }, l.default.Geometry.prototype.computeFaces = function() {
            this.faces.length = 0;
            for (var e3, t3, r2, o = this.detailX + 1, n = 0; n < this.detailY; n++)
              for (var s2 = 0; s2 < this.detailX; s2++)
                t3 = (n + 1) * o + s2 + 1, this.faces.push([n * o + s2, e3 = n * o + s2 + 1, r2 = (n + 1) * o + s2]), this.faces.push([r2, e3, t3]);
            return this;
          }, l.default.Geometry.prototype._getFaceNormal = function(e3) {
            var e3 = this.faces[e3], t3 = this.vertices[e3[0]], r2 = this.vertices[e3[1]], e3 = this.vertices[e3[2]], r2 = l.default.Vector.sub(r2, t3), e3 = l.default.Vector.sub(e3, t3), t3 = l.default.Vector.cross(r2, e3), o = l.default.Vector.mag(t3), r2 = o / (l.default.Vector.mag(r2) * l.default.Vector.mag(e3));
            return 0 === r2 || isNaN(r2) ? (console.warn("p5.Geometry.prototype._getFaceNormal:", "face has colinear sides or a repeated vertex"), t3) : (1 < r2 && (r2 = 1), t3.mult(Math.asin(r2) / o));
          }, l.default.Geometry.prototype.computeNormals = function() {
            for (var e3 = this.vertexNormals, t3 = this.vertices, r2 = this.faces, o = e3.length = 0; o < t3.length; ++o)
              e3.push(new l.default.Vector());
            for (var n = 0; n < r2.length; ++n)
              for (var s2 = r2[n], i = this._getFaceNormal(n), a = 0; a < 3; ++a)
                e3[s2[a]].add(i);
            for (o = 0; o < t3.length; ++o)
              e3[o].normalize();
            return this;
          }, l.default.Geometry.prototype.averageNormals = function() {
            for (var e3 = 0; e3 <= this.detailY; e3++) {
              var t3 = this.detailX + 1, r2 = l.default.Vector.add(this.vertexNormals[e3 * t3], this.vertexNormals[e3 * t3 + this.detailX]), r2 = l.default.Vector.div(r2, 2);
              this.vertexNormals[e3 * t3] = r2, this.vertexNormals[e3 * t3 + this.detailX] = r2;
            }
            return this;
          }, l.default.Geometry.prototype.averagePoleNormals = function() {
            for (var e3 = new l.default.Vector(0, 0, 0), t3 = 0; t3 < this.detailX; t3++)
              e3.add(this.vertexNormals[t3]);
            for (var e3 = l.default.Vector.div(e3, this.detailX), r2 = 0; r2 < this.detailX; r2++)
              this.vertexNormals[r2] = e3;
            e3 = new l.default.Vector(0, 0, 0);
            for (var o = this.vertices.length - 1; o > this.vertices.length - 1 - this.detailX; o--)
              e3.add(this.vertexNormals[o]);
            e3 = l.default.Vector.div(e3, this.detailX);
            for (var n = this.vertices.length - 1; n > this.vertices.length - 1 - this.detailX; n--)
              this.vertexNormals[n] = e3;
            return this;
          }, l.default.Geometry.prototype._makeTriangleEdges = function() {
            if (this.edges.length = 0, Array.isArray(this.strokeIndices))
              for (var e3 = 0, t3 = this.strokeIndices.length; e3 < t3; e3++)
                this.edges.push(this.strokeIndices[e3]);
            else
              for (var r2 = 0; r2 < this.faces.length; r2++)
                this.edges.push([this.faces[r2][0], this.faces[r2][1]]), this.edges.push([this.faces[r2][1], this.faces[r2][2]]), this.edges.push([this.faces[r2][2], this.faces[r2][0]]);
            return this;
          }, l.default.Geometry.prototype._edgesToVertices = function() {
            this.lineVertices.length = 0;
            for (var e3 = this.lineNormals.length = 0; e3 < this.edges.length; e3++) {
              var t3 = this.vertices[this.edges[e3][0]], r2 = this.vertices[this.edges[e3][1]], o = r2.copy().sub(t3).normalize(), n = t3.array(), t3 = t3.array(), s2 = r2.array(), r2 = r2.array(), i = o.array(), o = o.array();
              i.push(1), o.push(-1), this.lineNormals.push(i, o, i, i, o, o), this.lineVertices.push(n, t3, s2, s2, t3, r2);
            }
            return this;
          }, l.default.Geometry.prototype.normalize = function() {
            if (0 < this.vertices.length) {
              for (var e3 = this.vertices[0].copy(), t3 = this.vertices[0].copy(), r2 = 0; r2 < this.vertices.length; r2++)
                e3.x = Math.max(e3.x, this.vertices[r2].x), t3.x = Math.min(t3.x, this.vertices[r2].x), e3.y = Math.max(e3.y, this.vertices[r2].y), t3.y = Math.min(t3.y, this.vertices[r2].y), e3.z = Math.max(e3.z, this.vertices[r2].z), t3.z = Math.min(t3.z, this.vertices[r2].z);
              for (var o = l.default.Vector.lerp(e3, t3, 0.5), n = l.default.Vector.sub(e3, t3), s2 = 200 / Math.max(Math.max(n.x, n.y), n.z), i = 0; i < this.vertices.length; i++)
                this.vertices[i].sub(o), this.vertices[i].mult(s2);
            }
            return this;
          };
          e2 = l.default.Geometry;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.string.sub": 192 }], 317: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.typed-array.float32-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.typed-array.float32-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var O = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          var o = Array, L = function(e3) {
            return e3 instanceof Array;
          }, e2 = ("undefined" != typeof Float32Array && (o = Float32Array, L = function(e3) {
            return e3 instanceof Array || e3 instanceof Float32Array;
          }), O.default.Matrix = function() {
            for (var e3 = new Array(arguments.length), t3 = 0; t3 < e3.length; ++t3)
              e3[t3] = arguments[t3];
            return e3.length && e3[e3.length - 1] instanceof O.default && (this.p5 = e3[e3.length - 1]), "mat3" === e3[0] ? this.mat3 = Array.isArray(e3[1]) ? e3[1] : new o([1, 0, 0, 0, 1, 0, 0, 0, 1]) : this.mat4 = Array.isArray(e3[0]) ? e3[0] : new o([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this;
          }, O.default.Matrix.prototype.set = function(e3) {
            return e3 instanceof O.default.Matrix ? this.mat4 = e3.mat4 : L(e3) ? this.mat4 = e3 : 16 === arguments.length && (this.mat4[0] = e3, this.mat4[1] = arguments[1], this.mat4[2] = arguments[2], this.mat4[3] = arguments[3], this.mat4[4] = arguments[4], this.mat4[5] = arguments[5], this.mat4[6] = arguments[6], this.mat4[7] = arguments[7], this.mat4[8] = arguments[8], this.mat4[9] = arguments[9], this.mat4[10] = arguments[10], this.mat4[11] = arguments[11], this.mat4[12] = arguments[12], this.mat4[13] = arguments[13], this.mat4[14] = arguments[14], this.mat4[15] = arguments[15]), this;
          }, O.default.Matrix.prototype.get = function() {
            return new O.default.Matrix(this.mat4, this.p5);
          }, O.default.Matrix.prototype.copy = function() {
            var e3 = new O.default.Matrix(this.p5);
            return e3.mat4[0] = this.mat4[0], e3.mat4[1] = this.mat4[1], e3.mat4[2] = this.mat4[2], e3.mat4[3] = this.mat4[3], e3.mat4[4] = this.mat4[4], e3.mat4[5] = this.mat4[5], e3.mat4[6] = this.mat4[6], e3.mat4[7] = this.mat4[7], e3.mat4[8] = this.mat4[8], e3.mat4[9] = this.mat4[9], e3.mat4[10] = this.mat4[10], e3.mat4[11] = this.mat4[11], e3.mat4[12] = this.mat4[12], e3.mat4[13] = this.mat4[13], e3.mat4[14] = this.mat4[14], e3.mat4[15] = this.mat4[15], e3;
          }, O.default.Matrix.identity = function(e3) {
            return new O.default.Matrix(e3);
          }, O.default.Matrix.prototype.transpose = function(e3) {
            var t3, r2, o2, n, s2, i;
            return e3 instanceof O.default.Matrix ? (t3 = e3.mat4[1], r2 = e3.mat4[2], o2 = e3.mat4[3], n = e3.mat4[6], s2 = e3.mat4[7], i = e3.mat4[11], this.mat4[0] = e3.mat4[0], this.mat4[1] = e3.mat4[4], this.mat4[2] = e3.mat4[8], this.mat4[3] = e3.mat4[12], this.mat4[4] = t3, this.mat4[5] = e3.mat4[5], this.mat4[6] = e3.mat4[9], this.mat4[7] = e3.mat4[13], this.mat4[8] = r2, this.mat4[9] = n, this.mat4[10] = e3.mat4[10], this.mat4[11] = e3.mat4[14], this.mat4[12] = o2, this.mat4[13] = s2, this.mat4[14] = i, this.mat4[15] = e3.mat4[15]) : L(e3) && (t3 = e3[1], r2 = e3[2], o2 = e3[3], n = e3[6], s2 = e3[7], i = e3[11], this.mat4[0] = e3[0], this.mat4[1] = e3[4], this.mat4[2] = e3[8], this.mat4[3] = e3[12], this.mat4[4] = t3, this.mat4[5] = e3[5], this.mat4[6] = e3[9], this.mat4[7] = e3[13], this.mat4[8] = r2, this.mat4[9] = n, this.mat4[10] = e3[10], this.mat4[11] = e3[14], this.mat4[12] = o2, this.mat4[13] = s2, this.mat4[14] = i, this.mat4[15] = e3[15]), this;
          }, O.default.Matrix.prototype.invert = function(e3) {
            e3 instanceof O.default.Matrix ? (t3 = e3.mat4[0], r2 = e3.mat4[1], o2 = e3.mat4[2], n = e3.mat4[3], s2 = e3.mat4[4], i = e3.mat4[5], a = e3.mat4[6], l = e3.mat4[7], u = e3.mat4[8], c = e3.mat4[9], d = e3.mat4[10], f = e3.mat4[11], h = e3.mat4[12], p = e3.mat4[13], m = e3.mat4[14], y = e3.mat4[15]) : L(e3) && (t3 = e3[0], r2 = e3[1], o2 = e3[2], n = e3[3], s2 = e3[4], i = e3[5], a = e3[6], l = e3[7], u = e3[8], c = e3[9], d = e3[10], f = e3[11], h = e3[12], p = e3[13], m = e3[14], y = e3[15]);
            var t3, r2, o2, n, s2, i, a, l, u, c, d, f, h, p, m, y, e3 = t3 * i - r2 * s2, g = t3 * a - o2 * s2, v = t3 * l - n * s2, b = r2 * a - o2 * i, j = r2 * l - n * i, _ = o2 * l - n * a, x = u * p - c * h, w = u * m - d * h, S = u * y - f * h, M = c * m - d * p, E = c * y - f * p, T = d * y - f * m, C = e3 * T - g * E + v * M + b * S - j * w + _ * x;
            return C ? (this.mat4[0] = (i * T - a * E + l * M) * (C = 1 / C), this.mat4[1] = (o2 * E - r2 * T - n * M) * C, this.mat4[2] = (p * _ - m * j + y * b) * C, this.mat4[3] = (d * j - c * _ - f * b) * C, this.mat4[4] = (a * S - s2 * T - l * w) * C, this.mat4[5] = (t3 * T - o2 * S + n * w) * C, this.mat4[6] = (m * v - h * _ - y * g) * C, this.mat4[7] = (u * _ - d * v + f * g) * C, this.mat4[8] = (s2 * E - i * S + l * x) * C, this.mat4[9] = (r2 * S - t3 * E - n * x) * C, this.mat4[10] = (h * j - p * v + y * e3) * C, this.mat4[11] = (c * v - u * j - f * e3) * C, this.mat4[12] = (i * w - s2 * M - a * x) * C, this.mat4[13] = (t3 * M - r2 * w + o2 * x) * C, this.mat4[14] = (p * g - h * b - m * e3) * C, this.mat4[15] = (u * b - c * g + d * e3) * C, this) : null;
          }, O.default.Matrix.prototype.invert3x3 = function() {
            var e3 = this.mat3[0], t3 = this.mat3[1], r2 = this.mat3[2], o2 = this.mat3[3], n = this.mat3[4], s2 = this.mat3[5], i = this.mat3[6], a = this.mat3[7], l = this.mat3[8], u = l * n - s2 * a, c = -l * o2 + s2 * i, d = a * o2 - n * i, f = e3 * u + t3 * c + r2 * d;
            return f ? (this.mat3[0] = u * (f = 1 / f), this.mat3[1] = (-l * t3 + r2 * a) * f, this.mat3[2] = (s2 * t3 - r2 * n) * f, this.mat3[3] = c * f, this.mat3[4] = (l * e3 - r2 * i) * f, this.mat3[5] = (-s2 * e3 + r2 * o2) * f, this.mat3[6] = d * f, this.mat3[7] = (-a * e3 + t3 * i) * f, this.mat3[8] = (n * e3 - t3 * o2) * f, this) : null;
          }, O.default.Matrix.prototype.transpose3x3 = function(e3) {
            var t3 = e3[1], r2 = e3[2], o2 = e3[5];
            return this.mat3[1] = e3[3], this.mat3[2] = e3[6], this.mat3[3] = t3, this.mat3[5] = e3[7], this.mat3[6] = r2, this.mat3[7] = o2, this;
          }, O.default.Matrix.prototype.inverseTranspose = function(e3) {
            void 0 === this.mat3 ? console.error("sorry, this function only works with mat3") : (this.mat3[0] = e3.mat4[0], this.mat3[1] = e3.mat4[1], this.mat3[2] = e3.mat4[2], this.mat3[3] = e3.mat4[4], this.mat3[4] = e3.mat4[5], this.mat3[5] = e3.mat4[6], this.mat3[6] = e3.mat4[8], this.mat3[7] = e3.mat4[9], this.mat3[8] = e3.mat4[10]);
            e3 = this.invert3x3();
            if (e3)
              e3.transpose3x3(this.mat3);
            else
              for (var t3 = 0; t3 < 9; t3++)
                this.mat3[t3] = 0;
            return this;
          }, O.default.Matrix.prototype.determinant = function() {
            var e3 = this.mat4[0] * this.mat4[5] - this.mat4[1] * this.mat4[4], t3 = this.mat4[0] * this.mat4[6] - this.mat4[2] * this.mat4[4], r2 = this.mat4[0] * this.mat4[7] - this.mat4[3] * this.mat4[4], o2 = this.mat4[1] * this.mat4[6] - this.mat4[2] * this.mat4[5], n = this.mat4[1] * this.mat4[7] - this.mat4[3] * this.mat4[5], s2 = this.mat4[2] * this.mat4[7] - this.mat4[3] * this.mat4[6], i = this.mat4[8] * this.mat4[13] - this.mat4[9] * this.mat4[12], a = this.mat4[8] * this.mat4[14] - this.mat4[10] * this.mat4[12], l = this.mat4[8] * this.mat4[15] - this.mat4[11] * this.mat4[12], u = this.mat4[9] * this.mat4[14] - this.mat4[10] * this.mat4[13], c = this.mat4[9] * this.mat4[15] - this.mat4[11] * this.mat4[13];
            return e3 * (this.mat4[10] * this.mat4[15] - this.mat4[11] * this.mat4[14]) - t3 * c + r2 * u + o2 * l - n * a + s2 * i;
          }, O.default.Matrix.prototype.mult = function(e3) {
            var t3;
            if (e3 === this || e3 === this.mat4)
              t3 = this.copy().mat4;
            else if (e3 instanceof O.default.Matrix)
              t3 = e3.mat4;
            else if (L(e3))
              t3 = e3;
            else {
              if (16 !== arguments.length)
                return;
              t3 = arguments;
            }
            var e3 = this.mat4[0], r2 = this.mat4[1], o2 = this.mat4[2], n = this.mat4[3];
            return this.mat4[0] = e3 * t3[0] + r2 * t3[4] + o2 * t3[8] + n * t3[12], this.mat4[1] = e3 * t3[1] + r2 * t3[5] + o2 * t3[9] + n * t3[13], this.mat4[2] = e3 * t3[2] + r2 * t3[6] + o2 * t3[10] + n * t3[14], this.mat4[3] = e3 * t3[3] + r2 * t3[7] + o2 * t3[11] + n * t3[15], e3 = this.mat4[4], r2 = this.mat4[5], o2 = this.mat4[6], n = this.mat4[7], this.mat4[4] = e3 * t3[0] + r2 * t3[4] + o2 * t3[8] + n * t3[12], this.mat4[5] = e3 * t3[1] + r2 * t3[5] + o2 * t3[9] + n * t3[13], this.mat4[6] = e3 * t3[2] + r2 * t3[6] + o2 * t3[10] + n * t3[14], this.mat4[7] = e3 * t3[3] + r2 * t3[7] + o2 * t3[11] + n * t3[15], e3 = this.mat4[8], r2 = this.mat4[9], o2 = this.mat4[10], n = this.mat4[11], this.mat4[8] = e3 * t3[0] + r2 * t3[4] + o2 * t3[8] + n * t3[12], this.mat4[9] = e3 * t3[1] + r2 * t3[5] + o2 * t3[9] + n * t3[13], this.mat4[10] = e3 * t3[2] + r2 * t3[6] + o2 * t3[10] + n * t3[14], this.mat4[11] = e3 * t3[3] + r2 * t3[7] + o2 * t3[11] + n * t3[15], e3 = this.mat4[12], r2 = this.mat4[13], o2 = this.mat4[14], n = this.mat4[15], this.mat4[12] = e3 * t3[0] + r2 * t3[4] + o2 * t3[8] + n * t3[12], this.mat4[13] = e3 * t3[1] + r2 * t3[5] + o2 * t3[9] + n * t3[13], this.mat4[14] = e3 * t3[2] + r2 * t3[6] + o2 * t3[10] + n * t3[14], this.mat4[15] = e3 * t3[3] + r2 * t3[7] + o2 * t3[11] + n * t3[15], this;
          }, O.default.Matrix.prototype.apply = function(e3) {
            var t3;
            if (e3 === this || e3 === this.mat4)
              t3 = this.copy().mat4;
            else if (e3 instanceof O.default.Matrix)
              t3 = e3.mat4;
            else if (L(e3))
              t3 = e3;
            else {
              if (16 !== arguments.length)
                return;
              t3 = arguments;
            }
            var e3 = this.mat4, r2 = e3[0], o2 = e3[4], n = e3[8], s2 = e3[12], r2 = (e3[0] = t3[0] * r2 + t3[1] * o2 + t3[2] * n + t3[3] * s2, e3[4] = t3[4] * r2 + t3[5] * o2 + t3[6] * n + t3[7] * s2, e3[8] = t3[8] * r2 + t3[9] * o2 + t3[10] * n + t3[11] * s2, e3[12] = t3[12] * r2 + t3[13] * o2 + t3[14] * n + t3[15] * s2, e3[1]), o2 = e3[5], n = e3[9], s2 = e3[13], r2 = (e3[1] = t3[0] * r2 + t3[1] * o2 + t3[2] * n + t3[3] * s2, e3[5] = t3[4] * r2 + t3[5] * o2 + t3[6] * n + t3[7] * s2, e3[9] = t3[8] * r2 + t3[9] * o2 + t3[10] * n + t3[11] * s2, e3[13] = t3[12] * r2 + t3[13] * o2 + t3[14] * n + t3[15] * s2, e3[2]), o2 = e3[6], n = e3[10], s2 = e3[14], r2 = (e3[2] = t3[0] * r2 + t3[1] * o2 + t3[2] * n + t3[3] * s2, e3[6] = t3[4] * r2 + t3[5] * o2 + t3[6] * n + t3[7] * s2, e3[10] = t3[8] * r2 + t3[9] * o2 + t3[10] * n + t3[11] * s2, e3[14] = t3[12] * r2 + t3[13] * o2 + t3[14] * n + t3[15] * s2, e3[3]), o2 = e3[7], n = e3[11], s2 = e3[15];
            return e3[3] = t3[0] * r2 + t3[1] * o2 + t3[2] * n + t3[3] * s2, e3[7] = t3[4] * r2 + t3[5] * o2 + t3[6] * n + t3[7] * s2, e3[11] = t3[8] * r2 + t3[9] * o2 + t3[10] * n + t3[11] * s2, e3[15] = t3[12] * r2 + t3[13] * o2 + t3[14] * n + t3[15] * s2, this;
          }, O.default.Matrix.prototype.scale = function(e3, t3, r2) {
            return e3 instanceof O.default.Vector ? (t3 = e3.y, r2 = e3.z, e3 = e3.x) : e3 instanceof Array && (t3 = e3[1], r2 = e3[2], e3 = e3[0]), this.mat4[0] *= e3, this.mat4[1] *= e3, this.mat4[2] *= e3, this.mat4[3] *= e3, this.mat4[4] *= t3, this.mat4[5] *= t3, this.mat4[6] *= t3, this.mat4[7] *= t3, this.mat4[8] *= r2, this.mat4[9] *= r2, this.mat4[10] *= r2, this.mat4[11] *= r2, this;
          }, O.default.Matrix.prototype.rotate = function(e3, t3, r2, o2) {
            t3 instanceof O.default.Vector ? (r2 = t3.y, o2 = t3.z, t3 = t3.x) : t3 instanceof Array && (r2 = t3[1], o2 = t3[2], t3 = t3[0]);
            var n = Math.sqrt(t3 * t3 + r2 * r2 + o2 * o2), n = (t3 *= 1 / n, r2 *= 1 / n, o2 *= 1 / n, this.mat4[0]), s2 = this.mat4[1], i = this.mat4[2], a = this.mat4[3], l = this.mat4[4], u = this.mat4[5], c = this.mat4[6], d = this.mat4[7], f = this.mat4[8], h = this.mat4[9], p = this.mat4[10], m = this.mat4[11], y = Math.sin(e3), e3 = Math.cos(e3), g = 1 - e3, v = t3 * t3 * g + e3, b = r2 * t3 * g + o2 * y, j = o2 * t3 * g - r2 * y, _ = t3 * r2 * g - o2 * y, x = r2 * r2 * g + e3, w = o2 * r2 * g + t3 * y, S = t3 * o2 * g + r2 * y, r2 = r2 * o2 * g - t3 * y, t3 = o2 * o2 * g + e3;
            return this.mat4[0] = n * v + l * b + f * j, this.mat4[1] = s2 * v + u * b + h * j, this.mat4[2] = i * v + c * b + p * j, this.mat4[3] = a * v + d * b + m * j, this.mat4[4] = n * _ + l * x + f * w, this.mat4[5] = s2 * _ + u * x + h * w, this.mat4[6] = i * _ + c * x + p * w, this.mat4[7] = a * _ + d * x + m * w, this.mat4[8] = n * S + l * r2 + f * t3, this.mat4[9] = s2 * S + u * r2 + h * t3, this.mat4[10] = i * S + c * r2 + p * t3, this.mat4[11] = a * S + d * r2 + m * t3, this;
          }, O.default.Matrix.prototype.translate = function(e3) {
            var t3 = e3[0], r2 = e3[1], e3 = e3[2] || 0;
            this.mat4[12] += this.mat4[0] * t3 + this.mat4[4] * r2 + this.mat4[8] * e3, this.mat4[13] += this.mat4[1] * t3 + this.mat4[5] * r2 + this.mat4[9] * e3, this.mat4[14] += this.mat4[2] * t3 + this.mat4[6] * r2 + this.mat4[10] * e3, this.mat4[15] += this.mat4[3] * t3 + this.mat4[7] * r2 + this.mat4[11] * e3;
          }, O.default.Matrix.prototype.rotateX = function(e3) {
            this.rotate(e3, 1, 0, 0);
          }, O.default.Matrix.prototype.rotateY = function(e3) {
            this.rotate(e3, 0, 1, 0);
          }, O.default.Matrix.prototype.rotateZ = function(e3) {
            this.rotate(e3, 0, 0, 1);
          }, O.default.Matrix.prototype.perspective = function(e3, t3, r2, o2) {
            var e3 = 1 / Math.tan(e3 / 2), n = 1 / (r2 - o2);
            return this.mat4[0] = e3 / t3, this.mat4[1] = 0, this.mat4[2] = 0, this.mat4[3] = 0, this.mat4[4] = 0, this.mat4[5] = e3, this.mat4[6] = 0, this.mat4[7] = 0, this.mat4[8] = 0, this.mat4[9] = 0, this.mat4[10] = (o2 + r2) * n, this.mat4[11] = -1, this.mat4[12] = 0, this.mat4[13] = 0, this.mat4[14] = 2 * o2 * r2 * n, this.mat4[15] = 0, this;
          }, O.default.Matrix.prototype.ortho = function(e3, t3, r2, o2, n, s2) {
            var i = 1 / (e3 - t3), a = 1 / (r2 - o2), l = 1 / (n - s2);
            return this.mat4[0] = -2 * i, this.mat4[1] = 0, this.mat4[2] = 0, this.mat4[3] = 0, this.mat4[4] = 0, this.mat4[5] = -2 * a, this.mat4[6] = 0, this.mat4[7] = 0, this.mat4[8] = 0, this.mat4[9] = 0, this.mat4[10] = 2 * l, this.mat4[11] = 0, this.mat4[12] = (e3 + t3) * i, this.mat4[13] = (o2 + r2) * a, this.mat4[14] = (s2 + n) * l, this.mat4[15] = 1, this;
          }, O.default.Matrix);
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.typed-array.copy-within": 197, "core-js/modules/es.typed-array.every": 198, "core-js/modules/es.typed-array.fill": 199, "core-js/modules/es.typed-array.filter": 200, "core-js/modules/es.typed-array.find": 202, "core-js/modules/es.typed-array.find-index": 201, "core-js/modules/es.typed-array.float32-array": 203, "core-js/modules/es.typed-array.for-each": 205, "core-js/modules/es.typed-array.includes": 206, "core-js/modules/es.typed-array.index-of": 207, "core-js/modules/es.typed-array.iterator": 210, "core-js/modules/es.typed-array.join": 211, "core-js/modules/es.typed-array.last-index-of": 212, "core-js/modules/es.typed-array.map": 213, "core-js/modules/es.typed-array.reduce": 215, "core-js/modules/es.typed-array.reduce-right": 214, "core-js/modules/es.typed-array.reverse": 216, "core-js/modules/es.typed-array.set": 217, "core-js/modules/es.typed-array.slice": 218, "core-js/modules/es.typed-array.some": 219, "core-js/modules/es.typed-array.sort": 220, "core-js/modules/es.typed-array.subarray": 221, "core-js/modules/es.typed-array.to-locale-string": 222, "core-js/modules/es.typed-array.to-string": 223 }], 318: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.map"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          e2 = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          e2.default.RenderBuffer = function(e3, t3, r2, o, n, s2) {
            this.size = e3, this.src = t3, this.dst = r2, this.attr = o, this._renderer = n, this.map = s2;
          }, e2.default.RenderBuffer.prototype._prepareBuffer = function(e3, t3) {
            var r2, o, n, s2 = t3.attributes, i = this._renderer.GL, a = e3.model || e3, s2 = s2[this.attr];
            s2 && (r2 = e3[this.dst], 0 < (o = a[this.src]).length && ((n = !r2) && (e3[this.dst] = r2 = i.createBuffer()), i.bindBuffer(i.ARRAY_BUFFER, r2), !n && false === a.dirtyFlags[this.src] || (n = (e3 = this.map) ? e3(o) : o, this._renderer._bindBuffer(r2, i.ARRAY_BUFFER, n), a.dirtyFlags[this.src] = false), t3.enableAttrib(s2, this.size)));
          };
          e2 = e2.default.RenderBuffer;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.map": 161 }], 319: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.map"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var l = (n = e2("../core/main")) && n.__esModule ? n : { default: n }, u = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s2;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s2 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s2.get || s2.set) ? Object.defineProperty(o2, r2, s2) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          function c(e3) {
            return function(e4) {
              if (Array.isArray(e4)) {
                for (var t3 = 0, r2 = new Array(e4.length); t3 < e4.length; t3++)
                  r2[t3] = e4[t3];
                return r2;
              }
            }(e3) || function(e4) {
              if (Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4))
                return Array.from(e4);
            }(e3) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance");
            }();
          }
          e2("./p5.RenderBuffer"), l.default.RendererGL.prototype.beginShape = function(e3) {
            return this.immediateMode.shapeMode = void 0 !== e3 ? e3 : u.TRIANGLE_FAN, this.immediateMode.geometry.reset(), this;
          };
          var d = { vertices: 1, vertexNormals: 1, vertexColors: 4, uvs: 2 }, n = (l.default.RendererGL.prototype.vertex = function(e3, t3) {
            if (this.immediateMode.shapeMode === u.QUADS && this.immediateMode.geometry.vertices.length % 6 == 3)
              for (var r2 in d) {
                var o2 = d[r2], r2 = this.immediateMode.geometry[r2];
                r2.push.apply(r2, c(r2.slice(r2.length - 3 * o2, r2.length - 2 * o2)).concat(c(r2.slice(r2.length - o2, r2.length))));
              }
            var n2, s2, i2 = n2 = s2 = 0, a2 = (3 === arguments.length ? i2 = arguments[2] : 4 === arguments.length ? (n2 = arguments[2], s2 = arguments[3]) : 5 === arguments.length && (i2 = arguments[2], n2 = arguments[3], s2 = arguments[4]), new l.default.Vector(e3, t3, i2)), a2 = (this.immediateMode.geometry.vertices.push(a2), this.immediateMode.geometry.vertexNormals.push(this._currentNormal), this.curFillColor || [0.5, 0.5, 0.5, 1]);
            return this.immediateMode.geometry.vertexColors.push(a2[0], a2[1], a2[2], a2[3]), this.textureMode === u.IMAGE && (null !== this._tex ? 0 < this._tex.width && 0 < this._tex.height && (n2 /= this._tex.width, s2 /= this._tex.height) : null === this._tex && 4 <= arguments.length && console.warn("You must first call texture() before using vertex() with image based u and v coordinates")), this.immediateMode.geometry.uvs.push(n2, s2), this.immediateMode._bezierVertex[0] = e3, this.immediateMode._bezierVertex[1] = t3, this.immediateMode._bezierVertex[2] = i2, this.immediateMode._quadraticVertex[0] = e3, this.immediateMode._quadraticVertex[1] = t3, this.immediateMode._quadraticVertex[2] = i2, this;
          }, l.default.RendererGL.prototype.normal = function(e3, t3, r2) {
            return e3 instanceof l.default.Vector ? this._currentNormal = e3 : this._currentNormal = new l.default.Vector(e3, t3, r2), this;
          }, l.default.RendererGL.prototype.endShape = function(e3, t3, r2, o2, n2, s2) {
            return this.immediateMode.shapeMode === u.POINTS ? this._drawPoints(this.immediateMode.geometry.vertices, this.immediateMode.buffers.point) : (this._processVertices.apply(this, arguments), this._doFill && 1 < this.immediateMode.geometry.vertices.length && this._drawImmediateFill(), this._doStroke && 1 < this.immediateMode.geometry.lineVertices.length && this._drawImmediateStroke(), this.isBezier = false, this.isQuadratic = false, this.isCurve = false, this.immediateMode._bezierVertex.length = 0, this.immediateMode._quadraticVertex.length = 0, this.immediateMode._curveVertex.length = 0), this;
          }, l.default.RendererGL.prototype._processVertices = function(e3) {
            var t3;
            0 !== this.immediateMode.geometry.vertices.length && (t3 = this._doStroke && this.drawMode !== u.TEXTURE, e3 = e3 === u.CLOSE, t3 && (this.immediateMode.geometry.edges = this._calculateEdges(this.immediateMode.shapeMode, this.immediateMode.geometry.vertices, e3), this.immediateMode.geometry._edgesToVertices()), t3 = this.immediateMode.shapeMode === u.TESS, (this.isBezier || this.isQuadratic || this.isCurve || t3) && this.immediateMode.shapeMode !== u.LINES && this._tesselateShape());
          }, l.default.RendererGL.prototype._calculateEdges = function(e3, t3, r2) {
            var o2 = [], n2 = 0;
            switch (e3) {
              case u.TRIANGLE_STRIP:
                for (n2 = 0; n2 < t3.length - 2; n2++)
                  o2.push([n2, n2 + 1]), o2.push([n2, n2 + 2]);
                o2.push([n2, n2 + 1]);
                break;
              case u.TRIANGLES:
                for (n2 = 0; n2 < t3.length - 2; n2 += 3)
                  o2.push([n2, n2 + 1]), o2.push([n2 + 1, n2 + 2]), o2.push([n2 + 2, n2]);
                break;
              case u.LINES:
                for (n2 = 0; n2 < t3.length - 1; n2 += 2)
                  o2.push([n2, n2 + 1]);
                break;
              case u.QUADS:
                for (n2 = 0; n2 < t3.length - 5; n2 += 6)
                  o2.push([n2, n2 + 1]), o2.push([n2 + 1, n2 + 2]), o2.push([n2 + 3, n2 + 5]), o2.push([n2 + 4, n2 + 5]);
                break;
              case u.QUAD_STRIP:
                for (n2 = 0; n2 < t3.length - 2; n2 += 2)
                  o2.push([n2, n2 + 1]), o2.push([n2, n2 + 2]), o2.push([n2 + 1, n2 + 3]);
                o2.push([n2, n2 + 1]);
                break;
              default:
                for (n2 = 0; n2 < t3.length - 1; n2++)
                  o2.push([n2, n2 + 1]);
            }
            return r2 && o2.push([t3.length - 1, 0]), o2;
          }, l.default.RendererGL.prototype._tesselateShape = function() {
            for (var r2 = this, e3 = (this.immediateMode.shapeMode = u.TRIANGLES, [this._flatten(this.immediateMode.geometry.vertices.map(function(e4, t4) {
              return [e4.x, e4.y, e4.z, r2.immediateMode.geometry.uvs[2 * t4], r2.immediateMode.geometry.uvs[2 * t4 + 1], r2.immediateMode.geometry.vertexColors[4 * t4], r2.immediateMode.geometry.vertexColors[4 * t4 + 1], r2.immediateMode.geometry.vertexColors[4 * t4 + 2], r2.immediateMode.geometry.vertexColors[4 * t4 + 3], r2.immediateMode.geometry.vertexNormals[t4].x, r2.immediateMode.geometry.vertexNormals[t4].y, r2.immediateMode.geometry.vertexNormals[t4].z];
            }))]), t3 = this._triangulate(e3), o2 = (this.immediateMode.geometry.vertices = [], this.immediateMode.geometry.vertexNormals = [], this.immediateMode.geometry.uvs = [], []), n2 = 0, s2 = t3.length; n2 < s2; n2 += 12)
              o2.push.apply(o2, c(t3.slice(n2 + 5, n2 + 9))), this.normal.apply(this, c(t3.slice(n2 + 9, n2 + 12))), this.vertex.apply(this, c(t3.slice(n2, n2 + 5)));
            this.immediateMode.geometry.vertexColors = o2;
          }, l.default.RendererGL.prototype._drawImmediateFill = function() {
            var e3 = this.GL, t3 = this._getImmediateFillShader(), r2 = (this._setFillUniforms(t3), true), o2 = false, n2 = void 0;
            try {
              for (var s2, i2 = this.immediateMode.buffers.fill[Symbol.iterator](); !(r2 = (s2 = i2.next()).done); r2 = true)
                s2.value._prepareBuffer(this.immediateMode.geometry, t3);
            } catch (e4) {
              o2 = true, n2 = e4;
            } finally {
              try {
                r2 || null == i2.return || i2.return();
              } finally {
                if (o2)
                  throw n2;
              }
            }
            this.immediateMode.shapeMode !== u.LINE_STRIP && this.immediateMode.shapeMode !== u.LINES || (this.immediateMode.shapeMode = u.TRIANGLE_FAN), this.immediateMode.shapeMode === u.QUADS ? this.immediateMode.shapeMode = u.TRIANGLES : this.immediateMode.shapeMode === u.QUAD_STRIP && (this.immediateMode.shapeMode = u.TRIANGLE_STRIP), this._applyColorBlend(this.curFillColor), e3.drawArrays(this.immediateMode.shapeMode, 0, this.immediateMode.geometry.vertices.length), t3.unbindShader();
          }, l.default.RendererGL.prototype._drawImmediateStroke = function() {
            var e3 = this.GL, t3 = this._getImmediateStrokeShader(), r2 = (this._setStrokeUniforms(t3), true), o2 = false, n2 = void 0;
            try {
              for (var s2, i2 = this.immediateMode.buffers.stroke[Symbol.iterator](); !(r2 = (s2 = i2.next()).done); r2 = true)
                s2.value._prepareBuffer(this.immediateMode.geometry, t3);
            } catch (e4) {
              o2 = true, n2 = e4;
            } finally {
              try {
                r2 || null == i2.return || i2.return();
              } finally {
                if (o2)
                  throw n2;
              }
            }
            this._applyColorBlend(this.curStrokeColor), e3.drawArrays(e3.TRIANGLES, 0, this.immediateMode.geometry.lineVertices.length), t3.unbindShader();
          }, l.default.RendererGL);
          r.default = n;
        }, { "../core/constants": 256, "../core/main": 267, "./p5.RenderBuffer": 318, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.fill": 152, "core-js/modules/es.array.from": 155, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.map": 161, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 320: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.some"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.typed-array.float32-array"), e2("core-js/modules/es.typed-array.uint16-array"), e2("core-js/modules/es.typed-array.uint32-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.some"), e2("core-js/modules/es.object.keys"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.typed-array.float32-array"), e2("core-js/modules/es.typed-array.uint16-array"), e2("core-js/modules/es.typed-array.uint32-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var a = (n = e2("../core/main")) && n.__esModule ? n : { default: n };
          e2("./p5.RendererGL"), e2("./p5.RenderBuffer");
          var o = 0, n = (a.default.RendererGL.prototype._initBufferDefaults = function(e3) {
            var t3;
            return this._freeBuffers(e3), 1e3 < ++o && (t3 = Object.keys(this.retainedMode.geometry)[0], delete this.retainedMode.geometry[t3], o--), this.retainedMode.geometry[e3] = {};
          }, a.default.RendererGL.prototype._freeBuffers = function(e3) {
            var a2, l = this.retainedMode.geometry[e3];
            function t3(e4) {
              var t4 = true, r2 = false, o2 = void 0;
              try {
                for (var n2, s2 = e4[Symbol.iterator](); !(t4 = (n2 = s2.next()).done); t4 = true) {
                  var i = n2.value;
                  l[i.dst] && (a2.deleteBuffer(l[i.dst]), l[i.dst] = null);
                }
              } catch (e5) {
                r2 = true, o2 = e5;
              } finally {
                try {
                  t4 || null == s2.return || s2.return();
                } finally {
                  if (r2)
                    throw o2;
                }
              }
            }
            l && (delete this.retainedMode.geometry[e3], o--, a2 = this.GL, l.indexBuffer && a2.deleteBuffer(l.indexBuffer), t3(this.retainedMode.buffers.stroke), t3(this.retainedMode.buffers.fill));
          }, a.default.RendererGL.prototype.createBuffers = function(e3, t3) {
            var r2, o2, n2, s2 = this.GL, e3 = this._initBufferDefaults(e3), i = (e3.model = t3, e3.indexBuffer);
            return t3.faces.length ? (i = i || (e3.indexBuffer = s2.createBuffer()), n2 = (o2 = (r2 = a.default.RendererGL.prototype._flatten(t3.faces)).some(function(e4) {
              return 65535 < e4;
            })) ? Uint32Array : Uint16Array, this._bindBuffer(i, s2.ELEMENT_ARRAY_BUFFER, r2, n2), e3.indexBufferType = o2 ? s2.UNSIGNED_INT : s2.UNSIGNED_SHORT, e3.vertexCount = 3 * t3.faces.length) : (i && (s2.deleteBuffer(i), e3.indexBuffer = null), e3.vertexCount = t3.vertices ? t3.vertices.length : 0), e3.lineVertexCount = t3.lineVertices ? t3.lineVertices.length : 0, e3;
          }, a.default.RendererGL.prototype.drawBuffers = function(e3) {
            var t3 = this.GL, r2 = this.retainedMode.geometry[e3];
            if (this._doStroke && 0 < r2.lineVertexCount) {
              var o2 = this._getRetainedStrokeShader(), n2 = (this._setStrokeUniforms(o2), true), s2 = false, i = void 0;
              try {
                for (var a2, l = this.retainedMode.buffers.stroke[Symbol.iterator](); !(n2 = (a2 = l.next()).done); n2 = true)
                  a2.value._prepareBuffer(r2, o2);
              } catch (e4) {
                s2 = true, i = e4;
              } finally {
                try {
                  n2 || null == l.return || l.return();
                } finally {
                  if (s2)
                    throw i;
                }
              }
              this._applyColorBlend(this.curStrokeColor), this._drawArrays(t3.TRIANGLES, e3), o2.unbindShader();
            }
            if (this._doFill) {
              var u = this._getRetainedFillShader(), c = (this._setFillUniforms(u), true), s2 = false, i = void 0;
              try {
                for (var d, f = this.retainedMode.buffers.fill[Symbol.iterator](); !(c = (d = f.next()).done); c = true)
                  d.value._prepareBuffer(r2, u);
              } catch (e4) {
                s2 = true, i = e4;
              } finally {
                try {
                  c || null == f.return || f.return();
                } finally {
                  if (s2)
                    throw i;
                }
              }
              r2.indexBuffer && this._bindBuffer(r2.indexBuffer, t3.ELEMENT_ARRAY_BUFFER), this._applyColorBlend(this.curFillColor), this._drawElements(t3.TRIANGLES, e3), u.unbindShader();
            }
            return this;
          }, a.default.RendererGL.prototype.drawBuffersScaled = function(e3, t3, r2, o2) {
            var n2 = this.uMVMatrix.copy();
            try {
              this.uMVMatrix.scale(t3, r2, o2), this.drawBuffers(e3);
            } finally {
              this.uMVMatrix = n2;
            }
          }, a.default.RendererGL.prototype._drawArrays = function(e3, t3) {
            return this.GL.drawArrays(e3, 0, this.retainedMode.geometry[t3].lineVertexCount), this;
          }, a.default.RendererGL.prototype._drawElements = function(e3, t3) {
            var t3 = this.retainedMode.geometry[t3], r2 = this.GL;
            if (t3.indexBuffer) {
              if (t3.indexBufferType === r2.UNSIGNED_INT && !r2.getExtension("OES_element_index_uint"))
                throw new Error("Unable to render a 3d model with > 65535 triangles. Your web browser does not support the WebGL Extension OES_element_index_uint.");
              r2.drawElements(r2.TRIANGLES, t3.vertexCount, t3.indexBufferType, 0);
            } else
              r2.drawArrays(e3 || r2.TRIANGLES, 0, t3.vertexCount);
          }, a.default.RendererGL.prototype._drawPoints = function(e3, t3) {
            var r2 = this.GL, o2 = this._getImmediatePointShader();
            this._setPointUniforms(o2), this._bindBuffer(t3, r2.ARRAY_BUFFER, this._vToNArray(e3), Float32Array, r2.STATIC_DRAW), o2.enableAttrib(o2.attributes.aPosition, 3), r2.drawArrays(r2.Points, 0, e3.length), o2.unbindShader();
          }, a.default.RendererGL);
          r.default = n;
        }, { "../core/main": 267, "./p5.RenderBuffer": 318, "./p5.RendererGL": 321, "core-js/modules/es.array.fill": 152, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.some": 163, "core-js/modules/es.object.keys": 176, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.typed-array.copy-within": 197, "core-js/modules/es.typed-array.every": 198, "core-js/modules/es.typed-array.fill": 199, "core-js/modules/es.typed-array.filter": 200, "core-js/modules/es.typed-array.find": 202, "core-js/modules/es.typed-array.find-index": 201, "core-js/modules/es.typed-array.float32-array": 203, "core-js/modules/es.typed-array.for-each": 205, "core-js/modules/es.typed-array.includes": 206, "core-js/modules/es.typed-array.index-of": 207, "core-js/modules/es.typed-array.iterator": 210, "core-js/modules/es.typed-array.join": 211, "core-js/modules/es.typed-array.last-index-of": 212, "core-js/modules/es.typed-array.map": 213, "core-js/modules/es.typed-array.reduce": 215, "core-js/modules/es.typed-array.reduce-right": 214, "core-js/modules/es.typed-array.reverse": 216, "core-js/modules/es.typed-array.set": 217, "core-js/modules/es.typed-array.slice": 218, "core-js/modules/es.typed-array.some": 219, "core-js/modules/es.typed-array.sort": 220, "core-js/modules/es.typed-array.subarray": 221, "core-js/modules/es.typed-array.to-locale-string": 222, "core-js/modules/es.typed-array.to-string": 223, "core-js/modules/es.typed-array.uint16-array": 224, "core-js/modules/es.typed-array.uint32-array": 225, "core-js/modules/web.dom-collections.iterator": 230 }], 321: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.assign"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.typed-array.float32-array"), e2("core-js/modules/es.typed-array.float64-array"), e2("core-js/modules/es.typed-array.int16-array"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.uint16-array"), e2("core-js/modules/es.typed-array.uint32-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.concat"), e2("core-js/modules/es.array.fill"), e2("core-js/modules/es.array.filter"), e2("core-js/modules/es.array.from"), e2("core-js/modules/es.array.includes"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.object.assign"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.to-string"), e2("core-js/modules/es.string.includes"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.typed-array.float32-array"), e2("core-js/modules/es.typed-array.float64-array"), e2("core-js/modules/es.typed-array.int16-array"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.uint16-array"), e2("core-js/modules/es.typed-array.uint32-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var l = u(e2("../core/main")), s2 = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants")), n = u(e2("libtess"));
          e2("./p5.Shader"), e2("./p5.Camera"), e2("../core/p5.Renderer"), e2("./p5.Matrix"), e2("path");
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          function u(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          function c(e3) {
            return function(e4) {
              if (Array.isArray(e4)) {
                for (var t3 = 0, r2 = new Array(e4.length); t3 < e4.length; t3++)
                  r2[t3] = e4[t3];
                return r2;
              }
            }(e3) || function(e4) {
              if (Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4))
                return Array.from(e4);
            }(e3) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance");
            }();
          }
          var e2 = "precision highp float;\nprecision highp int;\n\nuniform mat4 uViewMatrix;\n\nuniform bool uUseLighting;\n\nuniform int uAmbientLightCount;\nuniform vec3 uAmbientColor[5];\n\nuniform int uDirectionalLightCount;\nuniform vec3 uLightingDirection[5];\nuniform vec3 uDirectionalDiffuseColors[5];\nuniform vec3 uDirectionalSpecularColors[5];\n\nuniform int uPointLightCount;\nuniform vec3 uPointLightLocation[5];\nuniform vec3 uPointLightDiffuseColors[5];	\nuniform vec3 uPointLightSpecularColors[5];\n\nuniform int uSpotLightCount;\nuniform float uSpotLightAngle[5];\nuniform float uSpotLightConc[5];\nuniform vec3 uSpotLightDiffuseColors[5];\nuniform vec3 uSpotLightSpecularColors[5];\nuniform vec3 uSpotLightLocation[5];\nuniform vec3 uSpotLightDirection[5];\n\nuniform bool uSpecular;\nuniform float uShininess;\n\nuniform float uConstantAttenuation;\nuniform float uLinearAttenuation;\nuniform float uQuadraticAttenuation;\n\nconst float specularFactor = 2.0;\nconst float diffuseFactor = 0.73;\n\nstruct LightResult {\n  float specular;\n  float diffuse;\n};\n\nfloat _phongSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n\n  vec3 R = reflect(lightDirection, surfaceNormal);\n  return pow(max(0.0, dot(R, viewDirection)), shininess);\n}\n\nfloat _lambertDiffuse(vec3 lightDirection, vec3 surfaceNormal) {\n  return max(0.0, dot(-lightDirection, surfaceNormal));\n}\n\nLightResult _light(vec3 viewDirection, vec3 normal, vec3 lightVector) {\n\n  vec3 lightDir = normalize(lightVector);\n\n  //compute our diffuse & specular terms\n  LightResult lr;\n  if (uSpecular)\n    lr.specular = _phongSpecular(lightDir, viewDirection, normal, uShininess);\n  lr.diffuse = _lambertDiffuse(lightDir, normal);\n  return lr;\n}\n\nvoid totalLight(\n  vec3 modelPosition,\n  vec3 normal,\n  out vec3 totalDiffuse,\n  out vec3 totalSpecular\n) {\n\n  totalSpecular = vec3(0.0);\n\n  if (!uUseLighting) {\n    totalDiffuse = vec3(1.0);\n    return;\n  }\n\n  totalDiffuse = vec3(0.0);\n\n  vec3 viewDirection = normalize(-modelPosition);\n\n  for (int j = 0; j < 5; j++) {\n    if (j < uDirectionalLightCount) {\n      vec3 lightVector = (uViewMatrix * vec4(uLightingDirection[j], 0.0)).xyz;\n      vec3 lightColor = uDirectionalDiffuseColors[j];\n      vec3 specularColor = uDirectionalSpecularColors[j];\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if (j < uPointLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      //calculate attenuation\n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n      vec3 lightColor = lightFalloff * uPointLightDiffuseColors[j];\n      vec3 specularColor = lightFalloff * uPointLightSpecularColors[j];\n\n      LightResult result = _light(viewDirection, normal, lightVector);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if(j < uSpotLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uSpotLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n\n      vec3 lightDirection = (uViewMatrix * vec4(uSpotLightDirection[j], 0.0)).xyz;\n      float spotDot = dot(normalize(lightVector), normalize(lightDirection));\n      float spotFalloff;\n      if(spotDot < uSpotLightAngle[j]) {\n        spotFalloff = 0.0;\n      }\n      else {\n        spotFalloff = pow(spotDot, uSpotLightConc[j]);\n      }\n      lightFalloff *= spotFalloff;\n\n      vec3 lightColor = uSpotLightDiffuseColors[j];\n      vec3 specularColor = uSpotLightSpecularColors[j];\n     \n      LightResult result = _light(viewDirection, normal, lightVector);\n      \n      totalDiffuse += result.diffuse * lightColor * lightFalloff;\n      totalSpecular += result.specular * lightColor * specularColor * lightFalloff;\n    }\n  }\n\n  totalDiffuse *= diffuseFactor;\n  totalSpecular *= specularFactor;\n}\n", d = { immediateVert: "attribute vec3 aPosition;\nattribute vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uResolution;\nuniform float uPointSize;\n\nvarying vec4 vColor;\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vColor = aVertexColor;\n  gl_PointSize = uPointSize;\n}\n", vertexColorVert: "attribute vec3 aPosition;\nattribute vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vColor = aVertexColor;\n}\n", vertexColorFrag: "precision mediump float;\nvarying vec4 vColor;\nvoid main(void) {\n  gl_FragColor = vColor;\n}", normalVert: "attribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvarying vec3 vVertexNormal;\nvarying highp vec2 vVertTexCoord;\n\nvoid main(void) {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vVertexNormal = normalize(vec3( uNormalMatrix * aNormal ));\n  vVertTexCoord = aTexCoord;\n}\n", normalFrag: "precision mediump float;\nvarying vec3 vVertexNormal;\nvoid main(void) {\n  gl_FragColor = vec4(vVertexNormal, 1.0);\n}", basicFrag: "precision mediump float;\nuniform vec4 uMaterialColor;\nvoid main(void) {\n  gl_FragColor = uMaterialColor;\n}", lightVert: e2 + "// include lighting.glgl\n\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvarying highp vec2 vVertTexCoord;\nvarying vec3 vDiffuseColor;\nvarying vec3 vSpecularColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * viewModelPosition;\n\n  vec3 vertexNormal = normalize(uNormalMatrix * aNormal);\n  vVertTexCoord = aTexCoord;\n\n  totalLight(viewModelPosition.xyz, vertexNormal, vDiffuseColor, vSpecularColor);\n\n  for (int i = 0; i < 8; i++) {\n    if (i < uAmbientLightCount) {\n      vDiffuseColor += uAmbientColor[i];\n    }\n  }\n}\n", lightTextureFrag: "precision highp float;\n\nuniform vec4 uMaterialColor;\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\nuniform bool uEmissive;\n\nvarying highp vec2 vVertTexCoord;\nvarying vec3 vDiffuseColor;\nvarying vec3 vSpecularColor;\n\nvoid main(void) {\n  if(uEmissive && !isTexture) {\n    gl_FragColor = uMaterialColor;\n  }\n  else {\n    gl_FragColor = isTexture ? texture2D(uSampler, vVertTexCoord) * (uTint / vec4(255, 255, 255, 255)) : uMaterialColor;\n    gl_FragColor.rgb = gl_FragColor.rgb * vDiffuseColor + vSpecularColor;\n  }\n}", phongVert: "precision highp float;\nprecision highp int;\n\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nuniform vec3 uAmbientColor[5];\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform int uAmbientLightCount;\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec3 vViewPosition;\nvarying vec3 vAmbientColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n\n  // Pass varyings to fragment shader\n  vViewPosition = viewModelPosition.xyz;\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n\n  vNormal = uNormalMatrix * aNormal;\n  vTexCoord = aTexCoord;\n\n  // TODO: this should be a uniform\n  vAmbientColor = vec3(0.0);\n  for (int i = 0; i < 5; i++) {\n    if (i < uAmbientLightCount) {\n      vAmbientColor += uAmbientColor[i];\n    }\n  }\n}\n", phongFrag: e2 + "// include lighting.glsl\nprecision highp float;\nprecision highp int;\n\nuniform vec4 uSpecularMatColor;\nuniform vec4 uAmbientMatColor;\nuniform vec4 uEmissiveMatColor;\n\nuniform vec4 uMaterialColor;\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec3 vViewPosition;\nvarying vec3 vAmbientColor;\n\nvoid main(void) {\n\n  vec3 diffuse;\n  vec3 specular;\n  totalLight(vViewPosition, normalize(vNormal), diffuse, specular);\n\n  // Calculating final color as result of all lights (plus emissive term).\n\n  gl_FragColor = isTexture ? texture2D(uSampler, vTexCoord) * (uTint / vec4(255, 255, 255, 255)) : uMaterialColor;\n  gl_FragColor.rgb = diffuse * gl_FragColor.rgb + \n                    vAmbientColor * uAmbientMatColor.rgb + \n                    specular * uSpecularMatColor.rgb + \n                    uEmissiveMatColor.rgb;\n}", fontVert: "precision mediump float;\n\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform vec4 uGlyphRect;\nuniform float uGlyphOffset;\n\nvarying vec2 vTexCoord;\nvarying float w;\n\nvoid main() {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  // scale by the size of the glyph's rectangle\n  positionVec4.xy *= uGlyphRect.zw - uGlyphRect.xy;\n\n  // move to the corner of the glyph\n  positionVec4.xy += uGlyphRect.xy;\n\n  // move to the letter's line offset\n  positionVec4.x += uGlyphOffset;\n  \n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vTexCoord = aTexCoord;\n  w = gl_Position.w;\n}\n", fontFrag: "#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\n\n#if 0\n  // simulate integer math using floats\n	#define int float\n	#define ivec2 vec2\n	#define INT(x) float(x)\n\n	int ifloor(float v) { return floor(v); }\n	ivec2 ifloor(vec2 v) { return floor(v); }\n\n#else\n  // use native integer math\n	precision highp int;\n	#define INT(x) x\n\n	int ifloor(float v) { return int(v); }\n	int ifloor(int v) { return v; }\n	ivec2 ifloor(vec2 v) { return ivec2(v); }\n\n#endif\n\nuniform sampler2D uSamplerStrokes;\nuniform sampler2D uSamplerRowStrokes;\nuniform sampler2D uSamplerRows;\nuniform sampler2D uSamplerColStrokes;\nuniform sampler2D uSamplerCols;\n\nuniform ivec2 uStrokeImageSize;\nuniform ivec2 uCellsImageSize;\nuniform ivec2 uGridImageSize;\n\nuniform ivec2 uGridOffset;\nuniform ivec2 uGridSize;\nuniform vec4 uMaterialColor;\n\nvarying vec2 vTexCoord;\n\n// some helper functions\nint round(float v) { return ifloor(v + 0.5); }\nivec2 round(vec2 v) { return ifloor(v + 0.5); }\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2 saturate(vec2 v) { return clamp(v, 0.0, 1.0); }\n\nint mul(float v1, int v2) {\n  return ifloor(v1 * float(v2));\n}\n\nivec2 mul(vec2 v1, ivec2 v2) {\n  return ifloor(v1 * vec2(v2) + 0.5);\n}\n\n// unpack a 16-bit integer from a float vec2\nint getInt16(vec2 v) {\n  ivec2 iv = round(v * 255.0);\n  return iv.x * INT(128) + iv.y;\n}\n\nvec2 pixelScale;\nvec2 coverage = vec2(0.0);\nvec2 weight = vec2(0.5);\nconst float minDistance = 1.0/8192.0;\nconst float hardness = 1.05; // amount of antialias\n\n// the maximum number of curves in a glyph\nconst int N = INT(250);\n\n// retrieves an indexed pixel from a sampler\nvec4 getTexel(sampler2D sampler, int pos, ivec2 size) {\n  int width = size.x;\n  int y = ifloor(pos / width);\n  int x = pos - y * width;  // pos % width\n\n  return texture2D(sampler, (vec2(x, y) + 0.5) / vec2(size));\n}\n\nvoid calulateCrossings(vec2 p0, vec2 p1, vec2 p2, out vec2 C1, out vec2 C2) {\n\n  // get the coefficients of the quadratic in t\n  vec2 a = p0 - p1 * 2.0 + p2;\n  vec2 b = p0 - p1;\n  vec2 c = p0 - vTexCoord;\n\n  // found out which values of 't' it crosses the axes\n  vec2 surd = sqrt(max(vec2(0.0), b * b - a * c));\n  vec2 t1 = ((b - surd) / a).yx;\n  vec2 t2 = ((b + surd) / a).yx;\n\n  // approximate straight lines to avoid rounding errors\n  if (abs(a.y) < 0.001)\n    t1.x = t2.x = c.y / (2.0 * b.y);\n\n  if (abs(a.x) < 0.001)\n    t1.y = t2.y = c.x / (2.0 * b.x);\n\n  // plug into quadratic formula to find the corrdinates of the crossings\n  C1 = ((a * t1 - b * 2.0) * t1 + c) * pixelScale;\n  C2 = ((a * t2 - b * 2.0) * t2 + c) * pixelScale;\n}\n\nvoid coverageX(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  // determine on which side of the x-axis the points lie\n  bool y0 = p0.y > vTexCoord.y;\n  bool y1 = p1.y > vTexCoord.y;\n  bool y2 = p2.y > vTexCoord.y;\n\n  // could web be under the curve (after t1)?\n  if (y1 ? !y2 : y0) {\n    // add the coverage for t1\n    coverage.x += saturate(C1.x + 0.5);\n    // calculate the anti-aliasing for t1\n    weight.x = min(weight.x, abs(C1.x));\n  }\n\n  // are we outside the curve (after t2)?\n  if (y1 ? !y0 : y2) {\n    // subtract the coverage for t2\n    coverage.x -= saturate(C2.x + 0.5);\n    // calculate the anti-aliasing for t2\n    weight.x = min(weight.x, abs(C2.x));\n  }\n}\n\n// this is essentially the same as coverageX, but with the axes swapped\nvoid coverageY(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  bool x0 = p0.x > vTexCoord.x;\n  bool x1 = p1.x > vTexCoord.x;\n  bool x2 = p2.x > vTexCoord.x;\n\n  if (x1 ? !x2 : x0) {\n    coverage.y -= saturate(C1.y + 0.5);\n    weight.y = min(weight.y, abs(C1.y));\n  }\n\n  if (x1 ? !x0 : x2) {\n    coverage.y += saturate(C2.y + 0.5);\n    weight.y = min(weight.y, abs(C2.y));\n  }\n}\n\nvoid main() {\n\n  // calculate the pixel scale based on screen-coordinates\n  pixelScale = hardness / fwidth(vTexCoord);\n\n  // which grid cell is this pixel in?\n  ivec2 gridCoord = ifloor(vTexCoord * vec2(uGridSize));\n\n  // intersect curves in this row\n  {\n    // the index into the row info bitmap\n    int rowIndex = gridCoord.y + uGridOffset.y;\n    // fetch the info texel\n    vec4 rowInfo = getTexel(uSamplerRows, rowIndex, uGridImageSize);\n    // unpack the rowInfo\n    int rowStrokeIndex = getInt16(rowInfo.xy);\n    int rowStrokeCount = getInt16(rowInfo.zw);\n\n    for (int iRowStroke = INT(0); iRowStroke < N; iRowStroke++) {\n      if (iRowStroke >= rowStrokeCount)\n        break;\n\n      // each stroke is made up of 3 points: the start and control point\n      // and the start of the next curve.\n      // fetch the indices of this pair of strokes:\n      vec4 strokeIndices = getTexel(uSamplerRowStrokes, rowStrokeIndex++, uCellsImageSize);\n\n      // unpack the stroke index\n      int strokePos = getInt16(strokeIndices.xy);\n\n      // fetch the two strokes\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n\n      // calculate the coverage\n      coverageX(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  // intersect curves in this column\n  {\n    int colIndex = gridCoord.x + uGridOffset.x;\n    vec4 colInfo = getTexel(uSamplerCols, colIndex, uGridImageSize);\n    int colStrokeIndex = getInt16(colInfo.xy);\n    int colStrokeCount = getInt16(colInfo.zw);\n    \n    for (int iColStroke = INT(0); iColStroke < N; iColStroke++) {\n      if (iColStroke >= colStrokeCount)\n        break;\n\n      vec4 strokeIndices = getTexel(uSamplerColStrokes, colStrokeIndex++, uCellsImageSize);\n\n      int strokePos = getInt16(strokeIndices.xy);\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n      coverageY(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  weight = saturate(1.0 - weight * 2.0);\n  float distance = max(weight.x + weight.y, minDistance); // manhattan approx.\n  float antialias = abs(dot(coverage, weight) / distance);\n  float cover = min(abs(coverage.x), abs(coverage.y));\n  gl_FragColor = uMaterialColor;\n  gl_FragColor.a *= saturate(max(antialias, cover));\n}", lineVert: "/*\n  Part of the Processing project - http://processing.org\n  Copyright (c) 2012-15 The Processing Foundation\n  Copyright (c) 2004-12 Ben Fry and Casey Reas\n  Copyright (c) 2001-04 Massachusetts Institute of Technology\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation, version 2.1.\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n  You should have received a copy of the GNU Lesser General\n  Public License along with this library; if not, write to the\n  Free Software Foundation, Inc., 59 Temple Place, Suite 330,\n  Boston, MA  02111-1307  USA\n*/\n\n#define PROCESSING_LINE_SHADER\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uStrokeWeight;\n\nuniform vec4 uViewport;\nuniform int uPerspective;\n\nattribute vec4 aPosition;\nattribute vec4 aDirection;\n  \nvoid main() {\n  // using a scale <1 moves the lines towards the camera\n  // in order to prevent popping effects due to half of\n  // the line disappearing behind the geometry faces.\n  vec3 scale = vec3(0.9995);\n\n  vec4 posp = uModelViewMatrix * aPosition;\n  vec4 posq = uModelViewMatrix * (aPosition + vec4(aDirection.xyz, 0));\n\n  // Moving vertices slightly toward the camera\n  // to avoid depth-fighting with the fill triangles.\n  // Discussed here:\n  // http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=252848  \n  posp.xyz = posp.xyz * scale;\n  posq.xyz = posq.xyz * scale;\n\n  vec4 p = uProjectionMatrix * posp;\n  vec4 q = uProjectionMatrix * posq;\n\n  // formula to convert from clip space (range -1..1) to screen space (range 0..[width or height])\n  // screen_p = (p.xy/p.w + <1,1>) * 0.5 * uViewport.zw\n\n  // prevent division by W by transforming the tangent formula (div by 0 causes\n  // the line to disappear, see https://github.com/processing/processing/issues/5183)\n  // t = screen_q - screen_p\n  //\n  // tangent is normalized and we don't care which aDirection it points to (+-)\n  // t = +- normalize( screen_q - screen_p )\n  // t = +- normalize( (q.xy/q.w+<1,1>)*0.5*uViewport.zw - (p.xy/p.w+<1,1>)*0.5*uViewport.zw )\n  //\n  // extract common factor, <1,1> - <1,1> cancels out\n  // t = +- normalize( (q.xy/q.w - p.xy/p.w) * 0.5 * uViewport.zw )\n  //\n  // convert to common divisor\n  // t = +- normalize( ((q.xy*p.w - p.xy*q.w) / (p.w*q.w)) * 0.5 * uViewport.zw )\n  //\n  // remove the common scalar divisor/factor, not needed due to normalize and +-\n  // (keep uViewport - can't remove because it has different components for x and y\n  //  and corrects for aspect ratio, see https://github.com/processing/processing/issues/5181)\n  // t = +- normalize( (q.xy*p.w - p.xy*q.w) * uViewport.zw )\n\n  vec2 tangent = normalize((q.xy*p.w - p.xy*q.w) * uViewport.zw);\n\n  // flip tangent to normal (it's already normalized)\n  vec2 normal = vec2(-tangent.y, tangent.x);\n\n  float thickness = aDirection.w * uStrokeWeight;\n  vec2 offset = normal * thickness / 2.0;\n\n  vec2 curPerspScale;\n\n  if(uPerspective == 1) {\n    // Perspective ---\n    // convert from world to clip by multiplying with projection scaling factor\n    // to get the right thickness (see https://github.com/processing/processing/issues/5182)\n    // invert Y, projections in Processing invert Y\n    curPerspScale = (uProjectionMatrix * vec4(1, -1, 0, 0)).xy;\n  } else {\n    // No Perspective ---\n    // multiply by W (to cancel out division by W later in the pipeline) and\n    // convert from screen to clip (derived from clip to screen above)\n    curPerspScale = p.w / (0.5 * uViewport.zw);\n  }\n\n  gl_Position.xy = p.xy + offset.xy * curPerspScale;\n  gl_Position.zw = p.zw;\n}\n", lineFrag: "precision mediump float;\nprecision mediump int;\n\nuniform vec4 uMaterialColor;\n\nvoid main() {\n  gl_FragColor = uMaterialColor;\n}", pointVert: "attribute vec3 aPosition;\nuniform float uPointSize;\nvarying float vStrokeWeight;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nvoid main() {\n	vec4 positionVec4 =  vec4(aPosition, 1.0);\n	gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n	gl_PointSize = uPointSize;\n	vStrokeWeight = uPointSize;\n}", pointFrag: "precision mediump float;\nprecision mediump int;\nuniform vec4 uMaterialColor;\nvarying float vStrokeWeight;\n\nvoid main(){\n	float mask = 0.0;\n\n	// make a circular mask using the gl_PointCoord (goes from 0 - 1 on a point)\n    // might be able to get a nicer edge on big strokeweights with smoothstep but slightly less performant\n\n	mask = step(0.98, length(gl_PointCoord * 2.0 - 1.0));\n\n	// if strokeWeight is 1 or less lets just draw a square\n	// this prevents weird artifacting from carving circles when our points are really small\n	// if strokeWeight is larger than 1, we just use it as is\n\n	mask = mix(0.0, mask, clamp(floor(vStrokeWeight - 0.5),0.0,1.0));\n\n	// throw away the borders of the mask\n    // otherwise we get weird alpha blending issues\n\n	if(mask > 0.98){\n      discard;\n  	}\n\n  	gl_FragColor = vec4(uMaterialColor.rgb * (1.0 - mask), uMaterialColor.a) ;\n}" }, e2 = (l.default.RendererGL = function(e3, t3, r2, o2) {
            return l.default.Renderer.call(this, e3, t3, r2), this._setAttributeDefaults(t3), this._initContext(), this.isP3D = true, this.GL = this.drawingContext, this._pInst._setProperty("drawingContext", this.drawingContext), this._isErasing = false, this._enableLighting = false, this.ambientLightColors = [], this.specularColors = [1, 1, 1], this.directionalLightDirections = [], this.directionalLightDiffuseColors = [], this.directionalLightSpecularColors = [], this.pointLightPositions = [], this.pointLightDiffuseColors = [], this.pointLightSpecularColors = [], this.spotLightPositions = [], this.spotLightDirections = [], this.spotLightDiffuseColors = [], this.spotLightSpecularColors = [], this.spotLightAngle = [], this.spotLightConc = [], this.drawMode = s2.FILL, this.curFillColor = this._cachedFillStyle = [1, 1, 1, 1], this.curAmbientColor = this._cachedFillStyle = [0, 0, 0, 0], this.curSpecularColor = this._cachedFillStyle = [0, 0, 0, 0], this.curEmissiveColor = this._cachedFillStyle = [0, 0, 0, 0], this.curStrokeColor = this._cachedStrokeStyle = [0, 0, 0, 1], this.curBlendMode = s2.BLEND, this._cachedBlendMode = void 0, this.blendExt = this.GL.getExtension("EXT_blend_minmax"), this._isBlending = false, this._useSpecularMaterial = false, this._useEmissiveMaterial = false, this._useNormalMaterial = false, this._useShininess = 1, this._tint = [255, 255, 255, 255], this.constantAttenuation = 1, this.linearAttenuation = 0, this.quadraticAttenuation = 0, this.uMVMatrix = new l.default.Matrix(), this.uPMatrix = new l.default.Matrix(), this.uNMatrix = new l.default.Matrix("mat3"), this._currentNormal = new l.default.Vector(0, 0, 1), this._curCamera = new l.default.Camera(this), this._curCamera._computeCameraDefaultSettings(), this._curCamera._setDefaultCamera(), this._defaultLightShader = void 0, this._defaultImmediateModeShader = void 0, this._defaultNormalShader = void 0, this._defaultColorShader = void 0, this._defaultPointShader = void 0, this.userFillShader = void 0, this.userStrokeShader = void 0, this.userPointShader = void 0, this.retainedMode = { geometry: {}, buffers: { stroke: [new l.default.RenderBuffer(3, "lineVertices", "lineVertexBuffer", "aPosition", this, this._flatten), new l.default.RenderBuffer(4, "lineNormals", "lineNormalBuffer", "aDirection", this, this._flatten)], fill: [new l.default.RenderBuffer(3, "vertices", "vertexBuffer", "aPosition", this, this._vToNArray), new l.default.RenderBuffer(3, "vertexNormals", "normalBuffer", "aNormal", this, this._vToNArray), new l.default.RenderBuffer(4, "vertexColors", "colorBuffer", "aVertexColor", this), new l.default.RenderBuffer(3, "vertexAmbients", "ambientBuffer", "aAmbientColor", this), new l.default.RenderBuffer(2, "uvs", "uvBuffer", "aTexCoord", this, this._flatten)], text: [new l.default.RenderBuffer(3, "vertices", "vertexBuffer", "aPosition", this, this._vToNArray), new l.default.RenderBuffer(2, "uvs", "uvBuffer", "aTexCoord", this, this._flatten)] } }, this.immediateMode = { geometry: new l.default.Geometry(), shapeMode: s2.TRIANGLE_FAN, _bezierVertex: [], _quadraticVertex: [], _curveVertex: [], buffers: { fill: [new l.default.RenderBuffer(3, "vertices", "vertexBuffer", "aPosition", this, this._vToNArray), new l.default.RenderBuffer(3, "vertexNormals", "normalBuffer", "aNormal", this, this._vToNArray), new l.default.RenderBuffer(4, "vertexColors", "colorBuffer", "aVertexColor", this), new l.default.RenderBuffer(3, "vertexAmbients", "ambientBuffer", "aAmbientColor", this), new l.default.RenderBuffer(2, "uvs", "uvBuffer", "aTexCoord", this, this._flatten)], stroke: [new l.default.RenderBuffer(3, "lineVertices", "lineVertexBuffer", "aPosition", this, this._flatten), new l.default.RenderBuffer(4, "lineNormals", "lineNormalBuffer", "aDirection", this, this._flatten)], point: this.GL.createBuffer() } }, this.pointSize = 5, this.curStrokeWeight = 1, this.textures = [], this.textureMode = s2.IMAGE, this.textureWrapX = s2.CLAMP, this.textureWrapY = s2.CLAMP, this._tex = null, this._curveTightness = 6, this._lookUpTableBezier = [], this._lookUpTableQuadratic = [], this._lutBezierDetail = 0, this._lutQuadraticDetail = 0, this._tessy = this._initTessy(), this.fontInfos = {}, this._curShader = void 0, this;
          }, l.default.RendererGL.prototype = Object.create(l.default.Renderer.prototype), l.default.RendererGL.prototype._setAttributeDefaults = function(e3) {
            var t3 = { alpha: false, depth: true, stencil: true, antialias: navigator.userAgent.toLowerCase().includes("safari"), premultipliedAlpha: false, preserveDrawingBuffer: true, perPixelLighting: true };
            null === e3._glAttributes ? e3._glAttributes = t3 : e3._glAttributes = Object.assign(t3, e3._glAttributes);
          }, l.default.RendererGL.prototype._initContext = function() {
            if (this.drawingContext = this.canvas.getContext("webgl", this._pInst._glAttributes) || this.canvas.getContext("experimental-webgl", this._pInst._glAttributes), null === this.drawingContext)
              throw new Error("Error creating webgl context");
            var e3 = this.drawingContext;
            e3.enable(e3.DEPTH_TEST), e3.depthFunc(e3.LEQUAL), e3.viewport(0, 0, e3.drawingBufferWidth, e3.drawingBufferHeight), this._viewport = this.drawingContext.getParameter(this.drawingContext.VIEWPORT);
          }, l.default.RendererGL.prototype._resetContext = function(e3, t3) {
            var r2, o2 = this.width, n2 = this.height, s3 = this.canvas.id, i2 = this._pInst instanceof l.default.Graphics, s3 = (i2 ? ((r2 = this._pInst).canvas.parentNode.removeChild(r2.canvas), r2.canvas = document.createElement("canvas"), (r2._pInst._userNode || document.body).appendChild(r2.canvas), l.default.Element.call(r2, r2.canvas, r2._pInst), r2.width = o2, r2.height = n2) : ((r2 = this.canvas) && r2.parentNode.removeChild(r2), (r2 = document.createElement("canvas")).id = s3, (this._pInst._userNode || document.body).appendChild(r2), this._pInst.canvas = r2, this.canvas = r2), new l.default.RendererGL(this._pInst.canvas, this._pInst, !i2));
            this._pInst._setProperty("_renderer", s3), s3.resize(o2, n2), s3._applyDefaults(), i2 || this._pInst._elements.push(s3), "function" == typeof t3 && setTimeout(function() {
              t3.apply(window._renderer, e3);
            }, 0);
          }, l.default.prototype.setAttributes = function(e3, t3) {
            if (void 0 === this._glAttributes)
              console.log("You are trying to use setAttributes on a p5.Graphics object that does not use a WEBGL renderer.");
            else {
              var r2 = true;
              if (void 0 !== t3 ? (null === this._glAttributes && (this._glAttributes = {}), this._glAttributes[e3] !== t3 && (this._glAttributes[e3] = t3, r2 = false)) : e3 instanceof Object && this._glAttributes !== e3 && (this._glAttributes = e3, r2 = false), this._renderer.isP3D && !r2) {
                if (!this._setupDone) {
                  for (var o2 in this._renderer.retainedMode.geometry)
                    if (this._renderer.retainedMode.geometry.hasOwnProperty(o2))
                      return void console.error("Sorry, Could not set the attributes, you need to call setAttributes() before calling the other drawing methods in setup()");
                }
                this.push(), this._renderer._resetContext(), this.pop(), this._renderer._curCamera && (this._renderer._curCamera._renderer = this._renderer);
              }
            }
          }, l.default.RendererGL.prototype._update = function() {
            this.uMVMatrix.set(this._curCamera.cameraMatrix.mat4[0], this._curCamera.cameraMatrix.mat4[1], this._curCamera.cameraMatrix.mat4[2], this._curCamera.cameraMatrix.mat4[3], this._curCamera.cameraMatrix.mat4[4], this._curCamera.cameraMatrix.mat4[5], this._curCamera.cameraMatrix.mat4[6], this._curCamera.cameraMatrix.mat4[7], this._curCamera.cameraMatrix.mat4[8], this._curCamera.cameraMatrix.mat4[9], this._curCamera.cameraMatrix.mat4[10], this._curCamera.cameraMatrix.mat4[11], this._curCamera.cameraMatrix.mat4[12], this._curCamera.cameraMatrix.mat4[13], this._curCamera.cameraMatrix.mat4[14], this._curCamera.cameraMatrix.mat4[15]), this.ambientLightColors.length = 0, this.specularColors = [1, 1, 1], this.directionalLightDirections.length = 0, this.directionalLightDiffuseColors.length = 0, this.directionalLightSpecularColors.length = 0, this.pointLightPositions.length = 0, this.pointLightDiffuseColors.length = 0, this.pointLightSpecularColors.length = 0, this.spotLightPositions.length = 0, this.spotLightDirections.length = 0, this.spotLightDiffuseColors.length = 0, this.spotLightSpecularColors.length = 0, this.spotLightAngle.length = 0, this.spotLightConc.length = 0, this._enableLighting = false, this._tint = [255, 255, 255, 255], this.GL.clear(this.GL.DEPTH_BUFFER_BIT);
          }, l.default.RendererGL.prototype.background = function() {
            var e3 = (e3 = this._pInst).color.apply(e3, arguments), t3 = e3.levels[0] / 255, r2 = e3.levels[1] / 255, o2 = e3.levels[2] / 255, e3 = e3.levels[3] / 255;
            this.GL.clearColor(t3, r2, o2, e3), this.GL.clear(this.GL.COLOR_BUFFER_BIT);
          }, l.default.RendererGL.prototype.fill = function(e3, t3, r2, o2) {
            var n2 = l.default.prototype.color.apply(this._pInst, arguments);
            this.curFillColor = n2._array, this.drawMode = s2.FILL, this._useNormalMaterial = false, this._tex = null;
          }, l.default.RendererGL.prototype.stroke = function(e3, t3, r2, o2) {
            arguments[3] = 255;
            var n2 = l.default.prototype.color.apply(this._pInst, arguments);
            this.curStrokeColor = n2._array;
          }, l.default.RendererGL.prototype.strokeCap = function(e3) {
            console.error("Sorry, strokeCap() is not yet implemented in WEBGL mode");
          }, l.default.RendererGL.prototype.strokeJoin = function(e3) {
            console.error("Sorry, strokeJoin() is not yet implemented in WEBGL mode");
          }, l.default.RendererGL.prototype.filter = function(e3) {
            console.error("filter() does not work in WEBGL mode");
          }, l.default.RendererGL.prototype.blendMode = function(e3) {
            e3 === s2.DARKEST || e3 === s2.LIGHTEST || e3 === s2.ADD || e3 === s2.BLEND || e3 === s2.SUBTRACT || e3 === s2.SCREEN || e3 === s2.EXCLUSION || e3 === s2.REPLACE || e3 === s2.MULTIPLY || e3 === s2.REMOVE ? this.curBlendMode = e3 : e3 !== s2.BURN && e3 !== s2.OVERLAY && e3 !== s2.HARD_LIGHT && e3 !== s2.SOFT_LIGHT && e3 !== s2.DODGE || console.warn("BURN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, and DODGE only work for blendMode in 2D mode.");
          }, l.default.RendererGL.prototype.erase = function(e3, t3) {
            this._isErasing || (this._applyBlendMode(s2.REMOVE), this._isErasing = true, this._cachedFillStyle = this.curFillColor.slice(), this.curFillColor = [1, 1, 1, e3 / 255], this._cachedStrokeStyle = this.curStrokeColor.slice(), this.curStrokeColor = [1, 1, 1, t3 / 255]);
          }, l.default.RendererGL.prototype.noErase = function() {
            this._isErasing && (this._isErasing = false, this.curFillColor = this._cachedFillStyle.slice(), this.curStrokeColor = this._cachedStrokeStyle.slice(), this.blendMode(this._cachedBlendMode));
          }, l.default.RendererGL.prototype.strokeWeight = function(e3) {
            this.curStrokeWeight !== e3 && (this.pointSize = e3, this.curStrokeWeight = e3);
          }, l.default.RendererGL.prototype._getPixel = function(e3, t3) {
            var r2 = new Uint8Array(4);
            return this.drawingContext.readPixels(e3, t3, 1, 1, this.drawingContext.RGBA, this.drawingContext.UNSIGNED_BYTE, r2), [r2[0], r2[1], r2[2], r2[3]];
          }, l.default.RendererGL.prototype.loadPixels = function() {
            var e3, t3 = this._pixelsState;
            true !== this._pInst._glAttributes.preserveDrawingBuffer ? console.log("loadPixels only works in WebGL when preserveDrawingBuffer is true.") : (t3 = t3.pixels, e3 = this.GL.drawingBufferWidth * this.GL.drawingBufferHeight * 4, t3 instanceof Uint8Array && t3.length === e3 || (t3 = new Uint8Array(e3), this._pixelsState._setProperty("pixels", t3)), e3 = this._pInst._pixelDensity, this.GL.readPixels(0, 0, this.width * e3, this.height * e3, this.GL.RGBA, this.GL.UNSIGNED_BYTE, t3));
          }, l.default.RendererGL.prototype.geometryInHash = function(e3) {
            return void 0 !== this.retainedMode.geometry[e3];
          }, l.default.RendererGL.prototype.resize = function(e3, t3) {
            l.default.Renderer.prototype.resize.call(this, e3, t3), this.GL.viewport(0, 0, this.GL.drawingBufferWidth, this.GL.drawingBufferHeight), this._viewport = this.GL.getParameter(this.GL.VIEWPORT), this._curCamera._resize();
            e3 = this._pixelsState;
            void 0 !== e3.pixels && e3._setProperty("pixels", new Uint8Array(this.GL.drawingBufferWidth * this.GL.drawingBufferHeight * 4));
          }, l.default.RendererGL.prototype.clear = function() {
            this.GL.clearColor((arguments.length <= 0 ? void 0 : arguments[0]) || 0, (arguments.length <= 1 ? void 0 : arguments[1]) || 0, (arguments.length <= 2 ? void 0 : arguments[2]) || 0, (arguments.length <= 3 ? void 0 : arguments[3]) || 0), this.GL.clearDepth(1), this.GL.clear(this.GL.COLOR_BUFFER_BIT | this.GL.DEPTH_BUFFER_BIT);
          }, l.default.RendererGL.prototype.applyMatrix = function(e3, t3, r2, o2, n2, s3) {
            16 === arguments.length ? l.default.Matrix.prototype.apply.apply(this.uMVMatrix, arguments) : this.uMVMatrix.apply([e3, t3, 0, 0, r2, o2, 0, 0, 0, 0, 1, 0, n2, s3, 0, 1]);
          }, l.default.RendererGL.prototype.translate = function(e3, t3, r2) {
            return e3 instanceof l.default.Vector && (r2 = e3.z, t3 = e3.y, e3 = e3.x), this.uMVMatrix.translate([e3, t3, r2]), this;
          }, l.default.RendererGL.prototype.scale = function(e3, t3, r2) {
            return this.uMVMatrix.scale(e3, t3, r2), this;
          }, l.default.RendererGL.prototype.rotate = function(e3, t3) {
            return void 0 === t3 ? this.rotateZ(e3) : (l.default.Matrix.prototype.rotate.apply(this.uMVMatrix, arguments), this);
          }, l.default.RendererGL.prototype.rotateX = function(e3) {
            return this.rotate(e3, 1, 0, 0), this;
          }, l.default.RendererGL.prototype.rotateY = function(e3) {
            return this.rotate(e3, 0, 1, 0), this;
          }, l.default.RendererGL.prototype.rotateZ = function(e3) {
            return this.rotate(e3, 0, 0, 1), this;
          }, l.default.RendererGL.prototype.push = function() {
            var e3 = l.default.Renderer.prototype.push.apply(this), t3 = e3.properties;
            return t3.uMVMatrix = this.uMVMatrix.copy(), t3.uPMatrix = this.uPMatrix.copy(), t3._curCamera = this._curCamera, this._curCamera = this._curCamera.copy(), t3.ambientLightColors = this.ambientLightColors.slice(), t3.specularColors = this.specularColors.slice(), t3.directionalLightDirections = this.directionalLightDirections.slice(), t3.directionalLightDiffuseColors = this.directionalLightDiffuseColors.slice(), t3.directionalLightSpecularColors = this.directionalLightSpecularColors.slice(), t3.pointLightPositions = this.pointLightPositions.slice(), t3.pointLightDiffuseColors = this.pointLightDiffuseColors.slice(), t3.pointLightSpecularColors = this.pointLightSpecularColors.slice(), t3.spotLightPositions = this.spotLightPositions.slice(), t3.spotLightDirections = this.spotLightDirections.slice(), t3.spotLightDiffuseColors = this.spotLightDiffuseColors.slice(), t3.spotLightSpecularColors = this.spotLightSpecularColors.slice(), t3.spotLightAngle = this.spotLightAngle.slice(), t3.spotLightConc = this.spotLightConc.slice(), t3.userFillShader = this.userFillShader, t3.userStrokeShader = this.userStrokeShader, t3.userPointShader = this.userPointShader, t3.pointSize = this.pointSize, t3.curStrokeWeight = this.curStrokeWeight, t3.curStrokeColor = this.curStrokeColor, t3.curFillColor = this.curFillColor, t3.curAmbientColor = this.curAmbientColor, t3.curSpecularColor = this.curSpecularColor, t3.curEmissiveColor = this.curEmissiveColor, t3._useSpecularMaterial = this._useSpecularMaterial, t3._useEmissiveMaterial = this._useEmissiveMaterial, t3._useShininess = this._useShininess, t3.constantAttenuation = this.constantAttenuation, t3.linearAttenuation = this.linearAttenuation, t3.quadraticAttenuation = this.quadraticAttenuation, t3._enableLighting = this._enableLighting, t3._useNormalMaterial = this._useNormalMaterial, t3._tex = this._tex, t3.drawMode = this.drawMode, t3._currentNormal = this._currentNormal, t3.curBlendMode = this.curBlendMode, e3;
          }, l.default.RendererGL.prototype.resetMatrix = function() {
            return this.uMVMatrix = l.default.Matrix.identity(this._pInst), this;
          }, l.default.RendererGL.prototype._getImmediateStrokeShader = function() {
            var e3 = this.userStrokeShader;
            return e3 && e3.isStrokeShader() ? e3 : this._getLineShader();
          }, l.default.RendererGL.prototype._getRetainedStrokeShader = l.default.RendererGL.prototype._getImmediateStrokeShader, l.default.RendererGL.prototype._getImmediateFillShader = function() {
            var e3 = this.userFillShader;
            if (this._useNormalMaterial && (!e3 || !e3.isNormalShader()))
              return this._getNormalShader();
            if (this._enableLighting) {
              if (!e3 || !e3.isLightShader())
                return this._getLightShader();
            } else if (this._tex) {
              if (!e3 || !e3.isTextureShader())
                return this._getLightShader();
            } else if (!e3)
              return this._getImmediateModeShader();
            return e3;
          }, l.default.RendererGL.prototype._getRetainedFillShader = function() {
            if (this._useNormalMaterial)
              return this._getNormalShader();
            var e3 = this.userFillShader;
            if (this._enableLighting) {
              if (!e3 || !e3.isLightShader())
                return this._getLightShader();
            } else if (this._tex) {
              if (!e3 || !e3.isTextureShader())
                return this._getLightShader();
            } else if (!e3)
              return this._getColorShader();
            return e3;
          }, l.default.RendererGL.prototype._getImmediatePointShader = function() {
            var e3 = this.userPointShader;
            return e3 && e3.isPointShader() ? e3 : this._getPointShader();
          }, l.default.RendererGL.prototype._getRetainedLineShader = l.default.RendererGL.prototype._getImmediateLineShader, l.default.RendererGL.prototype._getLightShader = function() {
            return this._defaultLightShader || (this._pInst._glAttributes.perPixelLighting ? this._defaultLightShader = new l.default.Shader(this, d.phongVert, d.phongFrag) : this._defaultLightShader = new l.default.Shader(this, d.lightVert, d.lightTextureFrag)), this._defaultLightShader;
          }, l.default.RendererGL.prototype._getImmediateModeShader = function() {
            return this._defaultImmediateModeShader || (this._defaultImmediateModeShader = new l.default.Shader(this, d.immediateVert, d.vertexColorFrag)), this._defaultImmediateModeShader;
          }, l.default.RendererGL.prototype._getNormalShader = function() {
            return this._defaultNormalShader || (this._defaultNormalShader = new l.default.Shader(this, d.normalVert, d.normalFrag)), this._defaultNormalShader;
          }, l.default.RendererGL.prototype._getColorShader = function() {
            return this._defaultColorShader || (this._defaultColorShader = new l.default.Shader(this, d.normalVert, d.basicFrag)), this._defaultColorShader;
          }, l.default.RendererGL.prototype._getPointShader = function() {
            return this._defaultPointShader || (this._defaultPointShader = new l.default.Shader(this, d.pointVert, d.pointFrag)), this._defaultPointShader;
          }, l.default.RendererGL.prototype._getLineShader = function() {
            return this._defaultLineShader || (this._defaultLineShader = new l.default.Shader(this, d.lineVert, d.lineFrag)), this._defaultLineShader;
          }, l.default.RendererGL.prototype._getFontShader = function() {
            return this._defaultFontShader || (this.GL.getExtension("OES_standard_derivatives"), this._defaultFontShader = new l.default.Shader(this, d.fontVert, d.fontFrag)), this._defaultFontShader;
          }, l.default.RendererGL.prototype._getEmptyTexture = function() {
            var e3;
            return this._emptyTexture || ((e3 = new l.default.Image(1, 1)).set(0, 0, 255), this._emptyTexture = new l.default.Texture(this, e3)), this._emptyTexture;
          }, l.default.RendererGL.prototype.getTexture = function(e3) {
            var t3 = this.textures, r2 = true, o2 = false, n2 = void 0;
            try {
              for (var s3, i2 = t3[Symbol.iterator](); !(r2 = (s3 = i2.next()).done); r2 = true) {
                var a2 = s3.value;
                if (a2.src === e3)
                  return a2;
              }
            } catch (e4) {
              o2 = true, n2 = e4;
            } finally {
              try {
                r2 || null == i2.return || i2.return();
              } finally {
                if (o2)
                  throw n2;
              }
            }
            o2 = new l.default.Texture(this, e3);
            return t3.push(o2), o2;
          }, l.default.RendererGL.prototype._setStrokeUniforms = function(e3) {
            e3.bindShader(), e3.setUniform("uMaterialColor", this.curStrokeColor), e3.setUniform("uStrokeWeight", this.curStrokeWeight);
          }, l.default.RendererGL.prototype._setFillUniforms = function(e3) {
            e3.bindShader(), e3.setUniform("uMaterialColor", this.curFillColor), e3.setUniform("isTexture", !!this._tex), this._tex && e3.setUniform("uSampler", this._tex), e3.setUniform("uTint", this._tint), e3.setUniform("uAmbientMatColor", this.curAmbientColor), e3.setUniform("uSpecularMatColor", this.curSpecularColor), e3.setUniform("uEmissiveMatColor", this.curEmissiveColor), e3.setUniform("uSpecular", this._useSpecularMaterial), e3.setUniform("uEmissive", this._useEmissiveMaterial), e3.setUniform("uShininess", this._useShininess), e3.setUniform("uUseLighting", this._enableLighting);
            var t3 = this.pointLightDiffuseColors.length / 3, t3 = (e3.setUniform("uPointLightCount", t3), e3.setUniform("uPointLightLocation", this.pointLightPositions), e3.setUniform("uPointLightDiffuseColors", this.pointLightDiffuseColors), e3.setUniform("uPointLightSpecularColors", this.pointLightSpecularColors), this.directionalLightDiffuseColors.length / 3), t3 = (e3.setUniform("uDirectionalLightCount", t3), e3.setUniform("uLightingDirection", this.directionalLightDirections), e3.setUniform("uDirectionalDiffuseColors", this.directionalLightDiffuseColors), e3.setUniform("uDirectionalSpecularColors", this.directionalLightSpecularColors), this.ambientLightColors.length / 3), t3 = (e3.setUniform("uAmbientLightCount", t3), e3.setUniform("uAmbientColor", this.ambientLightColors), this.spotLightDiffuseColors.length / 3);
            e3.setUniform("uSpotLightCount", t3), e3.setUniform("uSpotLightAngle", this.spotLightAngle), e3.setUniform("uSpotLightConc", this.spotLightConc), e3.setUniform("uSpotLightDiffuseColors", this.spotLightDiffuseColors), e3.setUniform("uSpotLightSpecularColors", this.spotLightSpecularColors), e3.setUniform("uSpotLightLocation", this.spotLightPositions), e3.setUniform("uSpotLightDirection", this.spotLightDirections), e3.setUniform("uConstantAttenuation", this.constantAttenuation), e3.setUniform("uLinearAttenuation", this.linearAttenuation), e3.setUniform("uQuadraticAttenuation", this.quadraticAttenuation), e3.bindTextures();
          }, l.default.RendererGL.prototype._setPointUniforms = function(e3) {
            e3.bindShader(), e3.setUniform("uMaterialColor", this.curStrokeColor), e3.setUniform("uPointSize", this.pointSize * this._pInst._pixelDensity);
          }, l.default.RendererGL.prototype._bindBuffer = function(e3, t3, r2, o2, n2) {
            t3 = t3 || this.GL.ARRAY_BUFFER, this.GL.bindBuffer(t3, e3), void 0 !== r2 && (e3 = new (o2 || Float32Array)(r2), this.GL.bufferData(t3, e3, n2 || this.GL.STATIC_DRAW));
          }, l.default.RendererGL.prototype._arraysEqual = function(e3, t3) {
            var r2 = e3.length;
            if (r2 !== t3.length)
              return false;
            for (var o2 = 0; o2 < r2; o2++)
              if (e3[o2] !== t3[o2])
                return false;
            return true;
          }, l.default.RendererGL.prototype._isTypedArray = function(e3) {
            0 instanceof Float32Array;
            return 0 instanceof Float64Array, 0 instanceof Int16Array, 0 instanceof Uint16Array, e3 instanceof Uint32Array;
          }, l.default.RendererGL.prototype._flatten = function(e3) {
            if (0 === e3.length)
              return [];
            var t3;
            if (2e4 < e3.length) {
              for (var r2 = Object.prototype.toString, o2 = [], n2 = e3.slice(), s3 = n2.pop(); "[object Array]" === r2.call(s3) ? n2.push.apply(n2, c(s3)) : o2.push(s3), n2.length && void 0 !== (s3 = n2.pop()); )
                ;
              return o2.reverse(), o2;
            }
            return (t3 = []).concat.apply(t3, c(e3));
          }, l.default.RendererGL.prototype._vToNArray = function(e3) {
            var t3 = [], r2 = true, o2 = false, n2 = void 0;
            try {
              for (var s3, i2 = e3[Symbol.iterator](); !(r2 = (s3 = i2.next()).done); r2 = true) {
                var a2 = s3.value;
                t3.push(a2.x, a2.y, a2.z);
              }
            } catch (e4) {
              o2 = true, n2 = e4;
            } finally {
              try {
                r2 || null == i2.return || i2.return();
              } finally {
                if (o2)
                  throw n2;
              }
            }
            return t3;
          }, l.default.prototype._assert3d = function(e3) {
            if (!this._renderer.isP3D)
              throw new Error("".concat(e3, "() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information."));
          }, l.default.RendererGL.prototype._initTessy = function() {
            var e3 = new n.default.GluTesselator();
            return e3.gluTessCallback(n.default.gluEnum.GLU_TESS_VERTEX_DATA, function(e4, t3) {
              for (var r2 = 0; r2 < e4.length; r2++)
                t3[t3.length] = e4[r2];
            }), e3.gluTessCallback(n.default.gluEnum.GLU_TESS_BEGIN, function(e4) {
              e4 !== n.default.primitiveType.GL_TRIANGLES && console.log("expected TRIANGLES but got type: ".concat(e4));
            }), e3.gluTessCallback(n.default.gluEnum.GLU_TESS_ERROR, function(e4) {
              console.log("error callback"), console.log("error number: ".concat(e4));
            }), e3.gluTessCallback(n.default.gluEnum.GLU_TESS_COMBINE, function(e4, t3, r2) {
              for (var o2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], n2 = 0; n2 < r2.length; n2++)
                for (var s3 = 0; s3 < o2.length; s3++)
                  0 !== r2[n2] && t3[n2] && (o2[s3] += t3[n2][s3] * r2[n2]);
              return o2;
            }), e3.gluTessCallback(n.default.gluEnum.GLU_TESS_EDGE_FLAG, function(e4) {
            }), e3;
          }, l.default.RendererGL.prototype._triangulate = function(e3) {
            this._tessy.gluTessNormal(0, 0, 1);
            var t3 = [];
            this._tessy.gluTessBeginPolygon(t3);
            for (var r2 = 0; r2 < e3.length; r2++) {
              this._tessy.gluTessBeginContour();
              for (var o2 = e3[r2], n2 = 0; n2 < o2.length; n2 += 12) {
                var s3 = o2.slice(n2, n2 + 12);
                this._tessy.gluTessVertex(s3, s3);
              }
              this._tessy.gluTessEndContour();
            }
            return this._tessy.gluTessEndPolygon(), t3;
          }, l.default.RendererGL.prototype._bezierCoefficients = function(e3) {
            var t3 = e3 * e3, r2 = 1 - e3, o2 = r2 * r2;
            return [o2 * r2, 3 * o2 * e3, 3 * r2 * t3, t3 * e3];
          }, l.default.RendererGL.prototype._quadraticCoefficients = function(e3) {
            var t3 = 1 - e3;
            return [t3 * t3, 2 * t3 * e3, e3 * e3];
          }, l.default.RendererGL.prototype._bezierToCatmull = function(e3) {
            return [e3[1], e3[1] + (e3[2] - e3[0]) / this._curveTightness, e3[2] - (e3[3] - e3[1]) / this._curveTightness, e3[2]];
          }, l.default.RendererGL);
          r.default = e2;
        }, { "../core/constants": 256, "../core/main": 267, "../core/p5.Renderer": 270, "./p5.Camera": 315, "./p5.Matrix": 317, "./p5.Shader": 322, "core-js/modules/es.array.concat": 149, "core-js/modules/es.array.fill": 152, "core-js/modules/es.array.filter": 153, "core-js/modules/es.array.from": 155, "core-js/modules/es.array.includes": 156, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.slice": 162, "core-js/modules/es.object.assign": 172, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.to-string": 182, "core-js/modules/es.string.includes": 185, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.typed-array.copy-within": 197, "core-js/modules/es.typed-array.every": 198, "core-js/modules/es.typed-array.fill": 199, "core-js/modules/es.typed-array.filter": 200, "core-js/modules/es.typed-array.find": 202, "core-js/modules/es.typed-array.find-index": 201, "core-js/modules/es.typed-array.float32-array": 203, "core-js/modules/es.typed-array.float64-array": 204, "core-js/modules/es.typed-array.for-each": 205, "core-js/modules/es.typed-array.includes": 206, "core-js/modules/es.typed-array.index-of": 207, "core-js/modules/es.typed-array.int16-array": 208, "core-js/modules/es.typed-array.iterator": 210, "core-js/modules/es.typed-array.join": 211, "core-js/modules/es.typed-array.last-index-of": 212, "core-js/modules/es.typed-array.map": 213, "core-js/modules/es.typed-array.reduce": 215, "core-js/modules/es.typed-array.reduce-right": 214, "core-js/modules/es.typed-array.reverse": 216, "core-js/modules/es.typed-array.set": 217, "core-js/modules/es.typed-array.slice": 218, "core-js/modules/es.typed-array.some": 219, "core-js/modules/es.typed-array.sort": 220, "core-js/modules/es.typed-array.subarray": 221, "core-js/modules/es.typed-array.to-locale-string": 222, "core-js/modules/es.typed-array.to-string": 223, "core-js/modules/es.typed-array.uint16-array": 224, "core-js/modules/es.typed-array.uint32-array": 225, "core-js/modules/es.typed-array.uint8-array": 226, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230, libtess: 239, path: 242 }], 322: [function(e2, t2, r) {
          "use strict";
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.index-of"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.array.slice"), e2("core-js/modules/es.function.name"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/web.dom-collections.iterator"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var s2 = (e2 = e2("../core/main")) && e2.__esModule ? e2 : { default: e2 };
          s2.default.Shader = function(e3, t3, r2) {
            this._renderer = e3, this._vertSrc = t3, this._fragSrc = r2, this._vertShader = -1, this._fragShader = -1, this._glProgram = 0, this._loadedAttributes = false, this.attributes = {}, this._loadedUniforms = false, this.uniforms = {}, this._bound = false, this.samplers = [];
          }, s2.default.Shader.prototype.init = function() {
            if (0 === this._glProgram) {
              var e3 = this._renderer.GL;
              if (this._vertShader = e3.createShader(e3.VERTEX_SHADER), e3.shaderSource(this._vertShader, this._vertSrc), e3.compileShader(this._vertShader), !e3.getShaderParameter(this._vertShader, e3.COMPILE_STATUS))
                return console.error("Yikes! An error occurred compiling the vertex shader:".concat(e3.getShaderInfoLog(this._vertShader))), null;
              if (this._fragShader = e3.createShader(e3.FRAGMENT_SHADER), e3.shaderSource(this._fragShader, this._fragSrc), e3.compileShader(this._fragShader), !e3.getShaderParameter(this._fragShader, e3.COMPILE_STATUS))
                return console.error("Darn! An error occurred compiling the fragment shader:".concat(e3.getShaderInfoLog(this._fragShader))), null;
              this._glProgram = e3.createProgram(), e3.attachShader(this._glProgram, this._vertShader), e3.attachShader(this._glProgram, this._fragShader), e3.linkProgram(this._glProgram), e3.getProgramParameter(this._glProgram, e3.LINK_STATUS) || console.error("Snap! Error linking shader program: ".concat(e3.getProgramInfoLog(this._glProgram))), this._loadAttributes(), this._loadUniforms();
            }
            return this;
          }, s2.default.Shader.prototype._loadAttributes = function() {
            if (!this._loadedAttributes) {
              this.attributes = {};
              for (var e3 = this._renderer.GL, t3 = e3.getProgramParameter(this._glProgram, e3.ACTIVE_ATTRIBUTES), r2 = 0; r2 < t3; ++r2) {
                var o = e3.getActiveAttrib(this._glProgram, r2), n = o.name, s3 = e3.getAttribLocation(this._glProgram, n), i = {};
                i.name = n, i.location = s3, i.index = r2, i.type = o.type, i.size = o.size, this.attributes[n] = i;
              }
              this._loadedAttributes = true;
            }
          }, s2.default.Shader.prototype._loadUniforms = function() {
            if (!this._loadedUniforms) {
              for (var e3 = this._renderer.GL, t3 = e3.getProgramParameter(this._glProgram, e3.ACTIVE_UNIFORMS), r2 = 0, o = 0; o < t3; ++o) {
                var n = e3.getActiveUniform(this._glProgram, o), s3 = {}, i = (s3.location = e3.getUniformLocation(this._glProgram, n.name), s3.size = n.size, n.name);
                1 < n.size && (i = i.substring(0, i.indexOf("[0]"))), s3.name = i, s3.type = n.type, s3._cachedData = void 0, s3.type === e3.SAMPLER_2D && (s3.samplerIndex = r2, r2++, this.samplers.push(s3)), s3.isArray = 1 < n.size || s3.type === e3.FLOAT_MAT3 || s3.type === e3.FLOAT_MAT4 || s3.type === e3.FLOAT_VEC2 || s3.type === e3.FLOAT_VEC3 || s3.type === e3.FLOAT_VEC4 || s3.type === e3.INT_VEC2 || s3.type === e3.INT_VEC4 || s3.type === e3.INT_VEC3, this.uniforms[i] = s3;
              }
              this._loadedUniforms = true;
            }
          }, s2.default.Shader.prototype.compile = function() {
          }, s2.default.Shader.prototype.bindShader = function() {
            this.init(), this._bound || (this.useProgram(), this._bound = true, this._setMatrixUniforms(), this.setUniform("uViewport", this._renderer._viewport));
          }, s2.default.Shader.prototype.unbindShader = function() {
            return this._bound && (this.unbindTextures(), this._bound = false), this;
          }, s2.default.Shader.prototype.bindTextures = function() {
            var e3 = this._renderer.GL, t3 = true, r2 = false, o = void 0;
            try {
              for (var n, s3 = this.samplers[Symbol.iterator](); !(t3 = (n = s3.next()).done); t3 = true) {
                var i = n.value, a = i.texture;
                void 0 === a && (a = this._renderer._getEmptyTexture()), e3.activeTexture(e3.TEXTURE0 + i.samplerIndex), a.bindTexture(), a.update(), e3.uniform1i(i.location, i.samplerIndex);
              }
            } catch (e4) {
              r2 = true, o = e4;
            } finally {
              try {
                t3 || null == s3.return || s3.return();
              } finally {
                if (r2)
                  throw o;
              }
            }
          }, s2.default.Shader.prototype.updateTextures = function() {
            var e3 = true, t3 = false, r2 = void 0;
            try {
              for (var o, n = this.samplers[Symbol.iterator](); !(e3 = (o = n.next()).done); e3 = true) {
                var s3 = o.value.texture;
                s3 && s3.update();
              }
            } catch (e4) {
              t3 = true, r2 = e4;
            } finally {
              try {
                e3 || null == n.return || n.return();
              } finally {
                if (t3)
                  throw r2;
              }
            }
          }, s2.default.Shader.prototype.unbindTextures = function() {
          }, s2.default.Shader.prototype._setMatrixUniforms = function() {
            var e3 = this._renderer._curCamera.cameraMatrix, t3 = this._renderer.uPMatrix, r2 = this._renderer.uMVMatrix, o = r2.copy();
            o.mult(t3), this.isStrokeShader() && ("default" === this._renderer._curCamera.cameraType ? this.setUniform("uPerspective", 1) : this.setUniform("uPerspective", 0)), this.setUniform("uViewMatrix", e3.mat4), this.setUniform("uProjectionMatrix", t3.mat4), this.setUniform("uModelViewMatrix", r2.mat4), this.setUniform("uModelViewProjectionMatrix", o.mat4), this.uniforms.uNormalMatrix && (this._renderer.uNMatrix.inverseTranspose(this._renderer.uMVMatrix), this.setUniform("uNormalMatrix", this._renderer.uNMatrix.mat3));
          }, s2.default.Shader.prototype.useProgram = function() {
            var e3 = this._renderer.GL;
            return this._renderer._curShader !== this && (e3.useProgram(this._glProgram), this._renderer._curShader = this), this;
          }, s2.default.Shader.prototype.setUniform = function(e3, t3) {
            var r2 = this.uniforms[e3];
            if (r2) {
              var o = this._renderer.GL;
              if (r2.isArray) {
                if (r2._cachedData && this._renderer._arraysEqual(r2._cachedData, t3))
                  return;
                r2._cachedData = t3.slice(0);
              } else {
                if (r2._cachedData && r2._cachedData === t3)
                  return;
                Array.isArray(t3) ? r2._cachedData = t3.slice(0) : r2._cachedData = t3;
              }
              var n = r2.location;
              switch (this.useProgram(), r2.type) {
                case o.BOOL:
                  true === t3 ? o.uniform1i(n, 1) : o.uniform1i(n, 0);
                  break;
                case o.INT:
                  1 < r2.size ? t3.length && o.uniform1iv(n, t3) : o.uniform1i(n, t3);
                  break;
                case o.FLOAT:
                  1 < r2.size ? t3.length && o.uniform1fv(n, t3) : o.uniform1f(n, t3);
                  break;
                case o.FLOAT_MAT3:
                  o.uniformMatrix3fv(n, false, t3);
                  break;
                case o.FLOAT_MAT4:
                  o.uniformMatrix4fv(n, false, t3);
                  break;
                case o.FLOAT_VEC2:
                  1 < r2.size ? t3.length && o.uniform2fv(n, t3) : o.uniform2f(n, t3[0], t3[1]);
                  break;
                case o.FLOAT_VEC3:
                  1 < r2.size ? t3.length && o.uniform3fv(n, t3) : o.uniform3f(n, t3[0], t3[1], t3[2]);
                  break;
                case o.FLOAT_VEC4:
                  1 < r2.size ? t3.length && o.uniform4fv(n, t3) : o.uniform4f(n, t3[0], t3[1], t3[2], t3[3]);
                  break;
                case o.INT_VEC2:
                  1 < r2.size ? t3.length && o.uniform2iv(n, t3) : o.uniform2i(n, t3[0], t3[1]);
                  break;
                case o.INT_VEC3:
                  1 < r2.size ? t3.length && o.uniform3iv(n, t3) : o.uniform3i(n, t3[0], t3[1], t3[2]);
                  break;
                case o.INT_VEC4:
                  1 < r2.size ? t3.length && o.uniform4iv(n, t3) : o.uniform4i(n, t3[0], t3[1], t3[2], t3[3]);
                  break;
                case o.SAMPLER_2D:
                  o.activeTexture(o.TEXTURE0 + r2.samplerIndex), r2.texture = t3 instanceof s2.default.Texture ? t3 : this._renderer.getTexture(t3), o.uniform1i(n, r2.samplerIndex);
              }
              return this;
            }
          }, s2.default.Shader.prototype.isLightShader = function() {
            return void 0 !== this.attributes.aNormal || void 0 !== this.uniforms.uUseLighting || void 0 !== this.uniforms.uAmbientLightCount || void 0 !== this.uniforms.uDirectionalLightCount || void 0 !== this.uniforms.uPointLightCount || void 0 !== this.uniforms.uAmbientColor || void 0 !== this.uniforms.uDirectionalDiffuseColors || void 0 !== this.uniforms.uDirectionalSpecularColors || void 0 !== this.uniforms.uPointLightLocation || void 0 !== this.uniforms.uPointLightDiffuseColors || void 0 !== this.uniforms.uPointLightSpecularColors || void 0 !== this.uniforms.uLightingDirection || void 0 !== this.uniforms.uSpecular;
          }, s2.default.Shader.prototype.isNormalShader = function() {
            return void 0 !== this.attributes.aNormal;
          }, s2.default.Shader.prototype.isTextureShader = function() {
            return 0 < this.samplers.length;
          }, s2.default.Shader.prototype.isColorShader = function() {
            return void 0 !== this.attributes.aVertexColor || void 0 !== this.uniforms.uMaterialColor;
          }, s2.default.Shader.prototype.isTexLightShader = function() {
            return this.isLightShader() && this.isTextureShader();
          }, s2.default.Shader.prototype.isStrokeShader = function() {
            return void 0 !== this.uniforms.uStrokeWeight;
          }, s2.default.Shader.prototype.enableAttrib = function(e3, t3, r2, o, n, s3) {
            var i, a;
            return e3 && -1 !== (i = e3.location) && (a = this._renderer.GL, e3.enabled || (a.enableVertexAttribArray(i), e3.enabled = true), this._renderer.GL.vertexAttribPointer(i, t3, r2 || a.FLOAT, o || false, n || 0, s3 || 0)), this;
          };
          e2 = s2.default.Shader;
          r.default = e2;
        }, { "../core/main": 267, "core-js/modules/es.array.index-of": 157, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.array.slice": 162, "core-js/modules/es.function.name": 165, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/web.dom-collections.iterator": 230 }], 323: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.typed-array.uint8-array"), e2("core-js/modules/es.typed-array.copy-within"), e2("core-js/modules/es.typed-array.every"), e2("core-js/modules/es.typed-array.fill"), e2("core-js/modules/es.typed-array.filter"), e2("core-js/modules/es.typed-array.find"), e2("core-js/modules/es.typed-array.find-index"), e2("core-js/modules/es.typed-array.for-each"), e2("core-js/modules/es.typed-array.includes"), e2("core-js/modules/es.typed-array.index-of"), e2("core-js/modules/es.typed-array.iterator"), e2("core-js/modules/es.typed-array.join"), e2("core-js/modules/es.typed-array.last-index-of"), e2("core-js/modules/es.typed-array.map"), e2("core-js/modules/es.typed-array.reduce"), e2("core-js/modules/es.typed-array.reduce-right"), e2("core-js/modules/es.typed-array.reverse"), e2("core-js/modules/es.typed-array.set"), e2("core-js/modules/es.typed-array.slice"), e2("core-js/modules/es.typed-array.some"), e2("core-js/modules/es.typed-array.sort"), e2("core-js/modules/es.typed-array.subarray"), e2("core-js/modules/es.typed-array.to-locale-string"), e2("core-js/modules/es.typed-array.to-string"), Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
          var n = (s2 = e2("../core/main")) && s2.__esModule ? s2 : { default: s2 }, a = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = l();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function l() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), l = function() {
              return e3;
            }, e3);
          }
          n.default.Texture = function(e3, t3, r2) {
            this._renderer = e3;
            e3 = this._renderer.GL, (r2 = r2 || {}).dataType === e3.FLOAT && (e3.getExtension("OES_texture_float") || console.log("Oh no, your device doesn't support floating point textures!"), e3.getExtension("OES_texture_float_linear") || console.log("Ack! Your device doesn't support linear filtering for floating point textures")), this.src = t3, this.glTex = void 0, this.glTarget = e3.TEXTURE_2D, this.glFormat = r2.format || e3.RGBA, this.mipmaps = false, this.glMinFilter = r2.minFilter || e3.LINEAR, this.glMagFilter = r2.magFilter || e3.LINEAR, this.glWrapS = r2.wrapS || e3.CLAMP_TO_EDGE, this.glWrapT = r2.wrapT || e3.CLAMP_TO_EDGE, this.glDataType = r2.dataType || e3.UNSIGNED_BYTE, this.isSrcMediaElement = void 0 !== n.default.MediaElement && t3 instanceof n.default.MediaElement, this._videoPrevUpdateTime = 0, this.isSrcHTMLElement = void 0 !== n.default.Element && t3 instanceof n.default.Element && !(t3 instanceof n.default.Graphics) && !(t3 instanceof n.default.Renderer), this.isSrcP5Image = t3 instanceof n.default.Image, this.isSrcP5Graphics = t3 instanceof n.default.Graphics, this.isSrcP5Renderer = t3 instanceof n.default.Renderer, this.isImageData = "undefined" != typeof ImageData && t3 instanceof ImageData, r2 = this._getTextureDataFromSource();
            return this.width = r2.width, this.height = r2.height, this.init(r2), this;
          }, n.default.Texture.prototype._getTextureDataFromSource = function() {
            var e3;
            return this.isSrcP5Image ? e3 = this.src.canvas : this.isSrcMediaElement || this.isSrcP5Graphics || this.isSrcP5Renderer || this.isSrcHTMLElement ? e3 = this.src.elt : this.isImageData && (e3 = this.src), e3;
          }, n.default.Texture.prototype.init = function(e3) {
            var t3, r2 = this._renderer.GL;
            this.glTex = r2.createTexture(), this.glWrapS = this._renderer.textureWrapX, this.glWrapT = this._renderer.textureWrapY, this.setWrapMode(this.glWrapS, this.glWrapT), this.bindTexture(), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, this.glMagFilter), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, this.glMinFilter), 0 === this.width || 0 === this.height || this.isSrcMediaElement && !this.src.loadedmetadata ? (t3 = new Uint8Array([1, 1, 1, 1]), r2.texImage2D(this.glTarget, 0, r2.RGBA, 1, 1, 0, this.glFormat, this.glDataType, t3)) : r2.texImage2D(this.glTarget, 0, this.glFormat, this.glFormat, this.glDataType, e3);
          }, n.default.Texture.prototype.update = function() {
            var e3, t3, r2, o2 = this.src;
            return 0 !== o2.width && 0 !== o2.height && (e3 = this._getTextureDataFromSource(), t3 = false, r2 = this._renderer.GL, e3.width !== this.width || e3.height !== this.height ? (t3 = true, this.width = e3.width, this.height = e3.height, this.isSrcP5Image ? o2.setModified(false) : (this.isSrcMediaElement || this.isSrcHTMLElement) && o2.setModified(true)) : this.isSrcP5Image ? o2.isModified() && o2.setModified(!(t3 = true)) : this.isSrcMediaElement ? o2.isModified() ? o2.setModified(!(t3 = true)) : o2.loadedmetadata && this._videoPrevUpdateTime !== o2.time() && (this._videoPrevUpdateTime = o2.time(), t3 = true) : this.isImageData ? o2._dirty && (t3 = !(o2._dirty = false)) : t3 = true, t3 && (this.bindTexture(), r2.texImage2D(this.glTarget, 0, this.glFormat, this.glFormat, this.glDataType, e3)), t3);
          }, n.default.Texture.prototype.bindTexture = function() {
            return this._renderer.GL.bindTexture(this.glTarget, this.glTex), this;
          }, n.default.Texture.prototype.unbindTexture = function() {
            this._renderer.GL.bindTexture(this.glTarget, null);
          }, n.default.Texture.prototype.setInterpolation = function(e3, t3) {
            var r2 = this._renderer.GL;
            e3 === a.NEAREST ? this.glMinFilter = r2.NEAREST : this.glMinFilter = r2.LINEAR, t3 === a.NEAREST ? this.glMagFilter = r2.NEAREST : this.glMagFilter = r2.LINEAR, this.bindTexture(), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, this.glMinFilter), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, this.glMagFilter), this.unbindTexture();
          }, n.default.Texture.prototype.setWrapMode = function(e3, t3) {
            function r2(e4) {
              return 0 == (e4 & e4 - 1);
            }
            var o2 = this._renderer.GL, n2 = r2(this.width), s3 = r2(this.height);
            e3 === a.REPEAT ? n2 && s3 ? this.glWrapS = o2.REPEAT : (console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"), this.glWrapS = o2.CLAMP_TO_EDGE) : e3 === a.MIRROR ? n2 && s3 ? this.glWrapS = o2.MIRRORED_REPEAT : (console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"), this.glWrapS = o2.CLAMP_TO_EDGE) : this.glWrapS = o2.CLAMP_TO_EDGE, t3 === a.REPEAT ? n2 && s3 ? this.glWrapT = o2.REPEAT : (console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"), this.glWrapT = o2.CLAMP_TO_EDGE) : t3 === a.MIRROR ? n2 && s3 ? this.glWrapT = o2.MIRRORED_REPEAT : (console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"), this.glWrapT = o2.CLAMP_TO_EDGE) : this.glWrapT = o2.CLAMP_TO_EDGE, this.bindTexture(), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, this.glWrapS), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, this.glWrapT), this.unbindTexture();
          };
          var s2 = n.default.Texture;
          r.default = s2;
        }, { "../core/constants": 256, "../core/main": 267, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.typed-array.copy-within": 197, "core-js/modules/es.typed-array.every": 198, "core-js/modules/es.typed-array.fill": 199, "core-js/modules/es.typed-array.filter": 200, "core-js/modules/es.typed-array.find": 202, "core-js/modules/es.typed-array.find-index": 201, "core-js/modules/es.typed-array.for-each": 205, "core-js/modules/es.typed-array.includes": 206, "core-js/modules/es.typed-array.index-of": 207, "core-js/modules/es.typed-array.iterator": 210, "core-js/modules/es.typed-array.join": 211, "core-js/modules/es.typed-array.last-index-of": 212, "core-js/modules/es.typed-array.map": 213, "core-js/modules/es.typed-array.reduce": 215, "core-js/modules/es.typed-array.reduce-right": 214, "core-js/modules/es.typed-array.reverse": 216, "core-js/modules/es.typed-array.set": 217, "core-js/modules/es.typed-array.slice": 218, "core-js/modules/es.typed-array.some": 219, "core-js/modules/es.typed-array.sort": 220, "core-js/modules/es.typed-array.subarray": 221, "core-js/modules/es.typed-array.to-locale-string": 222, "core-js/modules/es.typed-array.to-string": 223, "core-js/modules/es.typed-array.uint8-array": 226, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }], 324: [function(e2, t2, r) {
          "use strict";
          function o(e3) {
            return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            })(e3);
          }
          function i(e3) {
            return (i = "function" == typeof Symbol && "symbol" === o(Symbol.iterator) ? function(e4) {
              return o(e4);
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : o(e4);
            })(e3);
          }
          e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.get-own-property-descriptor"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.sub"), e2("core-js/modules/es.weak-map"), e2("core-js/modules/web.dom-collections.iterator"), e2("core-js/modules/es.symbol"), e2("core-js/modules/es.symbol.description"), e2("core-js/modules/es.symbol.iterator"), e2("core-js/modules/es.array.iterator"), e2("core-js/modules/es.object.to-string"), e2("core-js/modules/es.regexp.exec"), e2("core-js/modules/es.string.iterator"), e2("core-js/modules/es.string.split"), e2("core-js/modules/es.string.sub"), e2("core-js/modules/web.dom-collections.iterator");
          var n, B = (n = e2("../core/main")) && n.__esModule ? n : { default: n }, E = function(e3) {
            if (e3 && e3.__esModule)
              return e3;
            if (null === e3 || "object" !== i(e3) && "function" != typeof e3)
              return { default: e3 };
            var t3 = a();
            if (t3 && t3.has(e3))
              return t3.get(e3);
            var r2, o2 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (r2 in e3) {
              var s3;
              Object.prototype.hasOwnProperty.call(e3, r2) && ((s3 = n2 ? Object.getOwnPropertyDescriptor(e3, r2) : null) && (s3.get || s3.set) ? Object.defineProperty(o2, r2, s3) : o2[r2] = e3[r2]);
            }
            o2.default = e3, t3 && t3.set(e3, o2);
            return o2;
          }(e2("../core/constants"));
          function a() {
            var e3;
            return "function" != typeof WeakMap ? null : (e3 = /* @__PURE__ */ new WeakMap(), a = function() {
              return e3;
            }, e3);
          }
          e2("./p5.Shader"), e2("./p5.RendererGL.Retained"), B.default.RendererGL.prototype._applyTextProperties = function() {
          }, B.default.RendererGL.prototype.textWidth = function(e3) {
            return this._isOpenType() ? this._textFont._textWidth(e3, this._textSize) : 0;
          };
          function s2(e3, t3) {
            this.width = e3, this.height = t3, this.infos = [], this.findImage = function(e4) {
              var t4, r2, o2 = this.width * this.height;
              if (o2 < e4)
                throw new Error("font is too complex to render in 3D");
              for (var n2 = this.infos.length - 1; 0 <= n2; --n2) {
                var s3 = this.infos[n2];
                if (s3.index + e4 < o2) {
                  r2 = (t4 = s3).imageData;
                  break;
                }
              }
              if (!t4) {
                try {
                  r2 = new ImageData(this.width, this.height);
                } catch (e5) {
                  var i2 = document.getElementsByTagName("canvas")[0], a2 = !i2, l = (i2 || ((i2 = document.createElement("canvas")).style.display = "none", document.body.appendChild(i2)), i2.getContext("2d"));
                  l && (r2 = l.createImageData(this.width, this.height)), a2 && document.body.removeChild(i2);
                }
                this.infos.push(t4 = { index: 0, imageData: r2 });
              }
              l = t4.index;
              return t4.index += e4, r2._dirty = true, { imageData: r2, index: l };
            };
          }
          function G(e3, t3, r2, o2, n2) {
            var s3 = e3.imageData.data, e3 = 4 * e3.index++;
            s3[e3++] = t3, s3[e3++] = r2, s3[e3++] = o2, s3[+e3] = n2;
          }
          function T(e3) {
            this.font = e3, this.strokeImageInfos = new s2(64, 64), this.colDimImageInfos = new s2(64, 64), this.rowDimImageInfos = new s2(64, 64), this.colCellImageInfos = new s2(64, 64), this.rowCellImageInfos = new s2(64, 64), this.glyphInfos = {}, this.getGlyphInfo = function(e4) {
              var t3 = this.glyphInfos[e4.index];
              if (!t3) {
                var r2 = e4.getBoundingBox(), o2 = r2.x1, n2 = r2.y1, s3 = r2.x2 - o2, i2 = r2.y2 - n2, a2 = e4.path.commands;
                if (0 == s3 || 0 == i2 || !a2.length)
                  return this.glyphInfos[e4.index] = {};
                for (var l, u, c, d, f = [], h = [], p = [], m = 8; 0 <= m; --m)
                  p.push([]);
                for (m = 8; 0 <= m; --m)
                  h.push([]);
                var y = true, g = false, v = void 0;
                try {
                  for (var b, j = a2[Symbol.iterator](); !(y = (b = j.next()).done); y = true) {
                    var _ = b.value, x = (_.x - o2) / s3, w = (_.y - n2) / i2;
                    if (!N(l, u, x, w)) {
                      switch (_.type) {
                        case "M":
                          c = x, d = w;
                          break;
                        case "L":
                          U(l, u, x, w);
                          break;
                        case "Q":
                          var S = (_.x1 - o2) / s3, M = (_.y1 - n2) / i2;
                          P([l, x, S], [u, w, M], { x: l, y: u, cx: S, cy: M });
                          break;
                        case "Z":
                          N(l, u, c, d) ? f.push({ x: l, y: u }) : (U(l, u, c, d), f.push({ x: c, y: d }));
                          break;
                        case "C":
                          for (var E2 = function(e5, t4, r3, o3, n3, s4, i3, a3) {
                            var e5 = new D(new B.default.Vector(e5, t4), new B.default.Vector(r3, o3), new B.default.Vector(n3, s4), new B.default.Vector(i3, a3)).splitInflections(), l2 = [], u2 = 30 / V, c2 = true, t4 = false, r3 = void 0;
                            try {
                              for (var d2, f2 = e5[Symbol.iterator](); !(c2 = (d2 = f2.next()).done); c2 = true) {
                                for (var h2 = d2.value, p2 = [], m2 = void 0; !(0.125 <= (m2 = u2 / h2.quadError())); ) {
                                  var y2 = Math.pow(m2, 1 / 3), g2 = h2.split(y2), v2 = h2.split(1 - y2 / (1 - y2));
                                  l2.push(g2), p2.push(h2), h2 = v2;
                                }
                                m2 < 1 && l2.push(h2.split(0.5)), l2.push(h2), Array.prototype.push.apply(l2, p2.reverse());
                              }
                            } catch (e6) {
                              t4 = true, r3 = e6;
                            } finally {
                              try {
                                c2 || null == f2.return || f2.return();
                              } finally {
                                if (t4)
                                  throw r3;
                              }
                            }
                            return l2;
                          }(l, u, (_.x1 - o2) / s3, (_.y1 - n2) / i2, (_.x2 - o2) / s3, (_.y2 - n2) / i2, x, w), T2 = 0; T2 < E2.length; T2++) {
                            var C = E2[T2].toQuadratic();
                            P([C.x, C.x1, C.cx], [C.y, C.y1, C.cy], C);
                          }
                          break;
                        default:
                          throw new Error("unknown command type: ".concat(_.type));
                      }
                      l = x, u = w;
                    }
                  }
                } catch (e5) {
                  g = true, v = e5;
                } finally {
                  try {
                    y || null == j.return || j.return();
                  } finally {
                    if (g)
                      throw v;
                  }
                }
                for (var O = f.length, L = this.strokeImageInfos.findImage(O), I = L.index, k = 0; k < O; ++k) {
                  var A = f[k];
                  G(L, R(A.x), R(A.y), R(A.cx), R(A.cy));
                }
                (t3 = this.glyphInfos[e4.index] = { glyph: e4, uGlyphRect: [r2.x1, -r2.y1, r2.x2, -r2.y2], strokeImageInfo: L, strokes: f, colInfo: F(p, this.colDimImageInfos, this.colCellImageInfos), rowInfo: F(h, this.rowDimImageInfos, this.rowCellImageInfos) }).uGridOffset = [t3.colInfo.dimOffset, t3.rowInfo.dimOffset];
              }
              return t3;
              function P(e5, t4, r3) {
                var o3 = f.length;
                function n3(e6, t5, r4) {
                  for (var o4 = e6.length; 0 < o4--; ) {
                    var n4 = e6[o4];
                    n4 < t5 && (t5 = n4), r4 < n4 && (r4 = n4);
                  }
                  return { min: t5, max: r4 };
                }
                f.push(r3);
                for (var r3 = n3(e5, 1, 0), e5 = Math.max(Math.floor(9 * r3.min), 0), s4 = Math.min(Math.ceil(9 * r3.max), 9), i3 = e5; i3 < s4; ++i3)
                  p[i3].push(o3);
                for (var r3 = n3(t4, 1, 0), e5 = Math.max(Math.floor(9 * r3.min), 0), a3 = Math.min(Math.ceil(9 * r3.max), 9), l2 = e5; l2 < a3; ++l2)
                  h[l2].push(o3);
              }
              function R(e5) {
                return (e5 = (r3 = 255) * e5) < (t4 = 0) ? t4 : r3 < e5 ? r3 : e5;
                var t4, r3;
              }
              function D(e5, t4, r3, o3) {
                this.p0 = e5, this.c0 = t4, this.c1 = r3, this.p1 = o3, this.toQuadratic = function() {
                  return { x: this.p0.x, y: this.p0.y, x1: this.p1.x, y1: this.p1.y, cx: (3 * (this.c0.x + this.c1.x) - (this.p0.x + this.p1.x)) / 4, cy: (3 * (this.c0.y + this.c1.y) - (this.p0.y + this.p1.y)) / 4 };
                }, this.quadError = function() {
                  return B.default.Vector.sub(B.default.Vector.sub(this.p1, this.p0), B.default.Vector.mult(B.default.Vector.sub(this.c1, this.c0), 3)).mag() / 2;
                }, this.split = function(e6) {
                  var t5 = B.default.Vector.lerp(this.p0, this.c0, e6), r4 = B.default.Vector.lerp(this.c0, this.c1, e6), o4 = B.default.Vector.lerp(t5, r4, e6), r4 = (this.c1 = B.default.Vector.lerp(this.c1, this.p1, e6), this.c0 = B.default.Vector.lerp(r4, this.c1, e6), B.default.Vector.lerp(o4, this.c0, e6)), e6 = new D(this.p0, t5, o4, r4);
                  return this.p0 = r4, e6;
                }, this.splitInflections = function() {
                  var e6 = B.default.Vector.sub(this.c0, this.p0), t5 = B.default.Vector.sub(B.default.Vector.sub(this.c1, this.c0), e6), r4 = B.default.Vector.sub(B.default.Vector.sub(B.default.Vector.sub(this.p1, this.c1), e6), B.default.Vector.mult(t5, 2)), o4 = [], n3 = t5.x * r4.y - t5.y * r4.x;
                  return 0 !== n3 && 0 <= (e6 = (r4 = e6.x * r4.y - e6.y * r4.x) * r4 - 4 * n3 * (e6.x * t5.y - e6.y * t5.x)) && (n3 < 0 && (n3 = -n3, r4 = -r4, 0), e6 = (-r4 + (t5 = Math.sqrt(e6))) / (2 * n3), 0 < (r4 = (-r4 - t5) / (2 * n3)) && r4 < 1 && (o4.push(this.split(r4)), e6 = 1 - (1 - e6) / (1 - r4)), 0 < e6 && e6 < 1 && o4.push(this.split(e6))), o4.push(this), o4;
                };
              }
              function U(e5, t4, r3, o3) {
                P([e5, r3], [t4, o3], { x: e5, y: t4, cx: (e5 + r3) / 2, cy: (t4 + o3) / 2 });
              }
              function N(e5, t4, r3, o3) {
                return Math.abs(r3 - e5) < 1e-5 && Math.abs(o3 - t4) < 1e-5;
              }
              function F(e5, t4, r3) {
                for (var o3 = e5.length, n3 = t4.findImage(o3), t4 = n3.index, s4 = 0, i3 = 0; i3 < o3; ++i3)
                  s4 += e5[i3].length;
                for (var a3 = r3.findImage(s4), l2 = 0; l2 < o3; ++l2) {
                  var u2 = e5[l2], c2 = u2.length, d2 = a3.index;
                  G(n3, d2 >> 7, 127 & d2, c2 >> 7, 127 & c2);
                  for (var f2 = 0; f2 < c2; ++f2) {
                    var h2 = u2[f2] + I;
                    G(a3, h2 >> 7, 127 & h2, 0, 0);
                  }
                }
                return { cellImageInfo: a3, dimOffset: t4, dimImageInfo: n3 };
              }
            };
          }
          var V = Math.sqrt(3);
          B.default.RendererGL.prototype._renderText = function(e3, t3, r2, o2, n2) {
            if (this._textFont && "string" != typeof this._textFont) {
              if (!(n2 <= o2) && this._doFill) {
                if (this._isOpenType()) {
                  e3.push();
                  var n2 = this._doStroke, s3 = this.drawMode, i2 = (this._doStroke = false, this.drawMode = E.TEXTURE, this._textFont.font), a2 = (a2 = this._textFont._fontInfo) || (this._textFont._fontInfo = new T(i2)), r2 = this._textFont._handleAlignment(this, t3, r2, o2), o2 = this._textSize / i2.unitsPerEm, l = (this.translate(r2.x, r2.y, 0), this.scale(o2, o2, 1), this.GL), r2 = !this._defaultFontShader, u = this._getFontShader(), c = (u.init(), u.bindShader(), r2 && (u.setUniform("uGridImageSize", [64, 64]), u.setUniform("uCellsImageSize", [64, 64]), u.setUniform("uStrokeImageSize", [64, 64]), u.setUniform("uGridSize", [9, 9])), this._applyColorBlend(this.curFillColor), this.retainedMode.geometry.glyph), d = (c || ((o2 = this._textGeom = new B.default.Geometry(1, 1, function() {
                    for (var e4 = 0; e4 <= 1; e4++)
                      for (var t4 = 0; t4 <= 1; t4++)
                        this.vertices.push(new B.default.Vector(t4, e4, 0)), this.uvs.push(t4, e4);
                  })).computeFaces().computeNormals(), c = this.createBuffers("glyph", o2)), true), r2 = false, o2 = void 0;
                  try {
                    for (var f, h = this.retainedMode.buffers.text[Symbol.iterator](); !(d = (f = h.next()).done); d = true)
                      f.value._prepareBuffer(c, u);
                  } catch (e4) {
                    r2 = true, o2 = e4;
                  } finally {
                    try {
                      d || null == h.return || h.return();
                    } finally {
                      if (r2)
                        throw o2;
                    }
                  }
                  this._bindBuffer(c.indexBuffer, l.ELEMENT_ARRAY_BUFFER), u.setUniform("uMaterialColor", this.curFillColor);
                  try {
                    var p = 0, m = null, y = i2.stringToGlyphs(t3), g = true, v = false, b = void 0;
                    try {
                      for (var j, _ = y[Symbol.iterator](); !(g = (j = _.next()).done); g = true) {
                        var x, w, S = j.value, M = (m && (p += i2.getKerningValue(m, S)), a2.getGlyphInfo(S));
                        M.uGlyphRect && (x = M.rowInfo, w = M.colInfo, u.setUniform("uSamplerStrokes", M.strokeImageInfo.imageData), u.setUniform("uSamplerRowStrokes", x.cellImageInfo.imageData), u.setUniform("uSamplerRows", x.dimImageInfo.imageData), u.setUniform("uSamplerColStrokes", w.cellImageInfo.imageData), u.setUniform("uSamplerCols", w.dimImageInfo.imageData), u.setUniform("uGridOffset", M.uGridOffset), u.setUniform("uGlyphRect", M.uGlyphRect), u.setUniform("uGlyphOffset", p), u.bindTextures(), l.drawElements(l.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0)), p += S.advanceWidth, m = S;
                      }
                    } catch (e4) {
                      v = true, b = e4;
                    } finally {
                      try {
                        g || null == _.return || _.return();
                      } finally {
                        if (v)
                          throw b;
                      }
                    }
                  } finally {
                    u.unbindShader(), this._doStroke = n2, this.drawMode = s3, e3.pop();
                  }
                } else
                  console.log("WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts are supported");
                return e3;
              }
            } else
              console.log("WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.");
          };
        }, { "../core/constants": 256, "../core/main": 267, "./p5.RendererGL.Retained": 320, "./p5.Shader": 322, "core-js/modules/es.array.iterator": 158, "core-js/modules/es.object.get-own-property-descriptor": 173, "core-js/modules/es.object.to-string": 177, "core-js/modules/es.regexp.exec": 181, "core-js/modules/es.string.iterator": 186, "core-js/modules/es.string.split": 191, "core-js/modules/es.string.sub": 192, "core-js/modules/es.symbol": 196, "core-js/modules/es.symbol.description": 194, "core-js/modules/es.symbol.iterator": 195, "core-js/modules/es.weak-map": 228, "core-js/modules/web.dom-collections.iterator": 230 }] }, {}, [251])(251);
      });
    }
  });

  // src/themes/migration.ts
  var migration_exports = {};
  __export(migration_exports, {
    start: () => start,
    tearDown: () => tearDown
  });
  var p5, rand, opt, Particles, time, start, P5, tearDown;
  var init_migration = __esm({
    "src/themes/migration.ts"() {
      p5 = __toESM(require_p5_min(), 1);
      rand = (v1, v2) => Math.floor(v1 + Math.random() * (v2 - v1));
      opt = {
        particles: window.width / 500 ? 1e3 : 500,
        noiseScale: 9e-3,
        angle: Math.PI / 180 * -90,
        h1: rand(0, 360),
        h2: rand(0, 360),
        s1: rand(20, 90),
        s2: rand(20, 90),
        l1: rand(30, 80),
        l2: rand(30, 80),
        strokeWeight: 1.2,
        tail: 82
      };
      Particles = [];
      time = 0;
      window.p5 = p5;
      start = (p52) => {
        class Particle {
          constructor(x, y) {
            this.x = x;
            this.y = y;
            this.lx = x;
            this.ly = y;
            this.vx = 0;
            this.vy = 0;
            this.ax = 0;
            this.ay = 0;
            this.hueSemen = Math.random();
            this.hue = this.hueSemen > 0.5 ? 20 + opt.h1 : 20 + opt.h2;
            this.sat = this.hueSemen > 0.5 ? opt.s1 : opt.s2;
            this.light = this.hueSemen > 0.5 ? opt.l1 : opt.l2;
            this.maxSpeed = this.hueSemen > 0.5 ? 3 : 2;
          }
          randomize() {
            this.hueSemen = Math.random();
            this.hue = this.hueSemen > 0.5 ? 20 + opt.h1 : 20 + opt.h2;
            this.sat = this.hueSemen > 0.5 ? opt.s1 : opt.s2;
            this.light = this.hueSemen > 0.5 ? opt.l1 : opt.l2;
            this.maxSpeed = this.hueSemen > 0.5 ? 3 : 2;
          }
          update() {
            this.follow();
            this.vx += this.ax;
            this.vy += this.ay;
            var p = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            var a = Math.atan2(this.vy, this.vx);
            var m = Math.min(this.maxSpeed, p);
            this.vx = Math.cos(a) * m;
            this.vy = Math.sin(a) * m;
            this.x += this.vx;
            this.y += this.vy;
            this.ax = 0;
            this.ay = 0;
            this.edges();
          }
          follow() {
            let angle = p52.noise(this.x * opt.noiseScale, this.y * opt.noiseScale, time * opt.noiseScale) * Math.PI * 0.5 + opt.angle;
            this.ax += Math.cos(angle);
            this.ay += Math.sin(angle);
          }
          updatePrev() {
            this.lx = this.x;
            this.ly = this.y;
          }
          edges() {
            if (this.x < 0) {
              this.x = p52.width;
              this.updatePrev();
            }
            if (this.x > p52.width) {
              this.x = 0;
              this.updatePrev();
            }
            if (this.y < 0) {
              this.y = p52.height;
              this.updatePrev();
            }
            if (this.y > p52.height) {
              this.y = 0;
              this.updatePrev();
            }
          }
          render() {
            p52.stroke(`hsla(${this.hue}, ${this.sat}%, ${this.light}%, .5)`);
            p52.line(this.x, this.y, this.lx, this.ly);
            this.updatePrev();
          }
        }
        console.debug("p5", p52);
        p52.setup = () => {
          console.debug("setup");
          document.head.innerHTML += '<link id="theme-migration" rel="stylesheet" type="text/css" href="./themes/migration.css">';
          const canvas = p52.createCanvas(p52.windowWidth, p52.windowHeight);
          canvas.parent(document.body);
          for (let i = 0; i < opt.particles; i++) {
            Particles.push(new Particle(Math.random() * p52.width, Math.random() * p52.height));
          }
          p52.strokeWeight(opt.strokeWeight);
        };
        p52.draw = () => {
          time++;
          p52.background(0, 100 - opt.tail);
          for (let p of Particles) {
            p.update();
            p.render();
          }
        };
        p52.tearDown = () => {
          document.getElementById("theme-migration").remove();
          p52.erase();
          p52.noLoop();
          p52.remove();
        };
        function windowResized() {
          p52.resizeCanvas(windowWidth, windowHeight);
        }
      };
      console.debug("p5", p5);
      P5 = new p5.default(start);
      tearDown = P5.tearDown;
      console.debug("P5", P5);
    }
  });

  // node_modules/chroma-js/chroma.js
  var require_chroma = __commonJS({
    "node_modules/chroma-js/chroma.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.chroma = factory());
      })(exports, function() {
        "use strict";
        var limit$2 = function(x, min2, max2) {
          if (min2 === void 0)
            min2 = 0;
          if (max2 === void 0)
            max2 = 1;
          return x < min2 ? min2 : x > max2 ? max2 : x;
        };
        var limit$1 = limit$2;
        var clip_rgb$3 = function(rgb2) {
          rgb2._clipped = false;
          rgb2._unclipped = rgb2.slice(0);
          for (var i2 = 0; i2 <= 3; i2++) {
            if (i2 < 3) {
              if (rgb2[i2] < 0 || rgb2[i2] > 255) {
                rgb2._clipped = true;
              }
              rgb2[i2] = limit$1(rgb2[i2], 0, 255);
            } else if (i2 === 3) {
              rgb2[i2] = limit$1(rgb2[i2], 0, 1);
            }
          }
          return rgb2;
        };
        var classToType = {};
        for (var i$1 = 0, list$1 = ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Undefined", "Null"]; i$1 < list$1.length; i$1 += 1) {
          var name = list$1[i$1];
          classToType["[object " + name + "]"] = name.toLowerCase();
        }
        var type$p = function(obj) {
          return classToType[Object.prototype.toString.call(obj)] || "object";
        };
        var type$o = type$p;
        var unpack$B = function(args, keyOrder) {
          if (keyOrder === void 0)
            keyOrder = null;
          if (args.length >= 3) {
            return Array.prototype.slice.call(args);
          }
          if (type$o(args[0]) == "object" && keyOrder) {
            return keyOrder.split("").filter(function(k) {
              return args[0][k] !== void 0;
            }).map(function(k) {
              return args[0][k];
            });
          }
          return args[0];
        };
        var type$n = type$p;
        var last$4 = function(args) {
          if (args.length < 2) {
            return null;
          }
          var l = args.length - 1;
          if (type$n(args[l]) == "string") {
            return args[l].toLowerCase();
          }
          return null;
        };
        var PI$2 = Math.PI;
        var utils = {
          clip_rgb: clip_rgb$3,
          limit: limit$2,
          type: type$p,
          unpack: unpack$B,
          last: last$4,
          PI: PI$2,
          TWOPI: PI$2 * 2,
          PITHIRD: PI$2 / 3,
          DEG2RAD: PI$2 / 180,
          RAD2DEG: 180 / PI$2
        };
        var input$h = {
          format: {},
          autodetect: []
        };
        var last$3 = utils.last;
        var clip_rgb$2 = utils.clip_rgb;
        var type$m = utils.type;
        var _input = input$h;
        var Color$D = function Color3() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var me = this;
          if (type$m(args[0]) === "object" && args[0].constructor && args[0].constructor === this.constructor) {
            return args[0];
          }
          var mode = last$3(args);
          var autodetect = false;
          if (!mode) {
            autodetect = true;
            if (!_input.sorted) {
              _input.autodetect = _input.autodetect.sort(function(a, b) {
                return b.p - a.p;
              });
              _input.sorted = true;
            }
            for (var i2 = 0, list2 = _input.autodetect; i2 < list2.length; i2 += 1) {
              var chk = list2[i2];
              mode = chk.test.apply(chk, args);
              if (mode) {
                break;
              }
            }
          }
          if (_input.format[mode]) {
            var rgb2 = _input.format[mode].apply(null, autodetect ? args : args.slice(0, -1));
            me._rgb = clip_rgb$2(rgb2);
          } else {
            throw new Error("unknown format: " + args);
          }
          if (me._rgb.length === 3) {
            me._rgb.push(1);
          }
        };
        Color$D.prototype.toString = function toString2() {
          if (type$m(this.hex) == "function") {
            return this.hex();
          }
          return "[" + this._rgb.join(",") + "]";
        };
        var Color_1 = Color$D;
        var chroma$k = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(chroma$k.Color, [null].concat(args)))();
        };
        chroma$k.Color = Color_1;
        chroma$k.version = "2.4.2";
        var chroma_1 = chroma$k;
        var unpack$A = utils.unpack;
        var max$2 = Math.max;
        var rgb2cmyk$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$A(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          r = r / 255;
          g = g / 255;
          b = b / 255;
          var k = 1 - max$2(r, max$2(g, b));
          var f = k < 1 ? 1 / (1 - k) : 0;
          var c = (1 - r - k) * f;
          var m = (1 - g - k) * f;
          var y = (1 - b - k) * f;
          return [c, m, y, k];
        };
        var rgb2cmyk_1 = rgb2cmyk$1;
        var unpack$z = utils.unpack;
        var cmyk2rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$z(args, "cmyk");
          var c = args[0];
          var m = args[1];
          var y = args[2];
          var k = args[3];
          var alpha = args.length > 4 ? args[4] : 1;
          if (k === 1) {
            return [0, 0, 0, alpha];
          }
          return [
            c >= 1 ? 0 : 255 * (1 - c) * (1 - k),
            m >= 1 ? 0 : 255 * (1 - m) * (1 - k),
            y >= 1 ? 0 : 255 * (1 - y) * (1 - k),
            alpha
          ];
        };
        var cmyk2rgb_1 = cmyk2rgb;
        var chroma$j = chroma_1;
        var Color$C = Color_1;
        var input$g = input$h;
        var unpack$y = utils.unpack;
        var type$l = utils.type;
        var rgb2cmyk = rgb2cmyk_1;
        Color$C.prototype.cmyk = function() {
          return rgb2cmyk(this._rgb);
        };
        chroma$j.cmyk = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$C, [null].concat(args, ["cmyk"])))();
        };
        input$g.format.cmyk = cmyk2rgb_1;
        input$g.autodetect.push({
          p: 2,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$y(args, "cmyk");
            if (type$l(args) === "array" && args.length === 4) {
              return "cmyk";
            }
          }
        });
        var unpack$x = utils.unpack;
        var last$2 = utils.last;
        var rnd = function(a) {
          return Math.round(a * 100) / 100;
        };
        var hsl2css$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var hsla = unpack$x(args, "hsla");
          var mode = last$2(args) || "lsa";
          hsla[0] = rnd(hsla[0] || 0);
          hsla[1] = rnd(hsla[1] * 100) + "%";
          hsla[2] = rnd(hsla[2] * 100) + "%";
          if (mode === "hsla" || hsla.length > 3 && hsla[3] < 1) {
            hsla[3] = hsla.length > 3 ? hsla[3] : 1;
            mode = "hsla";
          } else {
            hsla.length = 3;
          }
          return mode + "(" + hsla.join(",") + ")";
        };
        var hsl2css_1 = hsl2css$1;
        var unpack$w = utils.unpack;
        var rgb2hsl$3 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$w(args, "rgba");
          var r = args[0];
          var g = args[1];
          var b = args[2];
          r /= 255;
          g /= 255;
          b /= 255;
          var min2 = Math.min(r, g, b);
          var max2 = Math.max(r, g, b);
          var l = (max2 + min2) / 2;
          var s, h;
          if (max2 === min2) {
            s = 0;
            h = Number.NaN;
          } else {
            s = l < 0.5 ? (max2 - min2) / (max2 + min2) : (max2 - min2) / (2 - max2 - min2);
          }
          if (r == max2) {
            h = (g - b) / (max2 - min2);
          } else if (g == max2) {
            h = 2 + (b - r) / (max2 - min2);
          } else if (b == max2) {
            h = 4 + (r - g) / (max2 - min2);
          }
          h *= 60;
          if (h < 0) {
            h += 360;
          }
          if (args.length > 3 && args[3] !== void 0) {
            return [h, s, l, args[3]];
          }
          return [h, s, l];
        };
        var rgb2hsl_1 = rgb2hsl$3;
        var unpack$v = utils.unpack;
        var last$1 = utils.last;
        var hsl2css = hsl2css_1;
        var rgb2hsl$2 = rgb2hsl_1;
        var round$6 = Math.round;
        var rgb2css$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var rgba = unpack$v(args, "rgba");
          var mode = last$1(args) || "rgb";
          if (mode.substr(0, 3) == "hsl") {
            return hsl2css(rgb2hsl$2(rgba), mode);
          }
          rgba[0] = round$6(rgba[0]);
          rgba[1] = round$6(rgba[1]);
          rgba[2] = round$6(rgba[2]);
          if (mode === "rgba" || rgba.length > 3 && rgba[3] < 1) {
            rgba[3] = rgba.length > 3 ? rgba[3] : 1;
            mode = "rgba";
          }
          return mode + "(" + rgba.slice(0, mode === "rgb" ? 3 : 4).join(",") + ")";
        };
        var rgb2css_1 = rgb2css$1;
        var unpack$u = utils.unpack;
        var round$5 = Math.round;
        var hsl2rgb$1 = function() {
          var assign;
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$u(args, "hsl");
          var h = args[0];
          var s = args[1];
          var l = args[2];
          var r, g, b;
          if (s === 0) {
            r = g = b = l * 255;
          } else {
            var t3 = [0, 0, 0];
            var c = [0, 0, 0];
            var t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var t1 = 2 * l - t2;
            var h_ = h / 360;
            t3[0] = h_ + 1 / 3;
            t3[1] = h_;
            t3[2] = h_ - 1 / 3;
            for (var i2 = 0; i2 < 3; i2++) {
              if (t3[i2] < 0) {
                t3[i2] += 1;
              }
              if (t3[i2] > 1) {
                t3[i2] -= 1;
              }
              if (6 * t3[i2] < 1) {
                c[i2] = t1 + (t2 - t1) * 6 * t3[i2];
              } else if (2 * t3[i2] < 1) {
                c[i2] = t2;
              } else if (3 * t3[i2] < 2) {
                c[i2] = t1 + (t2 - t1) * (2 / 3 - t3[i2]) * 6;
              } else {
                c[i2] = t1;
              }
            }
            assign = [round$5(c[0] * 255), round$5(c[1] * 255), round$5(c[2] * 255)], r = assign[0], g = assign[1], b = assign[2];
          }
          if (args.length > 3) {
            return [r, g, b, args[3]];
          }
          return [r, g, b, 1];
        };
        var hsl2rgb_1 = hsl2rgb$1;
        var hsl2rgb = hsl2rgb_1;
        var input$f = input$h;
        var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
        var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
        var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
        var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
        var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
        var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
        var round$4 = Math.round;
        var css2rgb$1 = function(css) {
          css = css.toLowerCase().trim();
          var m;
          if (input$f.format.named) {
            try {
              return input$f.format.named(css);
            } catch (e) {
            }
          }
          if (m = css.match(RE_RGB)) {
            var rgb2 = m.slice(1, 4);
            for (var i2 = 0; i2 < 3; i2++) {
              rgb2[i2] = +rgb2[i2];
            }
            rgb2[3] = 1;
            return rgb2;
          }
          if (m = css.match(RE_RGBA)) {
            var rgb$1 = m.slice(1, 5);
            for (var i$12 = 0; i$12 < 4; i$12++) {
              rgb$1[i$12] = +rgb$1[i$12];
            }
            return rgb$1;
          }
          if (m = css.match(RE_RGB_PCT)) {
            var rgb$2 = m.slice(1, 4);
            for (var i$2 = 0; i$2 < 3; i$2++) {
              rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
            }
            rgb$2[3] = 1;
            return rgb$2;
          }
          if (m = css.match(RE_RGBA_PCT)) {
            var rgb$3 = m.slice(1, 5);
            for (var i$3 = 0; i$3 < 3; i$3++) {
              rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
            }
            rgb$3[3] = +rgb$3[3];
            return rgb$3;
          }
          if (m = css.match(RE_HSL)) {
            var hsl2 = m.slice(1, 4);
            hsl2[1] *= 0.01;
            hsl2[2] *= 0.01;
            var rgb$4 = hsl2rgb(hsl2);
            rgb$4[3] = 1;
            return rgb$4;
          }
          if (m = css.match(RE_HSLA)) {
            var hsl$1 = m.slice(1, 4);
            hsl$1[1] *= 0.01;
            hsl$1[2] *= 0.01;
            var rgb$5 = hsl2rgb(hsl$1);
            rgb$5[3] = +m[4];
            return rgb$5;
          }
        };
        css2rgb$1.test = function(s) {
          return RE_RGB.test(s) || RE_RGBA.test(s) || RE_RGB_PCT.test(s) || RE_RGBA_PCT.test(s) || RE_HSL.test(s) || RE_HSLA.test(s);
        };
        var css2rgb_1 = css2rgb$1;
        var chroma$i = chroma_1;
        var Color$B = Color_1;
        var input$e = input$h;
        var type$k = utils.type;
        var rgb2css = rgb2css_1;
        var css2rgb = css2rgb_1;
        Color$B.prototype.css = function(mode) {
          return rgb2css(this._rgb, mode);
        };
        chroma$i.css = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$B, [null].concat(args, ["css"])))();
        };
        input$e.format.css = css2rgb;
        input$e.autodetect.push({
          p: 5,
          test: function(h) {
            var rest = [], len = arguments.length - 1;
            while (len-- > 0)
              rest[len] = arguments[len + 1];
            if (!rest.length && type$k(h) === "string" && css2rgb.test(h)) {
              return "css";
            }
          }
        });
        var Color$A = Color_1;
        var chroma$h = chroma_1;
        var input$d = input$h;
        var unpack$t = utils.unpack;
        input$d.format.gl = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var rgb2 = unpack$t(args, "rgba");
          rgb2[0] *= 255;
          rgb2[1] *= 255;
          rgb2[2] *= 255;
          return rgb2;
        };
        chroma$h.gl = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$A, [null].concat(args, ["gl"])))();
        };
        Color$A.prototype.gl = function() {
          var rgb2 = this._rgb;
          return [rgb2[0] / 255, rgb2[1] / 255, rgb2[2] / 255, rgb2[3]];
        };
        var unpack$s = utils.unpack;
        var rgb2hcg$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$s(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var min2 = Math.min(r, g, b);
          var max2 = Math.max(r, g, b);
          var delta = max2 - min2;
          var c = delta * 100 / 255;
          var _g = min2 / (255 - delta) * 100;
          var h;
          if (delta === 0) {
            h = Number.NaN;
          } else {
            if (r === max2) {
              h = (g - b) / delta;
            }
            if (g === max2) {
              h = 2 + (b - r) / delta;
            }
            if (b === max2) {
              h = 4 + (r - g) / delta;
            }
            h *= 60;
            if (h < 0) {
              h += 360;
            }
          }
          return [h, c, _g];
        };
        var rgb2hcg_1 = rgb2hcg$1;
        var unpack$r = utils.unpack;
        var floor$3 = Math.floor;
        var hcg2rgb = function() {
          var assign, assign$1, assign$2, assign$3, assign$4, assign$5;
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$r(args, "hcg");
          var h = args[0];
          var c = args[1];
          var _g = args[2];
          var r, g, b;
          _g = _g * 255;
          var _c = c * 255;
          if (c === 0) {
            r = g = b = _g;
          } else {
            if (h === 360) {
              h = 0;
            }
            if (h > 360) {
              h -= 360;
            }
            if (h < 0) {
              h += 360;
            }
            h /= 60;
            var i2 = floor$3(h);
            var f = h - i2;
            var p = _g * (1 - c);
            var q = p + _c * (1 - f);
            var t = p + _c * f;
            var v = p + _c;
            switch (i2) {
              case 0:
                assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];
                break;
              case 1:
                assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];
                break;
              case 2:
                assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];
                break;
              case 3:
                assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];
                break;
              case 4:
                assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];
                break;
              case 5:
                assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];
                break;
            }
          }
          return [r, g, b, args.length > 3 ? args[3] : 1];
        };
        var hcg2rgb_1 = hcg2rgb;
        var unpack$q = utils.unpack;
        var type$j = utils.type;
        var chroma$g = chroma_1;
        var Color$z = Color_1;
        var input$c = input$h;
        var rgb2hcg = rgb2hcg_1;
        Color$z.prototype.hcg = function() {
          return rgb2hcg(this._rgb);
        };
        chroma$g.hcg = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$z, [null].concat(args, ["hcg"])))();
        };
        input$c.format.hcg = hcg2rgb_1;
        input$c.autodetect.push({
          p: 1,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$q(args, "hcg");
            if (type$j(args) === "array" && args.length === 3) {
              return "hcg";
            }
          }
        });
        var unpack$p = utils.unpack;
        var last = utils.last;
        var round$3 = Math.round;
        var rgb2hex$2 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$p(args, "rgba");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var a = ref[3];
          var mode = last(args) || "auto";
          if (a === void 0) {
            a = 1;
          }
          if (mode === "auto") {
            mode = a < 1 ? "rgba" : "rgb";
          }
          r = round$3(r);
          g = round$3(g);
          b = round$3(b);
          var u = r << 16 | g << 8 | b;
          var str = "000000" + u.toString(16);
          str = str.substr(str.length - 6);
          var hxa = "0" + round$3(a * 255).toString(16);
          hxa = hxa.substr(hxa.length - 2);
          switch (mode.toLowerCase()) {
            case "rgba":
              return "#" + str + hxa;
            case "argb":
              return "#" + hxa + str;
            default:
              return "#" + str;
          }
        };
        var rgb2hex_1 = rgb2hex$2;
        var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
        var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;
        var hex2rgb$1 = function(hex) {
          if (hex.match(RE_HEX)) {
            if (hex.length === 4 || hex.length === 7) {
              hex = hex.substr(1);
            }
            if (hex.length === 3) {
              hex = hex.split("");
              hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            var u = parseInt(hex, 16);
            var r = u >> 16;
            var g = u >> 8 & 255;
            var b = u & 255;
            return [r, g, b, 1];
          }
          if (hex.match(RE_HEXA)) {
            if (hex.length === 5 || hex.length === 9) {
              hex = hex.substr(1);
            }
            if (hex.length === 4) {
              hex = hex.split("");
              hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
            }
            var u$1 = parseInt(hex, 16);
            var r$1 = u$1 >> 24 & 255;
            var g$1 = u$1 >> 16 & 255;
            var b$1 = u$1 >> 8 & 255;
            var a = Math.round((u$1 & 255) / 255 * 100) / 100;
            return [r$1, g$1, b$1, a];
          }
          throw new Error("unknown hex color: " + hex);
        };
        var hex2rgb_1 = hex2rgb$1;
        var chroma$f = chroma_1;
        var Color$y = Color_1;
        var type$i = utils.type;
        var input$b = input$h;
        var rgb2hex$1 = rgb2hex_1;
        Color$y.prototype.hex = function(mode) {
          return rgb2hex$1(this._rgb, mode);
        };
        chroma$f.hex = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$y, [null].concat(args, ["hex"])))();
        };
        input$b.format.hex = hex2rgb_1;
        input$b.autodetect.push({
          p: 4,
          test: function(h) {
            var rest = [], len = arguments.length - 1;
            while (len-- > 0)
              rest[len] = arguments[len + 1];
            if (!rest.length && type$i(h) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0) {
              return "hex";
            }
          }
        });
        var unpack$o = utils.unpack;
        var TWOPI$2 = utils.TWOPI;
        var min$2 = Math.min;
        var sqrt$4 = Math.sqrt;
        var acos = Math.acos;
        var rgb2hsi$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$o(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          r /= 255;
          g /= 255;
          b /= 255;
          var h;
          var min_ = min$2(r, g, b);
          var i2 = (r + g + b) / 3;
          var s = i2 > 0 ? 1 - min_ / i2 : 0;
          if (s === 0) {
            h = NaN;
          } else {
            h = (r - g + (r - b)) / 2;
            h /= sqrt$4((r - g) * (r - g) + (r - b) * (g - b));
            h = acos(h);
            if (b > g) {
              h = TWOPI$2 - h;
            }
            h /= TWOPI$2;
          }
          return [h * 360, s, i2];
        };
        var rgb2hsi_1 = rgb2hsi$1;
        var unpack$n = utils.unpack;
        var limit = utils.limit;
        var TWOPI$1 = utils.TWOPI;
        var PITHIRD = utils.PITHIRD;
        var cos$4 = Math.cos;
        var hsi2rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$n(args, "hsi");
          var h = args[0];
          var s = args[1];
          var i2 = args[2];
          var r, g, b;
          if (isNaN(h)) {
            h = 0;
          }
          if (isNaN(s)) {
            s = 0;
          }
          if (h > 360) {
            h -= 360;
          }
          if (h < 0) {
            h += 360;
          }
          h /= 360;
          if (h < 1 / 3) {
            b = (1 - s) / 3;
            r = (1 + s * cos$4(TWOPI$1 * h) / cos$4(PITHIRD - TWOPI$1 * h)) / 3;
            g = 1 - (b + r);
          } else if (h < 2 / 3) {
            h -= 1 / 3;
            r = (1 - s) / 3;
            g = (1 + s * cos$4(TWOPI$1 * h) / cos$4(PITHIRD - TWOPI$1 * h)) / 3;
            b = 1 - (r + g);
          } else {
            h -= 2 / 3;
            g = (1 - s) / 3;
            b = (1 + s * cos$4(TWOPI$1 * h) / cos$4(PITHIRD - TWOPI$1 * h)) / 3;
            r = 1 - (g + b);
          }
          r = limit(i2 * r * 3);
          g = limit(i2 * g * 3);
          b = limit(i2 * b * 3);
          return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];
        };
        var hsi2rgb_1 = hsi2rgb;
        var unpack$m = utils.unpack;
        var type$h = utils.type;
        var chroma$e = chroma_1;
        var Color$x = Color_1;
        var input$a = input$h;
        var rgb2hsi = rgb2hsi_1;
        Color$x.prototype.hsi = function() {
          return rgb2hsi(this._rgb);
        };
        chroma$e.hsi = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$x, [null].concat(args, ["hsi"])))();
        };
        input$a.format.hsi = hsi2rgb_1;
        input$a.autodetect.push({
          p: 2,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$m(args, "hsi");
            if (type$h(args) === "array" && args.length === 3) {
              return "hsi";
            }
          }
        });
        var unpack$l = utils.unpack;
        var type$g = utils.type;
        var chroma$d = chroma_1;
        var Color$w = Color_1;
        var input$9 = input$h;
        var rgb2hsl$1 = rgb2hsl_1;
        Color$w.prototype.hsl = function() {
          return rgb2hsl$1(this._rgb);
        };
        chroma$d.hsl = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$w, [null].concat(args, ["hsl"])))();
        };
        input$9.format.hsl = hsl2rgb_1;
        input$9.autodetect.push({
          p: 2,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$l(args, "hsl");
            if (type$g(args) === "array" && args.length === 3) {
              return "hsl";
            }
          }
        });
        var unpack$k = utils.unpack;
        var min$1 = Math.min;
        var max$1 = Math.max;
        var rgb2hsl = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$k(args, "rgb");
          var r = args[0];
          var g = args[1];
          var b = args[2];
          var min_ = min$1(r, g, b);
          var max_ = max$1(r, g, b);
          var delta = max_ - min_;
          var h, s, v;
          v = max_ / 255;
          if (max_ === 0) {
            h = Number.NaN;
            s = 0;
          } else {
            s = delta / max_;
            if (r === max_) {
              h = (g - b) / delta;
            }
            if (g === max_) {
              h = 2 + (b - r) / delta;
            }
            if (b === max_) {
              h = 4 + (r - g) / delta;
            }
            h *= 60;
            if (h < 0) {
              h += 360;
            }
          }
          return [h, s, v];
        };
        var rgb2hsv$1 = rgb2hsl;
        var unpack$j = utils.unpack;
        var floor$2 = Math.floor;
        var hsv2rgb = function() {
          var assign, assign$1, assign$2, assign$3, assign$4, assign$5;
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$j(args, "hsv");
          var h = args[0];
          var s = args[1];
          var v = args[2];
          var r, g, b;
          v *= 255;
          if (s === 0) {
            r = g = b = v;
          } else {
            if (h === 360) {
              h = 0;
            }
            if (h > 360) {
              h -= 360;
            }
            if (h < 0) {
              h += 360;
            }
            h /= 60;
            var i2 = floor$2(h);
            var f = h - i2;
            var p = v * (1 - s);
            var q = v * (1 - s * f);
            var t = v * (1 - s * (1 - f));
            switch (i2) {
              case 0:
                assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2];
                break;
              case 1:
                assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2];
                break;
              case 2:
                assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2];
                break;
              case 3:
                assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2];
                break;
              case 4:
                assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2];
                break;
              case 5:
                assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2];
                break;
            }
          }
          return [r, g, b, args.length > 3 ? args[3] : 1];
        };
        var hsv2rgb_1 = hsv2rgb;
        var unpack$i = utils.unpack;
        var type$f = utils.type;
        var chroma$c = chroma_1;
        var Color$v = Color_1;
        var input$8 = input$h;
        var rgb2hsv = rgb2hsv$1;
        Color$v.prototype.hsv = function() {
          return rgb2hsv(this._rgb);
        };
        chroma$c.hsv = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$v, [null].concat(args, ["hsv"])))();
        };
        input$8.format.hsv = hsv2rgb_1;
        input$8.autodetect.push({
          p: 2,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$i(args, "hsv");
            if (type$f(args) === "array" && args.length === 3) {
              return "hsv";
            }
          }
        });
        var labConstants = {
          Kn: 18,
          Xn: 0.95047,
          Yn: 1,
          Zn: 1.08883,
          t0: 0.137931034,
          t1: 0.206896552,
          t2: 0.12841855,
          t3: 8856452e-9
        };
        var LAB_CONSTANTS$3 = labConstants;
        var unpack$h = utils.unpack;
        var pow$a = Math.pow;
        var rgb2lab$2 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$h(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var ref$1 = rgb2xyz(r, g, b);
          var x = ref$1[0];
          var y = ref$1[1];
          var z = ref$1[2];
          var l = 116 * y - 16;
          return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
        };
        var rgb_xyz = function(r) {
          if ((r /= 255) <= 0.04045) {
            return r / 12.92;
          }
          return pow$a((r + 0.055) / 1.055, 2.4);
        };
        var xyz_lab = function(t) {
          if (t > LAB_CONSTANTS$3.t3) {
            return pow$a(t, 1 / 3);
          }
          return t / LAB_CONSTANTS$3.t2 + LAB_CONSTANTS$3.t0;
        };
        var rgb2xyz = function(r, g, b) {
          r = rgb_xyz(r);
          g = rgb_xyz(g);
          b = rgb_xyz(b);
          var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS$3.Xn);
          var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.072175 * b) / LAB_CONSTANTS$3.Yn);
          var z = xyz_lab((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / LAB_CONSTANTS$3.Zn);
          return [x, y, z];
        };
        var rgb2lab_1 = rgb2lab$2;
        var LAB_CONSTANTS$2 = labConstants;
        var unpack$g = utils.unpack;
        var pow$9 = Math.pow;
        var lab2rgb$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$g(args, "lab");
          var l = args[0];
          var a = args[1];
          var b = args[2];
          var x, y, z, r, g, b_;
          y = (l + 16) / 116;
          x = isNaN(a) ? y : y + a / 500;
          z = isNaN(b) ? y : y - b / 200;
          y = LAB_CONSTANTS$2.Yn * lab_xyz(y);
          x = LAB_CONSTANTS$2.Xn * lab_xyz(x);
          z = LAB_CONSTANTS$2.Zn * lab_xyz(z);
          r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);
          g = xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z);
          b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);
          return [r, g, b_, args.length > 3 ? args[3] : 1];
        };
        var xyz_rgb = function(r) {
          return 255 * (r <= 304e-5 ? 12.92 * r : 1.055 * pow$9(r, 1 / 2.4) - 0.055);
        };
        var lab_xyz = function(t) {
          return t > LAB_CONSTANTS$2.t1 ? t * t * t : LAB_CONSTANTS$2.t2 * (t - LAB_CONSTANTS$2.t0);
        };
        var lab2rgb_1 = lab2rgb$1;
        var unpack$f = utils.unpack;
        var type$e = utils.type;
        var chroma$b = chroma_1;
        var Color$u = Color_1;
        var input$7 = input$h;
        var rgb2lab$1 = rgb2lab_1;
        Color$u.prototype.lab = function() {
          return rgb2lab$1(this._rgb);
        };
        chroma$b.lab = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$u, [null].concat(args, ["lab"])))();
        };
        input$7.format.lab = lab2rgb_1;
        input$7.autodetect.push({
          p: 2,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$f(args, "lab");
            if (type$e(args) === "array" && args.length === 3) {
              return "lab";
            }
          }
        });
        var unpack$e = utils.unpack;
        var RAD2DEG2 = utils.RAD2DEG;
        var sqrt$3 = Math.sqrt;
        var atan2$2 = Math.atan2;
        var round$2 = Math.round;
        var lab2lch$2 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$e(args, "lab");
          var l = ref[0];
          var a = ref[1];
          var b = ref[2];
          var c = sqrt$3(a * a + b * b);
          var h = (atan2$2(b, a) * RAD2DEG2 + 360) % 360;
          if (round$2(c * 1e4) === 0) {
            h = Number.NaN;
          }
          return [l, c, h];
        };
        var lab2lch_1 = lab2lch$2;
        var unpack$d = utils.unpack;
        var rgb2lab = rgb2lab_1;
        var lab2lch$1 = lab2lch_1;
        var rgb2lch$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$d(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var ref$1 = rgb2lab(r, g, b);
          var l = ref$1[0];
          var a = ref$1[1];
          var b_ = ref$1[2];
          return lab2lch$1(l, a, b_);
        };
        var rgb2lch_1 = rgb2lch$1;
        var unpack$c = utils.unpack;
        var DEG2RAD2 = utils.DEG2RAD;
        var sin$3 = Math.sin;
        var cos$3 = Math.cos;
        var lch2lab$2 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$c(args, "lch");
          var l = ref[0];
          var c = ref[1];
          var h = ref[2];
          if (isNaN(h)) {
            h = 0;
          }
          h = h * DEG2RAD2;
          return [l, cos$3(h) * c, sin$3(h) * c];
        };
        var lch2lab_1 = lch2lab$2;
        var unpack$b = utils.unpack;
        var lch2lab$1 = lch2lab_1;
        var lab2rgb = lab2rgb_1;
        var lch2rgb$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$b(args, "lch");
          var l = args[0];
          var c = args[1];
          var h = args[2];
          var ref = lch2lab$1(l, c, h);
          var L = ref[0];
          var a = ref[1];
          var b_ = ref[2];
          var ref$1 = lab2rgb(L, a, b_);
          var r = ref$1[0];
          var g = ref$1[1];
          var b = ref$1[2];
          return [r, g, b, args.length > 3 ? args[3] : 1];
        };
        var lch2rgb_1 = lch2rgb$1;
        var unpack$a = utils.unpack;
        var lch2rgb = lch2rgb_1;
        var hcl2rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var hcl = unpack$a(args, "hcl").reverse();
          return lch2rgb.apply(void 0, hcl);
        };
        var hcl2rgb_1 = hcl2rgb;
        var unpack$9 = utils.unpack;
        var type$d = utils.type;
        var chroma$a = chroma_1;
        var Color$t = Color_1;
        var input$6 = input$h;
        var rgb2lch = rgb2lch_1;
        Color$t.prototype.lch = function() {
          return rgb2lch(this._rgb);
        };
        Color$t.prototype.hcl = function() {
          return rgb2lch(this._rgb).reverse();
        };
        chroma$a.lch = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$t, [null].concat(args, ["lch"])))();
        };
        chroma$a.hcl = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$t, [null].concat(args, ["hcl"])))();
        };
        input$6.format.lch = lch2rgb_1;
        input$6.format.hcl = hcl2rgb_1;
        ["lch", "hcl"].forEach(function(m) {
          return input$6.autodetect.push({
            p: 2,
            test: function() {
              var args = [], len = arguments.length;
              while (len--)
                args[len] = arguments[len];
              args = unpack$9(args, m);
              if (type$d(args) === "array" && args.length === 3) {
                return m;
              }
            }
          });
        });
        var w3cx11$1 = {
          aliceblue: "#f0f8ff",
          antiquewhite: "#faebd7",
          aqua: "#00ffff",
          aquamarine: "#7fffd4",
          azure: "#f0ffff",
          beige: "#f5f5dc",
          bisque: "#ffe4c4",
          black: "#000000",
          blanchedalmond: "#ffebcd",
          blue: "#0000ff",
          blueviolet: "#8a2be2",
          brown: "#a52a2a",
          burlywood: "#deb887",
          cadetblue: "#5f9ea0",
          chartreuse: "#7fff00",
          chocolate: "#d2691e",
          coral: "#ff7f50",
          cornflower: "#6495ed",
          cornflowerblue: "#6495ed",
          cornsilk: "#fff8dc",
          crimson: "#dc143c",
          cyan: "#00ffff",
          darkblue: "#00008b",
          darkcyan: "#008b8b",
          darkgoldenrod: "#b8860b",
          darkgray: "#a9a9a9",
          darkgreen: "#006400",
          darkgrey: "#a9a9a9",
          darkkhaki: "#bdb76b",
          darkmagenta: "#8b008b",
          darkolivegreen: "#556b2f",
          darkorange: "#ff8c00",
          darkorchid: "#9932cc",
          darkred: "#8b0000",
          darksalmon: "#e9967a",
          darkseagreen: "#8fbc8f",
          darkslateblue: "#483d8b",
          darkslategray: "#2f4f4f",
          darkslategrey: "#2f4f4f",
          darkturquoise: "#00ced1",
          darkviolet: "#9400d3",
          deeppink: "#ff1493",
          deepskyblue: "#00bfff",
          dimgray: "#696969",
          dimgrey: "#696969",
          dodgerblue: "#1e90ff",
          firebrick: "#b22222",
          floralwhite: "#fffaf0",
          forestgreen: "#228b22",
          fuchsia: "#ff00ff",
          gainsboro: "#dcdcdc",
          ghostwhite: "#f8f8ff",
          gold: "#ffd700",
          goldenrod: "#daa520",
          gray: "#808080",
          green: "#008000",
          greenyellow: "#adff2f",
          grey: "#808080",
          honeydew: "#f0fff0",
          hotpink: "#ff69b4",
          indianred: "#cd5c5c",
          indigo: "#4b0082",
          ivory: "#fffff0",
          khaki: "#f0e68c",
          laserlemon: "#ffff54",
          lavender: "#e6e6fa",
          lavenderblush: "#fff0f5",
          lawngreen: "#7cfc00",
          lemonchiffon: "#fffacd",
          lightblue: "#add8e6",
          lightcoral: "#f08080",
          lightcyan: "#e0ffff",
          lightgoldenrod: "#fafad2",
          lightgoldenrodyellow: "#fafad2",
          lightgray: "#d3d3d3",
          lightgreen: "#90ee90",
          lightgrey: "#d3d3d3",
          lightpink: "#ffb6c1",
          lightsalmon: "#ffa07a",
          lightseagreen: "#20b2aa",
          lightskyblue: "#87cefa",
          lightslategray: "#778899",
          lightslategrey: "#778899",
          lightsteelblue: "#b0c4de",
          lightyellow: "#ffffe0",
          lime: "#00ff00",
          limegreen: "#32cd32",
          linen: "#faf0e6",
          magenta: "#ff00ff",
          maroon: "#800000",
          maroon2: "#7f0000",
          maroon3: "#b03060",
          mediumaquamarine: "#66cdaa",
          mediumblue: "#0000cd",
          mediumorchid: "#ba55d3",
          mediumpurple: "#9370db",
          mediumseagreen: "#3cb371",
          mediumslateblue: "#7b68ee",
          mediumspringgreen: "#00fa9a",
          mediumturquoise: "#48d1cc",
          mediumvioletred: "#c71585",
          midnightblue: "#191970",
          mintcream: "#f5fffa",
          mistyrose: "#ffe4e1",
          moccasin: "#ffe4b5",
          navajowhite: "#ffdead",
          navy: "#000080",
          oldlace: "#fdf5e6",
          olive: "#808000",
          olivedrab: "#6b8e23",
          orange: "#ffa500",
          orangered: "#ff4500",
          orchid: "#da70d6",
          palegoldenrod: "#eee8aa",
          palegreen: "#98fb98",
          paleturquoise: "#afeeee",
          palevioletred: "#db7093",
          papayawhip: "#ffefd5",
          peachpuff: "#ffdab9",
          peru: "#cd853f",
          pink: "#ffc0cb",
          plum: "#dda0dd",
          powderblue: "#b0e0e6",
          purple: "#800080",
          purple2: "#7f007f",
          purple3: "#a020f0",
          rebeccapurple: "#663399",
          red: "#ff0000",
          rosybrown: "#bc8f8f",
          royalblue: "#4169e1",
          saddlebrown: "#8b4513",
          salmon: "#fa8072",
          sandybrown: "#f4a460",
          seagreen: "#2e8b57",
          seashell: "#fff5ee",
          sienna: "#a0522d",
          silver: "#c0c0c0",
          skyblue: "#87ceeb",
          slateblue: "#6a5acd",
          slategray: "#708090",
          slategrey: "#708090",
          snow: "#fffafa",
          springgreen: "#00ff7f",
          steelblue: "#4682b4",
          tan: "#d2b48c",
          teal: "#008080",
          thistle: "#d8bfd8",
          tomato: "#ff6347",
          turquoise: "#40e0d0",
          violet: "#ee82ee",
          wheat: "#f5deb3",
          white: "#ffffff",
          whitesmoke: "#f5f5f5",
          yellow: "#ffff00",
          yellowgreen: "#9acd32"
        };
        var w3cx11_1 = w3cx11$1;
        var Color$s = Color_1;
        var input$5 = input$h;
        var type$c = utils.type;
        var w3cx11 = w3cx11_1;
        var hex2rgb = hex2rgb_1;
        var rgb2hex = rgb2hex_1;
        Color$s.prototype.name = function() {
          var hex = rgb2hex(this._rgb, "rgb");
          for (var i2 = 0, list2 = Object.keys(w3cx11); i2 < list2.length; i2 += 1) {
            var n = list2[i2];
            if (w3cx11[n] === hex) {
              return n.toLowerCase();
            }
          }
          return hex;
        };
        input$5.format.named = function(name2) {
          name2 = name2.toLowerCase();
          if (w3cx11[name2]) {
            return hex2rgb(w3cx11[name2]);
          }
          throw new Error("unknown color name: " + name2);
        };
        input$5.autodetect.push({
          p: 5,
          test: function(h) {
            var rest = [], len = arguments.length - 1;
            while (len-- > 0)
              rest[len] = arguments[len + 1];
            if (!rest.length && type$c(h) === "string" && w3cx11[h.toLowerCase()]) {
              return "named";
            }
          }
        });
        var unpack$8 = utils.unpack;
        var rgb2num$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$8(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          return (r << 16) + (g << 8) + b;
        };
        var rgb2num_1 = rgb2num$1;
        var type$b = utils.type;
        var num2rgb = function(num2) {
          if (type$b(num2) == "number" && num2 >= 0 && num2 <= 16777215) {
            var r = num2 >> 16;
            var g = num2 >> 8 & 255;
            var b = num2 & 255;
            return [r, g, b, 1];
          }
          throw new Error("unknown num color: " + num2);
        };
        var num2rgb_1 = num2rgb;
        var chroma$9 = chroma_1;
        var Color$r = Color_1;
        var input$4 = input$h;
        var type$a = utils.type;
        var rgb2num = rgb2num_1;
        Color$r.prototype.num = function() {
          return rgb2num(this._rgb);
        };
        chroma$9.num = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$r, [null].concat(args, ["num"])))();
        };
        input$4.format.num = num2rgb_1;
        input$4.autodetect.push({
          p: 5,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            if (args.length === 1 && type$a(args[0]) === "number" && args[0] >= 0 && args[0] <= 16777215) {
              return "num";
            }
          }
        });
        var chroma$8 = chroma_1;
        var Color$q = Color_1;
        var input$3 = input$h;
        var unpack$7 = utils.unpack;
        var type$9 = utils.type;
        var round$1 = Math.round;
        Color$q.prototype.rgb = function(rnd2) {
          if (rnd2 === void 0)
            rnd2 = true;
          if (rnd2 === false) {
            return this._rgb.slice(0, 3);
          }
          return this._rgb.slice(0, 3).map(round$1);
        };
        Color$q.prototype.rgba = function(rnd2) {
          if (rnd2 === void 0)
            rnd2 = true;
          return this._rgb.slice(0, 4).map(function(v, i2) {
            return i2 < 3 ? rnd2 === false ? v : round$1(v) : v;
          });
        };
        chroma$8.rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$q, [null].concat(args, ["rgb"])))();
        };
        input$3.format.rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var rgba = unpack$7(args, "rgba");
          if (rgba[3] === void 0) {
            rgba[3] = 1;
          }
          return rgba;
        };
        input$3.autodetect.push({
          p: 3,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$7(args, "rgba");
            if (type$9(args) === "array" && (args.length === 3 || args.length === 4 && type$9(args[3]) == "number" && args[3] >= 0 && args[3] <= 1)) {
              return "rgb";
            }
          }
        });
        var log$1 = Math.log;
        var temperature2rgb$1 = function(kelvin) {
          var temp = kelvin / 100;
          var r, g, b;
          if (temp < 66) {
            r = 255;
            g = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log$1(g);
            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log$1(b);
          } else {
            r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log$1(r);
            g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log$1(g);
            b = 255;
          }
          return [r, g, b, 1];
        };
        var temperature2rgb_1 = temperature2rgb$1;
        var temperature2rgb = temperature2rgb_1;
        var unpack$6 = utils.unpack;
        var round = Math.round;
        var rgb2temperature$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var rgb2 = unpack$6(args, "rgb");
          var r = rgb2[0], b = rgb2[2];
          var minTemp = 1e3;
          var maxTemp = 4e4;
          var eps = 0.4;
          var temp;
          while (maxTemp - minTemp > eps) {
            temp = (maxTemp + minTemp) * 0.5;
            var rgb$1 = temperature2rgb(temp);
            if (rgb$1[2] / rgb$1[0] >= b / r) {
              maxTemp = temp;
            } else {
              minTemp = temp;
            }
          }
          return round(temp);
        };
        var rgb2temperature_1 = rgb2temperature$1;
        var chroma$7 = chroma_1;
        var Color$p = Color_1;
        var input$2 = input$h;
        var rgb2temperature = rgb2temperature_1;
        Color$p.prototype.temp = Color$p.prototype.kelvin = Color$p.prototype.temperature = function() {
          return rgb2temperature(this._rgb);
        };
        chroma$7.temp = chroma$7.kelvin = chroma$7.temperature = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$p, [null].concat(args, ["temp"])))();
        };
        input$2.format.temp = input$2.format.kelvin = input$2.format.temperature = temperature2rgb_1;
        var unpack$5 = utils.unpack;
        var cbrt = Math.cbrt;
        var pow$8 = Math.pow;
        var sign$1 = Math.sign;
        var rgb2oklab$2 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$5(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var ref$1 = [rgb2lrgb(r / 255), rgb2lrgb(g / 255), rgb2lrgb(b / 255)];
          var lr = ref$1[0];
          var lg = ref$1[1];
          var lb = ref$1[2];
          var l = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
          var m = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
          var s = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);
          return [
            0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
            1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
            0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s
          ];
        };
        var rgb2oklab_1 = rgb2oklab$2;
        function rgb2lrgb(c) {
          var abs2 = Math.abs(c);
          if (abs2 < 0.04045) {
            return c / 12.92;
          }
          return (sign$1(c) || 1) * pow$8((abs2 + 0.055) / 1.055, 2.4);
        }
        var unpack$4 = utils.unpack;
        var pow$7 = Math.pow;
        var sign2 = Math.sign;
        var oklab2rgb$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$4(args, "lab");
          var L = args[0];
          var a = args[1];
          var b = args[2];
          var l = pow$7(L + 0.3963377774 * a + 0.2158037573 * b, 3);
          var m = pow$7(L - 0.1055613458 * a - 0.0638541728 * b, 3);
          var s = pow$7(L - 0.0894841775 * a - 1.291485548 * b, 3);
          return [
            255 * lrgb2rgb(4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s),
            255 * lrgb2rgb(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s),
            255 * lrgb2rgb(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s),
            args.length > 3 ? args[3] : 1
          ];
        };
        var oklab2rgb_1 = oklab2rgb$1;
        function lrgb2rgb(c) {
          var abs2 = Math.abs(c);
          if (abs2 > 31308e-7) {
            return (sign2(c) || 1) * (1.055 * pow$7(abs2, 1 / 2.4) - 0.055);
          }
          return c * 12.92;
        }
        var unpack$3 = utils.unpack;
        var type$8 = utils.type;
        var chroma$6 = chroma_1;
        var Color$o = Color_1;
        var input$1 = input$h;
        var rgb2oklab$1 = rgb2oklab_1;
        Color$o.prototype.oklab = function() {
          return rgb2oklab$1(this._rgb);
        };
        chroma$6.oklab = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$o, [null].concat(args, ["oklab"])))();
        };
        input$1.format.oklab = oklab2rgb_1;
        input$1.autodetect.push({
          p: 3,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack$3(args, "oklab");
            if (type$8(args) === "array" && args.length === 3) {
              return "oklab";
            }
          }
        });
        var unpack$2 = utils.unpack;
        var rgb2oklab = rgb2oklab_1;
        var lab2lch = lab2lch_1;
        var rgb2oklch$1 = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          var ref = unpack$2(args, "rgb");
          var r = ref[0];
          var g = ref[1];
          var b = ref[2];
          var ref$1 = rgb2oklab(r, g, b);
          var l = ref$1[0];
          var a = ref$1[1];
          var b_ = ref$1[2];
          return lab2lch(l, a, b_);
        };
        var rgb2oklch_1 = rgb2oklch$1;
        var unpack$1 = utils.unpack;
        var lch2lab = lch2lab_1;
        var oklab2rgb = oklab2rgb_1;
        var oklch2rgb = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          args = unpack$1(args, "lch");
          var l = args[0];
          var c = args[1];
          var h = args[2];
          var ref = lch2lab(l, c, h);
          var L = ref[0];
          var a = ref[1];
          var b_ = ref[2];
          var ref$1 = oklab2rgb(L, a, b_);
          var r = ref$1[0];
          var g = ref$1[1];
          var b = ref$1[2];
          return [r, g, b, args.length > 3 ? args[3] : 1];
        };
        var oklch2rgb_1 = oklch2rgb;
        var unpack = utils.unpack;
        var type$7 = utils.type;
        var chroma$5 = chroma_1;
        var Color$n = Color_1;
        var input = input$h;
        var rgb2oklch = rgb2oklch_1;
        Color$n.prototype.oklch = function() {
          return rgb2oklch(this._rgb);
        };
        chroma$5.oklch = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          return new (Function.prototype.bind.apply(Color$n, [null].concat(args, ["oklch"])))();
        };
        input.format.oklch = oklch2rgb_1;
        input.autodetect.push({
          p: 3,
          test: function() {
            var args = [], len = arguments.length;
            while (len--)
              args[len] = arguments[len];
            args = unpack(args, "oklch");
            if (type$7(args) === "array" && args.length === 3) {
              return "oklch";
            }
          }
        });
        var Color$m = Color_1;
        var type$6 = utils.type;
        Color$m.prototype.alpha = function(a, mutate) {
          if (mutate === void 0)
            mutate = false;
          if (a !== void 0 && type$6(a) === "number") {
            if (mutate) {
              this._rgb[3] = a;
              return this;
            }
            return new Color$m([this._rgb[0], this._rgb[1], this._rgb[2], a], "rgb");
          }
          return this._rgb[3];
        };
        var Color$l = Color_1;
        Color$l.prototype.clipped = function() {
          return this._rgb._clipped || false;
        };
        var Color$k = Color_1;
        var LAB_CONSTANTS$1 = labConstants;
        Color$k.prototype.darken = function(amount) {
          if (amount === void 0)
            amount = 1;
          var me = this;
          var lab2 = me.lab();
          lab2[0] -= LAB_CONSTANTS$1.Kn * amount;
          return new Color$k(lab2, "lab").alpha(me.alpha(), true);
        };
        Color$k.prototype.brighten = function(amount) {
          if (amount === void 0)
            amount = 1;
          return this.darken(-amount);
        };
        Color$k.prototype.darker = Color$k.prototype.darken;
        Color$k.prototype.brighter = Color$k.prototype.brighten;
        var Color$j = Color_1;
        Color$j.prototype.get = function(mc) {
          var ref = mc.split(".");
          var mode = ref[0];
          var channel = ref[1];
          var src = this[mode]();
          if (channel) {
            var i2 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
            if (i2 > -1) {
              return src[i2];
            }
            throw new Error("unknown channel " + channel + " in mode " + mode);
          } else {
            return src;
          }
        };
        var Color$i = Color_1;
        var type$5 = utils.type;
        var pow$6 = Math.pow;
        var EPS = 1e-7;
        var MAX_ITER = 20;
        Color$i.prototype.luminance = function(lum) {
          if (lum !== void 0 && type$5(lum) === "number") {
            if (lum === 0) {
              return new Color$i([0, 0, 0, this._rgb[3]], "rgb");
            }
            if (lum === 1) {
              return new Color$i([255, 255, 255, this._rgb[3]], "rgb");
            }
            var cur_lum = this.luminance();
            var mode = "rgb";
            var max_iter = MAX_ITER;
            var test = function(low, high) {
              var mid = low.interpolate(high, 0.5, mode);
              var lm = mid.luminance();
              if (Math.abs(lum - lm) < EPS || !max_iter--) {
                return mid;
              }
              return lm > lum ? test(low, mid) : test(mid, high);
            };
            var rgb2 = (cur_lum > lum ? test(new Color$i([0, 0, 0]), this) : test(this, new Color$i([255, 255, 255]))).rgb();
            return new Color$i(rgb2.concat([this._rgb[3]]));
          }
          return rgb2luminance.apply(void 0, this._rgb.slice(0, 3));
        };
        var rgb2luminance = function(r, g, b) {
          r = luminance_x(r);
          g = luminance_x(g);
          b = luminance_x(b);
          return 0.2126 * r + 0.7152 * g + 0.0722 * b;
        };
        var luminance_x = function(x) {
          x /= 255;
          return x <= 0.03928 ? x / 12.92 : pow$6((x + 0.055) / 1.055, 2.4);
        };
        var interpolator$1 = {};
        var Color$h = Color_1;
        var type$4 = utils.type;
        var interpolator = interpolator$1;
        var mix$1 = function(col1, col2, f) {
          if (f === void 0)
            f = 0.5;
          var rest = [], len = arguments.length - 3;
          while (len-- > 0)
            rest[len] = arguments[len + 3];
          var mode = rest[0] || "lrgb";
          if (!interpolator[mode] && !rest.length) {
            mode = Object.keys(interpolator)[0];
          }
          if (!interpolator[mode]) {
            throw new Error("interpolation mode " + mode + " is not defined");
          }
          if (type$4(col1) !== "object") {
            col1 = new Color$h(col1);
          }
          if (type$4(col2) !== "object") {
            col2 = new Color$h(col2);
          }
          return interpolator[mode](col1, col2, f).alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
        };
        var Color$g = Color_1;
        var mix = mix$1;
        Color$g.prototype.mix = Color$g.prototype.interpolate = function(col2, f) {
          if (f === void 0)
            f = 0.5;
          var rest = [], len = arguments.length - 2;
          while (len-- > 0)
            rest[len] = arguments[len + 2];
          return mix.apply(void 0, [this, col2, f].concat(rest));
        };
        var Color$f = Color_1;
        Color$f.prototype.premultiply = function(mutate) {
          if (mutate === void 0)
            mutate = false;
          var rgb2 = this._rgb;
          var a = rgb2[3];
          if (mutate) {
            this._rgb = [rgb2[0] * a, rgb2[1] * a, rgb2[2] * a, a];
            return this;
          } else {
            return new Color$f([rgb2[0] * a, rgb2[1] * a, rgb2[2] * a, a], "rgb");
          }
        };
        var Color$e = Color_1;
        var LAB_CONSTANTS = labConstants;
        Color$e.prototype.saturate = function(amount) {
          if (amount === void 0)
            amount = 1;
          var me = this;
          var lch2 = me.lch();
          lch2[1] += LAB_CONSTANTS.Kn * amount;
          if (lch2[1] < 0) {
            lch2[1] = 0;
          }
          return new Color$e(lch2, "lch").alpha(me.alpha(), true);
        };
        Color$e.prototype.desaturate = function(amount) {
          if (amount === void 0)
            amount = 1;
          return this.saturate(-amount);
        };
        var Color$d = Color_1;
        var type$3 = utils.type;
        Color$d.prototype.set = function(mc, value, mutate) {
          if (mutate === void 0)
            mutate = false;
          var ref = mc.split(".");
          var mode = ref[0];
          var channel = ref[1];
          var src = this[mode]();
          if (channel) {
            var i2 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
            if (i2 > -1) {
              if (type$3(value) == "string") {
                switch (value.charAt(0)) {
                  case "+":
                    src[i2] += +value;
                    break;
                  case "-":
                    src[i2] += +value;
                    break;
                  case "*":
                    src[i2] *= +value.substr(1);
                    break;
                  case "/":
                    src[i2] /= +value.substr(1);
                    break;
                  default:
                    src[i2] = +value;
                }
              } else if (type$3(value) === "number") {
                src[i2] = value;
              } else {
                throw new Error("unsupported value for Color.set");
              }
              var out = new Color$d(src, mode);
              if (mutate) {
                this._rgb = out._rgb;
                return this;
              }
              return out;
            }
            throw new Error("unknown channel " + channel + " in mode " + mode);
          } else {
            return src;
          }
        };
        var Color$c = Color_1;
        var rgb = function(col1, col2, f) {
          var xyz0 = col1._rgb;
          var xyz1 = col2._rgb;
          return new Color$c(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            "rgb"
          );
        };
        interpolator$1.rgb = rgb;
        var Color$b = Color_1;
        var sqrt$2 = Math.sqrt;
        var pow$5 = Math.pow;
        var lrgb = function(col1, col2, f) {
          var ref = col1._rgb;
          var x1 = ref[0];
          var y1 = ref[1];
          var z1 = ref[2];
          var ref$1 = col2._rgb;
          var x2 = ref$1[0];
          var y2 = ref$1[1];
          var z2 = ref$1[2];
          return new Color$b(
            sqrt$2(pow$5(x1, 2) * (1 - f) + pow$5(x2, 2) * f),
            sqrt$2(pow$5(y1, 2) * (1 - f) + pow$5(y2, 2) * f),
            sqrt$2(pow$5(z1, 2) * (1 - f) + pow$5(z2, 2) * f),
            "rgb"
          );
        };
        interpolator$1.lrgb = lrgb;
        var Color$a = Color_1;
        var lab = function(col1, col2, f) {
          var xyz0 = col1.lab();
          var xyz1 = col2.lab();
          return new Color$a(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            "lab"
          );
        };
        interpolator$1.lab = lab;
        var Color$9 = Color_1;
        var _hsx = function(col1, col2, f, m) {
          var assign, assign$1;
          var xyz0, xyz1;
          if (m === "hsl") {
            xyz0 = col1.hsl();
            xyz1 = col2.hsl();
          } else if (m === "hsv") {
            xyz0 = col1.hsv();
            xyz1 = col2.hsv();
          } else if (m === "hcg") {
            xyz0 = col1.hcg();
            xyz1 = col2.hcg();
          } else if (m === "hsi") {
            xyz0 = col1.hsi();
            xyz1 = col2.hsi();
          } else if (m === "lch" || m === "hcl") {
            m = "hcl";
            xyz0 = col1.hcl();
            xyz1 = col2.hcl();
          } else if (m === "oklch") {
            xyz0 = col1.oklch().reverse();
            xyz1 = col2.oklch().reverse();
          }
          var hue0, hue1, sat0, sat1, lbv0, lbv1;
          if (m.substr(0, 1) === "h" || m === "oklch") {
            assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2];
            assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2];
          }
          var sat, hue, lbv, dh;
          if (!isNaN(hue0) && !isNaN(hue1)) {
            if (hue1 > hue0 && hue1 - hue0 > 180) {
              dh = hue1 - (hue0 + 360);
            } else if (hue1 < hue0 && hue0 - hue1 > 180) {
              dh = hue1 + 360 - hue0;
            } else {
              dh = hue1 - hue0;
            }
            hue = hue0 + f * dh;
          } else if (!isNaN(hue0)) {
            hue = hue0;
            if ((lbv1 == 1 || lbv1 == 0) && m != "hsv") {
              sat = sat0;
            }
          } else if (!isNaN(hue1)) {
            hue = hue1;
            if ((lbv0 == 1 || lbv0 == 0) && m != "hsv") {
              sat = sat1;
            }
          } else {
            hue = Number.NaN;
          }
          if (sat === void 0) {
            sat = sat0 + f * (sat1 - sat0);
          }
          lbv = lbv0 + f * (lbv1 - lbv0);
          return m === "oklch" ? new Color$9([lbv, sat, hue], m) : new Color$9([hue, sat, lbv], m);
        };
        var interpolate_hsx$5 = _hsx;
        var lch = function(col1, col2, f) {
          return interpolate_hsx$5(col1, col2, f, "lch");
        };
        interpolator$1.lch = lch;
        interpolator$1.hcl = lch;
        var Color$8 = Color_1;
        var num = function(col1, col2, f) {
          var c1 = col1.num();
          var c2 = col2.num();
          return new Color$8(c1 + f * (c2 - c1), "num");
        };
        interpolator$1.num = num;
        var interpolate_hsx$4 = _hsx;
        var hcg = function(col1, col2, f) {
          return interpolate_hsx$4(col1, col2, f, "hcg");
        };
        interpolator$1.hcg = hcg;
        var interpolate_hsx$3 = _hsx;
        var hsi = function(col1, col2, f) {
          return interpolate_hsx$3(col1, col2, f, "hsi");
        };
        interpolator$1.hsi = hsi;
        var interpolate_hsx$2 = _hsx;
        var hsl = function(col1, col2, f) {
          return interpolate_hsx$2(col1, col2, f, "hsl");
        };
        interpolator$1.hsl = hsl;
        var interpolate_hsx$1 = _hsx;
        var hsv = function(col1, col2, f) {
          return interpolate_hsx$1(col1, col2, f, "hsv");
        };
        interpolator$1.hsv = hsv;
        var Color$7 = Color_1;
        var oklab = function(col1, col2, f) {
          var xyz0 = col1.oklab();
          var xyz1 = col2.oklab();
          return new Color$7(
            xyz0[0] + f * (xyz1[0] - xyz0[0]),
            xyz0[1] + f * (xyz1[1] - xyz0[1]),
            xyz0[2] + f * (xyz1[2] - xyz0[2]),
            "oklab"
          );
        };
        interpolator$1.oklab = oklab;
        var interpolate_hsx = _hsx;
        var oklch = function(col1, col2, f) {
          return interpolate_hsx(col1, col2, f, "oklch");
        };
        interpolator$1.oklch = oklch;
        var Color$6 = Color_1;
        var clip_rgb$1 = utils.clip_rgb;
        var pow$4 = Math.pow;
        var sqrt$1 = Math.sqrt;
        var PI$1 = Math.PI;
        var cos$2 = Math.cos;
        var sin$2 = Math.sin;
        var atan2$1 = Math.atan2;
        var average = function(colors, mode, weights) {
          if (mode === void 0)
            mode = "lrgb";
          if (weights === void 0)
            weights = null;
          var l = colors.length;
          if (!weights) {
            weights = Array.from(new Array(l)).map(function() {
              return 1;
            });
          }
          var k = l / weights.reduce(function(a, b) {
            return a + b;
          });
          weights.forEach(function(w, i3) {
            weights[i3] *= k;
          });
          colors = colors.map(function(c) {
            return new Color$6(c);
          });
          if (mode === "lrgb") {
            return _average_lrgb(colors, weights);
          }
          var first = colors.shift();
          var xyz = first.get(mode);
          var cnt = [];
          var dx = 0;
          var dy = 0;
          for (var i2 = 0; i2 < xyz.length; i2++) {
            xyz[i2] = (xyz[i2] || 0) * weights[0];
            cnt.push(isNaN(xyz[i2]) ? 0 : weights[0]);
            if (mode.charAt(i2) === "h" && !isNaN(xyz[i2])) {
              var A = xyz[i2] / 180 * PI$1;
              dx += cos$2(A) * weights[0];
              dy += sin$2(A) * weights[0];
            }
          }
          var alpha = first.alpha() * weights[0];
          colors.forEach(function(c, ci) {
            var xyz2 = c.get(mode);
            alpha += c.alpha() * weights[ci + 1];
            for (var i3 = 0; i3 < xyz.length; i3++) {
              if (!isNaN(xyz2[i3])) {
                cnt[i3] += weights[ci + 1];
                if (mode.charAt(i3) === "h") {
                  var A2 = xyz2[i3] / 180 * PI$1;
                  dx += cos$2(A2) * weights[ci + 1];
                  dy += sin$2(A2) * weights[ci + 1];
                } else {
                  xyz[i3] += xyz2[i3] * weights[ci + 1];
                }
              }
            }
          });
          for (var i$12 = 0; i$12 < xyz.length; i$12++) {
            if (mode.charAt(i$12) === "h") {
              var A$1 = atan2$1(dy / cnt[i$12], dx / cnt[i$12]) / PI$1 * 180;
              while (A$1 < 0) {
                A$1 += 360;
              }
              while (A$1 >= 360) {
                A$1 -= 360;
              }
              xyz[i$12] = A$1;
            } else {
              xyz[i$12] = xyz[i$12] / cnt[i$12];
            }
          }
          alpha /= l;
          return new Color$6(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);
        };
        var _average_lrgb = function(colors, weights) {
          var l = colors.length;
          var xyz = [0, 0, 0, 0];
          for (var i2 = 0; i2 < colors.length; i2++) {
            var col = colors[i2];
            var f = weights[i2] / l;
            var rgb2 = col._rgb;
            xyz[0] += pow$4(rgb2[0], 2) * f;
            xyz[1] += pow$4(rgb2[1], 2) * f;
            xyz[2] += pow$4(rgb2[2], 2) * f;
            xyz[3] += rgb2[3] * f;
          }
          xyz[0] = sqrt$1(xyz[0]);
          xyz[1] = sqrt$1(xyz[1]);
          xyz[2] = sqrt$1(xyz[2]);
          if (xyz[3] > 0.9999999) {
            xyz[3] = 1;
          }
          return new Color$6(clip_rgb$1(xyz));
        };
        var chroma$4 = chroma_1;
        var type$2 = utils.type;
        var pow$3 = Math.pow;
        var scale$2 = function(colors) {
          var _mode = "rgb";
          var _nacol = chroma$4("#ccc");
          var _spread = 0;
          var _domain = [0, 1];
          var _pos = [];
          var _padding = [0, 0];
          var _classes = false;
          var _colors = [];
          var _out = false;
          var _min = 0;
          var _max = 1;
          var _correctLightness = false;
          var _colorCache = {};
          var _useCache = true;
          var _gamma = 1;
          var setColors = function(colors2) {
            colors2 = colors2 || ["#fff", "#000"];
            if (colors2 && type$2(colors2) === "string" && chroma$4.brewer && chroma$4.brewer[colors2.toLowerCase()]) {
              colors2 = chroma$4.brewer[colors2.toLowerCase()];
            }
            if (type$2(colors2) === "array") {
              if (colors2.length === 1) {
                colors2 = [colors2[0], colors2[0]];
              }
              colors2 = colors2.slice(0);
              for (var c = 0; c < colors2.length; c++) {
                colors2[c] = chroma$4(colors2[c]);
              }
              _pos.length = 0;
              for (var c$1 = 0; c$1 < colors2.length; c$1++) {
                _pos.push(c$1 / (colors2.length - 1));
              }
            }
            resetCache();
            return _colors = colors2;
          };
          var getClass = function(value) {
            if (_classes != null) {
              var n = _classes.length - 1;
              var i2 = 0;
              while (i2 < n && value >= _classes[i2]) {
                i2++;
              }
              return i2 - 1;
            }
            return 0;
          };
          var tMapLightness = function(t) {
            return t;
          };
          var tMapDomain = function(t) {
            return t;
          };
          var getColor = function(val, bypassMap) {
            var col, t;
            if (bypassMap == null) {
              bypassMap = false;
            }
            if (isNaN(val) || val === null) {
              return _nacol;
            }
            if (!bypassMap) {
              if (_classes && _classes.length > 2) {
                var c = getClass(val);
                t = c / (_classes.length - 2);
              } else if (_max !== _min) {
                t = (val - _min) / (_max - _min);
              } else {
                t = 1;
              }
            } else {
              t = val;
            }
            t = tMapDomain(t);
            if (!bypassMap) {
              t = tMapLightness(t);
            }
            if (_gamma !== 1) {
              t = pow$3(t, _gamma);
            }
            t = _padding[0] + t * (1 - _padding[0] - _padding[1]);
            t = Math.min(1, Math.max(0, t));
            var k = Math.floor(t * 1e4);
            if (_useCache && _colorCache[k]) {
              col = _colorCache[k];
            } else {
              if (type$2(_colors) === "array") {
                for (var i2 = 0; i2 < _pos.length; i2++) {
                  var p = _pos[i2];
                  if (t <= p) {
                    col = _colors[i2];
                    break;
                  }
                  if (t >= p && i2 === _pos.length - 1) {
                    col = _colors[i2];
                    break;
                  }
                  if (t > p && t < _pos[i2 + 1]) {
                    t = (t - p) / (_pos[i2 + 1] - p);
                    col = chroma$4.interpolate(_colors[i2], _colors[i2 + 1], t, _mode);
                    break;
                  }
                }
              } else if (type$2(_colors) === "function") {
                col = _colors(t);
              }
              if (_useCache) {
                _colorCache[k] = col;
              }
            }
            return col;
          };
          var resetCache = function() {
            return _colorCache = {};
          };
          setColors(colors);
          var f = function(v) {
            var c = chroma$4(getColor(v));
            if (_out && c[_out]) {
              return c[_out]();
            } else {
              return c;
            }
          };
          f.classes = function(classes) {
            if (classes != null) {
              if (type$2(classes) === "array") {
                _classes = classes;
                _domain = [classes[0], classes[classes.length - 1]];
              } else {
                var d = chroma$4.analyze(_domain);
                if (classes === 0) {
                  _classes = [d.min, d.max];
                } else {
                  _classes = chroma$4.limits(d, "e", classes);
                }
              }
              return f;
            }
            return _classes;
          };
          f.domain = function(domain) {
            if (!arguments.length) {
              return _domain;
            }
            _min = domain[0];
            _max = domain[domain.length - 1];
            _pos = [];
            var k = _colors.length;
            if (domain.length === k && _min !== _max) {
              for (var i2 = 0, list2 = Array.from(domain); i2 < list2.length; i2 += 1) {
                var d = list2[i2];
                _pos.push((d - _min) / (_max - _min));
              }
            } else {
              for (var c = 0; c < k; c++) {
                _pos.push(c / (k - 1));
              }
              if (domain.length > 2) {
                var tOut = domain.map(function(d2, i3) {
                  return i3 / (domain.length - 1);
                });
                var tBreaks = domain.map(function(d2) {
                  return (d2 - _min) / (_max - _min);
                });
                if (!tBreaks.every(function(val, i3) {
                  return tOut[i3] === val;
                })) {
                  tMapDomain = function(t) {
                    if (t <= 0 || t >= 1) {
                      return t;
                    }
                    var i3 = 0;
                    while (t >= tBreaks[i3 + 1]) {
                      i3++;
                    }
                    var f2 = (t - tBreaks[i3]) / (tBreaks[i3 + 1] - tBreaks[i3]);
                    var out = tOut[i3] + f2 * (tOut[i3 + 1] - tOut[i3]);
                    return out;
                  };
                }
              }
            }
            _domain = [_min, _max];
            return f;
          };
          f.mode = function(_m) {
            if (!arguments.length) {
              return _mode;
            }
            _mode = _m;
            resetCache();
            return f;
          };
          f.range = function(colors2, _pos2) {
            setColors(colors2);
            return f;
          };
          f.out = function(_o) {
            _out = _o;
            return f;
          };
          f.spread = function(val) {
            if (!arguments.length) {
              return _spread;
            }
            _spread = val;
            return f;
          };
          f.correctLightness = function(v) {
            if (v == null) {
              v = true;
            }
            _correctLightness = v;
            resetCache();
            if (_correctLightness) {
              tMapLightness = function(t) {
                var L0 = getColor(0, true).lab()[0];
                var L1 = getColor(1, true).lab()[0];
                var pol = L0 > L1;
                var L_actual = getColor(t, true).lab()[0];
                var L_ideal = L0 + (L1 - L0) * t;
                var L_diff = L_actual - L_ideal;
                var t0 = 0;
                var t1 = 1;
                var max_iter = 20;
                while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
                  (function() {
                    if (pol) {
                      L_diff *= -1;
                    }
                    if (L_diff < 0) {
                      t0 = t;
                      t += (t1 - t) * 0.5;
                    } else {
                      t1 = t;
                      t += (t0 - t) * 0.5;
                    }
                    L_actual = getColor(t, true).lab()[0];
                    return L_diff = L_actual - L_ideal;
                  })();
                }
                return t;
              };
            } else {
              tMapLightness = function(t) {
                return t;
              };
            }
            return f;
          };
          f.padding = function(p) {
            if (p != null) {
              if (type$2(p) === "number") {
                p = [p, p];
              }
              _padding = p;
              return f;
            } else {
              return _padding;
            }
          };
          f.colors = function(numColors, out) {
            if (arguments.length < 2) {
              out = "hex";
            }
            var result = [];
            if (arguments.length === 0) {
              result = _colors.slice(0);
            } else if (numColors === 1) {
              result = [f(0.5)];
            } else if (numColors > 1) {
              var dm = _domain[0];
              var dd = _domain[1] - dm;
              result = __range__(0, numColors, false).map(function(i3) {
                return f(dm + i3 / (numColors - 1) * dd);
              });
            } else {
              colors = [];
              var samples = [];
              if (_classes && _classes.length > 2) {
                for (var i2 = 1, end = _classes.length, asc = 1 <= end; asc ? i2 < end : i2 > end; asc ? i2++ : i2--) {
                  samples.push((_classes[i2 - 1] + _classes[i2]) * 0.5);
                }
              } else {
                samples = _domain;
              }
              result = samples.map(function(v) {
                return f(v);
              });
            }
            if (chroma$4[out]) {
              result = result.map(function(c) {
                return c[out]();
              });
            }
            return result;
          };
          f.cache = function(c) {
            if (c != null) {
              _useCache = c;
              return f;
            } else {
              return _useCache;
            }
          };
          f.gamma = function(g) {
            if (g != null) {
              _gamma = g;
              return f;
            } else {
              return _gamma;
            }
          };
          f.nodata = function(d) {
            if (d != null) {
              _nacol = chroma$4(d);
              return f;
            } else {
              return _nacol;
            }
          };
          return f;
        };
        function __range__(left, right, inclusive) {
          var range = [];
          var ascending = left < right;
          var end = !inclusive ? right : ascending ? right + 1 : right - 1;
          for (var i2 = left; ascending ? i2 < end : i2 > end; ascending ? i2++ : i2--) {
            range.push(i2);
          }
          return range;
        }
        var Color$5 = Color_1;
        var scale$1 = scale$2;
        var binom_row = function(n) {
          var row = [1, 1];
          for (var i2 = 1; i2 < n; i2++) {
            var newrow = [1];
            for (var j = 1; j <= row.length; j++) {
              newrow[j] = (row[j] || 0) + row[j - 1];
            }
            row = newrow;
          }
          return row;
        };
        var bezier = function(colors) {
          var assign, assign$1, assign$2;
          var I, lab0, lab1, lab2;
          colors = colors.map(function(c) {
            return new Color$5(c);
          });
          if (colors.length === 2) {
            assign = colors.map(function(c) {
              return c.lab();
            }), lab0 = assign[0], lab1 = assign[1];
            I = function(t) {
              var lab4 = [0, 1, 2].map(function(i2) {
                return lab0[i2] + t * (lab1[i2] - lab0[i2]);
              });
              return new Color$5(lab4, "lab");
            };
          } else if (colors.length === 3) {
            assign$1 = colors.map(function(c) {
              return c.lab();
            }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2];
            I = function(t) {
              var lab4 = [0, 1, 2].map(function(i2) {
                return (1 - t) * (1 - t) * lab0[i2] + 2 * (1 - t) * t * lab1[i2] + t * t * lab2[i2];
              });
              return new Color$5(lab4, "lab");
            };
          } else if (colors.length === 4) {
            var lab3;
            assign$2 = colors.map(function(c) {
              return c.lab();
            }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3];
            I = function(t) {
              var lab4 = [0, 1, 2].map(function(i2) {
                return (1 - t) * (1 - t) * (1 - t) * lab0[i2] + 3 * (1 - t) * (1 - t) * t * lab1[i2] + 3 * (1 - t) * t * t * lab2[i2] + t * t * t * lab3[i2];
              });
              return new Color$5(lab4, "lab");
            };
          } else if (colors.length >= 5) {
            var labs, row, n;
            labs = colors.map(function(c) {
              return c.lab();
            });
            n = colors.length - 1;
            row = binom_row(n);
            I = function(t) {
              var u = 1 - t;
              var lab4 = [0, 1, 2].map(function(i2) {
                return labs.reduce(function(sum2, el, j) {
                  return sum2 + row[j] * Math.pow(u, n - j) * Math.pow(t, j) * el[i2];
                }, 0);
              });
              return new Color$5(lab4, "lab");
            };
          } else {
            throw new RangeError("No point in running bezier with only one color.");
          }
          return I;
        };
        var bezier_1 = function(colors) {
          var f = bezier(colors);
          f.scale = function() {
            return scale$1(f);
          };
          return f;
        };
        var chroma$3 = chroma_1;
        var blend = function(bottom, top, mode) {
          if (!blend[mode]) {
            throw new Error("unknown blend mode " + mode);
          }
          return blend[mode](bottom, top);
        };
        var blend_f = function(f) {
          return function(bottom, top) {
            var c0 = chroma$3(top).rgb();
            var c1 = chroma$3(bottom).rgb();
            return chroma$3.rgb(f(c0, c1));
          };
        };
        var each = function(f) {
          return function(c0, c1) {
            var out = [];
            out[0] = f(c0[0], c1[0]);
            out[1] = f(c0[1], c1[1]);
            out[2] = f(c0[2], c1[2]);
            return out;
          };
        };
        var normal = function(a) {
          return a;
        };
        var multiply = function(a, b) {
          return a * b / 255;
        };
        var darken = function(a, b) {
          return a > b ? b : a;
        };
        var lighten = function(a, b) {
          return a > b ? a : b;
        };
        var screen2 = function(a, b) {
          return 255 * (1 - (1 - a / 255) * (1 - b / 255));
        };
        var overlay = function(a, b) {
          return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
        };
        var burn = function(a, b) {
          return 255 * (1 - (1 - b / 255) / (a / 255));
        };
        var dodge = function(a, b) {
          if (a === 255) {
            return 255;
          }
          a = 255 * (b / 255) / (1 - a / 255);
          return a > 255 ? 255 : a;
        };
        blend.normal = blend_f(each(normal));
        blend.multiply = blend_f(each(multiply));
        blend.screen = blend_f(each(screen2));
        blend.overlay = blend_f(each(overlay));
        blend.darken = blend_f(each(darken));
        blend.lighten = blend_f(each(lighten));
        blend.dodge = blend_f(each(dodge));
        blend.burn = blend_f(each(burn));
        var blend_1 = blend;
        var type$1 = utils.type;
        var clip_rgb = utils.clip_rgb;
        var TWOPI = utils.TWOPI;
        var pow$2 = Math.pow;
        var sin$1 = Math.sin;
        var cos$1 = Math.cos;
        var chroma$2 = chroma_1;
        var cubehelix = function(start2, rotations, hue, gamma, lightness) {
          if (start2 === void 0)
            start2 = 300;
          if (rotations === void 0)
            rotations = -1.5;
          if (hue === void 0)
            hue = 1;
          if (gamma === void 0)
            gamma = 1;
          if (lightness === void 0)
            lightness = [0, 1];
          var dh = 0, dl;
          if (type$1(lightness) === "array") {
            dl = lightness[1] - lightness[0];
          } else {
            dl = 0;
            lightness = [lightness, lightness];
          }
          var f = function(fract) {
            var a = TWOPI * ((start2 + 120) / 360 + rotations * fract);
            var l = pow$2(lightness[0] + dl * fract, gamma);
            var h = dh !== 0 ? hue[0] + fract * dh : hue;
            var amp = h * l * (1 - l) / 2;
            var cos_a = cos$1(a);
            var sin_a = sin$1(a);
            var r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
            var g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
            var b = l + amp * (1.97294 * cos_a);
            return chroma$2(clip_rgb([r * 255, g * 255, b * 255, 1]));
          };
          f.start = function(s) {
            if (s == null) {
              return start2;
            }
            start2 = s;
            return f;
          };
          f.rotations = function(r) {
            if (r == null) {
              return rotations;
            }
            rotations = r;
            return f;
          };
          f.gamma = function(g) {
            if (g == null) {
              return gamma;
            }
            gamma = g;
            return f;
          };
          f.hue = function(h) {
            if (h == null) {
              return hue;
            }
            hue = h;
            if (type$1(hue) === "array") {
              dh = hue[1] - hue[0];
              if (dh === 0) {
                hue = hue[1];
              }
            } else {
              dh = 0;
            }
            return f;
          };
          f.lightness = function(h) {
            if (h == null) {
              return lightness;
            }
            if (type$1(h) === "array") {
              lightness = h;
              dl = h[1] - h[0];
            } else {
              lightness = [h, h];
              dl = 0;
            }
            return f;
          };
          f.scale = function() {
            return chroma$2.scale(f);
          };
          f.hue(hue);
          return f;
        };
        var Color$4 = Color_1;
        var digits = "0123456789abcdef";
        var floor$1 = Math.floor;
        var random = Math.random;
        var random_1 = function() {
          var code = "#";
          for (var i2 = 0; i2 < 6; i2++) {
            code += digits.charAt(floor$1(random() * 16));
          }
          return new Color$4(code, "hex");
        };
        var type3 = type$p;
        var log2 = Math.log;
        var pow$1 = Math.pow;
        var floor = Math.floor;
        var abs$1 = Math.abs;
        var analyze = function(data, key2) {
          if (key2 === void 0)
            key2 = null;
          var r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE * -1,
            sum: 0,
            values: [],
            count: 0
          };
          if (type3(data) === "object") {
            data = Object.values(data);
          }
          data.forEach(function(val) {
            if (key2 && type3(val) === "object") {
              val = val[key2];
            }
            if (val !== void 0 && val !== null && !isNaN(val)) {
              r.values.push(val);
              r.sum += val;
              if (val < r.min) {
                r.min = val;
              }
              if (val > r.max) {
                r.max = val;
              }
              r.count += 1;
            }
          });
          r.domain = [r.min, r.max];
          r.limits = function(mode, num2) {
            return limits(r, mode, num2);
          };
          return r;
        };
        var limits = function(data, mode, num2) {
          if (mode === void 0)
            mode = "equal";
          if (num2 === void 0)
            num2 = 7;
          if (type3(data) == "array") {
            data = analyze(data);
          }
          var min2 = data.min;
          var max2 = data.max;
          var values3 = data.values.sort(function(a, b) {
            return a - b;
          });
          if (num2 === 1) {
            return [min2, max2];
          }
          var limits2 = [];
          if (mode.substr(0, 1) === "c") {
            limits2.push(min2);
            limits2.push(max2);
          }
          if (mode.substr(0, 1) === "e") {
            limits2.push(min2);
            for (var i2 = 1; i2 < num2; i2++) {
              limits2.push(min2 + i2 / num2 * (max2 - min2));
            }
            limits2.push(max2);
          } else if (mode.substr(0, 1) === "l") {
            if (min2 <= 0) {
              throw new Error("Logarithmic scales are only possible for values > 0");
            }
            var min_log = Math.LOG10E * log2(min2);
            var max_log = Math.LOG10E * log2(max2);
            limits2.push(min2);
            for (var i$12 = 1; i$12 < num2; i$12++) {
              limits2.push(pow$1(10, min_log + i$12 / num2 * (max_log - min_log)));
            }
            limits2.push(max2);
          } else if (mode.substr(0, 1) === "q") {
            limits2.push(min2);
            for (var i$2 = 1; i$2 < num2; i$2++) {
              var p = (values3.length - 1) * i$2 / num2;
              var pb = floor(p);
              if (pb === p) {
                limits2.push(values3[pb]);
              } else {
                var pr = p - pb;
                limits2.push(values3[pb] * (1 - pr) + values3[pb + 1] * pr);
              }
            }
            limits2.push(max2);
          } else if (mode.substr(0, 1) === "k") {
            var cluster;
            var n = values3.length;
            var assignments = new Array(n);
            var clusterSizes = new Array(num2);
            var repeat = true;
            var nb_iters = 0;
            var centroids = null;
            centroids = [];
            centroids.push(min2);
            for (var i$3 = 1; i$3 < num2; i$3++) {
              centroids.push(min2 + i$3 / num2 * (max2 - min2));
            }
            centroids.push(max2);
            while (repeat) {
              for (var j = 0; j < num2; j++) {
                clusterSizes[j] = 0;
              }
              for (var i$4 = 0; i$4 < n; i$4++) {
                var value = values3[i$4];
                var mindist = Number.MAX_VALUE;
                var best = void 0;
                for (var j$1 = 0; j$1 < num2; j$1++) {
                  var dist = abs$1(centroids[j$1] - value);
                  if (dist < mindist) {
                    mindist = dist;
                    best = j$1;
                  }
                  clusterSizes[best]++;
                  assignments[i$4] = best;
                }
              }
              var newCentroids = new Array(num2);
              for (var j$2 = 0; j$2 < num2; j$2++) {
                newCentroids[j$2] = null;
              }
              for (var i$5 = 0; i$5 < n; i$5++) {
                cluster = assignments[i$5];
                if (newCentroids[cluster] === null) {
                  newCentroids[cluster] = values3[i$5];
                } else {
                  newCentroids[cluster] += values3[i$5];
                }
              }
              for (var j$3 = 0; j$3 < num2; j$3++) {
                newCentroids[j$3] *= 1 / clusterSizes[j$3];
              }
              repeat = false;
              for (var j$4 = 0; j$4 < num2; j$4++) {
                if (newCentroids[j$4] !== centroids[j$4]) {
                  repeat = true;
                  break;
                }
              }
              centroids = newCentroids;
              nb_iters++;
              if (nb_iters > 200) {
                repeat = false;
              }
            }
            var kClusters = {};
            for (var j$5 = 0; j$5 < num2; j$5++) {
              kClusters[j$5] = [];
            }
            for (var i$6 = 0; i$6 < n; i$6++) {
              cluster = assignments[i$6];
              kClusters[cluster].push(values3[i$6]);
            }
            var tmpKMeansBreaks = [];
            for (var j$6 = 0; j$6 < num2; j$6++) {
              tmpKMeansBreaks.push(kClusters[j$6][0]);
              tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length - 1]);
            }
            tmpKMeansBreaks = tmpKMeansBreaks.sort(function(a, b) {
              return a - b;
            });
            limits2.push(tmpKMeansBreaks[0]);
            for (var i$7 = 1; i$7 < tmpKMeansBreaks.length; i$7 += 2) {
              var v = tmpKMeansBreaks[i$7];
              if (!isNaN(v) && limits2.indexOf(v) === -1) {
                limits2.push(v);
              }
            }
          }
          return limits2;
        };
        var analyze_1 = { analyze, limits };
        var Color$3 = Color_1;
        var contrast = function(a, b) {
          a = new Color$3(a);
          b = new Color$3(b);
          var l1 = a.luminance();
          var l2 = b.luminance();
          return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
        };
        var Color$2 = Color_1;
        var sqrt = Math.sqrt;
        var pow = Math.pow;
        var min = Math.min;
        var max = Math.max;
        var atan2 = Math.atan2;
        var abs = Math.abs;
        var cos = Math.cos;
        var sin = Math.sin;
        var exp = Math.exp;
        var PI = Math.PI;
        var deltaE = function(a, b, Kl, Kc, Kh) {
          if (Kl === void 0)
            Kl = 1;
          if (Kc === void 0)
            Kc = 1;
          if (Kh === void 0)
            Kh = 1;
          var rad2deg = function(rad) {
            return 360 * rad / (2 * PI);
          };
          var deg2rad = function(deg) {
            return 2 * PI * deg / 360;
          };
          a = new Color$2(a);
          b = new Color$2(b);
          var ref = Array.from(a.lab());
          var L1 = ref[0];
          var a1 = ref[1];
          var b1 = ref[2];
          var ref$1 = Array.from(b.lab());
          var L2 = ref$1[0];
          var a2 = ref$1[1];
          var b2 = ref$1[2];
          var avgL = (L1 + L2) / 2;
          var C1 = sqrt(pow(a1, 2) + pow(b1, 2));
          var C2 = sqrt(pow(a2, 2) + pow(b2, 2));
          var avgC = (C1 + C2) / 2;
          var G = 0.5 * (1 - sqrt(pow(avgC, 7) / (pow(avgC, 7) + pow(25, 7))));
          var a1p = a1 * (1 + G);
          var a2p = a2 * (1 + G);
          var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));
          var C2p = sqrt(pow(a2p, 2) + pow(b2, 2));
          var avgCp = (C1p + C2p) / 2;
          var arctan1 = rad2deg(atan2(b1, a1p));
          var arctan2 = rad2deg(atan2(b2, a2p));
          var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
          var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
          var avgHp = abs(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;
          var T = 1 - 0.17 * cos(deg2rad(avgHp - 30)) + 0.24 * cos(deg2rad(2 * avgHp)) + 0.32 * cos(deg2rad(3 * avgHp + 6)) - 0.2 * cos(deg2rad(4 * avgHp - 63));
          var deltaHp = h2p - h1p;
          deltaHp = abs(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
          deltaHp = 2 * sqrt(C1p * C2p) * sin(deg2rad(deltaHp) / 2);
          var deltaL = L2 - L1;
          var deltaCp = C2p - C1p;
          var sl = 1 + 0.015 * pow(avgL - 50, 2) / sqrt(20 + pow(avgL - 50, 2));
          var sc = 1 + 0.045 * avgCp;
          var sh = 1 + 0.015 * avgCp * T;
          var deltaTheta = 30 * exp(-pow((avgHp - 275) / 25, 2));
          var Rc = 2 * sqrt(pow(avgCp, 7) / (pow(avgCp, 7) + pow(25, 7)));
          var Rt = -Rc * sin(2 * deg2rad(deltaTheta));
          var result = sqrt(pow(deltaL / (Kl * sl), 2) + pow(deltaCp / (Kc * sc), 2) + pow(deltaHp / (Kh * sh), 2) + Rt * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh)));
          return max(0, min(100, result));
        };
        var Color$1 = Color_1;
        var distance = function(a, b, mode) {
          if (mode === void 0)
            mode = "lab";
          a = new Color$1(a);
          b = new Color$1(b);
          var l1 = a.get(mode);
          var l2 = b.get(mode);
          var sum_sq = 0;
          for (var i2 in l1) {
            var d = (l1[i2] || 0) - (l2[i2] || 0);
            sum_sq += d * d;
          }
          return Math.sqrt(sum_sq);
        };
        var Color2 = Color_1;
        var valid = function() {
          var args = [], len = arguments.length;
          while (len--)
            args[len] = arguments[len];
          try {
            new (Function.prototype.bind.apply(Color2, [null].concat(args)))();
            return true;
          } catch (e) {
            return false;
          }
        };
        var chroma$1 = chroma_1;
        var scale = scale$2;
        var scales = {
          cool: function cool() {
            return scale([chroma$1.hsl(180, 1, 0.9), chroma$1.hsl(250, 0.7, 0.4)]);
          },
          hot: function hot() {
            return scale(["#000", "#f00", "#ff0", "#fff"]).mode("rgb");
          }
        };
        var colorbrewer = {
          OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
          PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
          BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
          Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
          BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
          YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
          YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
          Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
          RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
          Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
          YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
          Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
          GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
          Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
          YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
          PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
          Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
          PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
          Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
          Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
          RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
          RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
          PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
          PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
          RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
          BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
          RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
          PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
          Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
          Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
          Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
          Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
          Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
          Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
          Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
          Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
        };
        for (var i = 0, list = Object.keys(colorbrewer); i < list.length; i += 1) {
          var key = list[i];
          colorbrewer[key.toLowerCase()] = colorbrewer[key];
        }
        var colorbrewer_1 = colorbrewer;
        var chroma2 = chroma_1;
        chroma2.average = average;
        chroma2.bezier = bezier_1;
        chroma2.blend = blend_1;
        chroma2.cubehelix = cubehelix;
        chroma2.mix = chroma2.interpolate = mix$1;
        chroma2.random = random_1;
        chroma2.scale = scale$2;
        chroma2.analyze = analyze_1.analyze;
        chroma2.contrast = contrast;
        chroma2.deltaE = deltaE;
        chroma2.distance = distance;
        chroma2.limits = analyze_1.limits;
        chroma2.valid = valid;
        chroma2.scales = scales;
        chroma2.colors = w3cx11_1;
        chroma2.brewer = colorbrewer_1;
        var chroma_js = chroma2;
        return chroma_js;
      });
    }
  });

  // node_modules/three/build/three.module.js
  var three_module_exports = {};
  __export(three_module_exports, {
    ACESFilmicToneMapping: () => ACESFilmicToneMapping,
    AddEquation: () => AddEquation,
    AddOperation: () => AddOperation,
    AdditiveAnimationBlendMode: () => AdditiveAnimationBlendMode,
    AdditiveBlending: () => AdditiveBlending,
    AlphaFormat: () => AlphaFormat,
    AlwaysDepth: () => AlwaysDepth,
    AlwaysStencilFunc: () => AlwaysStencilFunc,
    AmbientLight: () => AmbientLight,
    AmbientLightProbe: () => AmbientLightProbe,
    AnimationClip: () => AnimationClip,
    AnimationLoader: () => AnimationLoader,
    AnimationMixer: () => AnimationMixer,
    AnimationObjectGroup: () => AnimationObjectGroup,
    AnimationUtils: () => AnimationUtils,
    ArcCurve: () => ArcCurve,
    ArrayCamera: () => ArrayCamera,
    ArrowHelper: () => ArrowHelper,
    Audio: () => Audio,
    AudioAnalyser: () => AudioAnalyser,
    AudioContext: () => AudioContext,
    AudioListener: () => AudioListener,
    AudioLoader: () => AudioLoader,
    AxesHelper: () => AxesHelper,
    BackSide: () => BackSide,
    BasicDepthPacking: () => BasicDepthPacking,
    BasicShadowMap: () => BasicShadowMap,
    Bone: () => Bone,
    BooleanKeyframeTrack: () => BooleanKeyframeTrack,
    Box2: () => Box2,
    Box3: () => Box3,
    Box3Helper: () => Box3Helper,
    BoxBufferGeometry: () => BoxBufferGeometry,
    BoxGeometry: () => BoxGeometry,
    BoxHelper: () => BoxHelper,
    BufferAttribute: () => BufferAttribute,
    BufferGeometry: () => BufferGeometry,
    BufferGeometryLoader: () => BufferGeometryLoader,
    ByteType: () => ByteType,
    Cache: () => Cache,
    Camera: () => Camera,
    CameraHelper: () => CameraHelper,
    CanvasTexture: () => CanvasTexture,
    CapsuleBufferGeometry: () => CapsuleBufferGeometry,
    CapsuleGeometry: () => CapsuleGeometry,
    CatmullRomCurve3: () => CatmullRomCurve3,
    CineonToneMapping: () => CineonToneMapping,
    CircleBufferGeometry: () => CircleBufferGeometry,
    CircleGeometry: () => CircleGeometry,
    ClampToEdgeWrapping: () => ClampToEdgeWrapping,
    Clock: () => Clock,
    Color: () => Color,
    ColorKeyframeTrack: () => ColorKeyframeTrack,
    ColorManagement: () => ColorManagement,
    CompressedArrayTexture: () => CompressedArrayTexture,
    CompressedTexture: () => CompressedTexture,
    CompressedTextureLoader: () => CompressedTextureLoader,
    ConeBufferGeometry: () => ConeBufferGeometry,
    ConeGeometry: () => ConeGeometry,
    CubeCamera: () => CubeCamera,
    CubeReflectionMapping: () => CubeReflectionMapping,
    CubeRefractionMapping: () => CubeRefractionMapping,
    CubeTexture: () => CubeTexture,
    CubeTextureLoader: () => CubeTextureLoader,
    CubeUVReflectionMapping: () => CubeUVReflectionMapping,
    CubicBezierCurve: () => CubicBezierCurve,
    CubicBezierCurve3: () => CubicBezierCurve3,
    CubicInterpolant: () => CubicInterpolant,
    CullFaceBack: () => CullFaceBack,
    CullFaceFront: () => CullFaceFront,
    CullFaceFrontBack: () => CullFaceFrontBack,
    CullFaceNone: () => CullFaceNone,
    Curve: () => Curve,
    CurvePath: () => CurvePath,
    CustomBlending: () => CustomBlending,
    CustomToneMapping: () => CustomToneMapping,
    CylinderBufferGeometry: () => CylinderBufferGeometry,
    CylinderGeometry: () => CylinderGeometry,
    Cylindrical: () => Cylindrical,
    Data3DTexture: () => Data3DTexture,
    DataArrayTexture: () => DataArrayTexture,
    DataTexture: () => DataTexture,
    DataTextureLoader: () => DataTextureLoader,
    DataUtils: () => DataUtils,
    DecrementStencilOp: () => DecrementStencilOp,
    DecrementWrapStencilOp: () => DecrementWrapStencilOp,
    DefaultLoadingManager: () => DefaultLoadingManager,
    DepthFormat: () => DepthFormat,
    DepthStencilFormat: () => DepthStencilFormat,
    DepthTexture: () => DepthTexture,
    DirectionalLight: () => DirectionalLight,
    DirectionalLightHelper: () => DirectionalLightHelper,
    DiscreteInterpolant: () => DiscreteInterpolant,
    DodecahedronBufferGeometry: () => DodecahedronBufferGeometry,
    DodecahedronGeometry: () => DodecahedronGeometry,
    DoubleSide: () => DoubleSide,
    DstAlphaFactor: () => DstAlphaFactor,
    DstColorFactor: () => DstColorFactor,
    DynamicCopyUsage: () => DynamicCopyUsage,
    DynamicDrawUsage: () => DynamicDrawUsage,
    DynamicReadUsage: () => DynamicReadUsage,
    EdgesGeometry: () => EdgesGeometry,
    EllipseCurve: () => EllipseCurve,
    EqualDepth: () => EqualDepth,
    EqualStencilFunc: () => EqualStencilFunc,
    EquirectangularReflectionMapping: () => EquirectangularReflectionMapping,
    EquirectangularRefractionMapping: () => EquirectangularRefractionMapping,
    Euler: () => Euler,
    EventDispatcher: () => EventDispatcher,
    ExtrudeBufferGeometry: () => ExtrudeBufferGeometry,
    ExtrudeGeometry: () => ExtrudeGeometry,
    FileLoader: () => FileLoader,
    Float16BufferAttribute: () => Float16BufferAttribute,
    Float32BufferAttribute: () => Float32BufferAttribute,
    Float64BufferAttribute: () => Float64BufferAttribute,
    FloatType: () => FloatType,
    Fog: () => Fog,
    FogExp2: () => FogExp2,
    FramebufferTexture: () => FramebufferTexture,
    FrontSide: () => FrontSide,
    Frustum: () => Frustum,
    GLBufferAttribute: () => GLBufferAttribute,
    GLSL1: () => GLSL1,
    GLSL3: () => GLSL3,
    GreaterDepth: () => GreaterDepth,
    GreaterEqualDepth: () => GreaterEqualDepth,
    GreaterEqualStencilFunc: () => GreaterEqualStencilFunc,
    GreaterStencilFunc: () => GreaterStencilFunc,
    GridHelper: () => GridHelper,
    Group: () => Group,
    HalfFloatType: () => HalfFloatType,
    HemisphereLight: () => HemisphereLight,
    HemisphereLightHelper: () => HemisphereLightHelper,
    HemisphereLightProbe: () => HemisphereLightProbe,
    IcosahedronBufferGeometry: () => IcosahedronBufferGeometry,
    IcosahedronGeometry: () => IcosahedronGeometry,
    ImageBitmapLoader: () => ImageBitmapLoader,
    ImageLoader: () => ImageLoader,
    ImageUtils: () => ImageUtils,
    IncrementStencilOp: () => IncrementStencilOp,
    IncrementWrapStencilOp: () => IncrementWrapStencilOp,
    InstancedBufferAttribute: () => InstancedBufferAttribute,
    InstancedBufferGeometry: () => InstancedBufferGeometry,
    InstancedInterleavedBuffer: () => InstancedInterleavedBuffer,
    InstancedMesh: () => InstancedMesh,
    Int16BufferAttribute: () => Int16BufferAttribute,
    Int32BufferAttribute: () => Int32BufferAttribute,
    Int8BufferAttribute: () => Int8BufferAttribute,
    IntType: () => IntType,
    InterleavedBuffer: () => InterleavedBuffer,
    InterleavedBufferAttribute: () => InterleavedBufferAttribute,
    Interpolant: () => Interpolant,
    InterpolateDiscrete: () => InterpolateDiscrete,
    InterpolateLinear: () => InterpolateLinear,
    InterpolateSmooth: () => InterpolateSmooth,
    InvertStencilOp: () => InvertStencilOp,
    KeepStencilOp: () => KeepStencilOp,
    KeyframeTrack: () => KeyframeTrack,
    LOD: () => LOD,
    LatheBufferGeometry: () => LatheBufferGeometry,
    LatheGeometry: () => LatheGeometry,
    Layers: () => Layers,
    LessDepth: () => LessDepth,
    LessEqualDepth: () => LessEqualDepth,
    LessEqualStencilFunc: () => LessEqualStencilFunc,
    LessStencilFunc: () => LessStencilFunc,
    Light: () => Light,
    LightProbe: () => LightProbe,
    Line: () => Line,
    Line3: () => Line3,
    LineBasicMaterial: () => LineBasicMaterial,
    LineCurve: () => LineCurve,
    LineCurve3: () => LineCurve3,
    LineDashedMaterial: () => LineDashedMaterial,
    LineLoop: () => LineLoop,
    LineSegments: () => LineSegments,
    LinearEncoding: () => LinearEncoding,
    LinearFilter: () => LinearFilter,
    LinearInterpolant: () => LinearInterpolant,
    LinearMipMapLinearFilter: () => LinearMipMapLinearFilter,
    LinearMipMapNearestFilter: () => LinearMipMapNearestFilter,
    LinearMipmapLinearFilter: () => LinearMipmapLinearFilter,
    LinearMipmapNearestFilter: () => LinearMipmapNearestFilter,
    LinearSRGBColorSpace: () => LinearSRGBColorSpace,
    LinearToneMapping: () => LinearToneMapping,
    Loader: () => Loader,
    LoaderUtils: () => LoaderUtils,
    LoadingManager: () => LoadingManager,
    LoopOnce: () => LoopOnce,
    LoopPingPong: () => LoopPingPong,
    LoopRepeat: () => LoopRepeat,
    LuminanceAlphaFormat: () => LuminanceAlphaFormat,
    LuminanceFormat: () => LuminanceFormat,
    MOUSE: () => MOUSE,
    Material: () => Material,
    MaterialLoader: () => MaterialLoader,
    MathUtils: () => MathUtils,
    Matrix3: () => Matrix3,
    Matrix4: () => Matrix4,
    MaxEquation: () => MaxEquation,
    Mesh: () => Mesh,
    MeshBasicMaterial: () => MeshBasicMaterial,
    MeshDepthMaterial: () => MeshDepthMaterial,
    MeshDistanceMaterial: () => MeshDistanceMaterial,
    MeshLambertMaterial: () => MeshLambertMaterial,
    MeshMatcapMaterial: () => MeshMatcapMaterial,
    MeshNormalMaterial: () => MeshNormalMaterial,
    MeshPhongMaterial: () => MeshPhongMaterial,
    MeshPhysicalMaterial: () => MeshPhysicalMaterial,
    MeshStandardMaterial: () => MeshStandardMaterial,
    MeshToonMaterial: () => MeshToonMaterial,
    MinEquation: () => MinEquation,
    MirroredRepeatWrapping: () => MirroredRepeatWrapping,
    MixOperation: () => MixOperation,
    MultiplyBlending: () => MultiplyBlending,
    MultiplyOperation: () => MultiplyOperation,
    NearestFilter: () => NearestFilter,
    NearestMipMapLinearFilter: () => NearestMipMapLinearFilter,
    NearestMipMapNearestFilter: () => NearestMipMapNearestFilter,
    NearestMipmapLinearFilter: () => NearestMipmapLinearFilter,
    NearestMipmapNearestFilter: () => NearestMipmapNearestFilter,
    NeverDepth: () => NeverDepth,
    NeverStencilFunc: () => NeverStencilFunc,
    NoBlending: () => NoBlending,
    NoColorSpace: () => NoColorSpace,
    NoToneMapping: () => NoToneMapping,
    NormalAnimationBlendMode: () => NormalAnimationBlendMode,
    NormalBlending: () => NormalBlending,
    NotEqualDepth: () => NotEqualDepth,
    NotEqualStencilFunc: () => NotEqualStencilFunc,
    NumberKeyframeTrack: () => NumberKeyframeTrack,
    Object3D: () => Object3D,
    ObjectLoader: () => ObjectLoader,
    ObjectSpaceNormalMap: () => ObjectSpaceNormalMap,
    OctahedronBufferGeometry: () => OctahedronBufferGeometry,
    OctahedronGeometry: () => OctahedronGeometry,
    OneFactor: () => OneFactor,
    OneMinusDstAlphaFactor: () => OneMinusDstAlphaFactor,
    OneMinusDstColorFactor: () => OneMinusDstColorFactor,
    OneMinusSrcAlphaFactor: () => OneMinusSrcAlphaFactor,
    OneMinusSrcColorFactor: () => OneMinusSrcColorFactor,
    OrthographicCamera: () => OrthographicCamera,
    PCFShadowMap: () => PCFShadowMap,
    PCFSoftShadowMap: () => PCFSoftShadowMap,
    PMREMGenerator: () => PMREMGenerator,
    Path: () => Path,
    PerspectiveCamera: () => PerspectiveCamera,
    Plane: () => Plane,
    PlaneBufferGeometry: () => PlaneBufferGeometry,
    PlaneGeometry: () => PlaneGeometry,
    PlaneHelper: () => PlaneHelper,
    PointLight: () => PointLight,
    PointLightHelper: () => PointLightHelper,
    Points: () => Points,
    PointsMaterial: () => PointsMaterial,
    PolarGridHelper: () => PolarGridHelper,
    PolyhedronBufferGeometry: () => PolyhedronBufferGeometry,
    PolyhedronGeometry: () => PolyhedronGeometry,
    PositionalAudio: () => PositionalAudio,
    PropertyBinding: () => PropertyBinding,
    PropertyMixer: () => PropertyMixer,
    QuadraticBezierCurve: () => QuadraticBezierCurve,
    QuadraticBezierCurve3: () => QuadraticBezierCurve3,
    Quaternion: () => Quaternion,
    QuaternionKeyframeTrack: () => QuaternionKeyframeTrack,
    QuaternionLinearInterpolant: () => QuaternionLinearInterpolant,
    RED_GREEN_RGTC2_Format: () => RED_GREEN_RGTC2_Format,
    RED_RGTC1_Format: () => RED_RGTC1_Format,
    REVISION: () => REVISION,
    RGBADepthPacking: () => RGBADepthPacking,
    RGBAFormat: () => RGBAFormat,
    RGBAIntegerFormat: () => RGBAIntegerFormat,
    RGBA_ASTC_10x10_Format: () => RGBA_ASTC_10x10_Format,
    RGBA_ASTC_10x5_Format: () => RGBA_ASTC_10x5_Format,
    RGBA_ASTC_10x6_Format: () => RGBA_ASTC_10x6_Format,
    RGBA_ASTC_10x8_Format: () => RGBA_ASTC_10x8_Format,
    RGBA_ASTC_12x10_Format: () => RGBA_ASTC_12x10_Format,
    RGBA_ASTC_12x12_Format: () => RGBA_ASTC_12x12_Format,
    RGBA_ASTC_4x4_Format: () => RGBA_ASTC_4x4_Format,
    RGBA_ASTC_5x4_Format: () => RGBA_ASTC_5x4_Format,
    RGBA_ASTC_5x5_Format: () => RGBA_ASTC_5x5_Format,
    RGBA_ASTC_6x5_Format: () => RGBA_ASTC_6x5_Format,
    RGBA_ASTC_6x6_Format: () => RGBA_ASTC_6x6_Format,
    RGBA_ASTC_8x5_Format: () => RGBA_ASTC_8x5_Format,
    RGBA_ASTC_8x6_Format: () => RGBA_ASTC_8x6_Format,
    RGBA_ASTC_8x8_Format: () => RGBA_ASTC_8x8_Format,
    RGBA_BPTC_Format: () => RGBA_BPTC_Format,
    RGBA_ETC2_EAC_Format: () => RGBA_ETC2_EAC_Format,
    RGBA_PVRTC_2BPPV1_Format: () => RGBA_PVRTC_2BPPV1_Format,
    RGBA_PVRTC_4BPPV1_Format: () => RGBA_PVRTC_4BPPV1_Format,
    RGBA_S3TC_DXT1_Format: () => RGBA_S3TC_DXT1_Format,
    RGBA_S3TC_DXT3_Format: () => RGBA_S3TC_DXT3_Format,
    RGBA_S3TC_DXT5_Format: () => RGBA_S3TC_DXT5_Format,
    RGB_ETC1_Format: () => RGB_ETC1_Format,
    RGB_ETC2_Format: () => RGB_ETC2_Format,
    RGB_PVRTC_2BPPV1_Format: () => RGB_PVRTC_2BPPV1_Format,
    RGB_PVRTC_4BPPV1_Format: () => RGB_PVRTC_4BPPV1_Format,
    RGB_S3TC_DXT1_Format: () => RGB_S3TC_DXT1_Format,
    RGFormat: () => RGFormat,
    RGIntegerFormat: () => RGIntegerFormat,
    RawShaderMaterial: () => RawShaderMaterial,
    Ray: () => Ray,
    Raycaster: () => Raycaster,
    RectAreaLight: () => RectAreaLight,
    RedFormat: () => RedFormat,
    RedIntegerFormat: () => RedIntegerFormat,
    ReinhardToneMapping: () => ReinhardToneMapping,
    RepeatWrapping: () => RepeatWrapping,
    ReplaceStencilOp: () => ReplaceStencilOp,
    ReverseSubtractEquation: () => ReverseSubtractEquation,
    RingBufferGeometry: () => RingBufferGeometry,
    RingGeometry: () => RingGeometry,
    SIGNED_RED_GREEN_RGTC2_Format: () => SIGNED_RED_GREEN_RGTC2_Format,
    SIGNED_RED_RGTC1_Format: () => SIGNED_RED_RGTC1_Format,
    SRGBColorSpace: () => SRGBColorSpace,
    Scene: () => Scene,
    ShaderChunk: () => ShaderChunk,
    ShaderLib: () => ShaderLib,
    ShaderMaterial: () => ShaderMaterial,
    ShadowMaterial: () => ShadowMaterial,
    Shape: () => Shape,
    ShapeBufferGeometry: () => ShapeBufferGeometry,
    ShapeGeometry: () => ShapeGeometry,
    ShapePath: () => ShapePath,
    ShapeUtils: () => ShapeUtils,
    ShortType: () => ShortType,
    Skeleton: () => Skeleton,
    SkeletonHelper: () => SkeletonHelper,
    SkinnedMesh: () => SkinnedMesh,
    Source: () => Source,
    Sphere: () => Sphere,
    SphereBufferGeometry: () => SphereBufferGeometry,
    SphereGeometry: () => SphereGeometry,
    Spherical: () => Spherical,
    SphericalHarmonics3: () => SphericalHarmonics3,
    SplineCurve: () => SplineCurve,
    SpotLight: () => SpotLight,
    SpotLightHelper: () => SpotLightHelper,
    Sprite: () => Sprite,
    SpriteMaterial: () => SpriteMaterial,
    SrcAlphaFactor: () => SrcAlphaFactor,
    SrcAlphaSaturateFactor: () => SrcAlphaSaturateFactor,
    SrcColorFactor: () => SrcColorFactor,
    StaticCopyUsage: () => StaticCopyUsage,
    StaticDrawUsage: () => StaticDrawUsage,
    StaticReadUsage: () => StaticReadUsage,
    StereoCamera: () => StereoCamera,
    StreamCopyUsage: () => StreamCopyUsage,
    StreamDrawUsage: () => StreamDrawUsage,
    StreamReadUsage: () => StreamReadUsage,
    StringKeyframeTrack: () => StringKeyframeTrack,
    SubtractEquation: () => SubtractEquation,
    SubtractiveBlending: () => SubtractiveBlending,
    TOUCH: () => TOUCH,
    TangentSpaceNormalMap: () => TangentSpaceNormalMap,
    TetrahedronBufferGeometry: () => TetrahedronBufferGeometry,
    TetrahedronGeometry: () => TetrahedronGeometry,
    Texture: () => Texture,
    TextureLoader: () => TextureLoader,
    TorusBufferGeometry: () => TorusBufferGeometry,
    TorusGeometry: () => TorusGeometry,
    TorusKnotBufferGeometry: () => TorusKnotBufferGeometry,
    TorusKnotGeometry: () => TorusKnotGeometry,
    Triangle: () => Triangle,
    TriangleFanDrawMode: () => TriangleFanDrawMode,
    TriangleStripDrawMode: () => TriangleStripDrawMode,
    TrianglesDrawMode: () => TrianglesDrawMode,
    TubeBufferGeometry: () => TubeBufferGeometry,
    TubeGeometry: () => TubeGeometry,
    TwoPassDoubleSide: () => TwoPassDoubleSide,
    UVMapping: () => UVMapping,
    Uint16BufferAttribute: () => Uint16BufferAttribute,
    Uint32BufferAttribute: () => Uint32BufferAttribute,
    Uint8BufferAttribute: () => Uint8BufferAttribute,
    Uint8ClampedBufferAttribute: () => Uint8ClampedBufferAttribute,
    Uniform: () => Uniform,
    UniformsGroup: () => UniformsGroup,
    UniformsLib: () => UniformsLib,
    UniformsUtils: () => UniformsUtils,
    UnsignedByteType: () => UnsignedByteType,
    UnsignedInt248Type: () => UnsignedInt248Type,
    UnsignedIntType: () => UnsignedIntType,
    UnsignedShort4444Type: () => UnsignedShort4444Type,
    UnsignedShort5551Type: () => UnsignedShort5551Type,
    UnsignedShortType: () => UnsignedShortType,
    VSMShadowMap: () => VSMShadowMap,
    Vector2: () => Vector2,
    Vector3: () => Vector3,
    Vector4: () => Vector4,
    VectorKeyframeTrack: () => VectorKeyframeTrack,
    VideoTexture: () => VideoTexture,
    WebGL1Renderer: () => WebGL1Renderer,
    WebGL3DRenderTarget: () => WebGL3DRenderTarget,
    WebGLArrayRenderTarget: () => WebGLArrayRenderTarget,
    WebGLCubeRenderTarget: () => WebGLCubeRenderTarget,
    WebGLMultipleRenderTargets: () => WebGLMultipleRenderTargets,
    WebGLRenderTarget: () => WebGLRenderTarget,
    WebGLRenderer: () => WebGLRenderer,
    WebGLUtils: () => WebGLUtils,
    WireframeGeometry: () => WireframeGeometry,
    WrapAroundEnding: () => WrapAroundEnding,
    ZeroCurvatureEnding: () => ZeroCurvatureEnding,
    ZeroFactor: () => ZeroFactor,
    ZeroSlopeEnding: () => ZeroSlopeEnding,
    ZeroStencilOp: () => ZeroStencilOp,
    _SRGBAFormat: () => _SRGBAFormat,
    sRGBEncoding: () => sRGBEncoding
  });
  function generateUUID() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toLowerCase();
  }
  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function euclideanModulo(n, m) {
    return (n % m + m) % m;
  }
  function mapLinear(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  }
  function inverseLerp(x, y, value) {
    if (x !== y) {
      return (value - x) / (y - x);
    } else {
      return 0;
    }
  }
  function lerp(x, y, t) {
    return (1 - t) * x + t * y;
  }
  function damp(x, y, lambda, dt) {
    return lerp(x, y, 1 - Math.exp(-lambda * dt));
  }
  function pingpong(x, length = 1) {
    return length - Math.abs(euclideanModulo(x, length * 2) - length);
  }
  function smoothstep(x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  }
  function smootherstep(x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  }
  function randInt(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  }
  function randFloat(low, high) {
    return low + Math.random() * (high - low);
  }
  function randFloatSpread(range) {
    return range * (0.5 - Math.random());
  }
  function seededRandom(s) {
    if (s !== void 0)
      _seed = s;
    let t = _seed += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  function degToRad(degrees) {
    return degrees * DEG2RAD;
  }
  function radToDeg(radians) {
    return radians * RAD2DEG;
  }
  function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
  }
  function ceilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  }
  function floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
  function setQuaternionFromProperEuler(q, a, b, c, order) {
    const cos = Math.cos;
    const sin = Math.sin;
    const c2 = cos(b / 2);
    const s2 = sin(b / 2);
    const c13 = cos((a + c) / 2);
    const s13 = sin((a + c) / 2);
    const c1_3 = cos((a - c) / 2);
    const s1_3 = sin((a - c) / 2);
    const c3_1 = cos((c - a) / 2);
    const s3_1 = sin((c - a) / 2);
    switch (order) {
      case "XYX":
        q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
        break;
      case "YZY":
        q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
        break;
      case "ZXZ":
        q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
        break;
      case "XZX":
        q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
        break;
      case "YXY":
        q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
        break;
      case "ZYZ":
        q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
    }
  }
  function denormalize(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint16Array:
        return value / 65535;
      case Uint8Array:
        return value / 255;
      case Int16Array:
        return Math.max(value / 32767, -1);
      case Int8Array:
        return Math.max(value / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function normalize(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint16Array:
        return Math.round(value * 65535);
      case Uint8Array:
        return Math.round(value * 255);
      case Int16Array:
        return Math.round(value * 32767);
      case Int8Array:
        return Math.round(value * 127);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function arrayNeedsUint32(array) {
    for (let i = array.length - 1; i >= 0; --i) {
      if (array[i] >= 65535)
        return true;
    }
    return false;
  }
  function getTypedArray(type3, buffer) {
    return new TYPED_ARRAYS[type3](buffer);
  }
  function createElementNS(name) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", name);
  }
  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }
  function hue2rgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * 6 * (2 / 3 - t);
    return p;
  }
  function toComponents(source, target) {
    target.r = source.r;
    target.g = source.g;
    target.b = source.b;
    return target;
  }
  function serializeImage(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return ImageUtils.getDataURL(image);
    } else {
      if (image.data) {
        return {
          data: Array.from(image.data),
          width: image.width,
          height: image.height,
          type: image.data.constructor.name
        };
      } else {
        console.warn("THREE.Texture: Unable to serialize Texture.");
        return {};
      }
    }
  }
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
      _testAxis.fromArray(axes, i);
      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        return false;
      }
    }
    return true;
  }
  function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
    }
    if (intersect === null)
      return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far)
      return null;
    return {
      distance,
      point: _intersectionPointWorld.clone(),
      object
    };
  }
  function checkBufferGeometryIntersection(object, material, raycaster, ray, uv, uv2, a, b, c) {
    object.getVertexPosition(a, _vA$1);
    object.getVertexPosition(b, _vB$1);
    object.getVertexPosition(c, _vC$1);
    const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
      if (uv) {
        _uvA$1.fromBufferAttribute(uv, a);
        _uvB$1.fromBufferAttribute(uv, b);
        _uvC$1.fromBufferAttribute(uv, c);
        intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      if (uv2) {
        _uvA$1.fromBufferAttribute(uv2, a);
        _uvB$1.fromBufferAttribute(uv2, b);
        _uvC$1.fromBufferAttribute(uv2, c);
        intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      const face = {
        a,
        b,
        c,
        normal: new Vector3(),
        materialIndex: 0
      };
      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
      intersection.face = face;
    }
    return intersection;
  }
  function cloneUniforms(src) {
    const dst = {};
    for (const u in src) {
      dst[u] = {};
      for (const p in src[u]) {
        const property = src[u][p];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          dst[u][p] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    const merged = {};
    for (let u = 0; u < uniforms.length; u++) {
      const tmp2 = cloneUniforms(uniforms[u]);
      for (const p in tmp2) {
        merged[p] = tmp2[p];
      }
    }
    return merged;
  }
  function cloneUniformsGroups(src) {
    const dst = [];
    for (let u = 0; u < src.length; u++) {
      dst.push(src[u].clone());
    }
    return dst;
  }
  function getUnlitUniformColorSpace(renderer) {
    if (renderer.getRenderTarget() === null) {
      return renderer.outputEncoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;
    }
    return LinearSRGBColorSpace;
  }
  function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time2, frame) {
      animationLoop(time2, frame);
      requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
      start: function() {
        if (isAnimating === true)
          return;
        if (animationLoop === null)
          return;
        requestId = context.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function() {
        context.cancelAnimationFrame(requestId);
        isAnimating = false;
      },
      setAnimationLoop: function(callback) {
        animationLoop = callback;
      },
      setContext: function(value) {
        context = value;
      }
    };
  }
  function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = /* @__PURE__ */ new WeakMap();
    function createBuffer(attribute, bufferType) {
      const array = attribute.array;
      const usage = attribute.usage;
      const buffer = gl.createBuffer();
      gl.bindBuffer(bufferType, buffer);
      gl.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      let type3;
      if (array instanceof Float32Array) {
        type3 = 5126;
      } else if (array instanceof Uint16Array) {
        if (attribute.isFloat16BufferAttribute) {
          if (isWebGL2) {
            type3 = 5131;
          } else {
            throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
          }
        } else {
          type3 = 5123;
        }
      } else if (array instanceof Int16Array) {
        type3 = 5122;
      } else if (array instanceof Uint32Array) {
        type3 = 5125;
      } else if (array instanceof Int32Array) {
        type3 = 5124;
      } else if (array instanceof Int8Array) {
        type3 = 5120;
      } else if (array instanceof Uint8Array) {
        type3 = 5121;
      } else if (array instanceof Uint8ClampedArray) {
        type3 = 5121;
      } else {
        throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
      }
      return {
        buffer,
        type: type3,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version
      };
    }
    function updateBuffer(buffer, attribute, bufferType) {
      const array = attribute.array;
      const updateRange = attribute.updateRange;
      gl.bindBuffer(bufferType, buffer);
      if (updateRange.count === -1) {
        gl.bufferSubData(bufferType, 0, array);
      } else {
        if (isWebGL2) {
          gl.bufferSubData(
            bufferType,
            updateRange.offset * array.BYTES_PER_ELEMENT,
            array,
            updateRange.offset,
            updateRange.count
          );
        } else {
          gl.bufferSubData(
            bufferType,
            updateRange.offset * array.BYTES_PER_ELEMENT,
            array.subarray(updateRange.offset, updateRange.offset + updateRange.count)
          );
        }
        updateRange.count = -1;
      }
      attribute.onUploadCallback();
    }
    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      return buffers.get(attribute);
    }
    function remove3(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data) {
        gl.deleteBuffer(data.buffer);
        buffers.delete(attribute);
      }
    }
    function update(attribute, bufferType) {
      if (attribute.isGLBufferAttribute) {
        const cached = buffers.get(attribute);
        if (!cached || cached.version < attribute.version) {
          buffers.set(attribute, {
            buffer: attribute.buffer,
            type: attribute.type,
            bytesPerElement: attribute.elementSize,
            version: attribute.version
          });
        }
        return;
      }
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data === void 0) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }
    return {
      get,
      remove: remove3,
      update
    };
  }
  function WebGLBackground(renderer, cubemaps, cubeuvmaps, state2, objects, alpha, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = alpha === true ? 0 : 1;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene) {
      let forceClear = false;
      let background = scene.isScene === true ? scene.background : null;
      if (background && background.isTexture) {
        const usePMREM = scene.backgroundBlurriness > 0;
        background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
      }
      const xr = renderer.xr;
      const session = xr.getSession && xr.getSession();
      if (session && session.environmentBlendMode === "additive") {
        background = null;
      }
      if (background === null) {
        setClear(clearColor, clearAlpha);
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
      }
      if (renderer.autoClear || forceClear) {
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      }
      if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
        if (boxMesh === void 0) {
          boxMesh = new Mesh(
            new BoxGeometry(1, 1, 1),
            new ShaderMaterial({
              name: "BackgroundCubeMaterial",
              uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
              vertexShader: ShaderLib.backgroundCube.vertexShader,
              fragmentShader: ShaderLib.backgroundCube.fragmentShader,
              side: BackSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            })
          );
          boxMesh.geometry.deleteAttribute("normal");
          boxMesh.geometry.deleteAttribute("uv");
          boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
            this.matrixWorld.copyPosition(camera.matrixWorld);
          };
          Object.defineProperty(boxMesh.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          });
          objects.update(boxMesh);
        }
        boxMesh.material.uniforms.envMap.value = background;
        boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
        boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
        boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
        boxMesh.material.toneMapped = background.encoding === sRGBEncoding ? false : true;
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        boxMesh.layers.enableAll();
        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === void 0) {
          planeMesh = new Mesh(
            new PlaneGeometry(2, 2),
            new ShaderMaterial({
              name: "BackgroundMaterial",
              uniforms: cloneUniforms(ShaderLib.background.uniforms),
              vertexShader: ShaderLib.background.vertexShader,
              fragmentShader: ShaderLib.background.fragmentShader,
              side: FrontSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            })
          );
          planeMesh.geometry.deleteAttribute("normal");
          Object.defineProperty(planeMesh.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }
        planeMesh.material.uniforms.t2D.value = background;
        planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
        planeMesh.material.toneMapped = background.encoding === sRGBEncoding ? false : true;
        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }
        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        planeMesh.layers.enableAll();
        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }
    function setClear(color, alpha2) {
      color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
      state2.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
    }
    return {
      getClearColor: function() {
        return clearColor;
      },
      setClearColor: function(color, alpha2 = 1) {
        clearColor.set(color);
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function() {
        return clearAlpha;
      },
      setClearAlpha: function(alpha2) {
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      render
    };
  }
  function WebGLBindingStates(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    let forceUpdate = false;
    function setup(object, material, program, geometry, index) {
      let updateBuffers = false;
      if (vaoAvailable) {
        const state2 = getBindingState(geometry, program, material);
        if (currentState !== state2) {
          currentState = state2;
          bindVertexArrayObject(currentState.object);
        }
        updateBuffers = needsUpdate(object, geometry, program, index);
        if (updateBuffers)
          saveCache(object, geometry, program, index);
      } else {
        const wireframe = material.wireframe === true;
        if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
          currentState.geometry = geometry.id;
          currentState.program = program.id;
          currentState.wireframe = wireframe;
          updateBuffers = true;
        }
      }
      if (index !== null) {
        attributes.update(index, 34963);
      }
      if (updateBuffers || forceUpdate) {
        forceUpdate = false;
        setupVertexAttributes(object, material, program, geometry);
        if (index !== null) {
          gl.bindBuffer(34963, attributes.get(index).buffer);
        }
      }
    }
    function createVertexArrayObject() {
      if (capabilities.isWebGL2)
        return gl.createVertexArray();
      return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.bindVertexArray(vao);
      return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.deleteVertexArray(vao);
      return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
      const wireframe = material.wireframe === true;
      let programMap = bindingStates[geometry.id];
      if (programMap === void 0) {
        programMap = {};
        bindingStates[geometry.id] = programMap;
      }
      let stateMap = programMap[program.id];
      if (stateMap === void 0) {
        stateMap = {};
        programMap[program.id] = stateMap;
      }
      let state2 = stateMap[wireframe];
      if (state2 === void 0) {
        state2 = createBindingState(createVertexArrayObject());
        stateMap[wireframe] = state2;
      }
      return state2;
    }
    function createBindingState(vao) {
      const newAttributes = [];
      const enabledAttributes = [];
      const attributeDivisors = [];
      for (let i = 0; i < maxVertexAttributes; i++) {
        newAttributes[i] = 0;
        enabledAttributes[i] = 0;
        attributeDivisors[i] = 0;
      }
      return {
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes,
        enabledAttributes,
        attributeDivisors,
        object: vao,
        attributes: {},
        index: null
      };
    }
    function needsUpdate(object, geometry, program, index) {
      const cachedAttributes = currentState.attributes;
      const geometryAttributes = geometry.attributes;
      let attributesNum = 0;
      const programAttributes = program.getAttributes();
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          const cachedAttribute = cachedAttributes[name];
          let geometryAttribute = geometryAttributes[name];
          if (geometryAttribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              geometryAttribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              geometryAttribute = object.instanceColor;
          }
          if (cachedAttribute === void 0)
            return true;
          if (cachedAttribute.attribute !== geometryAttribute)
            return true;
          if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data)
            return true;
          attributesNum++;
        }
      }
      if (currentState.attributesNum !== attributesNum)
        return true;
      if (currentState.index !== index)
        return true;
      return false;
    }
    function saveCache(object, geometry, program, index) {
      const cache = {};
      const attributes2 = geometry.attributes;
      let attributesNum = 0;
      const programAttributes = program.getAttributes();
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          let attribute = attributes2[name];
          if (attribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              attribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              attribute = object.instanceColor;
          }
          const data = {};
          data.attribute = attribute;
          if (attribute && attribute.data) {
            data.data = attribute.data;
          }
          cache[name] = data;
          attributesNum++;
        }
      }
      currentState.attributes = cache;
      currentState.attributesNum = attributesNum;
      currentState.index = index;
    }
    function initAttributes() {
      const newAttributes = currentState.newAttributes;
      for (let i = 0, il = newAttributes.length; i < il; i++) {
        newAttributes[i] = 0;
      }
    }
    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      const attributeDivisors = currentState.attributeDivisors;
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
        extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }
    function disableUnusedAttributes() {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      for (let i = 0, il = enabledAttributes.length; i < il; i++) {
        if (enabledAttributes[i] !== newAttributes[i]) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }
    }
    function vertexAttribPointer(index, size, type3, normalized, stride, offset) {
      if (capabilities.isWebGL2 === true && (type3 === 5124 || type3 === 5125)) {
        gl.vertexAttribIPointer(index, size, type3, stride, offset);
      } else {
        gl.vertexAttribPointer(index, size, type3, normalized, stride, offset);
      }
    }
    function setupVertexAttributes(object, material, program, geometry) {
      if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
        if (extensions.get("ANGLE_instanced_arrays") === null)
          return;
      }
      initAttributes();
      const geometryAttributes = geometry.attributes;
      const programAttributes = program.getAttributes();
      const materialDefaultAttributeValues = material.defaultAttributeValues;
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          let geometryAttribute = geometryAttributes[name];
          if (geometryAttribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              geometryAttribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              geometryAttribute = object.instanceColor;
          }
          if (geometryAttribute !== void 0) {
            const normalized = geometryAttribute.normalized;
            const size = geometryAttribute.itemSize;
            const attribute = attributes.get(geometryAttribute);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type3 = attribute.type;
            const bytesPerElement = attribute.bytesPerElement;
            if (geometryAttribute.isInterleavedBufferAttribute) {
              const data = geometryAttribute.data;
              const stride = data.stride;
              const offset = geometryAttribute.offset;
              if (data.isInstancedInterleavedBuffer) {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                }
              } else {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttribute(programAttribute.location + i);
                }
              }
              gl.bindBuffer(34962, buffer);
              for (let i = 0; i < programAttribute.locationSize; i++) {
                vertexAttribPointer(
                  programAttribute.location + i,
                  size / programAttribute.locationSize,
                  type3,
                  normalized,
                  stride * bytesPerElement,
                  (offset + size / programAttribute.locationSize * i) * bytesPerElement
                );
              }
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttribute(programAttribute.location + i);
                }
              }
              gl.bindBuffer(34962, buffer);
              for (let i = 0; i < programAttribute.locationSize; i++) {
                vertexAttribPointer(
                  programAttribute.location + i,
                  size / programAttribute.locationSize,
                  type3,
                  normalized,
                  size * bytesPerElement,
                  size / programAttribute.locationSize * i * bytesPerElement
                );
              }
            }
          } else if (materialDefaultAttributeValues !== void 0) {
            const value = materialDefaultAttributeValues[name];
            if (value !== void 0) {
              switch (value.length) {
                case 2:
                  gl.vertexAttrib2fv(programAttribute.location, value);
                  break;
                case 3:
                  gl.vertexAttrib3fv(programAttribute.location, value);
                  break;
                case 4:
                  gl.vertexAttrib4fv(programAttribute.location, value);
                  break;
                default:
                  gl.vertexAttrib1fv(programAttribute.location, value);
              }
            }
          }
        }
      }
      disableUnusedAttributes();
    }
    function dispose() {
      reset();
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        for (const programId in programMap) {
          const stateMap = programMap[programId];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometryId];
      }
    }
    function releaseStatesOfGeometry(geometry) {
      if (bindingStates[geometry.id] === void 0)
        return;
      const programMap = bindingStates[geometry.id];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        if (programMap[program.id] === void 0)
          continue;
        const stateMap = programMap[program.id];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[program.id];
      }
    }
    function reset() {
      resetDefaultState();
      forceUpdate = true;
      if (currentState === defaultState)
        return;
      currentState = defaultState;
      bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
      defaultState.geometry = null;
      defaultState.program = null;
      defaultState.wireframe = false;
    }
    return {
      setup,
      reset,
      resetDefaultState,
      dispose,
      releaseStatesOfGeometry,
      releaseStatesOfProgram,
      initAttributes,
      enableAttribute,
      disableUnusedAttributes
    };
  }
  function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    function render(start2, count) {
      gl.drawArrays(mode, start2, count);
      info.update(count, mode, 1);
    }
    function renderInstances(start2, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawArraysInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawArraysInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, start2, count, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
      if (maxAnisotropy !== void 0)
        return maxAnisotropy;
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }
      return maxAnisotropy;
    }
    function getMaxPrecision(precision2) {
      if (precision2 === "highp") {
        if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
          return "highp";
        }
        precision2 = "mediump";
      }
      if (precision2 === "mediump") {
        if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
          return "mediump";
        }
      }
      return "lowp";
    }
    const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
    let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
      console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
      precision = maxPrecision;
    }
    const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
      isWebGL2,
      drawBuffers,
      getMaxAnisotropy,
      getMaxPrecision,
      precision,
      logarithmicDepthBuffer,
      maxTextures,
      maxVertexTextures,
      maxTextureSize,
      maxCubemapSize,
      maxAttributes,
      maxVertexUniforms,
      maxVaryings,
      maxFragmentUniforms,
      vertexTextures,
      floatFragmentTextures,
      floatVertexTextures,
      maxSamples
    };
  }
  function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping) {
      const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      numGlobalPlanes = planes.length;
      return enabled;
    };
    this.beginShadows = function() {
      renderingShadows = true;
      projectPlanes(null);
    };
    this.endShadows = function() {
      renderingShadows = false;
    };
    this.setGlobalState = function(planes, camera) {
      globalState = projectPlanes(planes, camera, 0);
    };
    this.setState = function(material, camera, useCache) {
      const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
      const materialProperties = properties.get(material);
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
        let dstArray = materialProperties.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera, lGlobal, useCache);
        for (let i = 0; i !== lGlobal; ++i) {
          dstArray[i] = globalState[i];
        }
        materialProperties.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };
    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }
      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
      const nPlanes = planes !== null ? planes.length : 0;
      let dstArray = null;
      if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
          const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);
          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }
          for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
            plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i4);
            dstArray[i4 + 3] = plane.constant;
          }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }
      scope.numPlanes = nPlanes;
      scope.numIntersection = 0;
      return dstArray;
    }
  }
  function WebGLCubeMaps(renderer) {
    let cubemaps = /* @__PURE__ */ new WeakMap();
    function mapTextureMapping(texture, mapping) {
      if (mapping === EquirectangularReflectionMapping) {
        texture.mapping = CubeReflectionMapping;
      } else if (mapping === EquirectangularRefractionMapping) {
        texture.mapping = CubeRefractionMapping;
      }
      return texture;
    }
    function get(texture) {
      if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
        const mapping = texture.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (cubemaps.has(texture)) {
            const cubemap = cubemaps.get(texture).texture;
            return mapTextureMapping(cubemap, texture.mapping);
          } else {
            const image = texture.image;
            if (image && image.height > 0) {
              const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
              renderTarget.fromEquirectangularTexture(renderer, texture);
              cubemaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return mapTextureMapping(renderTarget.texture, texture.mapping);
            } else {
              return null;
            }
          }
        }
      }
      return texture;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemap = cubemaps.get(texture);
      if (cubemap !== void 0) {
        cubemaps.delete(texture);
        cubemap.dispose();
      }
    }
    function dispose() {
      cubemaps = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function _createPlanes(lodMax) {
    const lodPlanes = [];
    const sizeLods = [];
    const sigmas = [];
    let lod = lodMax;
    const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let i = 0; i < totalLods; i++) {
      const sizeLod = Math.pow(2, lod);
      sizeLods.push(sizeLod);
      let sigma = 1 / sizeLod;
      if (i > lodMax - LOD_MIN) {
        sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
      } else if (i === 0) {
        sigma = 0;
      }
      sigmas.push(sigma);
      const texelSize = 1 / (sizeLod - 2);
      const min = -texelSize;
      const max = 1 + texelSize;
      const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
      const cubeFaces = 6;
      const vertices = 6;
      const positionSize = 3;
      const uvSize = 2;
      const faceIndexSize = 1;
      const position = new Float32Array(positionSize * vertices * cubeFaces);
      const uv = new Float32Array(uvSize * vertices * cubeFaces);
      const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
      for (let face = 0; face < cubeFaces; face++) {
        const x = face % 3 * 2 / 3 - 1;
        const y = face > 2 ? 0 : -1;
        const coordinates = [
          x,
          y,
          0,
          x + 2 / 3,
          y,
          0,
          x + 2 / 3,
          y + 1,
          0,
          x,
          y,
          0,
          x + 2 / 3,
          y + 1,
          0,
          x,
          y + 1,
          0
        ];
        position.set(coordinates, positionSize * vertices * face);
        uv.set(uv1, uvSize * vertices * face);
        const fill = [face, face, face, face, face, face];
        faceIndex.set(fill, faceIndexSize * vertices * face);
      }
      const planes = new BufferGeometry();
      planes.setAttribute("position", new BufferAttribute(position, positionSize));
      planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
      planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
      lodPlanes.push(planes);
      if (lod > LOD_MIN) {
        lod--;
      }
    }
    return { lodPlanes, sizeLods, sigmas };
  }
  function _createRenderTarget(width2, height2, params2) {
    const cubeUVRenderTarget = new WebGLRenderTarget(width2, height2, params2);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
  }
  function _setViewport(target, x, y, width2, height2) {
    target.viewport.set(x, y, width2, height2);
    target.scissor.set(x, y, width2, height2);
  }
  function _getBlurShader(lodMax, width2, height2) {
    const weights = new Float32Array(MAX_SAMPLES);
    const poleAxis = new Vector3(0, 1, 0);
    const shaderMaterial = new ShaderMaterial({
      name: "SphericalGaussianBlur",
      defines: {
        "n": MAX_SAMPLES,
        "CUBEUV_TEXEL_WIDTH": 1 / width2,
        "CUBEUV_TEXEL_HEIGHT": 1 / height2,
        "CUBEUV_MAX_MIP": `${lodMax}.0`
      },
      uniforms: {
        "envMap": { value: null },
        "samples": { value: 1 },
        "weights": { value: weights },
        "latitudinal": { value: false },
        "dTheta": { value: 0 },
        "mipInt": { value: 0 },
        "poleAxis": { value: poleAxis }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getEquirectMaterial() {
    return new ShaderMaterial({
      name: "EquirectangularToCubeUV",
      uniforms: {
        "envMap": { value: null }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCubemapMaterial() {
    return new ShaderMaterial({
      name: "CubemapToCubeUV",
      uniforms: {
        "envMap": { value: null },
        "flipEnvMap": { value: -1 }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCommonVertexShader() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
  }
  function WebGLCubeUVMaps(renderer) {
    let cubeUVmaps = /* @__PURE__ */ new WeakMap();
    let pmremGenerator = null;
    function get(texture) {
      if (texture && texture.isTexture) {
        const mapping = texture.mapping;
        const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
        const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
        if (isEquirectMap || isCubeMap) {
          if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
            texture.needsPMREMUpdate = false;
            let renderTarget = cubeUVmaps.get(texture);
            if (pmremGenerator === null)
              pmremGenerator = new PMREMGenerator(renderer);
            renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
            cubeUVmaps.set(texture, renderTarget);
            return renderTarget.texture;
          } else {
            if (cubeUVmaps.has(texture)) {
              return cubeUVmaps.get(texture).texture;
            } else {
              const image = texture.image;
              if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                if (pmremGenerator === null)
                  pmremGenerator = new PMREMGenerator(renderer);
                const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                cubeUVmaps.set(texture, renderTarget);
                texture.addEventListener("dispose", onTextureDispose);
                return renderTarget.texture;
              } else {
                return null;
              }
            }
          }
        }
      }
      return texture;
    }
    function isCubeTextureComplete(image) {
      let count = 0;
      const length = 6;
      for (let i = 0; i < length; i++) {
        if (image[i] !== void 0)
          count++;
      }
      return count === length;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemapUV = cubeUVmaps.get(texture);
      if (cubemapUV !== void 0) {
        cubeUVmaps.delete(texture);
        cubemapUV.dispose();
      }
    }
    function dispose() {
      cubeUVmaps = /* @__PURE__ */ new WeakMap();
      if (pmremGenerator !== null) {
        pmremGenerator.dispose();
        pmremGenerator = null;
      }
    }
    return {
      get,
      dispose
    };
  }
  function WebGLExtensions(gl) {
    const extensions = {};
    function getExtension(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      let extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl.getExtension(name);
      }
      extensions[name] = extension;
      return extension;
    }
    return {
      has: function(name) {
        return getExtension(name) !== null;
      },
      init: function(capabilities) {
        if (capabilities.isWebGL2) {
          getExtension("EXT_color_buffer_float");
        } else {
          getExtension("WEBGL_depth_texture");
          getExtension("OES_texture_float");
          getExtension("OES_texture_half_float");
          getExtension("OES_texture_half_float_linear");
          getExtension("OES_standard_derivatives");
          getExtension("OES_element_index_uint");
          getExtension("OES_vertex_array_object");
          getExtension("ANGLE_instanced_arrays");
        }
        getExtension("OES_texture_float_linear");
        getExtension("EXT_color_buffer_half_float");
        getExtension("WEBGL_multisampled_render_to_texture");
      },
      get: function(name) {
        const extension = getExtension(name);
        if (extension === null) {
          console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
        }
        return extension;
      }
    };
  }
  function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = {};
    const wireframeAttributes = /* @__PURE__ */ new WeakMap();
    function onGeometryDispose(event) {
      const geometry = event.target;
      if (geometry.index !== null) {
        attributes.remove(geometry.index);
      }
      for (const name in geometry.attributes) {
        attributes.remove(geometry.attributes[name]);
      }
      geometry.removeEventListener("dispose", onGeometryDispose);
      delete geometries[geometry.id];
      const attribute = wireframeAttributes.get(geometry);
      if (attribute) {
        attributes.remove(attribute);
        wireframeAttributes.delete(geometry);
      }
      bindingStates.releaseStatesOfGeometry(geometry);
      if (geometry.isInstancedBufferGeometry === true) {
        delete geometry._maxInstanceCount;
      }
      info.memory.geometries--;
    }
    function get(object, geometry) {
      if (geometries[geometry.id] === true)
        return geometry;
      geometry.addEventListener("dispose", onGeometryDispose);
      geometries[geometry.id] = true;
      info.memory.geometries++;
      return geometry;
    }
    function update(geometry) {
      const geometryAttributes = geometry.attributes;
      for (const name in geometryAttributes) {
        attributes.update(geometryAttributes[name], 34962);
      }
      const morphAttributes = geometry.morphAttributes;
      for (const name in morphAttributes) {
        const array = morphAttributes[name];
        for (let i = 0, l = array.length; i < l; i++) {
          attributes.update(array[i], 34962);
        }
      }
    }
    function updateWireframeAttribute(geometry) {
      const indices = [];
      const geometryIndex = geometry.index;
      const geometryPosition = geometry.attributes.position;
      let version = 0;
      if (geometryIndex !== null) {
        const array = geometryIndex.array;
        version = geometryIndex.version;
        for (let i = 0, l = array.length; i < l; i += 3) {
          const a = array[i + 0];
          const b = array[i + 1];
          const c = array[i + 2];
          indices.push(a, b, b, c, c, a);
        }
      } else {
        const array = geometryPosition.array;
        version = geometryPosition.version;
        for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
          const a = i + 0;
          const b = i + 1;
          const c = i + 2;
          indices.push(a, b, b, c, c, a);
        }
      }
      const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attribute.version = version;
      const previousAttribute = wireframeAttributes.get(geometry);
      if (previousAttribute)
        attributes.remove(previousAttribute);
      wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
      const currentAttribute = wireframeAttributes.get(geometry);
      if (currentAttribute) {
        const geometryIndex = geometry.index;
        if (geometryIndex !== null) {
          if (currentAttribute.version < geometryIndex.version) {
            updateWireframeAttribute(geometry);
          }
        }
      } else {
        updateWireframeAttribute(geometry);
      }
      return wireframeAttributes.get(geometry);
    }
    return {
      get,
      update,
      getWireframeAttribute
    };
  }
  function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    let type3, bytesPerElement;
    function setIndex(value) {
      type3 = value.type;
      bytesPerElement = value.bytesPerElement;
    }
    function render(start2, count) {
      gl.drawElements(mode, count, type3, start2 * bytesPerElement);
      info.update(count, mode, 1);
    }
    function renderInstances(start2, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawElementsInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawElementsInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, count, type3, start2 * bytesPerElement, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLInfo(gl) {
    const memory = {
      geometries: 0,
      textures: 0
    };
    const render = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function update(count, mode, instanceCount) {
      render.calls++;
      switch (mode) {
        case 4:
          render.triangles += instanceCount * (count / 3);
          break;
        case 1:
          render.lines += instanceCount * (count / 2);
          break;
        case 3:
          render.lines += instanceCount * (count - 1);
          break;
        case 2:
          render.lines += instanceCount * count;
          break;
        case 0:
          render.points += instanceCount * count;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
          break;
      }
    }
    function reset() {
      render.frame++;
      render.calls = 0;
      render.triangles = 0;
      render.points = 0;
      render.lines = 0;
    }
    return {
      memory,
      render,
      programs: null,
      autoReset: true,
      reset,
      update
    };
  }
  function numericalSort(a, b) {
    return a[0] - b[0];
  }
  function absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
  }
  function WebGLMorphtargets(gl, capabilities, textures) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const morphTextures = /* @__PURE__ */ new WeakMap();
    const morph = new Vector4();
    const workInfluences = [];
    for (let i = 0; i < 8; i++) {
      workInfluences[i] = [i, 0];
    }
    function update(object, geometry, material, program) {
      const objectInfluences = object.morphTargetInfluences;
      if (capabilities.isWebGL2 === true) {
        const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
        const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
        let entry = morphTextures.get(geometry);
        if (entry === void 0 || entry.count !== morphTargetsCount) {
          let disposeTexture = function() {
            texture.dispose();
            morphTextures.delete(geometry);
            geometry.removeEventListener("dispose", disposeTexture);
          };
          if (entry !== void 0)
            entry.texture.dispose();
          const hasMorphPosition = geometry.morphAttributes.position !== void 0;
          const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
          const hasMorphColors = geometry.morphAttributes.color !== void 0;
          const morphTargets = geometry.morphAttributes.position || [];
          const morphNormals = geometry.morphAttributes.normal || [];
          const morphColors = geometry.morphAttributes.color || [];
          let vertexDataCount = 0;
          if (hasMorphPosition === true)
            vertexDataCount = 1;
          if (hasMorphNormals === true)
            vertexDataCount = 2;
          if (hasMorphColors === true)
            vertexDataCount = 3;
          let width2 = geometry.attributes.position.count * vertexDataCount;
          let height2 = 1;
          if (width2 > capabilities.maxTextureSize) {
            height2 = Math.ceil(width2 / capabilities.maxTextureSize);
            width2 = capabilities.maxTextureSize;
          }
          const buffer = new Float32Array(width2 * height2 * 4 * morphTargetsCount);
          const texture = new DataArrayTexture(buffer, width2, height2, morphTargetsCount);
          texture.type = FloatType;
          texture.needsUpdate = true;
          const vertexDataStride = vertexDataCount * 4;
          for (let i = 0; i < morphTargetsCount; i++) {
            const morphTarget = morphTargets[i];
            const morphNormal = morphNormals[i];
            const morphColor = morphColors[i];
            const offset = width2 * height2 * 4 * i;
            for (let j = 0; j < morphTarget.count; j++) {
              const stride = j * vertexDataStride;
              if (hasMorphPosition === true) {
                morph.fromBufferAttribute(morphTarget, j);
                buffer[offset + stride + 0] = morph.x;
                buffer[offset + stride + 1] = morph.y;
                buffer[offset + stride + 2] = morph.z;
                buffer[offset + stride + 3] = 0;
              }
              if (hasMorphNormals === true) {
                morph.fromBufferAttribute(morphNormal, j);
                buffer[offset + stride + 4] = morph.x;
                buffer[offset + stride + 5] = morph.y;
                buffer[offset + stride + 6] = morph.z;
                buffer[offset + stride + 7] = 0;
              }
              if (hasMorphColors === true) {
                morph.fromBufferAttribute(morphColor, j);
                buffer[offset + stride + 8] = morph.x;
                buffer[offset + stride + 9] = morph.y;
                buffer[offset + stride + 10] = morph.z;
                buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
              }
            }
          }
          entry = {
            count: morphTargetsCount,
            texture,
            size: new Vector2(width2, height2)
          };
          morphTextures.set(geometry, entry);
          geometry.addEventListener("dispose", disposeTexture);
        }
        let morphInfluencesSum = 0;
        for (let i = 0; i < objectInfluences.length; i++) {
          morphInfluencesSum += objectInfluences[i];
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
        program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
        program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
      } else {
        const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === void 0 || influences.length !== length) {
          influences = [];
          for (let i = 0; i < length; i++) {
            influences[i] = [i, 0];
          }
          influencesList[geometry.id] = influences;
        }
        for (let i = 0; i < length; i++) {
          const influence = influences[i];
          influence[0] = i;
          influence[1] = objectInfluences[i];
        }
        influences.sort(absNumericalSort);
        for (let i = 0; i < 8; i++) {
          if (i < length && influences[i][1]) {
            workInfluences[i][0] = influences[i][0];
            workInfluences[i][1] = influences[i][1];
          } else {
            workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i][1] = 0;
          }
        }
        workInfluences.sort(numericalSort);
        const morphTargets = geometry.morphAttributes.position;
        const morphNormals = geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for (let i = 0; i < 8; i++) {
          const influence = workInfluences[i];
          const index = influence[0];
          const value = influence[1];
          if (index !== Number.MAX_SAFE_INTEGER && value) {
            if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index]) {
              geometry.setAttribute("morphTarget" + i, morphTargets[index]);
            }
            if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index]) {
              geometry.setAttribute("morphNormal" + i, morphNormals[index]);
            }
            morphInfluences[i] = value;
            morphInfluencesSum += value;
          } else {
            if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
              geometry.deleteAttribute("morphTarget" + i);
            }
            if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
              geometry.deleteAttribute("morphNormal" + i);
            }
            morphInfluences[i] = 0;
          }
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
      }
    }
    return {
      update
    };
  }
  function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = /* @__PURE__ */ new WeakMap();
    function update(object) {
      const frame = info.render.frame;
      const geometry = object.geometry;
      const buffergeometry = geometries.get(object, geometry);
      if (updateMap.get(buffergeometry) !== frame) {
        geometries.update(buffergeometry);
        updateMap.set(buffergeometry, frame);
      }
      if (object.isInstancedMesh) {
        if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
          object.addEventListener("dispose", onInstancedMeshDispose);
        }
        attributes.update(object.instanceMatrix, 34962);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, 34962);
        }
      }
      return buffergeometry;
    }
    function dispose() {
      updateMap = /* @__PURE__ */ new WeakMap();
    }
    function onInstancedMeshDispose(event) {
      const instancedMesh = event.target;
      instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
      attributes.remove(instancedMesh.instanceMatrix);
      if (instancedMesh.instanceColor !== null)
        attributes.remove(instancedMesh.instanceColor);
    }
    return {
      update,
      dispose
    };
  }
  function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
      return array;
    const n = nBlocks * blockSize;
    let r = arrayCacheF32[n];
    if (r === void 0) {
      r = new Float32Array(n);
      arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
      firstElem.toArray(r, 0);
      for (let i = 1, offset = 0; i !== nBlocks; ++i) {
        offset += blockSize;
        array[i].toArray(r, offset);
      }
    }
    return r;
  }
  function arraysEqual(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0, l = a.length; i < l; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  function copyArray(a, b) {
    for (let i = 0, l = b.length; i < l; i++) {
      a[i] = b[i];
    }
  }
  function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === void 0) {
      r = new Int32Array(n);
      arrayCacheI32[n] = r;
    }
    for (let i = 0; i !== n; ++i) {
      r[i] = textures.allocateTextureUnit();
    }
    return r;
  }
  function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
  }
  function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2f(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3f(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else if (v.r !== void 0) {
      if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
        gl.uniform3f(this.addr, v.r, v.g, v.b);
        cache[0] = v.r;
        cache[1] = v.g;
        cache[2] = v.b;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix2fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat2array.set(elements);
      gl.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }
  function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix3fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat3array.set(elements);
      gl.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }
  function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix4fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat4array.set(elements);
      gl.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }
  function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
  }
  function setValueV2i(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2i(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2iv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV3i(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3i(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3iv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV4i(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4iv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
  }
  function setValueV2ui(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2ui(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2uiv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV3ui(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3ui(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3uiv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV4ui(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4uiv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2D(v || emptyTexture, unit);
  }
  function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture3D(v || empty3dTexture, unit);
  }
  function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTextureCube(v || emptyCubeTexture, unit);
  }
  function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyArrayTexture, unit);
  }
  function getSingularSetter(type3) {
    switch (type3) {
      case 5126:
        return setValueV1f;
      case 35664:
        return setValueV2f;
      case 35665:
        return setValueV3f;
      case 35666:
        return setValueV4f;
      case 35674:
        return setValueM2;
      case 35675:
        return setValueM3;
      case 35676:
        return setValueM4;
      case 5124:
      case 35670:
        return setValueV1i;
      case 35667:
      case 35671:
        return setValueV2i;
      case 35668:
      case 35672:
        return setValueV3i;
      case 35669:
      case 35673:
        return setValueV4i;
      case 5125:
        return setValueV1ui;
      case 36294:
        return setValueV2ui;
      case 36295:
        return setValueV3ui;
      case 36296:
        return setValueV4ui;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3D1;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArray1;
    }
  }
  function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
  }
  function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
  }
  function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
  }
  function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
  }
  function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
  }
  function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
  }
  function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
  }
  function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
  }
  function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
  }
  function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
  }
  function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
  }
  function setValueV1uiArray(gl, v) {
    gl.uniform1uiv(this.addr, v);
  }
  function setValueV2uiArray(gl, v) {
    gl.uniform2uiv(this.addr, v);
  }
  function setValueV3uiArray(gl, v) {
    gl.uniform3uiv(this.addr, v);
  }
  function setValueV4uiArray(gl, v) {
    gl.uniform4uiv(this.addr, v);
  }
  function setValueT1Array(gl, v, textures) {
    const cache = this.cache;
    const n = v.length;
    const units = allocTexUnits(textures, n);
    if (!arraysEqual(cache, units)) {
      gl.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i = 0; i !== n; ++i) {
      textures.setTexture2D(v[i] || emptyTexture, units[i]);
    }
  }
  function setValueT3DArray(gl, v, textures) {
    const cache = this.cache;
    const n = v.length;
    const units = allocTexUnits(textures, n);
    if (!arraysEqual(cache, units)) {
      gl.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i = 0; i !== n; ++i) {
      textures.setTexture3D(v[i] || empty3dTexture, units[i]);
    }
  }
  function setValueT6Array(gl, v, textures) {
    const cache = this.cache;
    const n = v.length;
    const units = allocTexUnits(textures, n);
    if (!arraysEqual(cache, units)) {
      gl.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i = 0; i !== n; ++i) {
      textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
  }
  function setValueT2DArrayArray(gl, v, textures) {
    const cache = this.cache;
    const n = v.length;
    const units = allocTexUnits(textures, n);
    if (!arraysEqual(cache, units)) {
      gl.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i = 0; i !== n; ++i) {
      textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
    }
  }
  function getPureArraySetter(type3) {
    switch (type3) {
      case 5126:
        return setValueV1fArray;
      case 35664:
        return setValueV2fArray;
      case 35665:
        return setValueV3fArray;
      case 35666:
        return setValueV4fArray;
      case 35674:
        return setValueM2Array;
      case 35675:
        return setValueM3Array;
      case 35676:
        return setValueM4Array;
      case 5124:
      case 35670:
        return setValueV1iArray;
      case 35667:
      case 35671:
        return setValueV2iArray;
      case 35668:
      case 35672:
        return setValueV3iArray;
      case 35669:
      case 35673:
        return setValueV4iArray;
      case 5125:
        return setValueV1uiArray;
      case 36294:
        return setValueV2uiArray;
      case 36295:
        return setValueV3uiArray;
      case 36296:
        return setValueV4uiArray;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1Array;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3DArray;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6Array;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArrayArray;
    }
  }
  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }
  function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while (true) {
      const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
      let id2 = match[1];
      const idIsIndex = match[2] === "]", subscript = match[3];
      if (idIsIndex)
        id2 = id2 | 0;
      if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new PureArrayUniform(id2, activeInfo, addr));
        break;
      } else {
        const map3 = container.map;
        let next = map3[id2];
        if (next === void 0) {
          next = new StructuredUniform(id2);
          addUniform(container, next);
        }
        container = next;
      }
    }
  }
  function WebGLShader(gl, type3, string) {
    const shader = gl.createShader(type3);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
  }
  function handleSource(string, errorLine) {
    const lines = string.split("\n");
    const lines2 = [];
    const from = Math.max(errorLine - 6, 0);
    const to = Math.min(errorLine + 6, lines.length);
    for (let i = from; i < to; i++) {
      const line = i + 1;
      lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
    }
    return lines2.join("\n");
  }
  function getEncodingComponents(encoding) {
    switch (encoding) {
      case LinearEncoding:
        return ["Linear", "( value )"];
      case sRGBEncoding:
        return ["sRGB", "( value )"];
      default:
        console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
        return ["Linear", "( value )"];
    }
  }
  function getShaderErrors(gl, shader, type3) {
    const status = gl.getShaderParameter(shader, 35713);
    const errors = gl.getShaderInfoLog(shader).trim();
    if (status && errors === "")
      return "";
    const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
    if (errorMatches) {
      const errorLine = parseInt(errorMatches[1]);
      return type3.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
    } else {
      return errors;
    }
  }
  function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
  }
  function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = "Linear";
        break;
      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;
      case CineonToneMapping:
        toneMappingName = "OptimizedCineon";
        break;
      case ACESFilmicToneMapping:
        toneMappingName = "ACESFilmic";
        break;
      case CustomToneMapping:
        toneMappingName = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
        toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
  }
  function generateExtensions(parameters) {
    const chunks = [
      parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
      (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
      parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(defines) {
    const chunks = [];
    for (const name in defines) {
      const value = defines[name];
      if (value === false)
        continue;
      chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
  }
  function fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n = gl.getProgramParameter(program, 35721);
    for (let i = 0; i < n; i++) {
      const info = gl.getActiveAttrib(program, i);
      const name = info.name;
      let locationSize = 1;
      if (info.type === 35674)
        locationSize = 2;
      if (info.type === 35675)
        locationSize = 3;
      if (info.type === 35676)
        locationSize = 4;
      attributes[name] = {
        type: info.type,
        location: gl.getAttribLocation(program, name),
        locationSize
      };
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== "";
  }
  function replaceLightNums(string, parameters) {
    const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
  }
  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }
  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }
  function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === void 0) {
      throw new Error("Can not resolve #include <" + include + ">");
    }
    return resolveIncludes(string);
  }
  function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer);
  }
  function loopReplacer(match, start2, end, snippet) {
    let string = "";
    for (let i = parseInt(start2); i < parseInt(end); i++) {
      string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
    }
    return string;
  }
  function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") {
      precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
      precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
      precisionstring += "\n#define LOW_PRECISION";
    }
    return precisionstring;
  }
  function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    } else if (parameters.shadowMapType === VSMShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    }
    return shadowMapTypeDefine;
  }
  function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
    }
    return envMapTypeDefine;
  }
  function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeRefractionMapping:
          envMapModeDefine = "ENVMAP_MODE_REFRACTION";
          break;
      }
    }
    return envMapModeDefine;
  }
  function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) {
      switch (parameters.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
          break;
      }
    }
    return envMapBlendingDefine;
  }
  function generateCubeUVSize(parameters) {
    const imageHeight = parameters.envMapCubeUVHeight;
    if (imageHeight === null)
      return null;
    const maxMip = Math.log2(imageHeight) - 2;
    const texelHeight = 1 / imageHeight;
    const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
    return { texelWidth, texelHeight, maxMip };
  }
  function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const envMapCubeUVSize = generateCubeUVSize(parameters);
    const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
      prefixVertex = [
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixVertex.length > 0) {
        prefixVertex += "\n";
      }
      prefixFragment = [
        customExtensions,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixFragment.length > 0) {
        prefixFragment += "\n";
      }
    } else {
      prefixVertex = [
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.instancing ? "#define USE_INSTANCING" : "",
        parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
      ].filter(filterEmptyLine).join("\n");
      prefixFragment = [
        customExtensions,
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.matcap ? "#define USE_MATCAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapTypeDefine : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.envMap ? "#define " + envMapBlendingDefine : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
        envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
        parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.alphaTest ? "#define USE_ALPHATEST" : "",
        parameters.sheen ? "#define USE_SHEEN" : "",
        parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
        parameters.dithering ? "#define DITHERING" : "",
        parameters.opaque ? "#define OPAQUE" : "",
        ShaderChunk["encodings_pars_fragment"],
        getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
        parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
        "\n"
      ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
      versionString = "#version 300 es\n";
      prefixVertex = [
        "precision mediump sampler2DArray;",
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join("\n") + "\n" + prefixVertex;
      prefixFragment = [
        "#define varying in",
        parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
        parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== void 0) {
      gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl.bindAttribLocation(program, 0, "position");
    }
    gl.linkProgram(program);
    if (renderer.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, 35714) === false) {
        runnable = false;
        const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
        const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
        );
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        this.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    let cachedUniforms;
    this.getUniforms = function() {
      if (cachedUniforms === void 0) {
        cachedUniforms = new WebGLUniforms(gl, program);
      }
      return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
      if (cachedAttributes === void 0) {
        cachedAttributes = fetchAttributeLocations(gl, program);
      }
      return cachedAttributes;
    };
    this.destroy = function() {
      bindingStates.releaseStatesOfProgram(this);
      gl.deleteProgram(program);
      this.program = void 0;
    };
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  }
  function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
    const _programLayers = new Layers();
    const _customShaders = new WebGLShaderCache();
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    function getParameters(material, lights, shadows, scene, object) {
      const fog = scene.fog;
      const geometry = object.geometry;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
      const shaderID = shaderIDs[material.type];
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let morphTextureStride = 0;
      if (geometry.morphAttributes.position !== void 0)
        morphTextureStride = 1;
      if (geometry.morphAttributes.normal !== void 0)
        morphTextureStride = 2;
      if (geometry.morphAttributes.color !== void 0)
        morphTextureStride = 3;
      let vertexShader, fragmentShader;
      let customVertexShaderID, customFragmentShaderID;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        vertexShader = shader.vertexShader;
        fragmentShader = shader.fragmentShader;
      } else {
        vertexShader = material.vertexShader;
        fragmentShader = material.fragmentShader;
        _customShaders.update(material);
        customVertexShaderID = _customShaders.getVertexShaderID(material);
        customFragmentShaderID = _customShaders.getFragmentShaderID(material);
      }
      const currentRenderTarget = renderer.getRenderTarget();
      const useAlphaTest = material.alphaTest > 0;
      const useClearcoat = material.clearcoat > 0;
      const useIridescence = material.iridescence > 0;
      const parameters = {
        isWebGL2,
        shaderID,
        shaderName: material.type,
        vertexShader,
        fragmentShader,
        defines: material.defines,
        customVertexShaderID,
        customFragmentShaderID,
        isRawShaderMaterial: material.isRawShaderMaterial === true,
        glslVersion: material.glslVersion,
        precision,
        instancing: object.isInstancedMesh === true,
        instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
        supportsVertexTextures: vertexTextures,
        outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
        map: !!material.map,
        matcap: !!material.matcap,
        envMap: !!envMap,
        envMapMode: envMap && envMap.mapping,
        envMapCubeUVHeight,
        lightMap: !!material.lightMap,
        aoMap: !!material.aoMap,
        emissiveMap: !!material.emissiveMap,
        bumpMap: !!material.bumpMap,
        normalMap: !!material.normalMap,
        objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
        tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
        decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
        clearcoat: useClearcoat,
        clearcoatMap: useClearcoat && !!material.clearcoatMap,
        clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
        clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
        iridescence: useIridescence,
        iridescenceMap: useIridescence && !!material.iridescenceMap,
        iridescenceThicknessMap: useIridescence && !!material.iridescenceThicknessMap,
        displacementMap: !!material.displacementMap,
        roughnessMap: !!material.roughnessMap,
        metalnessMap: !!material.metalnessMap,
        specularMap: !!material.specularMap,
        specularIntensityMap: !!material.specularIntensityMap,
        specularColorMap: !!material.specularColorMap,
        opaque: material.transparent === false && material.blending === NormalBlending,
        alphaMap: !!material.alphaMap,
        alphaTest: useAlphaTest,
        gradientMap: !!material.gradientMap,
        sheen: material.sheen > 0,
        sheenColorMap: !!material.sheenColorMap,
        sheenRoughnessMap: !!material.sheenRoughnessMap,
        transmission: material.transmission > 0,
        transmissionMap: !!material.transmissionMap,
        thicknessMap: !!material.thicknessMap,
        combine: material.combine,
        vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
        vertexColors: material.vertexColors,
        vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
        vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
        uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
        fog: !!fog,
        useFog: material.fog === true,
        fogExp2: fog && fog.isFogExp2,
        flatShading: !!material.flatShading,
        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer,
        skinning: object.isSkinnedMesh === true,
        morphTargets: geometry.morphAttributes.position !== void 0,
        morphNormals: geometry.morphAttributes.normal !== void 0,
        morphColors: geometry.morphAttributes.color !== void 0,
        morphTargetsCount,
        morphTextureStride,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numSpotLightMaps: lights.spotLightMap.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numDirLightShadows: lights.directionalShadowMap.length,
        numPointLightShadows: lights.pointShadowMap.length,
        numSpotLightShadows: lights.spotShadowMap.length,
        numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
        numClippingPlanes: clipping.numPlanes,
        numClipIntersection: clipping.numIntersection,
        dithering: material.dithering,
        shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
        shadowMapType: renderer.shadowMap.type,
        toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
        physicallyCorrectLights: renderer.physicallyCorrectLights,
        premultipliedAlpha: material.premultipliedAlpha,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        useDepthPacking: !!material.depthPacking,
        depthPacking: material.depthPacking || 0,
        index0AttributeName: material.index0AttributeName,
        extensionDerivatives: material.extensions && material.extensions.derivatives,
        extensionFragDepth: material.extensions && material.extensions.fragDepth,
        extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
        extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
        customProgramCacheKey: material.customProgramCacheKey()
      };
      return parameters;
    }
    function getProgramCacheKey(parameters) {
      const array = [];
      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(parameters.customVertexShaderID);
        array.push(parameters.customFragmentShaderID);
      }
      if (parameters.defines !== void 0) {
        for (const name in parameters.defines) {
          array.push(name);
          array.push(parameters.defines[name]);
        }
      }
      if (parameters.isRawShaderMaterial === false) {
        getProgramCacheKeyParameters(array, parameters);
        getProgramCacheKeyBooleans(array, parameters);
        array.push(renderer.outputEncoding);
      }
      array.push(parameters.customProgramCacheKey);
      return array.join();
    }
    function getProgramCacheKeyParameters(array, parameters) {
      array.push(parameters.precision);
      array.push(parameters.outputEncoding);
      array.push(parameters.envMapMode);
      array.push(parameters.envMapCubeUVHeight);
      array.push(parameters.combine);
      array.push(parameters.vertexUvs);
      array.push(parameters.fogExp2);
      array.push(parameters.sizeAttenuation);
      array.push(parameters.morphTargetsCount);
      array.push(parameters.morphAttributeCount);
      array.push(parameters.numDirLights);
      array.push(parameters.numPointLights);
      array.push(parameters.numSpotLights);
      array.push(parameters.numSpotLightMaps);
      array.push(parameters.numHemiLights);
      array.push(parameters.numRectAreaLights);
      array.push(parameters.numDirLightShadows);
      array.push(parameters.numPointLightShadows);
      array.push(parameters.numSpotLightShadows);
      array.push(parameters.numSpotLightShadowsWithMaps);
      array.push(parameters.shadowMapType);
      array.push(parameters.toneMapping);
      array.push(parameters.numClippingPlanes);
      array.push(parameters.numClipIntersection);
      array.push(parameters.depthPacking);
    }
    function getProgramCacheKeyBooleans(array, parameters) {
      _programLayers.disableAll();
      if (parameters.isWebGL2)
        _programLayers.enable(0);
      if (parameters.supportsVertexTextures)
        _programLayers.enable(1);
      if (parameters.instancing)
        _programLayers.enable(2);
      if (parameters.instancingColor)
        _programLayers.enable(3);
      if (parameters.map)
        _programLayers.enable(4);
      if (parameters.matcap)
        _programLayers.enable(5);
      if (parameters.envMap)
        _programLayers.enable(6);
      if (parameters.lightMap)
        _programLayers.enable(7);
      if (parameters.aoMap)
        _programLayers.enable(8);
      if (parameters.emissiveMap)
        _programLayers.enable(9);
      if (parameters.bumpMap)
        _programLayers.enable(10);
      if (parameters.normalMap)
        _programLayers.enable(11);
      if (parameters.objectSpaceNormalMap)
        _programLayers.enable(12);
      if (parameters.tangentSpaceNormalMap)
        _programLayers.enable(13);
      if (parameters.clearcoat)
        _programLayers.enable(14);
      if (parameters.clearcoatMap)
        _programLayers.enable(15);
      if (parameters.clearcoatRoughnessMap)
        _programLayers.enable(16);
      if (parameters.clearcoatNormalMap)
        _programLayers.enable(17);
      if (parameters.iridescence)
        _programLayers.enable(18);
      if (parameters.iridescenceMap)
        _programLayers.enable(19);
      if (parameters.iridescenceThicknessMap)
        _programLayers.enable(20);
      if (parameters.displacementMap)
        _programLayers.enable(21);
      if (parameters.specularMap)
        _programLayers.enable(22);
      if (parameters.roughnessMap)
        _programLayers.enable(23);
      if (parameters.metalnessMap)
        _programLayers.enable(24);
      if (parameters.gradientMap)
        _programLayers.enable(25);
      if (parameters.alphaMap)
        _programLayers.enable(26);
      if (parameters.alphaTest)
        _programLayers.enable(27);
      if (parameters.vertexColors)
        _programLayers.enable(28);
      if (parameters.vertexAlphas)
        _programLayers.enable(29);
      if (parameters.vertexUvs)
        _programLayers.enable(30);
      if (parameters.vertexTangents)
        _programLayers.enable(31);
      if (parameters.uvsVertexOnly)
        _programLayers.enable(32);
      array.push(_programLayers.mask);
      _programLayers.disableAll();
      if (parameters.fog)
        _programLayers.enable(0);
      if (parameters.useFog)
        _programLayers.enable(1);
      if (parameters.flatShading)
        _programLayers.enable(2);
      if (parameters.logarithmicDepthBuffer)
        _programLayers.enable(3);
      if (parameters.skinning)
        _programLayers.enable(4);
      if (parameters.morphTargets)
        _programLayers.enable(5);
      if (parameters.morphNormals)
        _programLayers.enable(6);
      if (parameters.morphColors)
        _programLayers.enable(7);
      if (parameters.premultipliedAlpha)
        _programLayers.enable(8);
      if (parameters.shadowMapEnabled)
        _programLayers.enable(9);
      if (parameters.physicallyCorrectLights)
        _programLayers.enable(10);
      if (parameters.doubleSided)
        _programLayers.enable(11);
      if (parameters.flipSided)
        _programLayers.enable(12);
      if (parameters.useDepthPacking)
        _programLayers.enable(13);
      if (parameters.dithering)
        _programLayers.enable(14);
      if (parameters.specularIntensityMap)
        _programLayers.enable(15);
      if (parameters.specularColorMap)
        _programLayers.enable(16);
      if (parameters.transmission)
        _programLayers.enable(17);
      if (parameters.transmissionMap)
        _programLayers.enable(18);
      if (parameters.thicknessMap)
        _programLayers.enable(19);
      if (parameters.sheen)
        _programLayers.enable(20);
      if (parameters.sheenColorMap)
        _programLayers.enable(21);
      if (parameters.sheenRoughnessMap)
        _programLayers.enable(22);
      if (parameters.decodeVideoTexture)
        _programLayers.enable(23);
      if (parameters.opaque)
        _programLayers.enable(24);
      array.push(_programLayers.mask);
    }
    function getUniforms(material) {
      const shaderID = shaderIDs[material.type];
      let uniforms;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        uniforms = UniformsUtils.clone(shader.uniforms);
      } else {
        uniforms = material.uniforms;
      }
      return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
      let program;
      for (let p = 0, pl = programs.length; p < pl; p++) {
        const preexistingProgram = programs[p];
        if (preexistingProgram.cacheKey === cacheKey) {
          program = preexistingProgram;
          ++program.usedTimes;
          break;
        }
      }
      if (program === void 0) {
        program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
        programs.push(program);
      }
      return program;
    }
    function releaseProgram(program) {
      if (--program.usedTimes === 0) {
        const i = programs.indexOf(program);
        programs[i] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    }
    function releaseShaderCache(material) {
      _customShaders.remove(material);
    }
    function dispose() {
      _customShaders.dispose();
    }
    return {
      getParameters,
      getProgramCacheKey,
      getUniforms,
      acquireProgram,
      releaseProgram,
      releaseShaderCache,
      programs,
      dispose
    };
  }
  function WebGLProperties() {
    let properties = /* @__PURE__ */ new WeakMap();
    function get(object) {
      let map3 = properties.get(object);
      if (map3 === void 0) {
        map3 = {};
        properties.set(object, map3);
      }
      return map3;
    }
    function remove3(object) {
      properties.delete(object);
    }
    function update(object, key, value) {
      properties.get(object)[key] = value;
    }
    function dispose() {
      properties = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      remove: remove3,
      update,
      dispose
    };
  }
  function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.material.id !== b.material.id) {
      return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
      return a.z - b.z;
    } else {
      return a.id - b.id;
    }
  }
  function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }
  function WebGLRenderList() {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transmissive = [];
    const transparent = [];
    function init() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transmissive.length = 0;
      transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
      let renderItem = renderItems[renderItemsIndex];
      if (renderItem === void 0) {
        renderItem = {
          id: object.id,
          object,
          geometry,
          material,
          groupOrder,
          renderOrder: object.renderOrder,
          z,
          group
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z;
        renderItem.group = group;
      }
      renderItemsIndex++;
      return renderItem;
    }
    function push(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      if (material.transmission > 0) {
        transmissive.push(renderItem);
      } else if (material.transparent === true) {
        transparent.push(renderItem);
      } else {
        opaque.push(renderItem);
      }
    }
    function unshift(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      if (material.transmission > 0) {
        transmissive.unshift(renderItem);
      } else if (material.transparent === true) {
        transparent.unshift(renderItem);
      } else {
        opaque.unshift(renderItem);
      }
    }
    function sort(customOpaqueSort, customTransparentSort) {
      if (opaque.length > 1)
        opaque.sort(customOpaqueSort || painterSortStable);
      if (transmissive.length > 1)
        transmissive.sort(customTransparentSort || reversePainterSortStable);
      if (transparent.length > 1)
        transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
      for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
        const renderItem = renderItems[i];
        if (renderItem.id === null)
          break;
        renderItem.id = null;
        renderItem.object = null;
        renderItem.geometry = null;
        renderItem.material = null;
        renderItem.group = null;
      }
    }
    return {
      opaque,
      transmissive,
      transparent,
      init,
      push,
      unshift,
      finish,
      sort
    };
  }
  function WebGLRenderLists() {
    let lists = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth) {
      const listArray = lists.get(scene);
      let list;
      if (listArray === void 0) {
        list = new WebGLRenderList();
        lists.set(scene, [list]);
      } else {
        if (renderCallDepth >= listArray.length) {
          list = new WebGLRenderList();
          listArray.push(list);
        } else {
          list = listArray[renderCallDepth];
        }
      }
      return list;
    }
    function dispose() {
      lists = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function UniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              direction: new Vector3(),
              color: new Color()
            };
            break;
          case "SpotLight":
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;
          case "RectAreaLight":
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function ShadowUniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "SpotLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "PointLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
  }
  function WebGLLights(extensions, capabilities) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state2 = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0
    };
    for (let i = 0; i < 9; i++)
      state2.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights, physicallyCorrectLights) {
      let r = 0, g = 0, b = 0;
      for (let i = 0; i < 9; i++)
        state2.probe[i].set(0, 0, 0);
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      let numDirectionalShadows = 0;
      let numPointShadows = 0;
      let numSpotShadows = 0;
      let numSpotMaps = 0;
      let numSpotShadowsWithMaps = 0;
      lights.sort(shadowCastingAndTexturingLightsFirst);
      const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
      for (let i = 0, l = lights.length; i < l; i++) {
        const light = lights[i];
        const color = light.color;
        const intensity = light.intensity;
        const distance = light.distance;
        const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
        if (light.isAmbientLight) {
          r += color.r * intensity * scaleFactor;
          g += color.g * intensity * scaleFactor;
          b += color.b * intensity * scaleFactor;
        } else if (light.isLightProbe) {
          for (let j = 0; j < 9; j++) {
            state2.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
          }
        } else if (light.isDirectionalLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state2.directionalShadow[directionalLength] = shadowUniforms;
            state2.directionalShadowMap[directionalLength] = shadowMap;
            state2.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
            numDirectionalShadows++;
          }
          state2.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
          uniforms.distance = distance;
          uniforms.coneCos = Math.cos(light.angle);
          uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
          uniforms.decay = light.decay;
          state2.spot[spotLength] = uniforms;
          const shadow = light.shadow;
          if (light.map) {
            state2.spotLightMap[numSpotMaps] = light.map;
            numSpotMaps++;
            shadow.updateMatrices(light);
            if (light.castShadow)
              numSpotShadowsWithMaps++;
          }
          state2.spotLightMatrix[spotLength] = shadow.matrix;
          if (light.castShadow) {
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state2.spotShadow[spotLength] = shadowUniforms;
            state2.spotShadowMap[spotLength] = shadowMap;
            numSpotShadows++;
          }
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          state2.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
          uniforms.distance = light.distance;
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            shadowUniforms.shadowCameraNear = shadow.camera.near;
            shadowUniforms.shadowCameraFar = shadow.camera.far;
            state2.pointShadow[pointLength] = shadowUniforms;
            state2.pointShadowMap[pointLength] = shadowMap;
            state2.pointShadowMatrix[pointLength] = light.shadow.matrix;
            numPointShadows++;
          }
          state2.point[pointLength] = uniforms;
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = cache.get(light);
          uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
          uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
          state2.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }
      if (rectAreaLength > 0) {
        if (capabilities.isWebGL2) {
          state2.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state2.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else {
          if (extensions.has("OES_texture_float_linear") === true) {
            state2.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
            state2.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
          } else if (extensions.has("OES_texture_half_float_linear") === true) {
            state2.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
            state2.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
          } else {
            console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
          }
        }
      }
      state2.ambient[0] = r;
      state2.ambient[1] = g;
      state2.ambient[2] = b;
      const hash = state2.hash;
      if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps) {
        state2.directional.length = directionalLength;
        state2.spot.length = spotLength;
        state2.rectArea.length = rectAreaLength;
        state2.point.length = pointLength;
        state2.hemi.length = hemiLength;
        state2.directionalShadow.length = numDirectionalShadows;
        state2.directionalShadowMap.length = numDirectionalShadows;
        state2.pointShadow.length = numPointShadows;
        state2.pointShadowMap.length = numPointShadows;
        state2.spotShadow.length = numSpotShadows;
        state2.spotShadowMap.length = numSpotShadows;
        state2.directionalShadowMatrix.length = numDirectionalShadows;
        state2.pointShadowMatrix.length = numPointShadows;
        state2.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
        state2.spotLightMap.length = numSpotMaps;
        state2.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
        hash.directionalLength = directionalLength;
        hash.pointLength = pointLength;
        hash.spotLength = spotLength;
        hash.rectAreaLength = rectAreaLength;
        hash.hemiLength = hemiLength;
        hash.numDirectionalShadows = numDirectionalShadows;
        hash.numPointShadows = numPointShadows;
        hash.numSpotShadows = numSpotShadows;
        hash.numSpotMaps = numSpotMaps;
        state2.version = nextVersion++;
      }
    }
    function setupView(lights, camera) {
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      const viewMatrix = camera.matrixWorldInverse;
      for (let i = 0, l = lights.length; i < l; i++) {
        const light = lights[i];
        if (light.isDirectionalLight) {
          const uniforms = state2.directional[directionalLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = state2.spot[spotLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = state2.rectArea[rectAreaLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = state2.point[pointLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = state2.hemi[hemiLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          hemiLength++;
        }
      }
    }
    return {
      setup,
      setupView,
      state: state2
    };
  }
  function WebGLRenderState(extensions, capabilities) {
    const lights = new WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }
    function pushLight(light) {
      lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }
    function setupLights(physicallyCorrectLights) {
      lights.setup(lightsArray, physicallyCorrectLights);
    }
    function setupLightsView(camera) {
      lights.setupView(lightsArray, camera);
    }
    const state2 = {
      lightsArray,
      shadowsArray,
      lights
    };
    return {
      init,
      state: state2,
      setupLights,
      setupLightsView,
      pushLight,
      pushShadow
    };
  }
  function WebGLRenderStates(extensions, capabilities) {
    let renderStates = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth = 0) {
      const renderStateArray = renderStates.get(scene);
      let renderState;
      if (renderStateArray === void 0) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.set(scene, [renderState]);
      } else {
        if (renderCallDepth >= renderStateArray.length) {
          renderState = new WebGLRenderState(extensions, capabilities);
          renderStateArray.push(renderState);
        } else {
          renderState = renderStateArray[renderCallDepth];
        }
      }
      return renderState;
    }
    function dispose() {
      renderStates = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function WebGLShadowMap(_renderer, _objects, _capabilities) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
    const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
    const shadowMaterialVertical = new ShaderMaterial({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 }
      },
      vertexShader: vertex,
      fragmentShader: fragment
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute(
      "position",
      new BufferAttribute(
        new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
        3
      )
    );
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
      if (scope.enabled === false)
        return;
      if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
      if (lights.length === 0)
        return;
      const currentRenderTarget = _renderer.getRenderTarget();
      const activeCubeFace = _renderer.getActiveCubeFace();
      const activeMipmapLevel = _renderer.getActiveMipmapLevel();
      const _state = _renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      for (let i = 0, il = lights.length; i < il; i++) {
        const light = lights[i];
        const shadow = light.shadow;
        if (shadow === void 0) {
          console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
          continue;
        }
        if (shadow.autoUpdate === false && shadow.needsUpdate === false)
          continue;
        _shadowMapSize.copy(shadow.mapSize);
        const shadowFrameExtents = shadow.getFrameExtents();
        _shadowMapSize.multiply(shadowFrameExtents);
        _viewportSize.copy(shadow.mapSize);
        if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
          if (_shadowMapSize.x > _maxTextureSize) {
            _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
            shadow.mapSize.x = _viewportSize.x;
          }
          if (_shadowMapSize.y > _maxTextureSize) {
            _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
            shadow.mapSize.y = _viewportSize.y;
          }
        }
        if (shadow.map === null) {
          const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.camera.updateProjectionMatrix();
        }
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        const viewportCount = shadow.getViewportCount();
        for (let vp = 0; vp < viewportCount; vp++) {
          const viewport = shadow.getViewport(vp);
          _viewport.set(
            _viewportSize.x * viewport.x,
            _viewportSize.y * viewport.y,
            _viewportSize.x * viewport.z,
            _viewportSize.y * viewport.w
          );
          _state.viewport(_viewport);
          shadow.updateMatrices(light, vp);
          _frustum = shadow.getFrustum();
          renderObject(scene, camera, shadow.camera, light, this.type);
        }
        if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
          VSMPass(shadow, camera);
        }
        shadow.needsUpdate = false;
      }
      scope.needsUpdate = false;
      _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
      const geometry = _objects.update(fullScreenMesh);
      if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
        shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialVertical.needsUpdate = true;
        shadowMaterialHorizontal.needsUpdate = true;
      }
      if (shadow.mapPass === null) {
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
      }
      shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
      shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialVertical.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.mapPass);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
      shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
      shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type3) {
      let result = null;
      const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
      if (customMaterial !== void 0) {
        result = customMaterial;
      } else {
        result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
        if (_renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
          const keyA = result.uuid, keyB = material.uuid;
          let materialsForVariant = _materialCache[keyA];
          if (materialsForVariant === void 0) {
            materialsForVariant = {};
            _materialCache[keyA] = materialsForVariant;
          }
          let cachedMaterial = materialsForVariant[keyB];
          if (cachedMaterial === void 0) {
            cachedMaterial = result.clone();
            materialsForVariant[keyB] = cachedMaterial;
          }
          result = cachedMaterial;
        }
      }
      result.visible = material.visible;
      result.wireframe = material.wireframe;
      if (type3 === VSMShadowMap) {
        result.side = material.shadowSide !== null ? material.shadowSide : material.side;
      } else {
        result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
      }
      result.alphaMap = material.alphaMap;
      result.alphaTest = material.alphaTest;
      result.map = material.map;
      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.displacementMap = material.displacementMap;
      result.displacementScale = material.displacementScale;
      result.displacementBias = material.displacementBias;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;
      if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
        result.referencePosition.setFromMatrixPosition(light.matrixWorld);
        result.nearDistance = shadowCameraNear;
        result.farDistance = shadowCameraFar;
      }
      return result;
    }
    function renderObject(object, camera, shadowCamera, light, type3) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if ((object.castShadow || object.receiveShadow && type3 === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          const geometry = _objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let k = 0, kl = groups.length; k < kl; k++) {
              const group = groups[k];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type3);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              }
            }
          } else if (material.visible) {
            const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type3);
            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        renderObject(children[i], camera, shadowCamera, light, type3);
      }
    }
  }
  function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
      let locked = false;
      const color = new Vector4();
      let currentColorMask = null;
      const currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(r, g, b, a, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b *= a;
          }
          color.set(r, g, b, a);
          if (currentColorClear.equals(color) === false) {
            gl.clearColor(r, g, b, a);
            currentColorClear.copy(color);
          }
        },
        reset: function() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }
    function DepthBuffer() {
      let locked = false;
      let currentDepthMask = null;
      let currentDepthFunc = null;
      let currentDepthClear = null;
      return {
        setTest: function(depthTest) {
          if (depthTest) {
            enable(2929);
          } else {
            disable(2929);
          }
        },
        setMask: function(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function(depthFunc) {
          if (currentDepthFunc !== depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(depth) {
          if (currentDepthClear !== depth) {
            gl.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
        }
      };
    }
    function StencilBuffer() {
      let locked = false;
      let currentStencilMask = null;
      let currentStencilFunc = null;
      let currentStencilRef = null;
      let currentStencilFuncMask = null;
      let currentStencilFail = null;
      let currentStencilZFail = null;
      let currentStencilZPass = null;
      let currentStencilClear = null;
      return {
        setTest: function(stencilTest) {
          if (!locked) {
            if (stencilTest) {
              enable(2960);
            } else {
              disable(2960);
            }
          }
        },
        setMask: function(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(stencil) {
          if (currentStencilClear !== stencil) {
            gl.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    const uboBindings = /* @__PURE__ */ new WeakMap();
    const uboProgramMap = /* @__PURE__ */ new WeakMap();
    let enabledCapabilities = {};
    let currentBoundFramebuffers = {};
    let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    let defaultDrawbuffers = [];
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf("WebGL") !== -1) {
      version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
      version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const scissorParam = gl.getParameter(3088);
    const viewportParam = gl.getParameter(2978);
    const currentScissor = new Vector4().fromArray(scissorParam);
    const currentViewport = new Vector4().fromArray(viewportParam);
    function createTexture(type3, target, count) {
      const data = new Uint8Array(4);
      const texture = gl.createTexture();
      gl.bindTexture(type3, texture);
      gl.texParameteri(type3, 10241, 9728);
      gl.texParameteri(type3, 10240, 9728);
      for (let i = 0; i < count; i++) {
        gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
      }
      return texture;
    }
    const emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    function enable(id2) {
      if (enabledCapabilities[id2] !== true) {
        gl.enable(id2);
        enabledCapabilities[id2] = true;
      }
    }
    function disable(id2) {
      if (enabledCapabilities[id2] !== false) {
        gl.disable(id2);
        enabledCapabilities[id2] = false;
      }
    }
    function bindFramebuffer(target, framebuffer) {
      if (currentBoundFramebuffers[target] !== framebuffer) {
        gl.bindFramebuffer(target, framebuffer);
        currentBoundFramebuffers[target] = framebuffer;
        if (isWebGL2) {
          if (target === 36009) {
            currentBoundFramebuffers[36160] = framebuffer;
          }
          if (target === 36160) {
            currentBoundFramebuffers[36009] = framebuffer;
          }
        }
        return true;
      }
      return false;
    }
    function drawBuffers(renderTarget, framebuffer) {
      let drawBuffers2 = defaultDrawbuffers;
      let needsUpdate = false;
      if (renderTarget) {
        drawBuffers2 = currentDrawbuffers.get(framebuffer);
        if (drawBuffers2 === void 0) {
          drawBuffers2 = [];
          currentDrawbuffers.set(framebuffer, drawBuffers2);
        }
        if (renderTarget.isWebGLMultipleRenderTargets) {
          const textures = renderTarget.texture;
          if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== 36064) {
            for (let i = 0, il = textures.length; i < il; i++) {
              drawBuffers2[i] = 36064 + i;
            }
            drawBuffers2.length = textures.length;
            needsUpdate = true;
          }
        } else {
          if (drawBuffers2[0] !== 36064) {
            drawBuffers2[0] = 36064;
            needsUpdate = true;
          }
        }
      } else {
        if (drawBuffers2[0] !== 1029) {
          drawBuffers2[0] = 1029;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        if (capabilities.isWebGL2) {
          gl.drawBuffers(drawBuffers2);
        } else {
          extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
        }
      }
    }
    function useProgram(program) {
      if (currentProgram !== program) {
        gl.useProgram(program);
        currentProgram = program;
        return true;
      }
      return false;
    }
    const equationToGL = {
      [AddEquation]: 32774,
      [SubtractEquation]: 32778,
      [ReverseSubtractEquation]: 32779
    };
    if (isWebGL2) {
      equationToGL[MinEquation] = 32775;
      equationToGL[MaxEquation] = 32776;
    } else {
      const extension = extensions.get("EXT_blend_minmax");
      if (extension !== null) {
        equationToGL[MinEquation] = extension.MIN_EXT;
        equationToGL[MaxEquation] = extension.MAX_EXT;
      }
    }
    const factorToGL = {
      [ZeroFactor]: 0,
      [OneFactor]: 1,
      [SrcColorFactor]: 768,
      [SrcAlphaFactor]: 770,
      [SrcAlphaSaturateFactor]: 776,
      [DstColorFactor]: 774,
      [DstAlphaFactor]: 772,
      [OneMinusSrcColorFactor]: 769,
      [OneMinusSrcAlphaFactor]: 771,
      [OneMinusDstColorFactor]: 775,
      [OneMinusDstAlphaFactor]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled === true) {
          disable(3042);
          currentBlendingEnabled = false;
        }
        return;
      }
      if (currentBlendingEnabled === false) {
        enable(3042);
        currentBlendingEnabled = true;
      }
      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl.blendEquation(32774);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }
          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(1, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(1, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 769, 0, 1);
                break;
              case MultiplyBlending:
                gl.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(770, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(770, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 769, 0, 1);
                break;
              case MultiplyBlending:
                gl.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          }
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }
        return;
      }
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
      currentBlending = blending;
      currentPremultipledAlpha = false;
    }
    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(2884) : enable(2884);
      let flipSided = material.side === BackSide;
      if (frontFaceCW)
        flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      const stencilWrite = material.stencilWrite;
      stencilBuffer.setTest(stencilWrite);
      if (stencilWrite) {
        stencilBuffer.setMask(material.stencilWriteMask);
        stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
        stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
      }
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      material.alphaToCoverage === true ? enable(32926) : disable(32926);
    }
    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl.frontFace(2304);
        } else {
          gl.frontFace(2305);
        }
        currentFlipSided = flipSided;
      }
    }
    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(2884);
        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl.cullFace(1029);
          } else if (cullFace === CullFaceFront) {
            gl.cullFace(1028);
          } else {
            gl.cullFace(1032);
          }
        }
      } else {
        disable(2884);
      }
      currentCullFace = cullFace;
    }
    function setLineWidth(width2) {
      if (width2 !== currentLineWidth) {
        if (lineWidthAvailable)
          gl.lineWidth(width2);
        currentLineWidth = width2;
      }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(32823);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(32823);
      }
    }
    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(3089);
      } else {
        disable(3089);
      }
    }
    function activeTexture(webglSlot) {
      if (webglSlot === void 0)
        webglSlot = 33984 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }
    function bindTexture(webglType, webglTexture, webglSlot) {
      if (webglSlot === void 0) {
        if (currentTextureSlot === null) {
          webglSlot = 33984 + maxTextures - 1;
        } else {
          webglSlot = currentTextureSlot;
        }
      }
      let boundTexture = currentBoundTextures[webglSlot];
      if (boundTexture === void 0) {
        boundTexture = { type: void 0, texture: void 0 };
        currentBoundTextures[webglSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        if (currentTextureSlot !== webglSlot) {
          gl.activeTexture(webglSlot);
          currentTextureSlot = webglSlot;
        }
        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }
    function unbindTexture() {
      const boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture !== void 0 && boundTexture.type !== void 0) {
        gl.bindTexture(boundTexture.type, null);
        boundTexture.type = void 0;
        boundTexture.texture = void 0;
      }
    }
    function compressedTexImage2D() {
      try {
        gl.compressedTexImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexImage3D() {
      try {
        gl.compressedTexImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage2D() {
      try {
        gl.texSubImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage3D() {
      try {
        gl.texSubImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexSubImage2D() {
      try {
        gl.compressedTexSubImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexSubImage3D() {
      try {
        gl.compressedTexSubImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage2D() {
      try {
        gl.texStorage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage3D() {
      try {
        gl.texStorage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage2D() {
      try {
        gl.texImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage3D() {
      try {
        gl.texImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function scissor(scissor2) {
      if (currentScissor.equals(scissor2) === false) {
        gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
        currentScissor.copy(scissor2);
      }
    }
    function viewport(viewport2) {
      if (currentViewport.equals(viewport2) === false) {
        gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
        currentViewport.copy(viewport2);
      }
    }
    function updateUBOMapping(uniformsGroup, program) {
      let mapping = uboProgramMap.get(program);
      if (mapping === void 0) {
        mapping = /* @__PURE__ */ new WeakMap();
        uboProgramMap.set(program, mapping);
      }
      let blockIndex = mapping.get(uniformsGroup);
      if (blockIndex === void 0) {
        blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
        mapping.set(uniformsGroup, blockIndex);
      }
    }
    function uniformBlockBinding(uniformsGroup, program) {
      const mapping = uboProgramMap.get(program);
      const blockIndex = mapping.get(uniformsGroup);
      if (uboBindings.get(program) !== blockIndex) {
        gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
        uboBindings.set(program, blockIndex);
      }
    }
    function reset() {
      gl.disable(3042);
      gl.disable(2884);
      gl.disable(2929);
      gl.disable(32823);
      gl.disable(3089);
      gl.disable(2960);
      gl.disable(32926);
      gl.blendEquation(32774);
      gl.blendFunc(1, 0);
      gl.blendFuncSeparate(1, 0, 1, 0);
      gl.colorMask(true, true, true, true);
      gl.clearColor(0, 0, 0, 0);
      gl.depthMask(true);
      gl.depthFunc(513);
      gl.clearDepth(1);
      gl.stencilMask(4294967295);
      gl.stencilFunc(519, 0, 4294967295);
      gl.stencilOp(7680, 7680, 7680);
      gl.clearStencil(0);
      gl.cullFace(1029);
      gl.frontFace(2305);
      gl.polygonOffset(0, 0);
      gl.activeTexture(33984);
      gl.bindFramebuffer(36160, null);
      if (isWebGL2 === true) {
        gl.bindFramebuffer(36009, null);
        gl.bindFramebuffer(36008, null);
      }
      gl.useProgram(null);
      gl.lineWidth(1);
      gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      enabledCapabilities = {};
      currentTextureSlot = null;
      currentBoundTextures = {};
      currentBoundFramebuffers = {};
      currentDrawbuffers = /* @__PURE__ */ new WeakMap();
      defaultDrawbuffers = [];
      currentProgram = null;
      currentBlendingEnabled = false;
      currentBlending = null;
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
      currentPremultipledAlpha = false;
      currentFlipSided = null;
      currentCullFace = null;
      currentLineWidth = null;
      currentPolygonOffsetFactor = null;
      currentPolygonOffsetUnits = null;
      currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
      currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }
    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      enable,
      disable,
      bindFramebuffer,
      drawBuffers,
      useProgram,
      setBlending,
      setMaterial,
      setFlipSided,
      setCullFace,
      setLineWidth,
      setPolygonOffset,
      setScissorTest,
      activeTexture,
      bindTexture,
      unbindTexture,
      compressedTexImage2D,
      compressedTexImage3D,
      texImage2D,
      texImage3D,
      updateUBOMapping,
      uniformBlockBinding,
      texStorage2D,
      texStorage3D,
      texSubImage2D,
      texSubImage3D,
      compressedTexSubImage2D,
      compressedTexSubImage3D,
      scissor,
      viewport,
      reset
    };
  }
  function WebGLTextures(_gl, extensions, state2, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
    const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
    const _videoTextures = /* @__PURE__ */ new WeakMap();
    let _canvas2;
    const _sources = /* @__PURE__ */ new WeakMap();
    let useOffscreenCanvas = false;
    try {
      useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width2, height2) {
      return useOffscreenCanvas ? new OffscreenCanvas(width2, height2) : createElementNS("canvas");
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
      let scale = 1;
      if (image.width > maxSize || image.height > maxSize) {
        scale = maxSize / Math.max(image.width, image.height);
      }
      if (scale < 1 || needsPowerOfTwo === true) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
          const width2 = floor(scale * image.width);
          const height2 = floor(scale * image.height);
          if (_canvas2 === void 0)
            _canvas2 = createCanvas(width2, height2);
          const canvas = needsNewCanvas ? createCanvas(width2, height2) : _canvas2;
          canvas.width = width2;
          canvas.height = height2;
          const context = canvas.getContext("2d");
          context.drawImage(image, 0, 0, width2, height2);
          console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width2 + "x" + height2 + ").");
          return canvas;
        } else {
          if ("data" in image) {
            console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
          }
          return image;
        }
      }
      return image;
    }
    function isPowerOfTwo$1(image) {
      return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
      if (isWebGL2)
        return false;
      return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
      return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target) {
      _gl.generateMipmap(target);
    }
    function getInternalFormat(internalFormatName, glFormat, glType, encoding, forceLinearEncoding = false) {
      if (isWebGL2 === false)
        return glFormat;
      if (internalFormatName !== null) {
        if (_gl[internalFormatName] !== void 0)
          return _gl[internalFormatName];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
      }
      let internalFormat = glFormat;
      if (glFormat === 6403) {
        if (glType === 5126)
          internalFormat = 33326;
        if (glType === 5131)
          internalFormat = 33325;
        if (glType === 5121)
          internalFormat = 33321;
      }
      if (glFormat === 33319) {
        if (glType === 5126)
          internalFormat = 33328;
        if (glType === 5131)
          internalFormat = 33327;
        if (glType === 5121)
          internalFormat = 33323;
      }
      if (glFormat === 6408) {
        if (glType === 5126)
          internalFormat = 34836;
        if (glType === 5131)
          internalFormat = 34842;
        if (glType === 5121)
          internalFormat = encoding === sRGBEncoding && forceLinearEncoding === false ? 35907 : 32856;
        if (glType === 32819)
          internalFormat = 32854;
        if (glType === 32820)
          internalFormat = 32855;
      }
      if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836) {
        extensions.get("EXT_color_buffer_float");
      }
      return internalFormat;
    }
    function getMipLevels(texture, image, supportsMips) {
      if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        return Math.log2(Math.max(image.width, image.height)) + 1;
      } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
        return texture.mipmaps.length;
      } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
        return image.mipmaps.length;
      } else {
        return 1;
      }
    }
    function filterFallback(f) {
      if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
        return 9728;
      }
      return 9729;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      deallocateTexture(texture);
      if (texture.isVideoTexture) {
        _videoTextures.delete(texture);
      }
    }
    function onRenderTargetDispose(event) {
      const renderTarget = event.target;
      renderTarget.removeEventListener("dispose", onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
    }
    function deallocateTexture(texture) {
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === void 0)
        return;
      const source = texture.source;
      const webglTextures = _sources.get(source);
      if (webglTextures) {
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        webglTexture.usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
        if (Object.keys(webglTextures).length === 0) {
          _sources.delete(source);
        }
      }
      properties.remove(texture);
    }
    function deleteTexture(texture) {
      const textureProperties = properties.get(texture);
      _gl.deleteTexture(textureProperties.__webglTexture);
      const source = texture.source;
      const webglTextures = _sources.get(source);
      delete webglTextures[textureProperties.__cacheKey];
      info.memory.textures--;
    }
    function deallocateRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglTexture !== void 0) {
        _gl.deleteTexture(textureProperties.__webglTexture);
        info.memory.textures--;
      }
      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
      }
      if (renderTarget.isWebGLCubeRenderTarget) {
        for (let i = 0; i < 6; i++) {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
        }
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        if (renderTargetProperties.__webglMultisampledFramebuffer)
          _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
        if (renderTargetProperties.__webglColorRenderbuffer) {
          for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
            if (renderTargetProperties.__webglColorRenderbuffer[i])
              _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
          }
        }
        if (renderTargetProperties.__webglDepthRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        for (let i = 0, il = texture.length; i < il; i++) {
          const attachmentProperties = properties.get(texture[i]);
          if (attachmentProperties.__webglTexture) {
            _gl.deleteTexture(attachmentProperties.__webglTexture);
            info.memory.textures--;
          }
          properties.remove(texture[i]);
        }
      }
      properties.remove(texture);
      properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
      textureUnits = 0;
    }
    function allocateTextureUnit() {
      const textureUnit = textureUnits;
      if (textureUnit >= maxTextures) {
        console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
      }
      textureUnits += 1;
      return textureUnit;
    }
    function getTextureCacheKey(texture) {
      const array = [];
      array.push(texture.wrapS);
      array.push(texture.wrapT);
      array.push(texture.wrapR || 0);
      array.push(texture.magFilter);
      array.push(texture.minFilter);
      array.push(texture.anisotropy);
      array.push(texture.internalFormat);
      array.push(texture.format);
      array.push(texture.type);
      array.push(texture.generateMipmaps);
      array.push(texture.premultiplyAlpha);
      array.push(texture.flipY);
      array.push(texture.unpackAlignment);
      array.push(texture.encoding);
      return array.join();
    }
    function setTexture2D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.isVideoTexture)
        updateVideoTexture(texture);
      if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
        const image = texture.image;
        if (image === null) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        } else if (image.complete === false) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }
      state2.bindTexture(3553, textureProperties.__webglTexture, 33984 + slot);
    }
    function setTexture2DArray(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state2.bindTexture(35866, textureProperties.__webglTexture, 33984 + slot);
    }
    function setTexture3D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state2.bindTexture(32879, textureProperties.__webglTexture, 33984 + slot);
    }
    function setTextureCube(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadCubeTexture(textureProperties, texture, slot);
        return;
      }
      state2.bindTexture(34067, textureProperties.__webglTexture, 33984 + slot);
    }
    const wrappingToGL = {
      [RepeatWrapping]: 10497,
      [ClampToEdgeWrapping]: 33071,
      [MirroredRepeatWrapping]: 33648
    };
    const filterToGL = {
      [NearestFilter]: 9728,
      [NearestMipmapNearestFilter]: 9984,
      [NearestMipmapLinearFilter]: 9986,
      [LinearFilter]: 9729,
      [LinearMipmapNearestFilter]: 9985,
      [LinearMipmapLinearFilter]: 9987
    };
    function setTextureParameters(textureType, texture, supportsMips) {
      if (supportsMips) {
        _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
        _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
        }
        _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
        _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
      } else {
        _gl.texParameteri(textureType, 10242, 33071);
        _gl.texParameteri(textureType, 10243, 33071);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, 33071);
        }
        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
        }
        _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
        _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
        }
      }
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        if (texture.magFilter === NearestFilter)
          return;
        if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter)
          return;
        if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
          return;
        if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
          return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function initTexture(textureProperties, texture) {
      let forceUpload = false;
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
      }
      const source = texture.source;
      let webglTextures = _sources.get(source);
      if (webglTextures === void 0) {
        webglTextures = {};
        _sources.set(source, webglTextures);
      }
      const textureCacheKey = getTextureCacheKey(texture);
      if (textureCacheKey !== textureProperties.__cacheKey) {
        if (webglTextures[textureCacheKey] === void 0) {
          webglTextures[textureCacheKey] = {
            texture: _gl.createTexture(),
            usedTimes: 0
          };
          info.memory.textures++;
          forceUpload = true;
        }
        webglTextures[textureCacheKey].usedTimes++;
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        if (webglTexture !== void 0) {
          webglTextures[textureProperties.__cacheKey].usedTimes--;
          if (webglTexture.usedTimes === 0) {
            deleteTexture(texture);
          }
        }
        textureProperties.__cacheKey = textureCacheKey;
        textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
      }
      return forceUpload;
    }
    function uploadTexture(textureProperties, texture, slot) {
      let textureType = 3553;
      if (texture.isDataArrayTexture || texture.isCompressedArrayTexture)
        textureType = 35866;
      if (texture.isData3DTexture)
        textureType = 32879;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state2.bindTexture(textureType, textureProperties.__webglTexture, 33984 + slot);
      const sourceProperties = properties.get(source);
      if (source.version !== sourceProperties.__version || forceUpload === true) {
        state2.activeTexture(33984 + slot);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
        let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        image = verifyColorSpace(texture, image);
        const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding);
        let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
        setTextureParameters(textureType, texture, supportsMips);
        let mipmap;
        const mipmaps = texture.mipmaps;
        const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
        const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
        const levels = getMipLevels(texture, image, supportsMips);
        if (texture.isDepthTexture) {
          glInternalFormat = 6402;
          if (isWebGL2) {
            if (texture.type === FloatType) {
              glInternalFormat = 36012;
            } else if (texture.type === UnsignedIntType) {
              glInternalFormat = 33190;
            } else if (texture.type === UnsignedInt248Type) {
              glInternalFormat = 35056;
            } else {
              glInternalFormat = 33189;
            }
          } else {
            if (texture.type === FloatType) {
              console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
            }
          }
          if (texture.format === DepthFormat && glInternalFormat === 6402) {
            if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
              console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
              texture.type = UnsignedIntType;
              glType = utils.convert(texture.type);
            }
          }
          if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
            glInternalFormat = 34041;
            if (texture.type !== UnsignedInt248Type) {
              console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
              texture.type = UnsignedInt248Type;
              glType = utils.convert(texture.type);
            }
          }
          if (allocateMemory) {
            if (useTexStorage) {
              state2.texStorage2D(3553, 1, glInternalFormat, image.width, image.height);
            } else {
              state2.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
            }
          }
        } else if (texture.isDataTexture) {
          if (mipmaps.length > 0 && supportsMips) {
            if (useTexStorage && allocateMemory) {
              state2.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (useTexStorage) {
                state2.texSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state2.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                state2.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
              }
              state2.texSubImage2D(3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
            } else {
              state2.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
            }
          }
        } else if (texture.isCompressedTexture) {
          if (texture.isCompressedArrayTexture) {
            if (useTexStorage && allocateMemory) {
              state2.texStorage3D(35866, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    state2.compressedTexSubImage3D(35866, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
                  } else {
                    state2.compressedTexImage3D(35866, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                }
              } else {
                if (useTexStorage) {
                  state2.texSubImage3D(35866, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
                } else {
                  state2.texImage3D(35866, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          } else {
            if (useTexStorage && allocateMemory) {
              state2.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    state2.compressedTexSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  } else {
                    state2.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                }
              } else {
                if (useTexStorage) {
                  state2.texSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                } else {
                  state2.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
        } else if (texture.isDataArrayTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state2.texStorage3D(35866, levels, glInternalFormat, image.width, image.height, image.depth);
            }
            state2.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          } else {
            state2.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          }
        } else if (texture.isData3DTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state2.texStorage3D(32879, levels, glInternalFormat, image.width, image.height, image.depth);
            }
            state2.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          } else {
            state2.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          }
        } else if (texture.isFramebufferTexture) {
          if (allocateMemory) {
            if (useTexStorage) {
              state2.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            } else {
              let width2 = image.width, height2 = image.height;
              for (let i = 0; i < levels; i++) {
                state2.texImage2D(3553, i, glInternalFormat, width2, height2, 0, glFormat, glType, null);
                width2 >>= 1;
                height2 >>= 1;
              }
            }
          }
        } else {
          if (mipmaps.length > 0 && supportsMips) {
            if (useTexStorage && allocateMemory) {
              state2.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (useTexStorage) {
                state2.texSubImage2D(3553, i, 0, 0, glFormat, glType, mipmap);
              } else {
                state2.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                state2.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
              }
              state2.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
            } else {
              state2.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(textureType);
        }
        sourceProperties.__version = source.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
      if (texture.image.length !== 6)
        return;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state2.bindTexture(34067, textureProperties.__webglTexture, 33984 + slot);
      const sourceProperties = properties.get(source);
      if (source.version !== sourceProperties.__version || forceUpload === true) {
        state2.activeTexture(33984 + slot);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
        const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        const cubeImage = [];
        for (let i = 0; i < 6; i++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
          } else {
            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
          }
          cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
        }
        const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
        const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
        let levels = getMipLevels(texture, image, supportsMips);
        setTextureParameters(34067, texture, supportsMips);
        let mipmaps;
        if (isCompressed) {
          if (useTexStorage && allocateMemory) {
            state2.texStorage2D(34067, levels, glInternalFormat, image.width, image.height);
          }
          for (let i = 0; i < 6; i++) {
            mipmaps = cubeImage[i].mipmaps;
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    state2.compressedTexSubImage2D(34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  } else {
                    state2.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                }
              } else {
                if (useTexStorage) {
                  state2.texSubImage2D(34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                } else {
                  state2.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
        } else {
          mipmaps = texture.mipmaps;
          if (useTexStorage && allocateMemory) {
            if (mipmaps.length > 0)
              levels++;
            state2.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
          }
          for (let i = 0; i < 6; i++) {
            if (isDataTexture) {
              if (useTexStorage) {
                state2.texSubImage2D(34069 + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
              } else {
                state2.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
              }
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                const mipmapImage = mipmap.image[i].image;
                if (useTexStorage) {
                  state2.texSubImage2D(34069 + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                } else {
                  state2.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
              }
            } else {
              if (useTexStorage) {
                state2.texSubImage2D(34069 + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
              } else {
                state2.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
              }
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                if (useTexStorage) {
                  state2.texSubImage2D(34069 + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
                } else {
                  state2.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
                }
              }
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067);
        }
        sourceProperties.__version = source.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
      const glFormat = utils.convert(texture.format, texture.encoding);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const renderTargetProperties = properties.get(renderTarget);
      if (!renderTargetProperties.__hasExternalTextures) {
        if (textureTarget === 32879 || textureTarget === 35866) {
          state2.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
        } else {
          state2.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        }
      }
      state2.bindFramebuffer(36160, framebuffer);
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
      } else if (textureTarget === 3553 || textureTarget >= 34069 && textureTarget <= 34074) {
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
      }
      state2.bindFramebuffer(36160, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(36161, renderbuffer);
      if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        let glInternalFormat = 33189;
        if (isMultisample || useMultisampledRTT(renderTarget)) {
          const depthTexture = renderTarget.depthTexture;
          if (depthTexture && depthTexture.isDepthTexture) {
            if (depthTexture.type === FloatType) {
              glInternalFormat = 36012;
            } else if (depthTexture.type === UnsignedIntType) {
              glInternalFormat = 33190;
            }
          }
          const samples = getRenderTargetSamples(renderTarget);
          if (useMultisampledRTT(renderTarget)) {
            multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
      } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
      } else {
        const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
        for (let i = 0; i < textures.length; i++) {
          const texture = textures[i];
          const glFormat = utils.convert(texture.format, texture.encoding);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          const samples = getRenderTargetSamples(renderTarget);
          if (isMultisample && useMultisampledRTT(renderTarget) === false) {
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else if (useMultisampledRTT(renderTarget)) {
            multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        }
      }
      _gl.bindRenderbuffer(36161, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
      const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
      if (isCube)
        throw new Error("Depth Texture with cube render targets is not supported");
      state2.bindFramebuffer(36160, framebuffer);
      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      }
      if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }
      setTexture2D(renderTarget.depthTexture, 0);
      const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
      const samples = getRenderTargetSamples(renderTarget);
      if (renderTarget.depthTexture.format === DepthFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        }
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        }
      } else {
        throw new Error("Unknown depthTexture format");
      }
    }
    function setupDepthRenderbuffer(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
        if (isCube)
          throw new Error("target.depthTexture not supported in Cube render targets");
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];
          for (let i = 0; i < 6; i++) {
            state2.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
          }
        } else {
          state2.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
      }
      state2.bindFramebuffer(36160, null);
    }
    function rebindTextures(renderTarget, colorTexture, depthTexture) {
      const renderTargetProperties = properties.get(renderTarget);
      if (colorTexture !== void 0) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
      }
      if (depthTexture !== void 0) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function setupRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      renderTarget.addEventListener("dispose", onRenderTargetDispose);
      if (renderTarget.isWebGLMultipleRenderTargets !== true) {
        if (textureProperties.__webglTexture === void 0) {
          textureProperties.__webglTexture = _gl.createTexture();
        }
        textureProperties.__version = texture.version;
        info.memory.textures++;
      }
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let i = 0; i < 6; i++) {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        if (isMultipleRenderTargets) {
          if (capabilities.drawBuffers) {
            const textures = renderTarget.texture;
            for (let i = 0, il = textures.length; i < il; i++) {
              const attachmentProperties = properties.get(textures[i]);
              if (attachmentProperties.__webglTexture === void 0) {
                attachmentProperties.__webglTexture = _gl.createTexture();
                info.memory.textures++;
              }
            }
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
          }
        }
        if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
          const textures = isMultipleRenderTargets ? texture : [texture];
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = [];
          state2.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          for (let i = 0; i < textures.length; i++) {
            const texture2 = textures[i];
            renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer[i]);
            const glFormat = utils.convert(texture2.format, texture2.encoding);
            const glType = utils.convert(texture2.type);
            const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.encoding, renderTarget.isXRRenderTarget === true);
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[i]);
          }
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state2.bindFramebuffer(36160, null);
        }
      }
      if (isCube) {
        state2.bindTexture(34067, textureProperties.__webglTexture);
        setTextureParameters(34067, texture, supportsMips);
        for (let i = 0; i < 6; i++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, 36064, 34069 + i);
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067);
        }
        state2.unbindTexture();
      } else if (isMultipleRenderTargets) {
        const textures = renderTarget.texture;
        for (let i = 0, il = textures.length; i < il; i++) {
          const attachment = textures[i];
          const attachmentProperties = properties.get(attachment);
          state2.bindTexture(3553, attachmentProperties.__webglTexture);
          setTextureParameters(3553, attachment, supportsMips);
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553);
          if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
            generateMipmap(3553);
          }
        }
        state2.unbindTexture();
      } else {
        let glTextureType = 3553;
        if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
          if (isWebGL2) {
            glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;
          } else {
            console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
          }
        }
        state2.bindTexture(glTextureType, textureProperties.__webglTexture);
        setTextureParameters(glTextureType, texture, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(glTextureType);
        }
        state2.unbindTexture();
      }
      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function updateRenderTargetMipmap(renderTarget) {
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
      for (let i = 0, il = textures.length; i < il; i++) {
        const texture = textures[i];
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
          const webglTexture = properties.get(texture).__webglTexture;
          state2.bindTexture(target, webglTexture);
          generateMipmap(target);
          state2.unbindTexture();
        }
      }
    }
    function updateMultisampleRenderTarget(renderTarget) {
      if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
        const width2 = renderTarget.width;
        const height2 = renderTarget.height;
        let mask = 16384;
        const invalidationArray = [];
        const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
        const renderTargetProperties = properties.get(renderTarget);
        const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state2.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(36160, 36064 + i, 36161, null);
            state2.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(36009, 36064 + i, 3553, null, 0);
          }
        }
        state2.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        state2.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        for (let i = 0; i < textures.length; i++) {
          invalidationArray.push(36064 + i);
          if (renderTarget.depthBuffer) {
            invalidationArray.push(depthStyle);
          }
          const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : false;
          if (ignoreDepthValues === false) {
            if (renderTarget.depthBuffer)
              mask |= 256;
            if (renderTarget.stencilBuffer)
              mask |= 1024;
          }
          if (isMultipleRenderTargets) {
            _gl.framebufferRenderbuffer(36008, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer[i]);
          }
          if (ignoreDepthValues === true) {
            _gl.invalidateFramebuffer(36008, [depthStyle]);
            _gl.invalidateFramebuffer(36009, [depthStyle]);
          }
          if (isMultipleRenderTargets) {
            const webglTexture = properties.get(textures[i]).__webglTexture;
            _gl.framebufferTexture2D(36009, 36064, 3553, webglTexture, 0);
          }
          _gl.blitFramebuffer(0, 0, width2, height2, 0, 0, width2, height2, mask, 9728);
          if (supportsInvalidateFramebuffer) {
            _gl.invalidateFramebuffer(36008, invalidationArray);
          }
        }
        state2.bindFramebuffer(36008, null);
        state2.bindFramebuffer(36009, null);
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state2.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[i]);
            const webglTexture = properties.get(textures[i]).__webglTexture;
            state2.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(36009, 36064 + i, 3553, webglTexture, 0);
          }
        }
        state2.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
      }
    }
    function getRenderTargetSamples(renderTarget) {
      return Math.min(maxSamples, renderTarget.samples);
    }
    function useMultisampledRTT(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
    }
    function updateVideoTexture(texture) {
      const frame = info.render.frame;
      if (_videoTextures.get(texture) !== frame) {
        _videoTextures.set(texture, frame);
        texture.update();
      }
    }
    function verifyColorSpace(texture, image) {
      const encoding = texture.encoding;
      const format = texture.format;
      const type3 = texture.type;
      if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
        return image;
      if (encoding !== LinearEncoding) {
        if (encoding === sRGBEncoding) {
          if (isWebGL2 === false) {
            if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
              texture.format = _SRGBAFormat;
              texture.minFilter = LinearFilter;
              texture.generateMipmaps = false;
            } else {
              image = ImageUtils.sRGBToLinear(image);
            }
          } else {
            if (format !== RGBAFormat || type3 !== UnsignedByteType) {
              console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
            }
          }
        } else {
          console.error("THREE.WebGLTextures: Unsupported texture encoding:", encoding);
        }
      }
      return image;
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.rebindTextures = rebindTextures;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.setupDepthRenderbuffer = setupDepthRenderbuffer;
    this.setupFrameBufferTexture = setupFrameBufferTexture;
    this.useMultisampledRTT = useMultisampledRTT;
  }
  function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p, encoding = null) {
      let extension;
      if (p === UnsignedByteType)
        return 5121;
      if (p === UnsignedShort4444Type)
        return 32819;
      if (p === UnsignedShort5551Type)
        return 32820;
      if (p === ByteType)
        return 5120;
      if (p === ShortType)
        return 5122;
      if (p === UnsignedShortType)
        return 5123;
      if (p === IntType)
        return 5124;
      if (p === UnsignedIntType)
        return 5125;
      if (p === FloatType)
        return 5126;
      if (p === HalfFloatType) {
        if (isWebGL2)
          return 5131;
        extension = extensions.get("OES_texture_half_float");
        if (extension !== null) {
          return extension.HALF_FLOAT_OES;
        } else {
          return null;
        }
      }
      if (p === AlphaFormat)
        return 6406;
      if (p === RGBAFormat)
        return 6408;
      if (p === LuminanceFormat)
        return 6409;
      if (p === LuminanceAlphaFormat)
        return 6410;
      if (p === DepthFormat)
        return 6402;
      if (p === DepthStencilFormat)
        return 34041;
      if (p === _SRGBAFormat) {
        extension = extensions.get("EXT_sRGB");
        if (extension !== null) {
          return extension.SRGB_ALPHA_EXT;
        } else {
          return null;
        }
      }
      if (p === RedFormat)
        return 6403;
      if (p === RedIntegerFormat)
        return 36244;
      if (p === RGFormat)
        return 33319;
      if (p === RGIntegerFormat)
        return 33320;
      if (p === RGBAIntegerFormat)
        return 36249;
      if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
        if (encoding === sRGBEncoding) {
          extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
          if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        } else {
          extension = extensions.get("WEBGL_compressed_texture_s3tc");
          if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        }
      }
      if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
          if (p === RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p === RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p === RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p === RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else {
          return null;
        }
      }
      if (p === RGB_ETC1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc1");
        if (extension !== null) {
          return extension.COMPRESSED_RGB_ETC1_WEBGL;
        } else {
          return null;
        }
      }
      if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc");
        if (extension !== null) {
          if (p === RGB_ETC2_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
          if (p === RGBA_ETC2_EAC_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
        } else {
          return null;
        }
      }
      if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
        extension = extensions.get("WEBGL_compressed_texture_astc");
        if (extension !== null) {
          if (p === RGBA_ASTC_4x4_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (p === RGBA_ASTC_5x4_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (p === RGBA_ASTC_5x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (p === RGBA_ASTC_6x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (p === RGBA_ASTC_6x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (p === RGBA_ASTC_8x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (p === RGBA_ASTC_8x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (p === RGBA_ASTC_8x8_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (p === RGBA_ASTC_10x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (p === RGBA_ASTC_10x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (p === RGBA_ASTC_10x8_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (p === RGBA_ASTC_10x10_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (p === RGBA_ASTC_12x10_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (p === RGBA_ASTC_12x12_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
        } else {
          return null;
        }
      }
      if (p === RGBA_BPTC_Format) {
        extension = extensions.get("EXT_texture_compression_bptc");
        if (extension !== null) {
          if (p === RGBA_BPTC_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        } else {
          return null;
        }
      }
      if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
        extension = extensions.get("EXT_texture_compression_rgtc");
        if (extension !== null) {
          if (p === RGBA_BPTC_Format)
            return extension.COMPRESSED_RED_RGTC1_EXT;
          if (p === SIGNED_RED_RGTC1_Format)
            return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
          if (p === RED_GREEN_RGTC2_Format)
            return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
          if (p === SIGNED_RED_GREEN_RGTC2_Format)
            return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
        } else {
          return null;
        }
      }
      if (p === UnsignedInt248Type) {
        if (isWebGL2)
          return 34042;
        extension = extensions.get("WEBGL_depth_texture");
        if (extension !== null) {
          return extension.UNSIGNED_INT_24_8_WEBGL;
        } else {
          return null;
        }
      }
      return gl[p] !== void 0 ? gl[p] : null;
    }
    return { convert };
  }
  function WebGLMaterials(renderer, properties) {
    function refreshFogUniforms(uniforms, fog) {
      fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height2, transmissionRenderTarget) {
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshToonMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsToon(uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsPhong(uniforms, material);
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsStandard(uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsMatcap(uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDistance(uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(uniforms, material, pixelRatio, height2);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(uniforms, material);
      } else if (material.isShadowMaterial) {
        uniforms.color.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      } else if (material.isShaderMaterial) {
        material.uniformsNeedUpdate = false;
      }
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      if (material.color) {
        uniforms.diffuse.value.copy(material.color);
      }
      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMap.value = envMap;
        uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.ior.value = material.ior;
        uniforms.refractionRatio.value = material.refractionRatio;
      }
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        const scaleFactor = renderer.physicallyCorrectLights !== true ? Math.PI : 1;
        uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
      }
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
      } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
      } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
      } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
      } else if (material.roughnessMap) {
        uvScaleMap = material.roughnessMap;
      } else if (material.metalnessMap) {
        uvScaleMap = material.metalnessMap;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
      } else if (material.clearcoatMap) {
        uvScaleMap = material.clearcoatMap;
      } else if (material.clearcoatNormalMap) {
        uvScaleMap = material.clearcoatNormalMap;
      } else if (material.clearcoatRoughnessMap) {
        uvScaleMap = material.clearcoatRoughnessMap;
      } else if (material.iridescenceMap) {
        uvScaleMap = material.iridescenceMap;
      } else if (material.iridescenceThicknessMap) {
        uvScaleMap = material.iridescenceThicknessMap;
      } else if (material.specularIntensityMap) {
        uvScaleMap = material.specularIntensityMap;
      } else if (material.specularColorMap) {
        uvScaleMap = material.specularColorMap;
      } else if (material.transmissionMap) {
        uvScaleMap = material.transmissionMap;
      } else if (material.thicknessMap) {
        uvScaleMap = material.thicknessMap;
      } else if (material.sheenColorMap) {
        uvScaleMap = material.sheenColorMap;
      } else if (material.sheenRoughnessMap) {
        uvScaleMap = material.sheenRoughnessMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
      let uv2ScaleMap;
      if (material.aoMap) {
        uv2ScaleMap = material.aoMap;
      } else if (material.lightMap) {
        uv2ScaleMap = material.lightMap;
      }
      if (uv2ScaleMap !== void 0) {
        if (uv2ScaleMap.isWebGLRenderTarget) {
          uv2ScaleMap = uv2ScaleMap.texture;
        }
        if (uv2ScaleMap.matrixAutoUpdate === true) {
          uv2ScaleMap.updateMatrix();
        }
        uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
      }
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height2) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * pixelRatio;
      uniforms.scale.value = height2 * 0.5;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    }
    function refreshUniformsToon(uniforms, material) {
      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }
    }
    function refreshUniformsStandard(uniforms, material) {
      uniforms.roughness.value = material.roughness;
      uniforms.metalness.value = material.metalness;
      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
      }
      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }
    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
      uniforms.ior.value = material.ior;
      if (material.sheen > 0) {
        uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
        uniforms.sheenRoughness.value = material.sheenRoughness;
        if (material.sheenColorMap) {
          uniforms.sheenColorMap.value = material.sheenColorMap;
        }
        if (material.sheenRoughnessMap) {
          uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        }
      }
      if (material.clearcoat > 0) {
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.clearcoatMap) {
          uniforms.clearcoatMap.value = material.clearcoatMap;
        }
        if (material.clearcoatRoughnessMap) {
          uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        }
        if (material.clearcoatNormalMap) {
          uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
          uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
          if (material.side === BackSide) {
            uniforms.clearcoatNormalScale.value.negate();
          }
        }
      }
      if (material.iridescence > 0) {
        uniforms.iridescence.value = material.iridescence;
        uniforms.iridescenceIOR.value = material.iridescenceIOR;
        uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
        uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
        if (material.iridescenceMap) {
          uniforms.iridescenceMap.value = material.iridescenceMap;
        }
        if (material.iridescenceThicknessMap) {
          uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        }
      }
      if (material.transmission > 0) {
        uniforms.transmission.value = material.transmission;
        uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
        uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
        if (material.transmissionMap) {
          uniforms.transmissionMap.value = material.transmissionMap;
        }
        uniforms.thickness.value = material.thickness;
        if (material.thicknessMap) {
          uniforms.thicknessMap.value = material.thicknessMap;
        }
        uniforms.attenuationDistance.value = material.attenuationDistance;
        uniforms.attenuationColor.value.copy(material.attenuationColor);
      }
      uniforms.specularIntensity.value = material.specularIntensity;
      uniforms.specularColor.value.copy(material.specularColor);
      if (material.specularIntensityMap) {
        uniforms.specularIntensityMap.value = material.specularIntensityMap;
      }
      if (material.specularColorMap) {
        uniforms.specularColorMap.value = material.specularColorMap;
      }
    }
    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }
    }
    function refreshUniformsDistance(uniforms, material) {
      uniforms.referencePosition.value.copy(material.referencePosition);
      uniforms.nearDistance.value = material.nearDistance;
      uniforms.farDistance.value = material.farDistance;
    }
    return {
      refreshFogUniforms,
      refreshMaterialUniforms
    };
  }
  function WebGLUniformsGroups(gl, info, capabilities, state2) {
    let buffers = {};
    let updateList = {};
    let allocatedBindingPoints = [];
    const maxBindingPoints = capabilities.isWebGL2 ? gl.getParameter(35375) : 0;
    function bind3(uniformsGroup, program) {
      const webglProgram = program.program;
      state2.uniformBlockBinding(uniformsGroup, webglProgram);
    }
    function update(uniformsGroup, program) {
      let buffer = buffers[uniformsGroup.id];
      if (buffer === void 0) {
        prepareUniformsGroup(uniformsGroup);
        buffer = createBuffer(uniformsGroup);
        buffers[uniformsGroup.id] = buffer;
        uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
      }
      const webglProgram = program.program;
      state2.updateUBOMapping(uniformsGroup, webglProgram);
      const frame = info.render.frame;
      if (updateList[uniformsGroup.id] !== frame) {
        updateBufferData(uniformsGroup);
        updateList[uniformsGroup.id] = frame;
      }
    }
    function createBuffer(uniformsGroup) {
      const bindingPointIndex = allocateBindingPointIndex();
      uniformsGroup.__bindingPointIndex = bindingPointIndex;
      const buffer = gl.createBuffer();
      const size = uniformsGroup.__size;
      const usage = uniformsGroup.usage;
      gl.bindBuffer(35345, buffer);
      gl.bufferData(35345, size, usage);
      gl.bindBuffer(35345, null);
      gl.bindBufferBase(35345, bindingPointIndex, buffer);
      return buffer;
    }
    function allocateBindingPointIndex() {
      for (let i = 0; i < maxBindingPoints; i++) {
        if (allocatedBindingPoints.indexOf(i) === -1) {
          allocatedBindingPoints.push(i);
          return i;
        }
      }
      console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
      return 0;
    }
    function updateBufferData(uniformsGroup) {
      const buffer = buffers[uniformsGroup.id];
      const uniforms = uniformsGroup.uniforms;
      const cache = uniformsGroup.__cache;
      gl.bindBuffer(35345, buffer);
      for (let i = 0, il = uniforms.length; i < il; i++) {
        const uniform = uniforms[i];
        if (hasUniformChanged(uniform, i, cache) === true) {
          const offset = uniform.__offset;
          const values3 = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
          let arrayOffset = 0;
          for (let i2 = 0; i2 < values3.length; i2++) {
            const value = values3[i2];
            const info2 = getUniformSize(value);
            if (typeof value === "number") {
              uniform.__data[0] = value;
              gl.bufferSubData(35345, offset + arrayOffset, uniform.__data);
            } else if (value.isMatrix3) {
              uniform.__data[0] = value.elements[0];
              uniform.__data[1] = value.elements[1];
              uniform.__data[2] = value.elements[2];
              uniform.__data[3] = value.elements[0];
              uniform.__data[4] = value.elements[3];
              uniform.__data[5] = value.elements[4];
              uniform.__data[6] = value.elements[5];
              uniform.__data[7] = value.elements[0];
              uniform.__data[8] = value.elements[6];
              uniform.__data[9] = value.elements[7];
              uniform.__data[10] = value.elements[8];
              uniform.__data[11] = value.elements[0];
            } else {
              value.toArray(uniform.__data, arrayOffset);
              arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
            }
          }
          gl.bufferSubData(35345, offset, uniform.__data);
        }
      }
      gl.bindBuffer(35345, null);
    }
    function hasUniformChanged(uniform, index, cache) {
      const value = uniform.value;
      if (cache[index] === void 0) {
        if (typeof value === "number") {
          cache[index] = value;
        } else {
          const values3 = Array.isArray(value) ? value : [value];
          const tempValues = [];
          for (let i = 0; i < values3.length; i++) {
            tempValues.push(values3[i].clone());
          }
          cache[index] = tempValues;
        }
        return true;
      } else {
        if (typeof value === "number") {
          if (cache[index] !== value) {
            cache[index] = value;
            return true;
          }
        } else {
          const cachedObjects = Array.isArray(cache[index]) ? cache[index] : [cache[index]];
          const values3 = Array.isArray(value) ? value : [value];
          for (let i = 0; i < cachedObjects.length; i++) {
            const cachedObject = cachedObjects[i];
            if (cachedObject.equals(values3[i]) === false) {
              cachedObject.copy(values3[i]);
              return true;
            }
          }
        }
      }
      return false;
    }
    function prepareUniformsGroup(uniformsGroup) {
      const uniforms = uniformsGroup.uniforms;
      let offset = 0;
      const chunkSize = 16;
      let chunkOffset = 0;
      for (let i = 0, l = uniforms.length; i < l; i++) {
        const uniform = uniforms[i];
        const infos = {
          boundary: 0,
          storage: 0
        };
        const values3 = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        for (let j = 0, jl = values3.length; j < jl; j++) {
          const value = values3[j];
          const info2 = getUniformSize(value);
          infos.boundary += info2.boundary;
          infos.storage += info2.storage;
        }
        uniform.__data = new Float32Array(infos.storage / Float32Array.BYTES_PER_ELEMENT);
        uniform.__offset = offset;
        if (i > 0) {
          chunkOffset = offset % chunkSize;
          const remainingSizeInChunk = chunkSize - chunkOffset;
          if (chunkOffset !== 0 && remainingSizeInChunk - infos.boundary < 0) {
            offset += chunkSize - chunkOffset;
            uniform.__offset = offset;
          }
        }
        offset += infos.storage;
      }
      chunkOffset = offset % chunkSize;
      if (chunkOffset > 0)
        offset += chunkSize - chunkOffset;
      uniformsGroup.__size = offset;
      uniformsGroup.__cache = {};
      return this;
    }
    function getUniformSize(value) {
      const info2 = {
        boundary: 0,
        storage: 0
      };
      if (typeof value === "number") {
        info2.boundary = 4;
        info2.storage = 4;
      } else if (value.isVector2) {
        info2.boundary = 8;
        info2.storage = 8;
      } else if (value.isVector3 || value.isColor) {
        info2.boundary = 16;
        info2.storage = 12;
      } else if (value.isVector4) {
        info2.boundary = 16;
        info2.storage = 16;
      } else if (value.isMatrix3) {
        info2.boundary = 48;
        info2.storage = 48;
      } else if (value.isMatrix4) {
        info2.boundary = 64;
        info2.storage = 64;
      } else if (value.isTexture) {
        console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
      } else {
        console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
      }
      return info2;
    }
    function onUniformsGroupsDispose(event) {
      const uniformsGroup = event.target;
      uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
      const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
      allocatedBindingPoints.splice(index, 1);
      gl.deleteBuffer(buffers[uniformsGroup.id]);
      delete buffers[uniformsGroup.id];
      delete updateList[uniformsGroup.id];
    }
    function dispose() {
      for (const id2 in buffers) {
        gl.deleteBuffer(buffers[id2]);
      }
      allocatedBindingPoints = [];
      buffers = {};
      updateList = {};
    }
    return {
      bind: bind3,
      update,
      dispose
    };
  }
  function createCanvasElement() {
    const canvas = createElementNS("canvas");
    canvas.style.display = "block";
    return canvas;
  }
  function WebGLRenderer(parameters = {}) {
    this.isWebGLRenderer = true;
    const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
    let _alpha;
    if (_context2 !== null) {
      _alpha = _context2.getContextAttributes().alpha;
    } else {
      _alpha = parameters.alpha !== void 0 ? parameters.alpha : false;
    }
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = _canvas2;
    this.debug = {
      checkShaderErrors: true
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.outputEncoding = LinearEncoding;
    this.physicallyCorrectLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    let _width = _canvas2.width;
    let _height = _canvas2.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    let _transmissionRenderTarget = null;
    const _projScreenMatrix2 = new Matrix4();
    const _vector22 = new Vector2();
    const _vector3 = new Vector3();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = _context2;
    function getContext(contextNames, contextAttributes) {
      for (let i = 0; i < contextNames.length; i++) {
        const contextName = contextNames[i];
        const context = _canvas2.getContext(contextName, contextAttributes);
        if (context !== null)
          return context;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer,
        powerPreference: _powerPreference,
        failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in _canvas2)
        _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
      _canvas2.addEventListener("webglcontextlost", onContextLost, false);
      _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
      _canvas2.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext(contextNames)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function() {
          return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state2, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);
      extensions.init(capabilities);
      utils = new WebGLUtils(_gl, extensions, capabilities);
      state2 = new WebGLState(_gl, extensions, capabilities);
      info = new WebGLInfo();
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state2, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities);
      bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions, capabilities);
      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state2, objects, _alpha, _premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state2);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state2;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0)
        return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width2, height2, updateStyle) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width2;
      _height = height2;
      _canvas2.width = Math.floor(width2 * _pixelRatio);
      _canvas2.height = Math.floor(height2 * _pixelRatio);
      if (updateStyle !== false) {
        _canvas2.style.width = width2 + "px";
        _canvas2.style.height = height2 + "px";
      }
      this.setViewport(0, 0, width2, height2);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width2, height2, pixelRatio) {
      _width = width2;
      _height = height2;
      _pixelRatio = pixelRatio;
      _canvas2.width = Math.floor(width2 * pixelRatio);
      _canvas2.height = Math.floor(height2 * pixelRatio);
      this.setViewport(0, 0, width2, height2);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width2, height2) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width2, height2);
      }
      state2.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width2, height2) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width2, height2);
      }
      state2.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state2.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color = true, depth = true, stencil = true) {
      let bits = 0;
      if (color)
        bits |= 16384;
      if (depth)
        bits |= 256;
      if (stencil)
        bits |= 1024;
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
      _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
      _canvas2.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      if (_transmissionRenderTarget) {
        _transmissionRenderTarget.dispose();
        _transmissionRenderTarget = null;
      }
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null)
        scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state2.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        rangeFactor = 2;
      }
      const drawRange = geometry.drawRange;
      const position = geometry.attributes.position;
      let drawStart = drawRange.start * rangeFactor;
      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index.count);
      } else if (position !== void 0 && position !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position.count);
      }
      const drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity)
        return;
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      if (object.isMesh) {
        if (material.wireframe === true) {
          state2.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(1);
        } else {
          renderer.setMode(4);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0)
          lineWidth = 1;
        state2.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(1);
        } else if (object.isLineLoop) {
          renderer.setMode(2);
        } else {
          renderer.setMode(3);
        }
      } else if (object.isPoints) {
        renderer.setMode(0);
      } else if (object.isSprite) {
        renderer.setMode(4);
      }
      if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
        const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    this.compile = function(scene, camera) {
      function prepare(material, scene2, object) {
        if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
          material.side = BackSide;
          material.needsUpdate = true;
          getProgram(material, scene2, object);
          material.side = FrontSide;
          material.needsUpdate = true;
          getProgram(material, scene2, object);
          material.side = DoubleSide;
        } else {
          getProgram(material, scene2, object);
        }
      }
      currentRenderState = renderStates.get(scene);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      scene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      currentRenderState.setupLights(_this.physicallyCorrectLights);
      scene.traverse(function(object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i = 0; i < material.length; i++) {
              const material2 = material[i];
              prepare(material2, scene, object);
            }
          } else {
            prepare(material, scene, object);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time2) {
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time2);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined")
      animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true)
        return;
      if (scene.matrixWorldAutoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
        camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true)
          xr.updateCamera(camera);
        camera = xr.getCamera();
      }
      if (scene.isScene === true)
        scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      if (_clippingEnabled === true)
        clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true)
        clipping.endShadows();
      if (this.info.autoReset === true)
        this.info.reset();
      background.render(currentRenderList, scene);
      currentRenderState.setupLights(_this.physicallyCorrectLights);
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let i = 0, l = cameras.length; i < l; i++) {
          const camera2 = cameras[i];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true)
        scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true)
            object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (object.isSkinnedMesh) {
            if (object.skeleton.frame !== info.render.frame) {
              object.skeleton.update();
              object.skeleton.frame = info.render.frame;
            }
          }
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i = 0, l = groups.length; i < l; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true)
        clipping.setGlobalState(_this.clippingPlanes, camera);
      if (transmissiveObjects.length > 0)
        renderTransmissionPass(opaqueObjects, scene, camera);
      if (viewport)
        state2.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0)
        renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0)
        renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0)
        renderObjects(transparentObjects, scene, camera);
      state2.buffers.depth.setTest(true);
      state2.buffers.depth.setMask(true);
      state2.buffers.color.setMask(true);
      state2.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, scene, camera) {
      const isWebGL2 = capabilities.isWebGL2;
      if (_transmissionRenderTarget === null) {
        _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions.has("EXT_color_buffer_half_float") ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: isWebGL2 && _antialias === true ? 4 : 0
        });
      }
      _this.getDrawingBufferSize(_vector22);
      if (isWebGL2) {
        _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
      } else {
        _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
      }
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(_transmissionRenderTarget);
      _this.clear();
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      renderObjects(opaqueObjects, scene, camera);
      _this.toneMapping = currentToneMapping;
      textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
      textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      _this.setRenderTarget(currentRenderTarget);
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i = 0, l = renderList.length; i < l; i++) {
        const renderItem = renderList[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBuild(object, parameters2, _this);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      const progUniforms = program.getUniforms();
      const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = uniformsList;
      return program;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputEncoding = parameters2.outputEncoding;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputEncoding !== encoding) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state2.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(
            _gl,
            "logDepthBufFC",
            2 / (Math.log(camera.far + 1) / Math.LN2)
          );
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
          const uCamPos = p_uniforms.map.cameraPosition;
          if (uCamPos !== void 0) {
            uCamPos.setValue(
              _gl,
              _vector3.setFromMatrixPosition(camera.matrixWorld)
            );
          }
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
          p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === null)
              skeleton.computeBoneTexture();
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.");
          }
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities.isWebGL2 === true) {
        morphtargets.update(object, geometry, material, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        const groups = material.uniformsGroups;
        for (let i = 0, l = groups.length; i < l; i++) {
          if (capabilities.isWebGL2) {
            const group = groups[i];
            uniformsGroups.update(group, program);
            uniformsGroups.bind(group, program);
          } else {
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
          }
        }
      }
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      if (renderTargetProperties.__hasExternalTextures) {
        renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
        if (!renderTargetProperties.__autoAllocateDepthBuffer) {
          if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
            console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
            renderTargetProperties.__useRenderToTexture = false;
          }
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state2.bindFramebuffer(36160, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        }
        const texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          framebuffer = __webglFramebuffer[activeCubeFace];
          isCube = true;
        } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          framebuffer = __webglFramebuffer;
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state2.bindFramebuffer(36160, framebuffer);
      if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
        state2.drawBuffers(renderTarget, framebuffer);
      }
      state2.viewport(_currentViewport);
      state2.scissor(_currentScissor);
      state2.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width2, height2, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state2.bindFramebuffer(36160, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
          if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x >= 0 && x <= renderTarget.width - width2 && (y >= 0 && y <= renderTarget.height - height2)) {
            _gl.readPixels(x, y, width2, height2, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state2.bindFramebuffer(36160, framebuffer2);
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
      const levelScale = Math.pow(2, -level);
      const width2 = Math.floor(texture.image.width * levelScale);
      const height2 = Math.floor(texture.image.height * levelScale);
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(3553, level, 0, 0, position.x, position.y, width2, height2);
      state2.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
      const width2 = srcTexture.image.width;
      const height2 = srcTexture.image.height;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(3553, level, position.x, position.y, width2, height2, glFormat, glType, srcTexture.image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        } else {
          _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
        }
      }
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(3553);
      state2.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
      if (_this.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const width2 = sourceBox.max.x - sourceBox.min.x + 1;
      const height2 = sourceBox.max.y - sourceBox.min.y + 1;
      const depth = sourceBox.max.z - sourceBox.min.z + 1;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = 32879;
      } else if (dstTexture.isDataArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = 35866;
      } else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      const unpackRowLen = _gl.getParameter(3314);
      const unpackImageHeight = _gl.getParameter(32878);
      const unpackSkipPixels = _gl.getParameter(3316);
      const unpackSkipRows = _gl.getParameter(3315);
      const unpackSkipImages = _gl.getParameter(32877);
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
      _gl.pixelStorei(3314, image.width);
      _gl.pixelStorei(32878, image.height);
      _gl.pixelStorei(3316, sourceBox.min.x);
      _gl.pixelStorei(3315, sourceBox.min.y);
      _gl.pixelStorei(32877, sourceBox.min.z);
      if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width2, height2, depth, glFormat, glType, image.data);
      } else {
        if (srcTexture.isCompressedArrayTexture) {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
          _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width2, height2, depth, glFormat, image.data);
        } else {
          _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width2, height2, depth, glFormat, glType, image);
        }
      }
      _gl.pixelStorei(3314, unpackRowLen);
      _gl.pixelStorei(32878, unpackImageHeight);
      _gl.pixelStorei(3316, unpackSkipPixels);
      _gl.pixelStorei(3315, unpackSkipRows);
      _gl.pixelStorei(32877, unpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(glTarget);
      state2.unbindTexture();
    };
    this.initTexture = function(texture) {
      if (texture.isCubeTexture) {
        textures.setTextureCube(texture, 0);
      } else if (texture.isData3DTexture) {
        textures.setTexture3D(texture, 0);
      } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
        textures.setTexture2DArray(texture, 0);
      } else {
        textures.setTexture2D(texture, 0);
      }
      state2.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state2.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
    if (sin !== void 0) {
      _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
      _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else {
      _rotatedPosition.copy(_alignedPosition);
    }
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    vertexPosition.applyMatrix4(_viewWorldMatrix);
  }
  function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
    const rayPointDistanceSq = _ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
      const intersectPoint = new Vector3();
      _ray.closestPointToPoint(point, intersectPoint);
      intersectPoint.applyMatrix4(matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far)
        return;
      intersects2.push({
        distance,
        distanceToRay: Math.sqrt(rayPointDistanceSq),
        point: intersectPoint,
        index,
        face: null,
        object
      });
    }
  }
  function CubicPoly() {
    let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    function init(x0, x1, t0, t1) {
      c0 = x0;
      c1 = t0;
      c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
      c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
      initCatmullRom: function(x0, x1, x2, x3, tension) {
        init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      },
      initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
        let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        init(x1, x2, t1, t2);
      },
      calc: function(t) {
        const t2 = t * t;
        const t3 = t2 * t;
        return c0 + c1 * t + c2 * t2 + c3 * t3;
      }
    };
  }
  function CatmullRom(t, p0, p1, p2, p3) {
    const v0 = (p2 - p0) * 0.5;
    const v1 = (p3 - p1) * 0.5;
    const t2 = t * t;
    const t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
  function QuadraticBezierP0(t, p) {
    const k = 1 - t;
    return k * k * p;
  }
  function QuadraticBezierP1(t, p) {
    return 2 * (1 - t) * t * p;
  }
  function QuadraticBezierP2(t, p) {
    return t * t * p;
  }
  function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
  }
  function CubicBezierP0(t, p) {
    const k = 1 - t;
    return k * k * k * p;
  }
  function CubicBezierP1(t, p) {
    const k = 1 - t;
    return 3 * k * k * t * p;
  }
  function CubicBezierP2(t, p) {
    return 3 * (1 - t) * t * t * p;
  }
  function CubicBezierP3(t, p) {
    return t * t * t * p;
  }
  function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
  }
  function linkedList(data, start2, end, dim, clockwise) {
    let i, last;
    if (clockwise === signedArea(data, start2, end, dim) > 0) {
      for (i = start2; i < end; i += dim)
        last = insertNode(i, data[i], data[i + 1], last);
    } else {
      for (i = end - dim; i >= start2; i -= dim)
        last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start2, end) {
    if (!start2)
      return start2;
    if (!end)
      end = start2;
    let p = start2, again;
    do {
      again = false;
      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next)
          break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    let p = c.next;
    while (p !== a) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start2, triangles, dim) {
    let p = start2;
    do {
      const a = p.prev, b = p.next.next;
      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim | 0);
        triangles.push(p.i / dim | 0);
        triangles.push(b.i / dim | 0);
        removeNode(p);
        removeNode(p.next);
        p = start2 = b;
      }
      p = p.next;
    } while (p !== start2);
    return filterPoints(p);
  }
  function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
    let a = start2;
    do {
      let b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          let c = splitPolygon(a, b);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start2);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i, len, start2, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start2 = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start2, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i = 0; i < queue.length; i++) {
      outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    const bridgeReverse = splitPolygon(bridge, hole);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }
  function findHoleBridge(hole, outerNode) {
    let p = outerNode, qx = -Infinity, m;
    const hx = hole.x, hy = hole.y;
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          m = p.x < p.next.x ? p : p.next;
          if (x === hx)
            return m;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m)
      return null;
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }
  function indexCurve(start2, minX, minY, invSize) {
    let p = start2;
    do {
      if (p.z === 0)
        p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start2);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }
  function sortLinked(list) {
    let i, p, q, e, tail2, numMerges, pSize, qSize, inSize = 1;
    do {
      p = list;
      list = null;
      tail2 = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail2)
            tail2.nextZ = e;
          else
            list = e;
          e.prevZ = tail2;
          tail2 = e;
        }
        p = q;
      }
      tail2.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost(start2) {
    let p = start2, leftmost = start2;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
        leftmost = p;
      p = p.next;
    } while (p !== start2);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
    return (cx - px2) * (ay - py2) >= (ax - px2) * (cy - py2) && (ax - px2) * (by - py2) >= (bx - px2) * (ay - py2) && (bx - px2) * (cy - py2) >= (cx - px2) * (by - py2);
  }
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a, b) {
    let p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
        return true;
      p = p.next;
    } while (p !== a);
    return false;
  }
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }
  function middleInside(a, b) {
    let p = a, inside = false;
    const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
    do {
      if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }
  function splitPolygon(a, b) {
    const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i, x, y, last) {
    const p = new Node(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
      p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
      p.nextZ.prevZ = p.prevZ;
  }
  function Node(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = 0;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  function signedArea(data, start2, end, dim) {
    let sum2 = 0;
    for (let i = start2, j = end - dim; i < end; i += dim) {
      sum2 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum2;
  }
  function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) {
      points.pop();
    }
  }
  function addContour(vertices, contour) {
    for (let i = 0; i < contour.length; i++) {
      vertices.push(contour[i].x);
      vertices.push(contour[i].y);
    }
  }
  function toJSON$1(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    data.options = Object.assign({}, options);
    if (options.extrudePath !== void 0)
      data.options.extrudePath = options.extrudePath.toJSON();
    return data;
  }
  function toJSON(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    return data;
  }
  function isUniqueEdge(start2, end, edges) {
    const hash1 = `${start2.x},${start2.y},${start2.z}-${end.x},${end.y},${end.z}`;
    const hash2 = `${end.x},${end.y},${end.z}-${start2.x},${start2.y},${start2.z}`;
    if (edges.has(hash1) === true || edges.has(hash2) === true) {
      return false;
    } else {
      edges.add(hash1);
      edges.add(hash2);
      return true;
    }
  }
  function arraySlice(array, from, to) {
    if (isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
    }
    return array.slice(from, to);
  }
  function convertArray(array, type3, forceClone) {
    if (!array || !forceClone && array.constructor === type3)
      return array;
    if (typeof type3.BYTES_PER_ELEMENT === "number") {
      return new type3(array);
    }
    return Array.prototype.slice.call(array);
  }
  function isTypedArray(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  }
  function getKeyframeOrder(times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }
    const n = times.length;
    const result = new Array(n);
    for (let i = 0; i !== n; ++i)
      result[i] = i;
    result.sort(compareTime);
    return result;
  }
  function sortedArray(values3, stride, order) {
    const nValues = values3.length;
    const result = new values3.constructor(nValues);
    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      const srcOffset = order[i] * stride;
      for (let j = 0; j !== stride; ++j) {
        result[dstOffset++] = values3[srcOffset + j];
      }
    }
    return result;
  }
  function flattenJSON(jsonKeys, times, values3, valuePropertyName) {
    let i = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values3.push.apply(values3, value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values3, values3.length);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values3.push(value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    }
  }
  function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];
    for (let i = 0; i < clip.tracks.length; ++i) {
      const track = clip.tracks[i];
      const valueSize = track.getValueSize();
      const times = [];
      const values3 = [];
      for (let j = 0; j < track.times.length; ++j) {
        const frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j]);
        for (let k = 0; k < valueSize; ++k) {
          values3.push(track.values[j * valueSize + k]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = convertArray(times, track.times.constructor);
      track.values = convertArray(values3, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i = 0; i < clip.tracks.length; ++i) {
      if (minStartTime > clip.tracks[i].times[0]) {
        minStartTime = clip.tracks[i].times[0];
      }
    }
    for (let i = 0; i < clip.tracks.length; ++i) {
      clip.tracks[i].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  }
  function makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i = 0; i < numTracks; ++i) {
      const referenceTrack = referenceClip.tracks[i];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j = 0; j < numTimes; ++j) {
        const valueStart = j * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(
            targetTrack.values,
            valueStart,
            referenceValue,
            0,
            targetTrack.values,
            valueStart
          );
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
  function getTrackTypeForValueTypeName(typeName) {
    switch (typeName.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return NumberKeyframeTrack;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return VectorKeyframeTrack;
      case "color":
        return ColorKeyframeTrack;
      case "quaternion":
        return QuaternionKeyframeTrack;
      case "bool":
      case "boolean":
        return BooleanKeyframeTrack;
      case "string":
        return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
  }
  function parseKeyframeTrack(json) {
    if (json.type === void 0) {
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === void 0) {
      const times = [], values3 = [];
      flattenJSON(json.keys, times, values3, "value");
      json.times = times;
      json.values = values3;
    }
    if (trackType.parse !== void 0) {
      return trackType.parse(json);
    } else {
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  }
  function now() {
    return (typeof performance === "undefined" ? Date : performance).now();
  }
  function ascSort(a, b) {
    return a.distance - b.distance;
  }
  function intersectObject(object, raycaster, intersects2, recursive) {
    if (object.layers.test(raycaster.layers)) {
      object.raycast(raycaster, intersects2);
    }
    if (recursive === true) {
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        intersectObject(children[i], raycaster, intersects2, true);
      }
    }
  }
  function getBoneList(object) {
    const boneList = [];
    if (object.isBone === true) {
      boneList.push(object);
    }
    for (let i = 0; i < object.children.length; i++) {
      boneList.push.apply(boneList, getBoneList(object.children[i]));
    }
    return boneList;
  }
  function setPoint(point, pointMap, geometry, camera, x, y, z) {
    _vector.set(x, y, z).unproject(camera);
    const points = pointMap[point];
    if (points !== void 0) {
      const position = geometry.getAttribute("position");
      for (let i = 0, l = points.length; i < l; i++) {
        position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
      }
    }
  }
  function _generateTables() {
    const buffer = new ArrayBuffer(4);
    const floatView = new Float32Array(buffer);
    const uint32View = new Uint32Array(buffer);
    const baseTable = new Uint32Array(512);
    const shiftTable = new Uint32Array(512);
    for (let i = 0; i < 256; ++i) {
      const e = i - 127;
      if (e < -27) {
        baseTable[i] = 0;
        baseTable[i | 256] = 32768;
        shiftTable[i] = 24;
        shiftTable[i | 256] = 24;
      } else if (e < -14) {
        baseTable[i] = 1024 >> -e - 14;
        baseTable[i | 256] = 1024 >> -e - 14 | 32768;
        shiftTable[i] = -e - 1;
        shiftTable[i | 256] = -e - 1;
      } else if (e <= 15) {
        baseTable[i] = e + 15 << 10;
        baseTable[i | 256] = e + 15 << 10 | 32768;
        shiftTable[i] = 13;
        shiftTable[i | 256] = 13;
      } else if (e < 128) {
        baseTable[i] = 31744;
        baseTable[i | 256] = 64512;
        shiftTable[i] = 24;
        shiftTable[i | 256] = 24;
      } else {
        baseTable[i] = 31744;
        baseTable[i | 256] = 64512;
        shiftTable[i] = 13;
        shiftTable[i | 256] = 13;
      }
    }
    const mantissaTable = new Uint32Array(2048);
    const exponentTable = new Uint32Array(64);
    const offsetTable = new Uint32Array(64);
    for (let i = 1; i < 1024; ++i) {
      let m = i << 13;
      let e = 0;
      while ((m & 8388608) === 0) {
        m <<= 1;
        e -= 8388608;
      }
      m &= ~8388608;
      e += 947912704;
      mantissaTable[i] = m | e;
    }
    for (let i = 1024; i < 2048; ++i) {
      mantissaTable[i] = 939524096 + (i - 1024 << 13);
    }
    for (let i = 1; i < 31; ++i) {
      exponentTable[i] = i << 23;
    }
    exponentTable[31] = 1199570944;
    exponentTable[32] = 2147483648;
    for (let i = 33; i < 63; ++i) {
      exponentTable[i] = 2147483648 + (i - 32 << 23);
    }
    exponentTable[63] = 3347054592;
    for (let i = 1; i < 64; ++i) {
      if (i !== 32) {
        offsetTable[i] = 1024;
      }
    }
    return {
      floatView,
      uint32View,
      baseTable,
      shiftTable,
      mantissaTable,
      exponentTable,
      offsetTable
    };
  }
  function toHalfFloat(val) {
    if (Math.abs(val) > 65504)
      console.warn("THREE.DataUtils.toHalfFloat(): Value out of range.");
    val = clamp(val, -65504, 65504);
    _tables.floatView[0] = val;
    const f = _tables.uint32View[0];
    const e = f >> 23 & 511;
    return _tables.baseTable[e] + ((f & 8388607) >> _tables.shiftTable[e]);
  }
  function fromHalfFloat(val) {
    const m = val >> 10;
    _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 1023)] + _tables.exponentTable[m];
    return _tables.floatView[0];
  }
  var REVISION, MOUSE, TOUCH, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, TwoPassDoubleSide, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, CustomToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt248Type, AlphaFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, DepthFormat, DepthStencilFormat, RedFormat, RedIntegerFormat, RGFormat, RGIntegerFormat, RGBAIntegerFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, NormalAnimationBlendMode, AdditiveAnimationBlendMode, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, NoColorSpace, SRGBColorSpace, LinearSRGBColorSpace, ZeroStencilOp, KeepStencilOp, ReplaceStencilOp, IncrementStencilOp, DecrementStencilOp, IncrementWrapStencilOp, DecrementWrapStencilOp, InvertStencilOp, NeverStencilFunc, LessStencilFunc, EqualStencilFunc, LessEqualStencilFunc, GreaterStencilFunc, NotEqualStencilFunc, GreaterEqualStencilFunc, AlwaysStencilFunc, StaticDrawUsage, DynamicDrawUsage, StreamDrawUsage, StaticReadUsage, DynamicReadUsage, StreamReadUsage, StaticCopyUsage, DynamicCopyUsage, StreamCopyUsage, GLSL1, GLSL3, _SRGBAFormat, EventDispatcher, _lut, _seed, DEG2RAD, RAD2DEG, MathUtils, Vector2, Matrix3, _m3, TYPED_ARRAYS, FN, ColorManagement, _colorKeywords, _rgb$1, _hslA, _hslB, Color, _canvas, ImageUtils, Source, textureId, Texture, Vector4, WebGLRenderTarget, DataArrayTexture, WebGLArrayRenderTarget, Data3DTexture, WebGL3DRenderTarget, WebGLMultipleRenderTargets, Quaternion, Vector3, _vector$c, _quaternion$4, Box3, _points, _vector$b, _box$3, _v0$2, _v1$7, _v2$4, _f0, _f1, _f2, _center, _extents, _triangleNormal, _testAxis, _box$2, _v1$6, _v2$3, Sphere, _vector$a, _segCenter, _segDir, _diff, _edge1, _edge2, _normal$1, Ray, Matrix4, _v1$5, _m1$2, _zero, _one, _x, _y, _z, _matrix$1, _quaternion$3, Euler, Layers, _object3DId, _v1$4, _q1, _m1$1, _target, _position$3, _scale$2, _quaternion$2, _xAxis, _yAxis, _zAxis, _addedEvent, _removedEvent, Object3D, _v0$1, _v1$3, _v2$2, _v3$1, _vab, _vac, _vbc, _vap, _vbp, _vcp, Triangle, materialId, Material, MeshBasicMaterial, _vector$9, _vector2$1, BufferAttribute, Int8BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Int16BufferAttribute, Uint16BufferAttribute, Int32BufferAttribute, Uint32BufferAttribute, Float16BufferAttribute, Float32BufferAttribute, Float64BufferAttribute, _id$1, _m1, _obj, _offset, _box$1, _boxMorphTargets, _vector$8, BufferGeometry, _inverseMatrix$2, _ray$2, _sphere$3, _vA$1, _vB$1, _vC$1, _tempA, _morphA, _uvA$1, _uvB$1, _uvC$1, _intersectionPoint, _intersectionPointWorld, Mesh, BoxGeometry, UniformsUtils, default_vertex, default_fragment, ShaderMaterial, Camera, PerspectiveCamera, fov, aspect, CubeCamera, CubeTexture, WebGLCubeRenderTarget, _vector1, _vector2, _normalMatrix, Plane, _sphere$2, _vector$7, Frustum, PlaneGeometry, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, alphatest_pars_fragment, aomap_fragment, aomap_pars_fragment, begin_vertex, beginnormal_vertex, bsdfs, iridescence_fragment, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, encodings_fragment, encodings_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_fragment, lightmap_pars_fragment, lights_lambert_fragment, lights_lambert_pars_fragment, lights_pars_begin, envmap_physical_pars_fragment, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphcolor_vertex, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normal_pars_fragment, normal_pars_vertex, normal_vertex, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, iridescence_pars_fragment, output_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmission_fragment, transmission_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, uv2_pars_fragment, uv2_pars_vertex, uv2_vertex, worldpos_vertex, vertex$h, fragment$h, vertex$g, fragment$g, vertex$f, fragment$f, vertex$e, fragment$e, vertex$d, fragment$d, vertex$c, fragment$c, vertex$b, fragment$b, vertex$a, fragment$a, vertex$9, fragment$9, vertex$8, fragment$8, vertex$7, fragment$7, vertex$6, fragment$6, vertex$5, fragment$5, vertex$4, fragment$4, vertex$3, fragment$3, vertex$2, fragment$2, vertex$1, fragment$1, ShaderChunk, UniformsLib, ShaderLib, _rgb, OrthographicCamera, LOD_MIN, EXTRA_LOD_SIGMA, MAX_SAMPLES, _flatCamera, _clearColor, _oldTarget, PHI, INV_PHI, _axisDirections, PMREMGenerator, emptyTexture, emptyArrayTexture, empty3dTexture, emptyCubeTexture, arrayCacheF32, arrayCacheI32, mat4array, mat3array, mat2array, SingleUniform, PureArrayUniform, StructuredUniform, RePathPart, WebGLUniforms, programIdCount, includePattern, unrollLoopPattern, _id, WebGLShaderCache, WebGLShaderStage, nextVersion, MeshDepthMaterial, MeshDistanceMaterial, vertex, fragment, ArrayCamera, Group, _moveEvent, WebXRController, DepthTexture, WebXRManager, WebGL1Renderer, FogExp2, Fog, Scene, InterleavedBuffer, _vector$6, InterleavedBufferAttribute, SpriteMaterial, _geometry, _intersectPoint, _worldScale, _mvPosition, _alignedPosition, _rotatedPosition, _viewWorldMatrix, _vA, _vB, _vC, _uvA, _uvB, _uvC, Sprite, _v1$2, _v2$1, LOD, _basePosition, _skinIndex, _skinWeight, _vector$5, _matrix, SkinnedMesh, Bone, DataTexture, _offsetMatrix, _identityMatrix, Skeleton, InstancedBufferAttribute, _instanceLocalMatrix, _instanceWorldMatrix, _instanceIntersects, _identity2, _mesh, InstancedMesh, LineBasicMaterial, _start$1, _end$1, _inverseMatrix$1, _ray$1, _sphere$1, Line, _start, _end, LineSegments, LineLoop, PointsMaterial, _inverseMatrix, _ray, _sphere, _position$2, Points, VideoTexture, FramebufferTexture, CompressedTexture, CompressedArrayTexture, CanvasTexture, Curve, EllipseCurve, ArcCurve, tmp, px, py, pz, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve, Curves, CurvePath, Path, LatheGeometry, CapsuleGeometry, CircleGeometry, CylinderGeometry, ConeGeometry, PolyhedronGeometry, DodecahedronGeometry, _v0, _v1$1, _normal, _triangle, EdgesGeometry, Shape, Earcut, ShapeUtils, ExtrudeGeometry, WorldUVGenerator, IcosahedronGeometry, OctahedronGeometry, RingGeometry, ShapeGeometry, SphereGeometry, TetrahedronGeometry, TorusGeometry, TorusKnotGeometry, TubeGeometry, WireframeGeometry, Geometries, ShadowMaterial, RawShaderMaterial, MeshStandardMaterial, MeshPhysicalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshNormalMaterial, MeshLambertMaterial, MeshMatcapMaterial, LineDashedMaterial, AnimationUtils, Interpolant, CubicInterpolant, LinearInterpolant, DiscreteInterpolant, KeyframeTrack, BooleanKeyframeTrack, ColorKeyframeTrack, NumberKeyframeTrack, QuaternionLinearInterpolant, QuaternionKeyframeTrack, StringKeyframeTrack, VectorKeyframeTrack, AnimationClip, Cache, LoadingManager, DefaultLoadingManager, Loader, loading, HttpError, FileLoader, AnimationLoader, CompressedTextureLoader, ImageLoader, CubeTextureLoader, DataTextureLoader, TextureLoader, Light, HemisphereLight, _projScreenMatrix$1, _lightPositionWorld$1, _lookTarget$1, LightShadow, SpotLightShadow, SpotLight, _projScreenMatrix, _lightPositionWorld, _lookTarget, PointLightShadow, PointLight, DirectionalLightShadow, DirectionalLight, AmbientLight, RectAreaLight, SphericalHarmonics3, LightProbe, MaterialLoader, LoaderUtils, InstancedBufferGeometry, BufferGeometryLoader, ObjectLoader, TEXTURE_MAPPING, TEXTURE_WRAPPING, TEXTURE_FILTER, ImageBitmapLoader, _context, AudioContext, AudioLoader, HemisphereLightProbe, AmbientLightProbe, _eyeRight, _eyeLeft, _projectionMatrix, StereoCamera, Clock, _position$1, _quaternion$1, _scale$1, _orientation$1, AudioListener, Audio, _position, _quaternion, _scale, _orientation, PositionalAudio, AudioAnalyser, PropertyMixer, _RESERVED_CHARS_RE, _reservedRe, _wordChar, _wordCharOrDot, _directoryRe, _nodeRe, _objectRe, _propertyRe, _trackRe, _supportedObjectNames, Composite, PropertyBinding, AnimationObjectGroup, AnimationAction, _controlInterpolantsResultBuffer, AnimationMixer, Uniform, id, UniformsGroup, InstancedInterleavedBuffer, GLBufferAttribute, Raycaster, Spherical, Cylindrical, _vector$4, Box2, _startP, _startEnd, Line3, _vector$3, SpotLightHelper, _vector$2, _boneMatrix, _matrixWorldInv, SkeletonHelper, PointLightHelper, _vector$1, _color1, _color2, HemisphereLightHelper, GridHelper, PolarGridHelper, _v1, _v2, _v3, DirectionalLightHelper, _vector, _camera, CameraHelper, _box, BoxHelper, Box3Helper, PlaneHelper, _axis, _lineGeometry, _coneGeometry, ArrowHelper, AxesHelper, ShapePath, _tables, DataUtils, BoxBufferGeometry, CapsuleBufferGeometry, CircleBufferGeometry, ConeBufferGeometry, CylinderBufferGeometry, DodecahedronBufferGeometry, ExtrudeBufferGeometry, IcosahedronBufferGeometry, LatheBufferGeometry, OctahedronBufferGeometry, PlaneBufferGeometry, PolyhedronBufferGeometry, RingBufferGeometry, ShapeBufferGeometry, SphereBufferGeometry, TetrahedronBufferGeometry, TorusBufferGeometry, TorusKnotBufferGeometry, TubeBufferGeometry;
  var init_three_module = __esm({
    "node_modules/three/build/three.module.js"() {
      REVISION = "149";
      MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
      TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
      CullFaceNone = 0;
      CullFaceBack = 1;
      CullFaceFront = 2;
      CullFaceFrontBack = 3;
      BasicShadowMap = 0;
      PCFShadowMap = 1;
      PCFSoftShadowMap = 2;
      VSMShadowMap = 3;
      FrontSide = 0;
      BackSide = 1;
      DoubleSide = 2;
      TwoPassDoubleSide = 2;
      NoBlending = 0;
      NormalBlending = 1;
      AdditiveBlending = 2;
      SubtractiveBlending = 3;
      MultiplyBlending = 4;
      CustomBlending = 5;
      AddEquation = 100;
      SubtractEquation = 101;
      ReverseSubtractEquation = 102;
      MinEquation = 103;
      MaxEquation = 104;
      ZeroFactor = 200;
      OneFactor = 201;
      SrcColorFactor = 202;
      OneMinusSrcColorFactor = 203;
      SrcAlphaFactor = 204;
      OneMinusSrcAlphaFactor = 205;
      DstAlphaFactor = 206;
      OneMinusDstAlphaFactor = 207;
      DstColorFactor = 208;
      OneMinusDstColorFactor = 209;
      SrcAlphaSaturateFactor = 210;
      NeverDepth = 0;
      AlwaysDepth = 1;
      LessDepth = 2;
      LessEqualDepth = 3;
      EqualDepth = 4;
      GreaterEqualDepth = 5;
      GreaterDepth = 6;
      NotEqualDepth = 7;
      MultiplyOperation = 0;
      MixOperation = 1;
      AddOperation = 2;
      NoToneMapping = 0;
      LinearToneMapping = 1;
      ReinhardToneMapping = 2;
      CineonToneMapping = 3;
      ACESFilmicToneMapping = 4;
      CustomToneMapping = 5;
      UVMapping = 300;
      CubeReflectionMapping = 301;
      CubeRefractionMapping = 302;
      EquirectangularReflectionMapping = 303;
      EquirectangularRefractionMapping = 304;
      CubeUVReflectionMapping = 306;
      RepeatWrapping = 1e3;
      ClampToEdgeWrapping = 1001;
      MirroredRepeatWrapping = 1002;
      NearestFilter = 1003;
      NearestMipmapNearestFilter = 1004;
      NearestMipMapNearestFilter = 1004;
      NearestMipmapLinearFilter = 1005;
      NearestMipMapLinearFilter = 1005;
      LinearFilter = 1006;
      LinearMipmapNearestFilter = 1007;
      LinearMipMapNearestFilter = 1007;
      LinearMipmapLinearFilter = 1008;
      LinearMipMapLinearFilter = 1008;
      UnsignedByteType = 1009;
      ByteType = 1010;
      ShortType = 1011;
      UnsignedShortType = 1012;
      IntType = 1013;
      UnsignedIntType = 1014;
      FloatType = 1015;
      HalfFloatType = 1016;
      UnsignedShort4444Type = 1017;
      UnsignedShort5551Type = 1018;
      UnsignedInt248Type = 1020;
      AlphaFormat = 1021;
      RGBAFormat = 1023;
      LuminanceFormat = 1024;
      LuminanceAlphaFormat = 1025;
      DepthFormat = 1026;
      DepthStencilFormat = 1027;
      RedFormat = 1028;
      RedIntegerFormat = 1029;
      RGFormat = 1030;
      RGIntegerFormat = 1031;
      RGBAIntegerFormat = 1033;
      RGB_S3TC_DXT1_Format = 33776;
      RGBA_S3TC_DXT1_Format = 33777;
      RGBA_S3TC_DXT3_Format = 33778;
      RGBA_S3TC_DXT5_Format = 33779;
      RGB_PVRTC_4BPPV1_Format = 35840;
      RGB_PVRTC_2BPPV1_Format = 35841;
      RGBA_PVRTC_4BPPV1_Format = 35842;
      RGBA_PVRTC_2BPPV1_Format = 35843;
      RGB_ETC1_Format = 36196;
      RGB_ETC2_Format = 37492;
      RGBA_ETC2_EAC_Format = 37496;
      RGBA_ASTC_4x4_Format = 37808;
      RGBA_ASTC_5x4_Format = 37809;
      RGBA_ASTC_5x5_Format = 37810;
      RGBA_ASTC_6x5_Format = 37811;
      RGBA_ASTC_6x6_Format = 37812;
      RGBA_ASTC_8x5_Format = 37813;
      RGBA_ASTC_8x6_Format = 37814;
      RGBA_ASTC_8x8_Format = 37815;
      RGBA_ASTC_10x5_Format = 37816;
      RGBA_ASTC_10x6_Format = 37817;
      RGBA_ASTC_10x8_Format = 37818;
      RGBA_ASTC_10x10_Format = 37819;
      RGBA_ASTC_12x10_Format = 37820;
      RGBA_ASTC_12x12_Format = 37821;
      RGBA_BPTC_Format = 36492;
      RED_RGTC1_Format = 36283;
      SIGNED_RED_RGTC1_Format = 36284;
      RED_GREEN_RGTC2_Format = 36285;
      SIGNED_RED_GREEN_RGTC2_Format = 36286;
      LoopOnce = 2200;
      LoopRepeat = 2201;
      LoopPingPong = 2202;
      InterpolateDiscrete = 2300;
      InterpolateLinear = 2301;
      InterpolateSmooth = 2302;
      ZeroCurvatureEnding = 2400;
      ZeroSlopeEnding = 2401;
      WrapAroundEnding = 2402;
      NormalAnimationBlendMode = 2500;
      AdditiveAnimationBlendMode = 2501;
      TrianglesDrawMode = 0;
      TriangleStripDrawMode = 1;
      TriangleFanDrawMode = 2;
      LinearEncoding = 3e3;
      sRGBEncoding = 3001;
      BasicDepthPacking = 3200;
      RGBADepthPacking = 3201;
      TangentSpaceNormalMap = 0;
      ObjectSpaceNormalMap = 1;
      NoColorSpace = "";
      SRGBColorSpace = "srgb";
      LinearSRGBColorSpace = "srgb-linear";
      ZeroStencilOp = 0;
      KeepStencilOp = 7680;
      ReplaceStencilOp = 7681;
      IncrementStencilOp = 7682;
      DecrementStencilOp = 7683;
      IncrementWrapStencilOp = 34055;
      DecrementWrapStencilOp = 34056;
      InvertStencilOp = 5386;
      NeverStencilFunc = 512;
      LessStencilFunc = 513;
      EqualStencilFunc = 514;
      LessEqualStencilFunc = 515;
      GreaterStencilFunc = 516;
      NotEqualStencilFunc = 517;
      GreaterEqualStencilFunc = 518;
      AlwaysStencilFunc = 519;
      StaticDrawUsage = 35044;
      DynamicDrawUsage = 35048;
      StreamDrawUsage = 35040;
      StaticReadUsage = 35045;
      DynamicReadUsage = 35049;
      StreamReadUsage = 35041;
      StaticCopyUsage = 35046;
      DynamicCopyUsage = 35050;
      StreamCopyUsage = 35042;
      GLSL1 = "100";
      GLSL3 = "300 es";
      _SRGBAFormat = 1035;
      EventDispatcher = class {
        addEventListener(type3, listener) {
          if (this._listeners === void 0)
            this._listeners = {};
          const listeners2 = this._listeners;
          if (listeners2[type3] === void 0) {
            listeners2[type3] = [];
          }
          if (listeners2[type3].indexOf(listener) === -1) {
            listeners2[type3].push(listener);
          }
        }
        hasEventListener(type3, listener) {
          if (this._listeners === void 0)
            return false;
          const listeners2 = this._listeners;
          return listeners2[type3] !== void 0 && listeners2[type3].indexOf(listener) !== -1;
        }
        removeEventListener(type3, listener) {
          if (this._listeners === void 0)
            return;
          const listeners2 = this._listeners;
          const listenerArray = listeners2[type3];
          if (listenerArray !== void 0) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) {
              listenerArray.splice(index, 1);
            }
          }
        }
        dispatchEvent(event) {
          if (this._listeners === void 0)
            return;
          const listeners2 = this._listeners;
          const listenerArray = listeners2[event.type];
          if (listenerArray !== void 0) {
            event.target = this;
            const array = listenerArray.slice(0);
            for (let i = 0, l = array.length; i < l; i++) {
              array[i].call(this, event);
            }
            event.target = null;
          }
        }
      };
      _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
      _seed = 1234567;
      DEG2RAD = Math.PI / 180;
      RAD2DEG = 180 / Math.PI;
      MathUtils = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        DEG2RAD,
        RAD2DEG,
        ceilPowerOfTwo,
        clamp,
        damp,
        degToRad,
        denormalize,
        euclideanModulo,
        floorPowerOfTwo,
        generateUUID,
        inverseLerp,
        isPowerOfTwo,
        lerp,
        mapLinear,
        normalize,
        pingpong,
        radToDeg,
        randFloat,
        randFloatSpread,
        randInt,
        seededRandom,
        setQuaternionFromProperEuler,
        smootherstep,
        smoothstep
      });
      Vector2 = class {
        constructor(x = 0, y = 0) {
          Vector2.prototype.isVector2 = true;
          this.x = x;
          this.y = y;
        }
        get width() {
          return this.x;
        }
        set width(value) {
          this.x = value;
        }
        get height() {
          return this.y;
        }
        set height(value) {
          this.y = value;
        }
        set(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          return this;
        }
        add(v) {
          this.x += v.x;
          this.y += v.y;
          return this;
        }
        addScalar(s) {
          this.x += s;
          this.y += s;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          return this;
        }
        addScaledVector(v, s) {
          this.x += v.x * s;
          this.y += v.y * s;
          return this;
        }
        sub(v) {
          this.x -= v.x;
          this.y -= v.y;
          return this;
        }
        subScalar(s) {
          this.x -= s;
          this.y -= s;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          return this;
        }
        multiply(v) {
          this.x *= v.x;
          this.y *= v.y;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          return this;
        }
        divide(v) {
          this.x /= v.x;
          this.y /= v.y;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        applyMatrix3(m) {
          const x = this.x, y = this.y;
          const e = m.elements;
          this.x = e[0] * x + e[3] * y + e[6];
          this.y = e[1] * x + e[4] * y + e[7];
          return this;
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y;
        }
        cross(v) {
          return this.x * v.y - this.y * v.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          const angle = Math.atan2(-this.y, -this.x) + Math.PI;
          return angle;
        }
        distanceTo(v) {
          return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
          const dx = this.x - v.x, dy = this.y - v.y;
          return dx * dx + dy * dy;
        }
        manhattanDistanceTo(v) {
          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          return this;
        }
        equals(v) {
          return v.x === this.x && v.y === this.y;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          return this;
        }
        rotateAround(center, angle) {
          const c = Math.cos(angle), s = Math.sin(angle);
          const x = this.x - center.x;
          const y = this.y - center.y;
          this.x = x * c - y * s + center.x;
          this.y = x * s + y * c + center.y;
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
        }
      };
      Matrix3 = class {
        constructor() {
          Matrix3.prototype.isMatrix3 = true;
          this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ];
        }
        set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
          const te = this.elements;
          te[0] = n11;
          te[1] = n21;
          te[2] = n31;
          te[3] = n12;
          te[4] = n22;
          te[5] = n32;
          te[6] = n13;
          te[7] = n23;
          te[8] = n33;
          return this;
        }
        identity() {
          this.set(
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          );
          return this;
        }
        copy(m) {
          const te = this.elements;
          const me = m.elements;
          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrix3Column(this, 0);
          yAxis.setFromMatrix3Column(this, 1);
          zAxis.setFromMatrix3Column(this, 2);
          return this;
        }
        setFromMatrix4(m) {
          const me = m.elements;
          this.set(
            me[0],
            me[4],
            me[8],
            me[1],
            me[5],
            me[9],
            me[2],
            me[6],
            me[10]
          );
          return this;
        }
        multiply(m) {
          return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
          return this.multiplyMatrices(m, this);
        }
        multiplyMatrices(a, b) {
          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;
          const a11 = ae[0], a12 = ae[3], a13 = ae[6];
          const a21 = ae[1], a22 = ae[4], a23 = ae[7];
          const a31 = ae[2], a32 = ae[5], a33 = ae[8];
          const b11 = be[0], b12 = be[3], b13 = be[6];
          const b21 = be[1], b22 = be[4], b23 = be[7];
          const b31 = be[2], b32 = be[5], b33 = be[8];
          te[0] = a11 * b11 + a12 * b21 + a13 * b31;
          te[3] = a11 * b12 + a12 * b22 + a13 * b32;
          te[6] = a11 * b13 + a12 * b23 + a13 * b33;
          te[1] = a21 * b11 + a22 * b21 + a23 * b31;
          te[4] = a21 * b12 + a22 * b22 + a23 * b32;
          te[7] = a21 * b13 + a22 * b23 + a23 * b33;
          te[2] = a31 * b11 + a32 * b21 + a33 * b31;
          te[5] = a31 * b12 + a32 * b22 + a33 * b32;
          te[8] = a31 * b13 + a32 * b23 + a33 * b33;
          return this;
        }
        multiplyScalar(s) {
          const te = this.elements;
          te[0] *= s;
          te[3] *= s;
          te[6] *= s;
          te[1] *= s;
          te[4] *= s;
          te[7] *= s;
          te[2] *= s;
          te[5] *= s;
          te[8] *= s;
          return this;
        }
        determinant() {
          const te = this.elements;
          const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
          return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        }
        invert() {
          const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te[0] = t11 * detInv;
          te[1] = (n31 * n23 - n33 * n21) * detInv;
          te[2] = (n32 * n21 - n31 * n22) * detInv;
          te[3] = t12 * detInv;
          te[4] = (n33 * n11 - n31 * n13) * detInv;
          te[5] = (n31 * n12 - n32 * n11) * detInv;
          te[6] = t13 * detInv;
          te[7] = (n21 * n13 - n23 * n11) * detInv;
          te[8] = (n22 * n11 - n21 * n12) * detInv;
          return this;
        }
        transpose() {
          let tmp2;
          const m = this.elements;
          tmp2 = m[1];
          m[1] = m[3];
          m[3] = tmp2;
          tmp2 = m[2];
          m[2] = m[6];
          m[6] = tmp2;
          tmp2 = m[5];
          m[5] = m[7];
          m[7] = tmp2;
          return this;
        }
        getNormalMatrix(matrix4) {
          return this.setFromMatrix4(matrix4).invert().transpose();
        }
        transposeIntoArray(r) {
          const m = this.elements;
          r[0] = m[0];
          r[1] = m[3];
          r[2] = m[6];
          r[3] = m[1];
          r[4] = m[4];
          r[5] = m[7];
          r[6] = m[2];
          r[7] = m[5];
          r[8] = m[8];
          return this;
        }
        setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
          const c = Math.cos(rotation);
          const s = Math.sin(rotation);
          this.set(
            sx * c,
            sx * s,
            -sx * (c * cx + s * cy) + cx + tx,
            -sy * s,
            sy * c,
            -sy * (-s * cx + c * cy) + cy + ty,
            0,
            0,
            1
          );
          return this;
        }
        scale(sx, sy) {
          this.premultiply(_m3.makeScale(sx, sy));
          return this;
        }
        rotate(theta) {
          this.premultiply(_m3.makeRotation(-theta));
          return this;
        }
        translate(tx, ty) {
          this.premultiply(_m3.makeTranslation(tx, ty));
          return this;
        }
        makeTranslation(x, y) {
          this.set(
            1,
            0,
            x,
            0,
            1,
            y,
            0,
            0,
            1
          );
          return this;
        }
        makeRotation(theta) {
          const c = Math.cos(theta);
          const s = Math.sin(theta);
          this.set(
            c,
            -s,
            0,
            s,
            c,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeScale(x, y) {
          this.set(
            x,
            0,
            0,
            0,
            y,
            0,
            0,
            0,
            1
          );
          return this;
        }
        equals(matrix) {
          const te = this.elements;
          const me = matrix.elements;
          for (let i = 0; i < 9; i++) {
            if (te[i] !== me[i])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i = 0; i < 9; i++) {
            this.elements[i] = array[i + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te = this.elements;
          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];
          array[offset + 3] = te[3];
          array[offset + 4] = te[4];
          array[offset + 5] = te[5];
          array[offset + 6] = te[6];
          array[offset + 7] = te[7];
          array[offset + 8] = te[8];
          return array;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      };
      _m3 = /* @__PURE__ */ new Matrix3();
      TYPED_ARRAYS = {
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      };
      FN = {
        [SRGBColorSpace]: { [LinearSRGBColorSpace]: SRGBToLinear },
        [LinearSRGBColorSpace]: { [SRGBColorSpace]: LinearToSRGB }
      };
      ColorManagement = {
        legacyMode: true,
        get workingColorSpace() {
          return LinearSRGBColorSpace;
        },
        set workingColorSpace(colorSpace) {
          console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
        },
        convert: function(color, sourceColorSpace, targetColorSpace) {
          if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
            return color;
          }
          if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== void 0) {
            const fn = FN[sourceColorSpace][targetColorSpace];
            color.r = fn(color.r);
            color.g = fn(color.g);
            color.b = fn(color.b);
            return color;
          }
          throw new Error("Unsupported color space conversion.");
        },
        fromWorkingColorSpace: function(color, targetColorSpace) {
          return this.convert(color, this.workingColorSpace, targetColorSpace);
        },
        toWorkingColorSpace: function(color, sourceColorSpace) {
          return this.convert(color, sourceColorSpace, this.workingColorSpace);
        }
      };
      _colorKeywords = {
        "aliceblue": 15792383,
        "antiquewhite": 16444375,
        "aqua": 65535,
        "aquamarine": 8388564,
        "azure": 15794175,
        "beige": 16119260,
        "bisque": 16770244,
        "black": 0,
        "blanchedalmond": 16772045,
        "blue": 255,
        "blueviolet": 9055202,
        "brown": 10824234,
        "burlywood": 14596231,
        "cadetblue": 6266528,
        "chartreuse": 8388352,
        "chocolate": 13789470,
        "coral": 16744272,
        "cornflowerblue": 6591981,
        "cornsilk": 16775388,
        "crimson": 14423100,
        "cyan": 65535,
        "darkblue": 139,
        "darkcyan": 35723,
        "darkgoldenrod": 12092939,
        "darkgray": 11119017,
        "darkgreen": 25600,
        "darkgrey": 11119017,
        "darkkhaki": 12433259,
        "darkmagenta": 9109643,
        "darkolivegreen": 5597999,
        "darkorange": 16747520,
        "darkorchid": 10040012,
        "darkred": 9109504,
        "darksalmon": 15308410,
        "darkseagreen": 9419919,
        "darkslateblue": 4734347,
        "darkslategray": 3100495,
        "darkslategrey": 3100495,
        "darkturquoise": 52945,
        "darkviolet": 9699539,
        "deeppink": 16716947,
        "deepskyblue": 49151,
        "dimgray": 6908265,
        "dimgrey": 6908265,
        "dodgerblue": 2003199,
        "firebrick": 11674146,
        "floralwhite": 16775920,
        "forestgreen": 2263842,
        "fuchsia": 16711935,
        "gainsboro": 14474460,
        "ghostwhite": 16316671,
        "gold": 16766720,
        "goldenrod": 14329120,
        "gray": 8421504,
        "green": 32768,
        "greenyellow": 11403055,
        "grey": 8421504,
        "honeydew": 15794160,
        "hotpink": 16738740,
        "indianred": 13458524,
        "indigo": 4915330,
        "ivory": 16777200,
        "khaki": 15787660,
        "lavender": 15132410,
        "lavenderblush": 16773365,
        "lawngreen": 8190976,
        "lemonchiffon": 16775885,
        "lightblue": 11393254,
        "lightcoral": 15761536,
        "lightcyan": 14745599,
        "lightgoldenrodyellow": 16448210,
        "lightgray": 13882323,
        "lightgreen": 9498256,
        "lightgrey": 13882323,
        "lightpink": 16758465,
        "lightsalmon": 16752762,
        "lightseagreen": 2142890,
        "lightskyblue": 8900346,
        "lightslategray": 7833753,
        "lightslategrey": 7833753,
        "lightsteelblue": 11584734,
        "lightyellow": 16777184,
        "lime": 65280,
        "limegreen": 3329330,
        "linen": 16445670,
        "magenta": 16711935,
        "maroon": 8388608,
        "mediumaquamarine": 6737322,
        "mediumblue": 205,
        "mediumorchid": 12211667,
        "mediumpurple": 9662683,
        "mediumseagreen": 3978097,
        "mediumslateblue": 8087790,
        "mediumspringgreen": 64154,
        "mediumturquoise": 4772300,
        "mediumvioletred": 13047173,
        "midnightblue": 1644912,
        "mintcream": 16121850,
        "mistyrose": 16770273,
        "moccasin": 16770229,
        "navajowhite": 16768685,
        "navy": 128,
        "oldlace": 16643558,
        "olive": 8421376,
        "olivedrab": 7048739,
        "orange": 16753920,
        "orangered": 16729344,
        "orchid": 14315734,
        "palegoldenrod": 15657130,
        "palegreen": 10025880,
        "paleturquoise": 11529966,
        "palevioletred": 14381203,
        "papayawhip": 16773077,
        "peachpuff": 16767673,
        "peru": 13468991,
        "pink": 16761035,
        "plum": 14524637,
        "powderblue": 11591910,
        "purple": 8388736,
        "rebeccapurple": 6697881,
        "red": 16711680,
        "rosybrown": 12357519,
        "royalblue": 4286945,
        "saddlebrown": 9127187,
        "salmon": 16416882,
        "sandybrown": 16032864,
        "seagreen": 3050327,
        "seashell": 16774638,
        "sienna": 10506797,
        "silver": 12632256,
        "skyblue": 8900331,
        "slateblue": 6970061,
        "slategray": 7372944,
        "slategrey": 7372944,
        "snow": 16775930,
        "springgreen": 65407,
        "steelblue": 4620980,
        "tan": 13808780,
        "teal": 32896,
        "thistle": 14204888,
        "tomato": 16737095,
        "turquoise": 4251856,
        "violet": 15631086,
        "wheat": 16113331,
        "white": 16777215,
        "whitesmoke": 16119285,
        "yellow": 16776960,
        "yellowgreen": 10145074
      };
      _rgb$1 = { r: 0, g: 0, b: 0 };
      _hslA = { h: 0, s: 0, l: 0 };
      _hslB = { h: 0, s: 0, l: 0 };
      Color = class {
        constructor(r, g, b) {
          this.isColor = true;
          this.r = 1;
          this.g = 1;
          this.b = 1;
          if (g === void 0 && b === void 0) {
            return this.set(r);
          }
          return this.setRGB(r, g, b);
        }
        set(value) {
          if (value && value.isColor) {
            this.copy(value);
          } else if (typeof value === "number") {
            this.setHex(value);
          } else if (typeof value === "string") {
            this.setStyle(value);
          }
          return this;
        }
        setScalar(scalar) {
          this.r = scalar;
          this.g = scalar;
          this.b = scalar;
          return this;
        }
        setHex(hex, colorSpace = SRGBColorSpace) {
          hex = Math.floor(hex);
          this.r = (hex >> 16 & 255) / 255;
          this.g = (hex >> 8 & 255) / 255;
          this.b = (hex & 255) / 255;
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        }
        setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
          this.r = r;
          this.g = g;
          this.b = b;
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        }
        setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
          h = euclideanModulo(h, 1);
          s = clamp(s, 0, 1);
          l = clamp(l, 0, 1);
          if (s === 0) {
            this.r = this.g = this.b = l;
          } else {
            const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
            const q = 2 * l - p;
            this.r = hue2rgb(q, p, h + 1 / 3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1 / 3);
          }
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        }
        setStyle(style, colorSpace = SRGBColorSpace) {
          function handleAlpha(string) {
            if (string === void 0)
              return;
            if (parseFloat(string) < 1) {
              console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
            }
          }
          let m;
          if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
            let color;
            const name = m[1];
            const components = m[2];
            switch (name) {
              case "rgb":
              case "rgba":
                if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                  this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                  this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                  ColorManagement.toWorkingColorSpace(this, colorSpace);
                  handleAlpha(color[4]);
                  return this;
                }
                if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                  this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                  this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                  ColorManagement.toWorkingColorSpace(this, colorSpace);
                  handleAlpha(color[4]);
                  return this;
                }
                break;
              case "hsl":
              case "hsla":
                if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                  const h = parseFloat(color[1]) / 360;
                  const s = parseFloat(color[2]) / 100;
                  const l = parseFloat(color[3]) / 100;
                  handleAlpha(color[4]);
                  return this.setHSL(h, s, l, colorSpace);
                }
                break;
            }
          } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
              this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
              this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
              ColorManagement.toWorkingColorSpace(this, colorSpace);
              return this;
            } else if (size === 6) {
              this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
              this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
              this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
              ColorManagement.toWorkingColorSpace(this, colorSpace);
              return this;
            }
          }
          if (style && style.length > 0) {
            return this.setColorName(style, colorSpace);
          }
          return this;
        }
        setColorName(style, colorSpace = SRGBColorSpace) {
          const hex = _colorKeywords[style.toLowerCase()];
          if (hex !== void 0) {
            this.setHex(hex, colorSpace);
          } else {
            console.warn("THREE.Color: Unknown color " + style);
          }
          return this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(color) {
          this.r = color.r;
          this.g = color.g;
          this.b = color.b;
          return this;
        }
        copySRGBToLinear(color) {
          this.r = SRGBToLinear(color.r);
          this.g = SRGBToLinear(color.g);
          this.b = SRGBToLinear(color.b);
          return this;
        }
        copyLinearToSRGB(color) {
          this.r = LinearToSRGB(color.r);
          this.g = LinearToSRGB(color.g);
          this.b = LinearToSRGB(color.b);
          return this;
        }
        convertSRGBToLinear() {
          this.copySRGBToLinear(this);
          return this;
        }
        convertLinearToSRGB() {
          this.copyLinearToSRGB(this);
          return this;
        }
        getHex(colorSpace = SRGBColorSpace) {
          ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), colorSpace);
          return clamp(_rgb$1.r * 255, 0, 255) << 16 ^ clamp(_rgb$1.g * 255, 0, 255) << 8 ^ clamp(_rgb$1.b * 255, 0, 255) << 0;
        }
        getHexString(colorSpace = SRGBColorSpace) {
          return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
        }
        getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
          ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), colorSpace);
          const r = _rgb$1.r, g = _rgb$1.g, b = _rgb$1.b;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let hue, saturation;
          const lightness = (min + max) / 2;
          if (min === max) {
            hue = 0;
            saturation = 0;
          } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch (max) {
              case r:
                hue = (g - b) / delta + (g < b ? 6 : 0);
                break;
              case g:
                hue = (b - r) / delta + 2;
                break;
              case b:
                hue = (r - g) / delta + 4;
                break;
            }
            hue /= 6;
          }
          target.h = hue;
          target.s = saturation;
          target.l = lightness;
          return target;
        }
        getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
          ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), colorSpace);
          target.r = _rgb$1.r;
          target.g = _rgb$1.g;
          target.b = _rgb$1.b;
          return target;
        }
        getStyle(colorSpace = SRGBColorSpace) {
          ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb$1), colorSpace);
          if (colorSpace !== SRGBColorSpace) {
            return `color(${colorSpace} ${_rgb$1.r} ${_rgb$1.g} ${_rgb$1.b})`;
          }
          return `rgb(${_rgb$1.r * 255 | 0},${_rgb$1.g * 255 | 0},${_rgb$1.b * 255 | 0})`;
        }
        offsetHSL(h, s, l) {
          this.getHSL(_hslA);
          _hslA.h += h;
          _hslA.s += s;
          _hslA.l += l;
          this.setHSL(_hslA.h, _hslA.s, _hslA.l);
          return this;
        }
        add(color) {
          this.r += color.r;
          this.g += color.g;
          this.b += color.b;
          return this;
        }
        addColors(color1, color2) {
          this.r = color1.r + color2.r;
          this.g = color1.g + color2.g;
          this.b = color1.b + color2.b;
          return this;
        }
        addScalar(s) {
          this.r += s;
          this.g += s;
          this.b += s;
          return this;
        }
        sub(color) {
          this.r = Math.max(0, this.r - color.r);
          this.g = Math.max(0, this.g - color.g);
          this.b = Math.max(0, this.b - color.b);
          return this;
        }
        multiply(color) {
          this.r *= color.r;
          this.g *= color.g;
          this.b *= color.b;
          return this;
        }
        multiplyScalar(s) {
          this.r *= s;
          this.g *= s;
          this.b *= s;
          return this;
        }
        lerp(color, alpha) {
          this.r += (color.r - this.r) * alpha;
          this.g += (color.g - this.g) * alpha;
          this.b += (color.b - this.b) * alpha;
          return this;
        }
        lerpColors(color1, color2, alpha) {
          this.r = color1.r + (color2.r - color1.r) * alpha;
          this.g = color1.g + (color2.g - color1.g) * alpha;
          this.b = color1.b + (color2.b - color1.b) * alpha;
          return this;
        }
        lerpHSL(color, alpha) {
          this.getHSL(_hslA);
          color.getHSL(_hslB);
          const h = lerp(_hslA.h, _hslB.h, alpha);
          const s = lerp(_hslA.s, _hslB.s, alpha);
          const l = lerp(_hslA.l, _hslB.l, alpha);
          this.setHSL(h, s, l);
          return this;
        }
        equals(c) {
          return c.r === this.r && c.g === this.g && c.b === this.b;
        }
        fromArray(array, offset = 0) {
          this.r = array[offset];
          this.g = array[offset + 1];
          this.b = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.r;
          array[offset + 1] = this.g;
          array[offset + 2] = this.b;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.r = attribute.getX(index);
          this.g = attribute.getY(index);
          this.b = attribute.getZ(index);
          return this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r;
          yield this.g;
          yield this.b;
        }
      };
      Color.NAMES = _colorKeywords;
      ImageUtils = class {
        static getDataURL(image) {
          if (/^data:/i.test(image.src)) {
            return image.src;
          }
          if (typeof HTMLCanvasElement == "undefined") {
            return image.src;
          }
          let canvas;
          if (image instanceof HTMLCanvasElement) {
            canvas = image;
          } else {
            if (_canvas === void 0)
              _canvas = createElementNS("canvas");
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext("2d");
            if (image instanceof ImageData) {
              context.putImageData(image, 0, 0);
            } else {
              context.drawImage(image, 0, 0, image.width, image.height);
            }
            canvas = _canvas;
          }
          if (canvas.width > 2048 || canvas.height > 2048) {
            console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
            return canvas.toDataURL("image/jpeg", 0.6);
          } else {
            return canvas.toDataURL("image/png");
          }
        }
        static sRGBToLinear(image) {
          if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
            const canvas = createElementNS("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, image.width, image.height);
            const imageData = context.getImageData(0, 0, image.width, image.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i++) {
              data[i] = SRGBToLinear(data[i] / 255) * 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
          } else if (image.data) {
            const data = image.data.slice(0);
            for (let i = 0; i < data.length; i++) {
              if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
                data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
              } else {
                data[i] = SRGBToLinear(data[i]);
              }
            }
            return {
              data,
              width: image.width,
              height: image.height
            };
          } else {
            console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
            return image;
          }
        }
      };
      Source = class {
        constructor(data = null) {
          this.isSource = true;
          this.uuid = generateUUID();
          this.data = data;
          this.version = 0;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (!isRootObject && meta.images[this.uuid] !== void 0) {
            return meta.images[this.uuid];
          }
          const output = {
            uuid: this.uuid,
            url: ""
          };
          const data = this.data;
          if (data !== null) {
            let url;
            if (Array.isArray(data)) {
              url = [];
              for (let i = 0, l = data.length; i < l; i++) {
                if (data[i].isDataTexture) {
                  url.push(serializeImage(data[i].image));
                } else {
                  url.push(serializeImage(data[i]));
                }
              }
            } else {
              url = serializeImage(data);
            }
            output.url = url;
          }
          if (!isRootObject) {
            meta.images[this.uuid] = output;
          }
          return output;
        }
      };
      textureId = 0;
      Texture = class extends EventDispatcher {
        constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type3 = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, encoding = LinearEncoding) {
          super();
          this.isTexture = true;
          Object.defineProperty(this, "id", { value: textureId++ });
          this.uuid = generateUUID();
          this.name = "";
          this.source = new Source(image);
          this.mipmaps = [];
          this.mapping = mapping;
          this.wrapS = wrapS;
          this.wrapT = wrapT;
          this.magFilter = magFilter;
          this.minFilter = minFilter;
          this.anisotropy = anisotropy;
          this.format = format;
          this.internalFormat = null;
          this.type = type3;
          this.offset = new Vector2(0, 0);
          this.repeat = new Vector2(1, 1);
          this.center = new Vector2(0, 0);
          this.rotation = 0;
          this.matrixAutoUpdate = true;
          this.matrix = new Matrix3();
          this.generateMipmaps = true;
          this.premultiplyAlpha = false;
          this.flipY = true;
          this.unpackAlignment = 4;
          this.encoding = encoding;
          this.userData = {};
          this.version = 0;
          this.onUpdate = null;
          this.isRenderTargetTexture = false;
          this.needsPMREMUpdate = false;
        }
        get image() {
          return this.source.data;
        }
        set image(value) {
          this.source.data = value;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.source = source.source;
          this.mipmaps = source.mipmaps.slice(0);
          this.mapping = source.mapping;
          this.wrapS = source.wrapS;
          this.wrapT = source.wrapT;
          this.magFilter = source.magFilter;
          this.minFilter = source.minFilter;
          this.anisotropy = source.anisotropy;
          this.format = source.format;
          this.internalFormat = source.internalFormat;
          this.type = source.type;
          this.offset.copy(source.offset);
          this.repeat.copy(source.repeat);
          this.center.copy(source.center);
          this.rotation = source.rotation;
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrix.copy(source.matrix);
          this.generateMipmaps = source.generateMipmaps;
          this.premultiplyAlpha = source.premultiplyAlpha;
          this.flipY = source.flipY;
          this.unpackAlignment = source.unpackAlignment;
          this.encoding = source.encoding;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          this.needsUpdate = true;
          return this;
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (!isRootObject && meta.textures[this.uuid] !== void 0) {
            return meta.textures[this.uuid];
          }
          const output = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(meta).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          if (Object.keys(this.userData).length > 0)
            output.userData = this.userData;
          if (!isRootObject) {
            meta.textures[this.uuid] = output;
          }
          return output;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(uv) {
          if (this.mapping !== UVMapping)
            return uv;
          uv.applyMatrix3(this.matrix);
          if (uv.x < 0 || uv.x > 1) {
            switch (this.wrapS) {
              case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
              case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                  uv.x = Math.ceil(uv.x) - uv.x;
                } else {
                  uv.x = uv.x - Math.floor(uv.x);
                }
                break;
            }
          }
          if (uv.y < 0 || uv.y > 1) {
            switch (this.wrapT) {
              case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
              case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
              case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                  uv.y = Math.ceil(uv.y) - uv.y;
                } else {
                  uv.y = uv.y - Math.floor(uv.y);
                }
                break;
            }
          }
          if (this.flipY) {
            uv.y = 1 - uv.y;
          }
          return uv;
        }
        set needsUpdate(value) {
          if (value === true) {
            this.version++;
            this.source.needsUpdate = true;
          }
        }
      };
      Texture.DEFAULT_IMAGE = null;
      Texture.DEFAULT_MAPPING = UVMapping;
      Texture.DEFAULT_ANISOTROPY = 1;
      Vector4 = class {
        constructor(x = 0, y = 0, z = 0, w = 1) {
          Vector4.prototype.isVector4 = true;
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
        }
        get width() {
          return this.z;
        }
        set width(value) {
          this.z = value;
        }
        get height() {
          return this.w;
        }
        set height(value) {
          this.w = value;
        }
        set(x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          this.w = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setZ(z) {
          this.z = z;
          return this;
        }
        setW(w) {
          this.w = w;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            case 3:
              this.w = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          this.w = v.w !== void 0 ? v.w : 1;
          return this;
        }
        add(v) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          this.w += v.w;
          return this;
        }
        addScalar(s) {
          this.x += s;
          this.y += s;
          this.z += s;
          this.w += s;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          this.w = a.w + b.w;
          return this;
        }
        addScaledVector(v, s) {
          this.x += v.x * s;
          this.y += v.y * s;
          this.z += v.z * s;
          this.w += v.w * s;
          return this;
        }
        sub(v) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          this.w -= v.w;
          return this;
        }
        subScalar(s) {
          this.x -= s;
          this.y -= s;
          this.z -= s;
          this.w -= s;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          this.w = a.w - b.w;
          return this;
        }
        multiply(v) {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
          this.w *= v.w;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
          return this;
        }
        applyMatrix4(m) {
          const x = this.x, y = this.y, z = this.z, w = this.w;
          const e = m.elements;
          this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
          this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
          this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
          this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        setAxisAngleFromQuaternion(q) {
          this.w = 2 * Math.acos(q.w);
          const s = Math.sqrt(1 - q.w * q.w);
          if (s < 1e-4) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
          } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
          }
          return this;
        }
        setAxisAngleFromRotationMatrix(m) {
          let angle, x, y, z;
          const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
          if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
              this.set(1, 0, 0, 0);
              return this;
            }
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
              if (xx < epsilon) {
                x = 0;
                y = 0.707106781;
                z = 0.707106781;
              } else {
                x = Math.sqrt(xx);
                y = xy / x;
                z = xz / x;
              }
            } else if (yy > zz) {
              if (yy < epsilon) {
                x = 0.707106781;
                y = 0;
                z = 0.707106781;
              } else {
                y = Math.sqrt(yy);
                x = xy / y;
                z = yz / y;
              }
            } else {
              if (zz < epsilon) {
                x = 0.707106781;
                y = 0.707106781;
                z = 0;
              } else {
                z = Math.sqrt(zz);
                x = xz / z;
                y = yz / z;
              }
            }
            this.set(x, y, z, angle);
            return this;
          }
          let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
          if (Math.abs(s) < 1e-3)
            s = 1;
          this.x = (m32 - m23) / s;
          this.y = (m13 - m31) / s;
          this.z = (m21 - m12) / s;
          this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
          return this;
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          this.w = Math.min(this.w, v.w);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          this.w = Math.max(this.w, v.w);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          this.w = Math.max(min.w, Math.min(max.w, this.w));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          this.w = Math.max(minVal, Math.min(maxVal, this.w));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          this.w = Math.floor(this.w);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          this.w = Math.ceil(this.w);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          this.w = Math.round(this.w);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;
          this.w += (v.w - this.w) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          this.w = v1.w + (v2.w - v1.w) * alpha;
          return this;
        }
        equals(v) {
          return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          this.w = array[offset + 3];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          array[offset + 3] = this.w;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          this.w = attribute.getW(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          this.w = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
          yield this.w;
        }
      };
      WebGLRenderTarget = class extends EventDispatcher {
        constructor(width2 = 1, height2 = 1, options = {}) {
          super();
          this.isWebGLRenderTarget = true;
          this.width = width2;
          this.height = height2;
          this.depth = 1;
          this.scissor = new Vector4(0, 0, width2, height2);
          this.scissorTest = false;
          this.viewport = new Vector4(0, 0, width2, height2);
          const image = { width: width2, height: height2, depth: 1 };
          this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.flipY = false;
          this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
          this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
          this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
          this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
          this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
          this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
          this.samples = options.samples !== void 0 ? options.samples : 0;
        }
        setSize(width2, height2, depth = 1) {
          if (this.width !== width2 || this.height !== height2 || this.depth !== depth) {
            this.width = width2;
            this.height = height2;
            this.depth = depth;
            this.texture.image.width = width2;
            this.texture.image.height = height2;
            this.texture.image.depth = depth;
            this.dispose();
          }
          this.viewport.set(0, 0, width2, height2);
          this.scissor.set(0, 0, width2, height2);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.copy(source.viewport);
          this.texture = source.texture.clone();
          this.texture.isRenderTargetTexture = true;
          const image = Object.assign({}, source.texture.image);
          this.texture.source = new Source(image);
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          if (source.depthTexture !== null)
            this.depthTexture = source.depthTexture.clone();
          this.samples = source.samples;
          return this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      };
      DataArrayTexture = class extends Texture {
        constructor(data = null, width2 = 1, height2 = 1, depth = 1) {
          super(null);
          this.isDataArrayTexture = true;
          this.image = { data, width: width2, height: height2, depth };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      WebGLArrayRenderTarget = class extends WebGLRenderTarget {
        constructor(width2 = 1, height2 = 1, depth = 1) {
          super(width2, height2);
          this.isWebGLArrayRenderTarget = true;
          this.depth = depth;
          this.texture = new DataArrayTexture(null, width2, height2, depth);
          this.texture.isRenderTargetTexture = true;
        }
      };
      Data3DTexture = class extends Texture {
        constructor(data = null, width2 = 1, height2 = 1, depth = 1) {
          super(null);
          this.isData3DTexture = true;
          this.image = { data, width: width2, height: height2, depth };
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.wrapR = ClampToEdgeWrapping;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      WebGL3DRenderTarget = class extends WebGLRenderTarget {
        constructor(width2 = 1, height2 = 1, depth = 1) {
          super(width2, height2);
          this.isWebGL3DRenderTarget = true;
          this.depth = depth;
          this.texture = new Data3DTexture(null, width2, height2, depth);
          this.texture.isRenderTargetTexture = true;
        }
      };
      WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
        constructor(width2 = 1, height2 = 1, count = 1, options = {}) {
          super(width2, height2, options);
          this.isWebGLMultipleRenderTargets = true;
          const texture = this.texture;
          this.texture = [];
          for (let i = 0; i < count; i++) {
            this.texture[i] = texture.clone();
            this.texture[i].isRenderTargetTexture = true;
          }
        }
        setSize(width2, height2, depth = 1) {
          if (this.width !== width2 || this.height !== height2 || this.depth !== depth) {
            this.width = width2;
            this.height = height2;
            this.depth = depth;
            for (let i = 0, il = this.texture.length; i < il; i++) {
              this.texture[i].image.width = width2;
              this.texture[i].image.height = height2;
              this.texture[i].image.depth = depth;
            }
            this.dispose();
          }
          this.viewport.set(0, 0, width2, height2);
          this.scissor.set(0, 0, width2, height2);
          return this;
        }
        copy(source) {
          this.dispose();
          this.width = source.width;
          this.height = source.height;
          this.depth = source.depth;
          this.viewport.set(0, 0, this.width, this.height);
          this.scissor.set(0, 0, this.width, this.height);
          this.depthBuffer = source.depthBuffer;
          this.stencilBuffer = source.stencilBuffer;
          if (source.depthTexture !== null)
            this.depthTexture = source.depthTexture.clone();
          this.texture.length = 0;
          for (let i = 0, il = source.texture.length; i < il; i++) {
            this.texture[i] = source.texture[i].clone();
            this.texture[i].isRenderTargetTexture = true;
          }
          return this;
        }
      };
      Quaternion = class {
        constructor(x = 0, y = 0, z = 0, w = 1) {
          this.isQuaternion = true;
          this._x = x;
          this._y = y;
          this._z = z;
          this._w = w;
        }
        static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
          let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
          if (t === 0) {
            dst[dstOffset + 0] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
            return;
          }
          if (t === 1) {
            dst[dstOffset + 0] = x1;
            dst[dstOffset + 1] = y1;
            dst[dstOffset + 2] = z1;
            dst[dstOffset + 3] = w1;
            return;
          }
          if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            let s = 1 - t;
            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            if (sqrSin > Number.EPSILON) {
              const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
              s = Math.sin(s * len) / sin;
              t = Math.sin(t * len) / sin;
            }
            const tDir = t * dir;
            x0 = x0 * s + x1 * tDir;
            y0 = y0 * s + y1 * tDir;
            z0 = z0 * s + z1 * tDir;
            w0 = w0 * s + w1 * tDir;
            if (s === 1 - t) {
              const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
              x0 *= f;
              y0 *= f;
              z0 *= f;
              w0 *= f;
            }
          }
          dst[dstOffset] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
        }
        static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
          const x0 = src0[srcOffset0];
          const y0 = src0[srcOffset0 + 1];
          const z0 = src0[srcOffset0 + 2];
          const w0 = src0[srcOffset0 + 3];
          const x1 = src1[srcOffset1];
          const y1 = src1[srcOffset1 + 1];
          const z1 = src1[srcOffset1 + 2];
          const w1 = src1[srcOffset1 + 3];
          dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
          dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
          dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
          dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
          return dst;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(value) {
          this._w = value;
          this._onChangeCallback();
        }
        set(x, y, z, w) {
          this._x = x;
          this._y = y;
          this._z = z;
          this._w = w;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(quaternion) {
          this._x = quaternion.x;
          this._y = quaternion.y;
          this._z = quaternion.z;
          this._w = quaternion.w;
          this._onChangeCallback();
          return this;
        }
        setFromEuler(euler, update) {
          const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
          const cos = Math.cos;
          const sin = Math.sin;
          const c1 = cos(x / 2);
          const c2 = cos(y / 2);
          const c3 = cos(z / 2);
          const s1 = sin(x / 2);
          const s2 = sin(y / 2);
          const s3 = sin(z / 2);
          switch (order) {
            case "XYZ":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "YXZ":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            case "ZXY":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "ZYX":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            case "YZX":
              this._x = s1 * c2 * c3 + c1 * s2 * s3;
              this._y = c1 * s2 * c3 + s1 * c2 * s3;
              this._z = c1 * c2 * s3 - s1 * s2 * c3;
              this._w = c1 * c2 * c3 - s1 * s2 * s3;
              break;
            case "XZY":
              this._x = s1 * c2 * c3 - c1 * s2 * s3;
              this._y = c1 * s2 * c3 - s1 * c2 * s3;
              this._z = c1 * c2 * s3 + s1 * s2 * c3;
              this._w = c1 * c2 * c3 + s1 * s2 * s3;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
          }
          if (update !== false)
            this._onChangeCallback();
          return this;
        }
        setFromAxisAngle(axis, angle) {
          const halfAngle = angle / 2, s = Math.sin(halfAngle);
          this._x = axis.x * s;
          this._y = axis.y * s;
          this._z = axis.z * s;
          this._w = Math.cos(halfAngle);
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m) {
          const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
          if (trace > 0) {
            const s = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
          } else if (m11 > m22 && m11 > m33) {
            const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
          } else if (m22 > m33) {
            const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
          } else {
            const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
          }
          this._onChangeCallback();
          return this;
        }
        setFromUnitVectors(vFrom, vTo) {
          let r = vFrom.dot(vTo) + 1;
          if (r < Number.EPSILON) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
              this._x = -vFrom.y;
              this._y = vFrom.x;
              this._z = 0;
              this._w = r;
            } else {
              this._x = 0;
              this._y = -vFrom.z;
              this._z = vFrom.y;
              this._w = r;
            }
          } else {
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r;
          }
          return this.normalize();
        }
        angleTo(q) {
          return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
        }
        rotateTowards(q, step) {
          const angle = this.angleTo(q);
          if (angle === 0)
            return this;
          const t = Math.min(1, step / angle);
          this.slerp(q, t);
          return this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          this._x *= -1;
          this._y *= -1;
          this._z *= -1;
          this._onChangeCallback();
          return this;
        }
        dot(v) {
          return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let l = this.length();
          if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
          } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
          }
          this._onChangeCallback();
          return this;
        }
        multiply(q) {
          return this.multiplyQuaternions(this, q);
        }
        premultiply(q) {
          return this.multiplyQuaternions(q, this);
        }
        multiplyQuaternions(a, b) {
          const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
          const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
          this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
          this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
          this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
          this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
          this._onChangeCallback();
          return this;
        }
        slerp(qb, t) {
          if (t === 0)
            return this;
          if (t === 1)
            return this.copy(qb);
          const x = this._x, y = this._y, z = this._z, w = this._w;
          let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
          if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
          } else {
            this.copy(qb);
          }
          if (cosHalfTheta >= 1) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;
            return this;
          }
          const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
          if (sqrSinHalfTheta <= Number.EPSILON) {
            const s = 1 - t;
            this._w = s * w + t * this._w;
            this._x = s * x + t * this._x;
            this._y = s * y + t * this._y;
            this._z = s * z + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
          }
          const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
          const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
          const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
          this._w = w * ratioA + this._w * ratioB;
          this._x = x * ratioA + this._x * ratioB;
          this._y = y * ratioA + this._y * ratioB;
          this._z = z * ratioA + this._z * ratioB;
          this._onChangeCallback();
          return this;
        }
        slerpQuaternions(qa, qb, t) {
          return this.copy(qa).slerp(qb, t);
        }
        random() {
          const u1 = Math.random();
          const sqrt1u1 = Math.sqrt(1 - u1);
          const sqrtu1 = Math.sqrt(u1);
          const u2 = 2 * Math.PI * Math.random();
          const u3 = 2 * Math.PI * Math.random();
          return this.set(
            sqrt1u1 * Math.cos(u2),
            sqrtu1 * Math.sin(u3),
            sqrtu1 * Math.cos(u3),
            sqrt1u1 * Math.sin(u2)
          );
        }
        equals(quaternion) {
          return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        }
        fromArray(array, offset = 0) {
          this._x = array[offset];
          this._y = array[offset + 1];
          this._z = array[offset + 2];
          this._w = array[offset + 3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._w;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this._x = attribute.getX(index);
          this._y = attribute.getY(index);
          this._z = attribute.getZ(index);
          this._w = attribute.getW(index);
          return this;
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x;
          yield this._y;
          yield this._z;
          yield this._w;
        }
      };
      Vector3 = class {
        constructor(x = 0, y = 0, z = 0) {
          Vector3.prototype.isVector3 = true;
          this.x = x;
          this.y = y;
          this.z = z;
        }
        set(x, y, z) {
          if (z === void 0)
            z = this.z;
          this.x = x;
          this.y = y;
          this.z = z;
          return this;
        }
        setScalar(scalar) {
          this.x = scalar;
          this.y = scalar;
          this.z = scalar;
          return this;
        }
        setX(x) {
          this.x = x;
          return this;
        }
        setY(y) {
          this.y = y;
          return this;
        }
        setZ(z) {
          this.z = z;
          return this;
        }
        setComponent(index, value) {
          switch (index) {
            case 0:
              this.x = value;
              break;
            case 1:
              this.y = value;
              break;
            case 2:
              this.z = value;
              break;
            default:
              throw new Error("index is out of range: " + index);
          }
          return this;
        }
        getComponent(index) {
          switch (index) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + index);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          return this;
        }
        add(v) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          return this;
        }
        addScalar(s) {
          this.x += s;
          this.y += s;
          this.z += s;
          return this;
        }
        addVectors(a, b) {
          this.x = a.x + b.x;
          this.y = a.y + b.y;
          this.z = a.z + b.z;
          return this;
        }
        addScaledVector(v, s) {
          this.x += v.x * s;
          this.y += v.y * s;
          this.z += v.z * s;
          return this;
        }
        sub(v) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          return this;
        }
        subScalar(s) {
          this.x -= s;
          this.y -= s;
          this.z -= s;
          return this;
        }
        subVectors(a, b) {
          this.x = a.x - b.x;
          this.y = a.y - b.y;
          this.z = a.z - b.z;
          return this;
        }
        multiply(v) {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
          return this;
        }
        multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          return this;
        }
        multiplyVectors(a, b) {
          this.x = a.x * b.x;
          this.y = a.y * b.y;
          this.z = a.z * b.z;
          return this;
        }
        applyEuler(euler) {
          return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
        }
        applyAxisAngle(axis, angle) {
          return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
        }
        applyMatrix3(m) {
          const x = this.x, y = this.y, z = this.z;
          const e = m.elements;
          this.x = e[0] * x + e[3] * y + e[6] * z;
          this.y = e[1] * x + e[4] * y + e[7] * z;
          this.z = e[2] * x + e[5] * y + e[8] * z;
          return this;
        }
        applyNormalMatrix(m) {
          return this.applyMatrix3(m).normalize();
        }
        applyMatrix4(m) {
          const x = this.x, y = this.y, z = this.z;
          const e = m.elements;
          const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
          this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
          this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
          this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
          return this;
        }
        applyQuaternion(q) {
          const x = this.x, y = this.y, z = this.z;
          const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
          const ix = qw * x + qy * z - qz * y;
          const iy = qw * y + qz * x - qx * z;
          const iz = qw * z + qx * y - qy * x;
          const iw = -qx * x - qy * y - qz * z;
          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return this;
        }
        project(camera) {
          return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
        }
        unproject(camera) {
          return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
        }
        transformDirection(m) {
          const x = this.x, y = this.y, z = this.z;
          const e = m.elements;
          this.x = e[0] * x + e[4] * y + e[8] * z;
          this.y = e[1] * x + e[5] * y + e[9] * z;
          this.z = e[2] * x + e[6] * y + e[10] * z;
          return this.normalize();
        }
        divide(v) {
          this.x /= v.x;
          this.y /= v.y;
          this.z /= v.z;
          return this;
        }
        divideScalar(scalar) {
          return this.multiplyScalar(1 / scalar);
        }
        min(v) {
          this.x = Math.min(this.x, v.x);
          this.y = Math.min(this.y, v.y);
          this.z = Math.min(this.z, v.z);
          return this;
        }
        max(v) {
          this.x = Math.max(this.x, v.x);
          this.y = Math.max(this.y, v.y);
          this.z = Math.max(this.z, v.z);
          return this;
        }
        clamp(min, max) {
          this.x = Math.max(min.x, Math.min(max.x, this.x));
          this.y = Math.max(min.y, Math.min(max.y, this.y));
          this.z = Math.max(min.z, Math.min(max.z, this.z));
          return this;
        }
        clampScalar(minVal, maxVal) {
          this.x = Math.max(minVal, Math.min(maxVal, this.x));
          this.y = Math.max(minVal, Math.min(maxVal, this.y));
          this.z = Math.max(minVal, Math.min(maxVal, this.z));
          return this;
        }
        clampLength(min, max) {
          const length = this.length();
          return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        }
        dot(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
          return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
          this.x += (v.x - this.x) * alpha;
          this.y += (v.y - this.y) * alpha;
          this.z += (v.z - this.z) * alpha;
          return this;
        }
        lerpVectors(v1, v2, alpha) {
          this.x = v1.x + (v2.x - v1.x) * alpha;
          this.y = v1.y + (v2.y - v1.y) * alpha;
          this.z = v1.z + (v2.z - v1.z) * alpha;
          return this;
        }
        cross(v) {
          return this.crossVectors(this, v);
        }
        crossVectors(a, b) {
          const ax = a.x, ay = a.y, az = a.z;
          const bx = b.x, by = b.y, bz = b.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
        projectOnVector(v) {
          const denominator = v.lengthSq();
          if (denominator === 0)
            return this.set(0, 0, 0);
          const scalar = v.dot(this) / denominator;
          return this.copy(v).multiplyScalar(scalar);
        }
        projectOnPlane(planeNormal) {
          _vector$c.copy(this).projectOnVector(planeNormal);
          return this.sub(_vector$c);
        }
        reflect(normal) {
          return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
        }
        angleTo(v) {
          const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
          if (denominator === 0)
            return Math.PI / 2;
          const theta = this.dot(v) / denominator;
          return Math.acos(clamp(theta, -1, 1));
        }
        distanceTo(v) {
          return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
          const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
          return dx * dx + dy * dy + dz * dz;
        }
        manhattanDistanceTo(v) {
          return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        }
        setFromSpherical(s) {
          return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
        }
        setFromSphericalCoords(radius, phi, theta) {
          const sinPhiRadius = Math.sin(phi) * radius;
          this.x = sinPhiRadius * Math.sin(theta);
          this.y = Math.cos(phi) * radius;
          this.z = sinPhiRadius * Math.cos(theta);
          return this;
        }
        setFromCylindrical(c) {
          return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
        }
        setFromCylindricalCoords(radius, theta, y) {
          this.x = radius * Math.sin(theta);
          this.y = y;
          this.z = radius * Math.cos(theta);
          return this;
        }
        setFromMatrixPosition(m) {
          const e = m.elements;
          this.x = e[12];
          this.y = e[13];
          this.z = e[14];
          return this;
        }
        setFromMatrixScale(m) {
          const sx = this.setFromMatrixColumn(m, 0).length();
          const sy = this.setFromMatrixColumn(m, 1).length();
          const sz = this.setFromMatrixColumn(m, 2).length();
          this.x = sx;
          this.y = sy;
          this.z = sz;
          return this;
        }
        setFromMatrixColumn(m, index) {
          return this.fromArray(m.elements, index * 4);
        }
        setFromMatrix3Column(m, index) {
          return this.fromArray(m.elements, index * 3);
        }
        setFromEuler(e) {
          this.x = e._x;
          this.y = e._y;
          this.z = e._z;
          return this;
        }
        equals(v) {
          return v.x === this.x && v.y === this.y && v.z === this.z;
        }
        fromArray(array, offset = 0) {
          this.x = array[offset];
          this.y = array[offset + 1];
          this.z = array[offset + 2];
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this.x;
          array[offset + 1] = this.y;
          array[offset + 2] = this.z;
          return array;
        }
        fromBufferAttribute(attribute, index) {
          this.x = attribute.getX(index);
          this.y = attribute.getY(index);
          this.z = attribute.getZ(index);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          return this;
        }
        randomDirection() {
          const u = (Math.random() - 0.5) * 2;
          const t = Math.random() * Math.PI * 2;
          const f = Math.sqrt(1 - u ** 2);
          this.x = f * Math.cos(t);
          this.y = f * Math.sin(t);
          this.z = u;
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
        }
      };
      _vector$c = /* @__PURE__ */ new Vector3();
      _quaternion$4 = /* @__PURE__ */ new Quaternion();
      Box3 = class {
        constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
          this.isBox3 = true;
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromArray(array) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i = 0, l = array.length; i < l; i += 3) {
            const x = array[i];
            const y = array[i + 1];
            const z = array[i + 2];
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (z < minZ)
              minZ = z;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
            if (z > maxZ)
              maxZ = z;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromBufferAttribute(attribute) {
          let minX = Infinity;
          let minY = Infinity;
          let minZ = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;
          let maxZ = -Infinity;
          for (let i = 0, l = attribute.count; i < l; i++) {
            const x = attribute.getX(i);
            const y = attribute.getY(i);
            const z = attribute.getZ(i);
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (z < minZ)
              minZ = z;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
            if (z > maxZ)
              maxZ = z;
          }
          this.min.set(minX, minY, minZ);
          this.max.set(maxX, maxY, maxZ);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i = 0, il = points.length; i < il; i++) {
            this.expandByPoint(points[i]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        setFromObject(object, precise = false) {
          this.makeEmpty();
          return this.expandByObject(object, precise);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = this.min.z = Infinity;
          this.max.x = this.max.y = this.max.z = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        expandByObject(object, precise = false) {
          object.updateWorldMatrix(false, false);
          const geometry = object.geometry;
          if (geometry !== void 0) {
            if (precise && geometry.attributes != void 0 && geometry.attributes.position !== void 0) {
              const position = geometry.attributes.position;
              for (let i = 0, l = position.count; i < l; i++) {
                _vector$b.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);
                this.expandByPoint(_vector$b);
              }
            } else {
              if (geometry.boundingBox === null) {
                geometry.computeBoundingBox();
              }
              _box$3.copy(geometry.boundingBox);
              _box$3.applyMatrix4(object.matrixWorld);
              this.union(_box$3);
            }
          }
          const children = object.children;
          for (let i = 0, l = children.length; i < l; i++) {
            this.expandByObject(children[i], precise);
          }
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        }
        getParameter(point, target) {
          return target.set(
            (point.x - this.min.x) / (this.max.x - this.min.x),
            (point.y - this.min.y) / (this.max.y - this.min.y),
            (point.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        }
        intersectsSphere(sphere) {
          this.clampPoint(sphere.center, _vector$b);
          return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
        }
        intersectsPlane(plane) {
          let min, max;
          if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
          } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
          }
          if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
          } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
          }
          if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
          } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
          }
          return min <= -plane.constant && max >= -plane.constant;
        }
        intersectsTriangle(triangle) {
          if (this.isEmpty()) {
            return false;
          }
          this.getCenter(_center);
          _extents.subVectors(this.max, _center);
          _v0$2.subVectors(triangle.a, _center);
          _v1$7.subVectors(triangle.b, _center);
          _v2$4.subVectors(triangle.c, _center);
          _f0.subVectors(_v1$7, _v0$2);
          _f1.subVectors(_v2$4, _v1$7);
          _f2.subVectors(_v0$2, _v2$4);
          let axes = [
            0,
            -_f0.z,
            _f0.y,
            0,
            -_f1.z,
            _f1.y,
            0,
            -_f2.z,
            _f2.y,
            _f0.z,
            0,
            -_f0.x,
            _f1.z,
            0,
            -_f1.x,
            _f2.z,
            0,
            -_f2.x,
            -_f0.y,
            _f0.x,
            0,
            -_f1.y,
            _f1.x,
            0,
            -_f2.y,
            _f2.x,
            0
          ];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
            return false;
          }
          axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
            return false;
          }
          _triangleNormal.crossVectors(_f0, _f1);
          axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
          return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        getBoundingSphere(target) {
          this.getCenter(target.center);
          target.radius = this.getSize(_vector$b).length() * 0.5;
          return target;
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          if (this.isEmpty())
            this.makeEmpty();
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        applyMatrix4(matrix) {
          if (this.isEmpty())
            return this;
          _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
          _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
          _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
          _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
          _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
          this.setFromPoints(_points);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      };
      _points = [
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3(),
        /* @__PURE__ */ new Vector3()
      ];
      _vector$b = /* @__PURE__ */ new Vector3();
      _box$3 = /* @__PURE__ */ new Box3();
      _v0$2 = /* @__PURE__ */ new Vector3();
      _v1$7 = /* @__PURE__ */ new Vector3();
      _v2$4 = /* @__PURE__ */ new Vector3();
      _f0 = /* @__PURE__ */ new Vector3();
      _f1 = /* @__PURE__ */ new Vector3();
      _f2 = /* @__PURE__ */ new Vector3();
      _center = /* @__PURE__ */ new Vector3();
      _extents = /* @__PURE__ */ new Vector3();
      _triangleNormal = /* @__PURE__ */ new Vector3();
      _testAxis = /* @__PURE__ */ new Vector3();
      _box$2 = /* @__PURE__ */ new Box3();
      _v1$6 = /* @__PURE__ */ new Vector3();
      _v2$3 = /* @__PURE__ */ new Vector3();
      Sphere = class {
        constructor(center = new Vector3(), radius = -1) {
          this.center = center;
          this.radius = radius;
        }
        set(center, radius) {
          this.center.copy(center);
          this.radius = radius;
          return this;
        }
        setFromPoints(points, optionalCenter) {
          const center = this.center;
          if (optionalCenter !== void 0) {
            center.copy(optionalCenter);
          } else {
            _box$2.setFromPoints(points).getCenter(center);
          }
          let maxRadiusSq = 0;
          for (let i = 0, il = points.length; i < il; i++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
          }
          this.radius = Math.sqrt(maxRadiusSq);
          return this;
        }
        copy(sphere) {
          this.center.copy(sphere.center);
          this.radius = sphere.radius;
          return this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          this.center.set(0, 0, 0);
          this.radius = -1;
          return this;
        }
        containsPoint(point) {
          return point.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(point) {
          return point.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(sphere) {
          const radiusSum = this.radius + sphere.radius;
          return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        }
        intersectsBox(box) {
          return box.intersectsSphere(this);
        }
        intersectsPlane(plane) {
          return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(point, target) {
          const deltaLengthSq = this.center.distanceToSquared(point);
          target.copy(point);
          if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
          }
          return target;
        }
        getBoundingBox(target) {
          if (this.isEmpty()) {
            target.makeEmpty();
            return target;
          }
          target.set(this.center, this.center);
          target.expandByScalar(this.radius);
          return target;
        }
        applyMatrix4(matrix) {
          this.center.applyMatrix4(matrix);
          this.radius = this.radius * matrix.getMaxScaleOnAxis();
          return this;
        }
        translate(offset) {
          this.center.add(offset);
          return this;
        }
        expandByPoint(point) {
          if (this.isEmpty()) {
            this.center.copy(point);
            this.radius = 0;
            return this;
          }
          _v1$6.subVectors(point, this.center);
          const lengthSq = _v1$6.lengthSq();
          if (lengthSq > this.radius * this.radius) {
            const length = Math.sqrt(lengthSq);
            const delta = (length - this.radius) * 0.5;
            this.center.addScaledVector(_v1$6, delta / length);
            this.radius += delta;
          }
          return this;
        }
        union(sphere) {
          if (sphere.isEmpty()) {
            return this;
          }
          if (this.isEmpty()) {
            this.copy(sphere);
            return this;
          }
          if (this.center.equals(sphere.center) === true) {
            this.radius = Math.max(this.radius, sphere.radius);
          } else {
            _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
            this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
            this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
          }
          return this;
        }
        equals(sphere) {
          return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      _vector$a = /* @__PURE__ */ new Vector3();
      _segCenter = /* @__PURE__ */ new Vector3();
      _segDir = /* @__PURE__ */ new Vector3();
      _diff = /* @__PURE__ */ new Vector3();
      _edge1 = /* @__PURE__ */ new Vector3();
      _edge2 = /* @__PURE__ */ new Vector3();
      _normal$1 = /* @__PURE__ */ new Vector3();
      Ray = class {
        constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
          this.origin = origin;
          this.direction = direction;
        }
        set(origin, direction) {
          this.origin.copy(origin);
          this.direction.copy(direction);
          return this;
        }
        copy(ray) {
          this.origin.copy(ray.origin);
          this.direction.copy(ray.direction);
          return this;
        }
        at(t, target) {
          return target.copy(this.direction).multiplyScalar(t).add(this.origin);
        }
        lookAt(v) {
          this.direction.copy(v).sub(this.origin).normalize();
          return this;
        }
        recast(t) {
          this.origin.copy(this.at(t, _vector$a));
          return this;
        }
        closestPointToPoint(point, target) {
          target.subVectors(point, this.origin);
          const directionDistance = target.dot(this.direction);
          if (directionDistance < 0) {
            return target.copy(this.origin);
          }
          return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        }
        distanceToPoint(point) {
          return Math.sqrt(this.distanceSqToPoint(point));
        }
        distanceSqToPoint(point) {
          const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
          if (directionDistance < 0) {
            return this.origin.distanceToSquared(point);
          }
          _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
          return _vector$a.distanceToSquared(point);
        }
        distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
          _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
          _segDir.copy(v1).sub(v0).normalize();
          _diff.copy(this.origin).sub(_segCenter);
          const segExtent = v0.distanceTo(v1) * 0.5;
          const a01 = -this.direction.dot(_segDir);
          const b0 = _diff.dot(this.direction);
          const b1 = -_diff.dot(_segDir);
          const c = _diff.lengthSq();
          const det = Math.abs(1 - a01 * a01);
          let s0, s1, sqrDist, extDet;
          if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
              if (s1 >= -extDet) {
                if (s1 <= extDet) {
                  const invDet = 1 / det;
                  s0 *= invDet;
                  s1 *= invDet;
                  sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else {
                  s1 = segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
              } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c;
              } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            }
          } else {
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
          if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
          }
          if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
          }
          return sqrDist;
        }
        intersectSphere(sphere, target) {
          _vector$a.subVectors(sphere.center, this.origin);
          const tca = _vector$a.dot(this.direction);
          const d2 = _vector$a.dot(_vector$a) - tca * tca;
          const radius2 = sphere.radius * sphere.radius;
          if (d2 > radius2)
            return null;
          const thc = Math.sqrt(radius2 - d2);
          const t0 = tca - thc;
          const t1 = tca + thc;
          if (t0 < 0 && t1 < 0)
            return null;
          if (t0 < 0)
            return this.at(t1, target);
          return this.at(t0, target);
        }
        intersectsSphere(sphere) {
          return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
        }
        distanceToPlane(plane) {
          const denominator = plane.normal.dot(this.direction);
          if (denominator === 0) {
            if (plane.distanceToPoint(this.origin) === 0) {
              return 0;
            }
            return null;
          }
          const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
          return t >= 0 ? t : null;
        }
        intersectPlane(plane, target) {
          const t = this.distanceToPlane(plane);
          if (t === null) {
            return null;
          }
          return this.at(t, target);
        }
        intersectsPlane(plane) {
          const distToPoint = plane.distanceToPoint(this.origin);
          if (distToPoint === 0) {
            return true;
          }
          const denominator = plane.normal.dot(this.direction);
          if (denominator * distToPoint < 0) {
            return true;
          }
          return false;
        }
        intersectBox(box, target) {
          let tmin, tmax, tymin, tymax, tzmin, tzmax;
          const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
          const origin = this.origin;
          if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
          } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
          }
          if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
          } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
          }
          if (tmin > tymax || tymin > tmax)
            return null;
          if (tymin > tmin || isNaN(tmin))
            tmin = tymin;
          if (tymax < tmax || isNaN(tmax))
            tmax = tymax;
          if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
          } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
          }
          if (tmin > tzmax || tzmin > tmax)
            return null;
          if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
          if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
          if (tmax < 0)
            return null;
          return this.at(tmin >= 0 ? tmin : tmax, target);
        }
        intersectsBox(box) {
          return this.intersectBox(box, _vector$a) !== null;
        }
        intersectTriangle(a, b, c, backfaceCulling, target) {
          _edge1.subVectors(b, a);
          _edge2.subVectors(c, a);
          _normal$1.crossVectors(_edge1, _edge2);
          let DdN = this.direction.dot(_normal$1);
          let sign2;
          if (DdN > 0) {
            if (backfaceCulling)
              return null;
            sign2 = 1;
          } else if (DdN < 0) {
            sign2 = -1;
            DdN = -DdN;
          } else {
            return null;
          }
          _diff.subVectors(this.origin, a);
          const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
          if (DdQxE2 < 0) {
            return null;
          }
          const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
          if (DdE1xQ < 0) {
            return null;
          }
          if (DdQxE2 + DdE1xQ > DdN) {
            return null;
          }
          const QdN = -sign2 * _diff.dot(_normal$1);
          if (QdN < 0) {
            return null;
          }
          return this.at(QdN / DdN, target);
        }
        applyMatrix4(matrix4) {
          this.origin.applyMatrix4(matrix4);
          this.direction.transformDirection(matrix4);
          return this;
        }
        equals(ray) {
          return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      Matrix4 = class {
        constructor() {
          Matrix4.prototype.isMatrix4 = true;
          this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ];
        }
        set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
          const te = this.elements;
          te[0] = n11;
          te[4] = n12;
          te[8] = n13;
          te[12] = n14;
          te[1] = n21;
          te[5] = n22;
          te[9] = n23;
          te[13] = n24;
          te[2] = n31;
          te[6] = n32;
          te[10] = n33;
          te[14] = n34;
          te[3] = n41;
          te[7] = n42;
          te[11] = n43;
          te[15] = n44;
          return this;
        }
        identity() {
          this.set(
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        clone() {
          return new Matrix4().fromArray(this.elements);
        }
        copy(m) {
          const te = this.elements;
          const me = m.elements;
          te[0] = me[0];
          te[1] = me[1];
          te[2] = me[2];
          te[3] = me[3];
          te[4] = me[4];
          te[5] = me[5];
          te[6] = me[6];
          te[7] = me[7];
          te[8] = me[8];
          te[9] = me[9];
          te[10] = me[10];
          te[11] = me[11];
          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];
          te[15] = me[15];
          return this;
        }
        copyPosition(m) {
          const te = this.elements, me = m.elements;
          te[12] = me[12];
          te[13] = me[13];
          te[14] = me[14];
          return this;
        }
        setFromMatrix3(m) {
          const me = m.elements;
          this.set(
            me[0],
            me[3],
            me[6],
            0,
            me[1],
            me[4],
            me[7],
            0,
            me[2],
            me[5],
            me[8],
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
          xAxis.setFromMatrixColumn(this, 0);
          yAxis.setFromMatrixColumn(this, 1);
          zAxis.setFromMatrixColumn(this, 2);
          return this;
        }
        makeBasis(xAxis, yAxis, zAxis) {
          this.set(
            xAxis.x,
            yAxis.x,
            zAxis.x,
            0,
            xAxis.y,
            yAxis.y,
            zAxis.y,
            0,
            xAxis.z,
            yAxis.z,
            zAxis.z,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        extractRotation(m) {
          const te = this.elements;
          const me = m.elements;
          const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
          const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
          const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
          te[0] = me[0] * scaleX;
          te[1] = me[1] * scaleX;
          te[2] = me[2] * scaleX;
          te[3] = 0;
          te[4] = me[4] * scaleY;
          te[5] = me[5] * scaleY;
          te[6] = me[6] * scaleY;
          te[7] = 0;
          te[8] = me[8] * scaleZ;
          te[9] = me[9] * scaleZ;
          te[10] = me[10] * scaleZ;
          te[11] = 0;
          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;
          return this;
        }
        makeRotationFromEuler(euler) {
          const te = this.elements;
          const x = euler.x, y = euler.y, z = euler.z;
          const a = Math.cos(x), b = Math.sin(x);
          const c = Math.cos(y), d = Math.sin(y);
          const e = Math.cos(z), f = Math.sin(z);
          if (euler.order === "XYZ") {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
          } else if (euler.order === "YXZ") {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
          } else if (euler.order === "ZXY") {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
          } else if (euler.order === "ZYX") {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
          } else if (euler.order === "YZX") {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
          } else if (euler.order === "XZY") {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
          }
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;
          te[12] = 0;
          te[13] = 0;
          te[14] = 0;
          te[15] = 1;
          return this;
        }
        makeRotationFromQuaternion(q) {
          return this.compose(_zero, q, _one);
        }
        lookAt(eye, target, up) {
          const te = this.elements;
          _z.subVectors(eye, target);
          if (_z.lengthSq() === 0) {
            _z.z = 1;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
          if (_x.lengthSq() === 0) {
            if (Math.abs(up.z) === 1) {
              _z.x += 1e-4;
            } else {
              _z.z += 1e-4;
            }
            _z.normalize();
            _x.crossVectors(up, _z);
          }
          _x.normalize();
          _y.crossVectors(_z, _x);
          te[0] = _x.x;
          te[4] = _y.x;
          te[8] = _z.x;
          te[1] = _x.y;
          te[5] = _y.y;
          te[9] = _z.y;
          te[2] = _x.z;
          te[6] = _y.z;
          te[10] = _z.z;
          return this;
        }
        multiply(m) {
          return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
          return this.multiplyMatrices(m, this);
        }
        multiplyMatrices(a, b) {
          const ae = a.elements;
          const be = b.elements;
          const te = this.elements;
          const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
          const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
          const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
          const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
          const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
          const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
          const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
          const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
          te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
          te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
          te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
          te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
          te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
          te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
          te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
          te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
          te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
          te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
          te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
          te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
          te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
          te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
          te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
          te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
          return this;
        }
        multiplyScalar(s) {
          const te = this.elements;
          te[0] *= s;
          te[4] *= s;
          te[8] *= s;
          te[12] *= s;
          te[1] *= s;
          te[5] *= s;
          te[9] *= s;
          te[13] *= s;
          te[2] *= s;
          te[6] *= s;
          te[10] *= s;
          te[14] *= s;
          te[3] *= s;
          te[7] *= s;
          te[11] *= s;
          te[15] *= s;
          return this;
        }
        determinant() {
          const te = this.elements;
          const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
          const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
          const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
          const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
          return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        }
        transpose() {
          const te = this.elements;
          let tmp2;
          tmp2 = te[1];
          te[1] = te[4];
          te[4] = tmp2;
          tmp2 = te[2];
          te[2] = te[8];
          te[8] = tmp2;
          tmp2 = te[6];
          te[6] = te[9];
          te[9] = tmp2;
          tmp2 = te[3];
          te[3] = te[12];
          te[12] = tmp2;
          tmp2 = te[7];
          te[7] = te[13];
          te[13] = tmp2;
          tmp2 = te[11];
          te[11] = te[14];
          te[14] = tmp2;
          return this;
        }
        setPosition(x, y, z) {
          const te = this.elements;
          if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
          } else {
            te[12] = x;
            te[13] = y;
            te[14] = z;
          }
          return this;
        }
        invert() {
          const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
          const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
          if (det === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const detInv = 1 / det;
          te[0] = t11 * detInv;
          te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
          te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
          te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
          te[4] = t12 * detInv;
          te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
          te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
          te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
          te[8] = t13 * detInv;
          te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
          te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
          te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
          te[12] = t14 * detInv;
          te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
          te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
          te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
          return this;
        }
        scale(v) {
          const te = this.elements;
          const x = v.x, y = v.y, z = v.z;
          te[0] *= x;
          te[4] *= y;
          te[8] *= z;
          te[1] *= x;
          te[5] *= y;
          te[9] *= z;
          te[2] *= x;
          te[6] *= y;
          te[10] *= z;
          te[3] *= x;
          te[7] *= y;
          te[11] *= z;
          return this;
        }
        getMaxScaleOnAxis() {
          const te = this.elements;
          const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
          const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
          const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
          return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        }
        makeTranslation(x, y, z) {
          this.set(
            1,
            0,
            0,
            x,
            0,
            1,
            0,
            y,
            0,
            0,
            1,
            z,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeRotationX(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          this.set(
            1,
            0,
            0,
            0,
            0,
            c,
            -s,
            0,
            0,
            s,
            c,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeRotationY(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          this.set(
            c,
            0,
            s,
            0,
            0,
            1,
            0,
            0,
            -s,
            0,
            c,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeRotationZ(theta) {
          const c = Math.cos(theta), s = Math.sin(theta);
          this.set(
            c,
            -s,
            0,
            0,
            s,
            c,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeRotationAxis(axis, angle) {
          const c = Math.cos(angle);
          const s = Math.sin(angle);
          const t = 1 - c;
          const x = axis.x, y = axis.y, z = axis.z;
          const tx = t * x, ty = t * y;
          this.set(
            tx * x + c,
            tx * y - s * z,
            tx * z + s * y,
            0,
            tx * y + s * z,
            ty * y + c,
            ty * z - s * x,
            0,
            tx * z - s * y,
            ty * z + s * x,
            t * z * z + c,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeScale(x, y, z) {
          this.set(
            x,
            0,
            0,
            0,
            0,
            y,
            0,
            0,
            0,
            0,
            z,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        makeShear(xy, xz, yx, yz, zx, zy) {
          this.set(
            1,
            yx,
            zx,
            0,
            xy,
            1,
            zy,
            0,
            xz,
            yz,
            1,
            0,
            0,
            0,
            0,
            1
          );
          return this;
        }
        compose(position, quaternion, scale) {
          const te = this.elements;
          const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
          const x2 = x + x, y2 = y + y, z2 = z + z;
          const xx = x * x2, xy = x * y2, xz = x * z2;
          const yy = y * y2, yz = y * z2, zz = z * z2;
          const wx = w * x2, wy = w * y2, wz = w * z2;
          const sx = scale.x, sy = scale.y, sz = scale.z;
          te[0] = (1 - (yy + zz)) * sx;
          te[1] = (xy + wz) * sx;
          te[2] = (xz - wy) * sx;
          te[3] = 0;
          te[4] = (xy - wz) * sy;
          te[5] = (1 - (xx + zz)) * sy;
          te[6] = (yz + wx) * sy;
          te[7] = 0;
          te[8] = (xz + wy) * sz;
          te[9] = (yz - wx) * sz;
          te[10] = (1 - (xx + yy)) * sz;
          te[11] = 0;
          te[12] = position.x;
          te[13] = position.y;
          te[14] = position.z;
          te[15] = 1;
          return this;
        }
        decompose(position, quaternion, scale) {
          const te = this.elements;
          let sx = _v1$5.set(te[0], te[1], te[2]).length();
          const sy = _v1$5.set(te[4], te[5], te[6]).length();
          const sz = _v1$5.set(te[8], te[9], te[10]).length();
          const det = this.determinant();
          if (det < 0)
            sx = -sx;
          position.x = te[12];
          position.y = te[13];
          position.z = te[14];
          _m1$2.copy(this);
          const invSX = 1 / sx;
          const invSY = 1 / sy;
          const invSZ = 1 / sz;
          _m1$2.elements[0] *= invSX;
          _m1$2.elements[1] *= invSX;
          _m1$2.elements[2] *= invSX;
          _m1$2.elements[4] *= invSY;
          _m1$2.elements[5] *= invSY;
          _m1$2.elements[6] *= invSY;
          _m1$2.elements[8] *= invSZ;
          _m1$2.elements[9] *= invSZ;
          _m1$2.elements[10] *= invSZ;
          quaternion.setFromRotationMatrix(_m1$2);
          scale.x = sx;
          scale.y = sy;
          scale.z = sz;
          return this;
        }
        makePerspective(left, right, top, bottom, near, far) {
          const te = this.elements;
          const x = 2 * near / (right - left);
          const y = 2 * near / (top - bottom);
          const a = (right + left) / (right - left);
          const b = (top + bottom) / (top - bottom);
          const c = -(far + near) / (far - near);
          const d = -2 * far * near / (far - near);
          te[0] = x;
          te[4] = 0;
          te[8] = a;
          te[12] = 0;
          te[1] = 0;
          te[5] = y;
          te[9] = b;
          te[13] = 0;
          te[2] = 0;
          te[6] = 0;
          te[10] = c;
          te[14] = d;
          te[3] = 0;
          te[7] = 0;
          te[11] = -1;
          te[15] = 0;
          return this;
        }
        makeOrthographic(left, right, top, bottom, near, far) {
          const te = this.elements;
          const w = 1 / (right - left);
          const h = 1 / (top - bottom);
          const p = 1 / (far - near);
          const x = (right + left) * w;
          const y = (top + bottom) * h;
          const z = (far + near) * p;
          te[0] = 2 * w;
          te[4] = 0;
          te[8] = 0;
          te[12] = -x;
          te[1] = 0;
          te[5] = 2 * h;
          te[9] = 0;
          te[13] = -y;
          te[2] = 0;
          te[6] = 0;
          te[10] = -2 * p;
          te[14] = -z;
          te[3] = 0;
          te[7] = 0;
          te[11] = 0;
          te[15] = 1;
          return this;
        }
        equals(matrix) {
          const te = this.elements;
          const me = matrix.elements;
          for (let i = 0; i < 16; i++) {
            if (te[i] !== me[i])
              return false;
          }
          return true;
        }
        fromArray(array, offset = 0) {
          for (let i = 0; i < 16; i++) {
            this.elements[i] = array[i + offset];
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const te = this.elements;
          array[offset] = te[0];
          array[offset + 1] = te[1];
          array[offset + 2] = te[2];
          array[offset + 3] = te[3];
          array[offset + 4] = te[4];
          array[offset + 5] = te[5];
          array[offset + 6] = te[6];
          array[offset + 7] = te[7];
          array[offset + 8] = te[8];
          array[offset + 9] = te[9];
          array[offset + 10] = te[10];
          array[offset + 11] = te[11];
          array[offset + 12] = te[12];
          array[offset + 13] = te[13];
          array[offset + 14] = te[14];
          array[offset + 15] = te[15];
          return array;
        }
      };
      _v1$5 = /* @__PURE__ */ new Vector3();
      _m1$2 = /* @__PURE__ */ new Matrix4();
      _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
      _one = /* @__PURE__ */ new Vector3(1, 1, 1);
      _x = /* @__PURE__ */ new Vector3();
      _y = /* @__PURE__ */ new Vector3();
      _z = /* @__PURE__ */ new Vector3();
      _matrix$1 = /* @__PURE__ */ new Matrix4();
      _quaternion$3 = /* @__PURE__ */ new Quaternion();
      Euler = class {
        constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
          this.isEuler = true;
          this._x = x;
          this._y = y;
          this._z = z;
          this._order = order;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x = value;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y = value;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(value) {
          this._z = value;
          this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(value) {
          this._order = value;
          this._onChangeCallback();
        }
        set(x, y, z, order = this._order) {
          this._x = x;
          this._y = y;
          this._z = z;
          this._order = order;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(euler) {
          this._x = euler._x;
          this._y = euler._y;
          this._z = euler._z;
          this._order = euler._order;
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(m, order = this._order, update = true) {
          const te = m.elements;
          const m11 = te[0], m12 = te[4], m13 = te[8];
          const m21 = te[1], m22 = te[5], m23 = te[9];
          const m31 = te[2], m32 = te[6], m33 = te[10];
          switch (order) {
            case "XYZ":
              this._y = Math.asin(clamp(m13, -1, 1));
              if (Math.abs(m13) < 0.9999999) {
                this._x = Math.atan2(-m23, m33);
                this._z = Math.atan2(-m12, m11);
              } else {
                this._x = Math.atan2(m32, m22);
                this._z = 0;
              }
              break;
            case "YXZ":
              this._x = Math.asin(-clamp(m23, -1, 1));
              if (Math.abs(m23) < 0.9999999) {
                this._y = Math.atan2(m13, m33);
                this._z = Math.atan2(m21, m22);
              } else {
                this._y = Math.atan2(-m31, m11);
                this._z = 0;
              }
              break;
            case "ZXY":
              this._x = Math.asin(clamp(m32, -1, 1));
              if (Math.abs(m32) < 0.9999999) {
                this._y = Math.atan2(-m31, m33);
                this._z = Math.atan2(-m12, m22);
              } else {
                this._y = 0;
                this._z = Math.atan2(m21, m11);
              }
              break;
            case "ZYX":
              this._y = Math.asin(-clamp(m31, -1, 1));
              if (Math.abs(m31) < 0.9999999) {
                this._x = Math.atan2(m32, m33);
                this._z = Math.atan2(m21, m11);
              } else {
                this._x = 0;
                this._z = Math.atan2(-m12, m22);
              }
              break;
            case "YZX":
              this._z = Math.asin(clamp(m21, -1, 1));
              if (Math.abs(m21) < 0.9999999) {
                this._x = Math.atan2(-m23, m22);
                this._y = Math.atan2(-m31, m11);
              } else {
                this._x = 0;
                this._y = Math.atan2(m13, m33);
              }
              break;
            case "XZY":
              this._z = Math.asin(-clamp(m12, -1, 1));
              if (Math.abs(m12) < 0.9999999) {
                this._x = Math.atan2(m32, m22);
                this._y = Math.atan2(m13, m11);
              } else {
                this._x = Math.atan2(-m23, m33);
                this._y = 0;
              }
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
          }
          this._order = order;
          if (update === true)
            this._onChangeCallback();
          return this;
        }
        setFromQuaternion(q, order, update) {
          _matrix$1.makeRotationFromQuaternion(q);
          return this.setFromRotationMatrix(_matrix$1, order, update);
        }
        setFromVector3(v, order = this._order) {
          return this.set(v.x, v.y, v.z, order);
        }
        reorder(newOrder) {
          _quaternion$3.setFromEuler(this);
          return this.setFromQuaternion(_quaternion$3, newOrder);
        }
        equals(euler) {
          return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        }
        fromArray(array) {
          this._x = array[0];
          this._y = array[1];
          this._z = array[2];
          if (array[3] !== void 0)
            this._order = array[3];
          this._onChangeCallback();
          return this;
        }
        toArray(array = [], offset = 0) {
          array[offset] = this._x;
          array[offset + 1] = this._y;
          array[offset + 2] = this._z;
          array[offset + 3] = this._order;
          return array;
        }
        _onChange(callback) {
          this._onChangeCallback = callback;
          return this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x;
          yield this._y;
          yield this._z;
          yield this._order;
        }
      };
      Euler.DEFAULT_ORDER = "XYZ";
      Layers = class {
        constructor() {
          this.mask = 1 | 0;
        }
        set(channel) {
          this.mask = (1 << channel | 0) >>> 0;
        }
        enable(channel) {
          this.mask |= 1 << channel | 0;
        }
        enableAll() {
          this.mask = 4294967295 | 0;
        }
        toggle(channel) {
          this.mask ^= 1 << channel | 0;
        }
        disable(channel) {
          this.mask &= ~(1 << channel | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(layers) {
          return (this.mask & layers.mask) !== 0;
        }
        isEnabled(channel) {
          return (this.mask & (1 << channel | 0)) !== 0;
        }
      };
      _object3DId = 0;
      _v1$4 = /* @__PURE__ */ new Vector3();
      _q1 = /* @__PURE__ */ new Quaternion();
      _m1$1 = /* @__PURE__ */ new Matrix4();
      _target = /* @__PURE__ */ new Vector3();
      _position$3 = /* @__PURE__ */ new Vector3();
      _scale$2 = /* @__PURE__ */ new Vector3();
      _quaternion$2 = /* @__PURE__ */ new Quaternion();
      _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
      _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
      _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
      _addedEvent = { type: "added" };
      _removedEvent = { type: "removed" };
      Object3D = class extends EventDispatcher {
        constructor() {
          super();
          this.isObject3D = true;
          Object.defineProperty(this, "id", { value: _object3DId++ });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Object3D";
          this.parent = null;
          this.children = [];
          this.up = Object3D.DEFAULT_UP.clone();
          const position = new Vector3();
          const rotation = new Euler();
          const quaternion = new Quaternion();
          const scale = new Vector3(1, 1, 1);
          function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
          }
          function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, void 0, false);
          }
          rotation._onChange(onRotationChange);
          quaternion._onChange(onQuaternionChange);
          Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: position
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: rotation
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: quaternion
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: scale
            },
            modelViewMatrix: {
              value: new Matrix4()
            },
            normalMatrix: {
              value: new Matrix3()
            }
          });
          this.matrix = new Matrix4();
          this.matrixWorld = new Matrix4();
          this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
          this.matrixWorldNeedsUpdate = false;
          this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
          this.layers = new Layers();
          this.visible = true;
          this.castShadow = false;
          this.receiveShadow = false;
          this.frustumCulled = true;
          this.renderOrder = 0;
          this.animations = [];
          this.userData = {};
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(matrix) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          this.matrix.premultiply(matrix);
          this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(q) {
          this.quaternion.premultiply(q);
          return this;
        }
        setRotationFromAxisAngle(axis, angle) {
          this.quaternion.setFromAxisAngle(axis, angle);
        }
        setRotationFromEuler(euler) {
          this.quaternion.setFromEuler(euler, true);
        }
        setRotationFromMatrix(m) {
          this.quaternion.setFromRotationMatrix(m);
        }
        setRotationFromQuaternion(q) {
          this.quaternion.copy(q);
        }
        rotateOnAxis(axis, angle) {
          _q1.setFromAxisAngle(axis, angle);
          this.quaternion.multiply(_q1);
          return this;
        }
        rotateOnWorldAxis(axis, angle) {
          _q1.setFromAxisAngle(axis, angle);
          this.quaternion.premultiply(_q1);
          return this;
        }
        rotateX(angle) {
          return this.rotateOnAxis(_xAxis, angle);
        }
        rotateY(angle) {
          return this.rotateOnAxis(_yAxis, angle);
        }
        rotateZ(angle) {
          return this.rotateOnAxis(_zAxis, angle);
        }
        translateOnAxis(axis, distance) {
          _v1$4.copy(axis).applyQuaternion(this.quaternion);
          this.position.add(_v1$4.multiplyScalar(distance));
          return this;
        }
        translateX(distance) {
          return this.translateOnAxis(_xAxis, distance);
        }
        translateY(distance) {
          return this.translateOnAxis(_yAxis, distance);
        }
        translateZ(distance) {
          return this.translateOnAxis(_zAxis, distance);
        }
        localToWorld(vector) {
          this.updateWorldMatrix(true, false);
          return vector.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(vector) {
          this.updateWorldMatrix(true, false);
          return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
        }
        lookAt(x, y, z) {
          if (x.isVector3) {
            _target.copy(x);
          } else {
            _target.set(x, y, z);
          }
          const parent = this.parent;
          this.updateWorldMatrix(true, false);
          _position$3.setFromMatrixPosition(this.matrixWorld);
          if (this.isCamera || this.isLight) {
            _m1$1.lookAt(_position$3, _target, this.up);
          } else {
            _m1$1.lookAt(_target, _position$3, this.up);
          }
          this.quaternion.setFromRotationMatrix(_m1$1);
          if (parent) {
            _m1$1.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m1$1);
            this.quaternion.premultiply(_q1.invert());
          }
        }
        add(object) {
          if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) {
              this.add(arguments[i]);
            }
            return this;
          }
          if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
          }
          if (object && object.isObject3D) {
            if (object.parent !== null) {
              object.parent.remove(object);
            }
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
          } else {
            console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
          }
          return this;
        }
        remove(object) {
          if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) {
              this.remove(arguments[i]);
            }
            return this;
          }
          const index = this.children.indexOf(object);
          if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent(_removedEvent);
          }
          return this;
        }
        removeFromParent() {
          const parent = this.parent;
          if (parent !== null) {
            parent.remove(this);
          }
          return this;
        }
        clear() {
          for (let i = 0; i < this.children.length; i++) {
            const object = this.children[i];
            object.parent = null;
            object.dispatchEvent(_removedEvent);
          }
          this.children.length = 0;
          return this;
        }
        attach(object) {
          this.updateWorldMatrix(true, false);
          _m1$1.copy(this.matrixWorld).invert();
          if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m1$1.multiply(object.parent.matrixWorld);
          }
          object.applyMatrix4(_m1$1);
          this.add(object);
          object.updateWorldMatrix(false, true);
          return this;
        }
        getObjectById(id2) {
          return this.getObjectByProperty("id", id2);
        }
        getObjectByName(name) {
          return this.getObjectByProperty("name", name);
        }
        getObjectByProperty(name, value) {
          if (this[name] === value)
            return this;
          for (let i = 0, l = this.children.length; i < l; i++) {
            const child = this.children[i];
            const object = child.getObjectByProperty(name, value);
            if (object !== void 0) {
              return object;
            }
          }
          return void 0;
        }
        getObjectsByProperty(name, value) {
          let result = [];
          if (this[name] === value)
            result.push(this);
          for (let i = 0, l = this.children.length; i < l; i++) {
            const childResult = this.children[i].getObjectsByProperty(name, value);
            if (childResult.length > 0) {
              result = result.concat(childResult);
            }
          }
          return result;
        }
        getWorldPosition(target) {
          this.updateWorldMatrix(true, false);
          return target.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, target, _scale$2);
          return target;
        }
        getWorldScale(target) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(_position$3, _quaternion$2, target);
          return target;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e = this.matrixWorld.elements;
          return target.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {
        }
        traverse(callback) {
          callback(this);
          const children = this.children;
          for (let i = 0, l = children.length; i < l; i++) {
            children[i].traverse(callback);
          }
        }
        traverseVisible(callback) {
          if (this.visible === false)
            return;
          callback(this);
          const children = this.children;
          for (let i = 0, l = children.length; i < l; i++) {
            children[i].traverseVisible(callback);
          }
        }
        traverseAncestors(callback) {
          const parent = this.parent;
          if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
          }
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale);
          this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(force) {
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) {
              this.matrixWorld.copy(this.matrix);
            } else {
              this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            force = true;
          }
          const children = this.children;
          for (let i = 0, l = children.length; i < l; i++) {
            const child = children[i];
            if (child.matrixWorldAutoUpdate === true || force === true) {
              child.updateMatrixWorld(force);
            }
          }
        }
        updateWorldMatrix(updateParents, updateChildren) {
          const parent = this.parent;
          if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
            parent.updateWorldMatrix(true, false);
          }
          if (this.matrixAutoUpdate)
            this.updateMatrix();
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          if (updateChildren === true) {
            const children = this.children;
            for (let i = 0, l = children.length; i < l; i++) {
              const child = children[i];
              if (child.matrixWorldAutoUpdate === true) {
                child.updateWorldMatrix(false, true);
              }
            }
          }
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          const output = {};
          if (isRootObject) {
            meta = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {}
            };
            output.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON"
            };
          }
          const object = {};
          object.uuid = this.uuid;
          object.type = this.type;
          if (this.name !== "")
            object.name = this.name;
          if (this.castShadow === true)
            object.castShadow = true;
          if (this.receiveShadow === true)
            object.receiveShadow = true;
          if (this.visible === false)
            object.visible = false;
          if (this.frustumCulled === false)
            object.frustumCulled = false;
          if (this.renderOrder !== 0)
            object.renderOrder = this.renderOrder;
          if (Object.keys(this.userData).length > 0)
            object.userData = this.userData;
          object.layers = this.layers.mask;
          object.matrix = this.matrix.toArray();
          if (this.matrixAutoUpdate === false)
            object.matrixAutoUpdate = false;
          if (this.isInstancedMesh) {
            object.type = "InstancedMesh";
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
            if (this.instanceColor !== null)
              object.instanceColor = this.instanceColor.toJSON();
          }
          function serialize(library, element) {
            if (library[element.uuid] === void 0) {
              library[element.uuid] = element.toJSON(meta);
            }
            return element.uuid;
          }
          if (this.isScene) {
            if (this.background) {
              if (this.background.isColor) {
                object.background = this.background.toJSON();
              } else if (this.background.isTexture) {
                object.background = this.background.toJSON(meta).uuid;
              }
            }
            if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
              object.environment = this.environment.toJSON(meta).uuid;
            }
          } else if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== void 0 && parameters.shapes !== void 0) {
              const shapes = parameters.shapes;
              if (Array.isArray(shapes)) {
                for (let i = 0, l = shapes.length; i < l; i++) {
                  const shape = shapes[i];
                  serialize(meta.shapes, shape);
                }
              } else {
                serialize(meta.shapes, shapes);
              }
            }
          }
          if (this.isSkinnedMesh) {
            object.bindMode = this.bindMode;
            object.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== void 0) {
              serialize(meta.skeletons, this.skeleton);
              object.skeleton = this.skeleton.uuid;
            }
          }
          if (this.material !== void 0) {
            if (Array.isArray(this.material)) {
              const uuids = [];
              for (let i = 0, l = this.material.length; i < l; i++) {
                uuids.push(serialize(meta.materials, this.material[i]));
              }
              object.material = uuids;
            } else {
              object.material = serialize(meta.materials, this.material);
            }
          }
          if (this.children.length > 0) {
            object.children = [];
            for (let i = 0; i < this.children.length; i++) {
              object.children.push(this.children[i].toJSON(meta).object);
            }
          }
          if (this.animations.length > 0) {
            object.animations = [];
            for (let i = 0; i < this.animations.length; i++) {
              const animation = this.animations[i];
              object.animations.push(serialize(meta.animations, animation));
            }
          }
          if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            const skeletons = extractFromCache(meta.skeletons);
            const animations = extractFromCache(meta.animations);
            const nodes = extractFromCache(meta.nodes);
            if (geometries.length > 0)
              output.geometries = geometries;
            if (materials.length > 0)
              output.materials = materials;
            if (textures.length > 0)
              output.textures = textures;
            if (images.length > 0)
              output.images = images;
            if (shapes.length > 0)
              output.shapes = shapes;
            if (skeletons.length > 0)
              output.skeletons = skeletons;
            if (animations.length > 0)
              output.animations = animations;
            if (nodes.length > 0)
              output.nodes = nodes;
          }
          output.object = object;
          return output;
          function extractFromCache(cache) {
            const values3 = [];
            for (const key in cache) {
              const data = cache[key];
              delete data.metadata;
              values3.push(data);
            }
            return values3;
          }
        }
        clone(recursive) {
          return new this.constructor().copy(this, recursive);
        }
        copy(source, recursive = true) {
          this.name = source.name;
          this.up.copy(source.up);
          this.position.copy(source.position);
          this.rotation.order = source.rotation.order;
          this.quaternion.copy(source.quaternion);
          this.scale.copy(source.scale);
          this.matrix.copy(source.matrix);
          this.matrixWorld.copy(source.matrixWorld);
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
          this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
          this.layers.mask = source.layers.mask;
          this.visible = source.visible;
          this.castShadow = source.castShadow;
          this.receiveShadow = source.receiveShadow;
          this.frustumCulled = source.frustumCulled;
          this.renderOrder = source.renderOrder;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          if (recursive === true) {
            for (let i = 0; i < source.children.length; i++) {
              const child = source.children[i];
              this.add(child.clone());
            }
          }
          return this;
        }
      };
      Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
      Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
      Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
      _v0$1 = /* @__PURE__ */ new Vector3();
      _v1$3 = /* @__PURE__ */ new Vector3();
      _v2$2 = /* @__PURE__ */ new Vector3();
      _v3$1 = /* @__PURE__ */ new Vector3();
      _vab = /* @__PURE__ */ new Vector3();
      _vac = /* @__PURE__ */ new Vector3();
      _vbc = /* @__PURE__ */ new Vector3();
      _vap = /* @__PURE__ */ new Vector3();
      _vbp = /* @__PURE__ */ new Vector3();
      _vcp = /* @__PURE__ */ new Vector3();
      Triangle = class {
        constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
          this.a = a;
          this.b = b;
          this.c = c;
        }
        static getNormal(a, b, c, target) {
          target.subVectors(c, b);
          _v0$1.subVectors(a, b);
          target.cross(_v0$1);
          const targetLengthSq = target.lengthSq();
          if (targetLengthSq > 0) {
            return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
          }
          return target.set(0, 0, 0);
        }
        static getBarycoord(point, a, b, c, target) {
          _v0$1.subVectors(c, a);
          _v1$3.subVectors(b, a);
          _v2$2.subVectors(point, a);
          const dot00 = _v0$1.dot(_v0$1);
          const dot01 = _v0$1.dot(_v1$3);
          const dot02 = _v0$1.dot(_v2$2);
          const dot11 = _v1$3.dot(_v1$3);
          const dot12 = _v1$3.dot(_v2$2);
          const denom = dot00 * dot11 - dot01 * dot01;
          if (denom === 0) {
            return target.set(-2, -1, -1);
          }
          const invDenom = 1 / denom;
          const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
          const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
          return target.set(1 - u - v, v, u);
        }
        static containsPoint(point, a, b, c) {
          this.getBarycoord(point, a, b, c, _v3$1);
          return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
        }
        static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
          this.getBarycoord(point, p1, p2, p3, _v3$1);
          target.set(0, 0);
          target.addScaledVector(uv1, _v3$1.x);
          target.addScaledVector(uv2, _v3$1.y);
          target.addScaledVector(uv3, _v3$1.z);
          return target;
        }
        static isFrontFacing(a, b, c, direction) {
          _v0$1.subVectors(c, b);
          _v1$3.subVectors(a, b);
          return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
        }
        set(a, b, c) {
          this.a.copy(a);
          this.b.copy(b);
          this.c.copy(c);
          return this;
        }
        setFromPointsAndIndices(points, i0, i1, i2) {
          this.a.copy(points[i0]);
          this.b.copy(points[i1]);
          this.c.copy(points[i2]);
          return this;
        }
        setFromAttributeAndIndices(attribute, i0, i1, i2) {
          this.a.fromBufferAttribute(attribute, i0);
          this.b.fromBufferAttribute(attribute, i1);
          this.c.fromBufferAttribute(attribute, i2);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(triangle) {
          this.a.copy(triangle.a);
          this.b.copy(triangle.b);
          this.c.copy(triangle.c);
          return this;
        }
        getArea() {
          _v0$1.subVectors(this.c, this.b);
          _v1$3.subVectors(this.a, this.b);
          return _v0$1.cross(_v1$3).length() * 0.5;
        }
        getMidpoint(target) {
          return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(target) {
          return Triangle.getNormal(this.a, this.b, this.c, target);
        }
        getPlane(target) {
          return target.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(point, target) {
          return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
        }
        getUV(point, uv1, uv2, uv3, target) {
          return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
        }
        containsPoint(point) {
          return Triangle.containsPoint(point, this.a, this.b, this.c);
        }
        isFrontFacing(direction) {
          return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
        }
        intersectsBox(box) {
          return box.intersectsTriangle(this);
        }
        closestPointToPoint(p, target) {
          const a = this.a, b = this.b, c = this.c;
          let v, w;
          _vab.subVectors(b, a);
          _vac.subVectors(c, a);
          _vap.subVectors(p, a);
          const d1 = _vab.dot(_vap);
          const d2 = _vac.dot(_vap);
          if (d1 <= 0 && d2 <= 0) {
            return target.copy(a);
          }
          _vbp.subVectors(p, b);
          const d3 = _vab.dot(_vbp);
          const d4 = _vac.dot(_vbp);
          if (d3 >= 0 && d4 <= d3) {
            return target.copy(b);
          }
          const vc = d1 * d4 - d3 * d2;
          if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            return target.copy(a).addScaledVector(_vab, v);
          }
          _vcp.subVectors(p, c);
          const d5 = _vab.dot(_vcp);
          const d6 = _vac.dot(_vcp);
          if (d6 >= 0 && d5 <= d6) {
            return target.copy(c);
          }
          const vb = d5 * d2 - d1 * d6;
          if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w = d2 / (d2 - d6);
            return target.copy(a).addScaledVector(_vac, w);
          }
          const va = d3 * d6 - d5 * d4;
          if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c, b);
            w = (d4 - d3) / (d4 - d3 + (d5 - d6));
            return target.copy(b).addScaledVector(_vbc, w);
          }
          const denom = 1 / (va + vb + vc);
          v = vb * denom;
          w = vc * denom;
          return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
        }
        equals(triangle) {
          return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
      };
      materialId = 0;
      Material = class extends EventDispatcher {
        constructor() {
          super();
          this.isMaterial = true;
          Object.defineProperty(this, "id", { value: materialId++ });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "Material";
          this.blending = NormalBlending;
          this.side = FrontSide;
          this.vertexColors = false;
          this.opacity = 1;
          this.transparent = false;
          this.blendSrc = SrcAlphaFactor;
          this.blendDst = OneMinusSrcAlphaFactor;
          this.blendEquation = AddEquation;
          this.blendSrcAlpha = null;
          this.blendDstAlpha = null;
          this.blendEquationAlpha = null;
          this.depthFunc = LessEqualDepth;
          this.depthTest = true;
          this.depthWrite = true;
          this.stencilWriteMask = 255;
          this.stencilFunc = AlwaysStencilFunc;
          this.stencilRef = 0;
          this.stencilFuncMask = 255;
          this.stencilFail = KeepStencilOp;
          this.stencilZFail = KeepStencilOp;
          this.stencilZPass = KeepStencilOp;
          this.stencilWrite = false;
          this.clippingPlanes = null;
          this.clipIntersection = false;
          this.clipShadows = false;
          this.shadowSide = null;
          this.colorWrite = true;
          this.precision = null;
          this.polygonOffset = false;
          this.polygonOffsetFactor = 0;
          this.polygonOffsetUnits = 0;
          this.dithering = false;
          this.alphaToCoverage = false;
          this.premultipliedAlpha = false;
          this.forceSinglePass = false;
          this.visible = true;
          this.toneMapped = true;
          this.userData = {};
          this.version = 0;
          this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(value) {
          if (this._alphaTest > 0 !== value > 0) {
            this.version++;
          }
          this._alphaTest = value;
        }
        onBuild() {
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(values3) {
          if (values3 === void 0)
            return;
          for (const key in values3) {
            const newValue = values3[key];
            if (newValue === void 0) {
              console.warn("THREE.Material: '" + key + "' parameter is undefined.");
              continue;
            }
            const currentValue = this[key];
            if (currentValue === void 0) {
              console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
              continue;
            }
            if (currentValue && currentValue.isColor) {
              currentValue.set(newValue);
            } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
              currentValue.copy(newValue);
            } else {
              this[key] = newValue;
            }
          }
        }
        toJSON(meta) {
          const isRootObject = meta === void 0 || typeof meta === "string";
          if (isRootObject) {
            meta = {
              textures: {},
              images: {}
            };
          }
          const data = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (this.color && this.color.isColor)
            data.color = this.color.getHex();
          if (this.roughness !== void 0)
            data.roughness = this.roughness;
          if (this.metalness !== void 0)
            data.metalness = this.metalness;
          if (this.sheen !== void 0)
            data.sheen = this.sheen;
          if (this.sheenColor && this.sheenColor.isColor)
            data.sheenColor = this.sheenColor.getHex();
          if (this.sheenRoughness !== void 0)
            data.sheenRoughness = this.sheenRoughness;
          if (this.emissive && this.emissive.isColor)
            data.emissive = this.emissive.getHex();
          if (this.emissiveIntensity && this.emissiveIntensity !== 1)
            data.emissiveIntensity = this.emissiveIntensity;
          if (this.specular && this.specular.isColor)
            data.specular = this.specular.getHex();
          if (this.specularIntensity !== void 0)
            data.specularIntensity = this.specularIntensity;
          if (this.specularColor && this.specularColor.isColor)
            data.specularColor = this.specularColor.getHex();
          if (this.shininess !== void 0)
            data.shininess = this.shininess;
          if (this.clearcoat !== void 0)
            data.clearcoat = this.clearcoat;
          if (this.clearcoatRoughness !== void 0)
            data.clearcoatRoughness = this.clearcoatRoughness;
          if (this.clearcoatMap && this.clearcoatMap.isTexture) {
            data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
          }
          if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
            data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
          }
          if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
          }
          if (this.iridescence !== void 0)
            data.iridescence = this.iridescence;
          if (this.iridescenceIOR !== void 0)
            data.iridescenceIOR = this.iridescenceIOR;
          if (this.iridescenceThicknessRange !== void 0)
            data.iridescenceThicknessRange = this.iridescenceThicknessRange;
          if (this.iridescenceMap && this.iridescenceMap.isTexture) {
            data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
          }
          if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
            data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
          }
          if (this.map && this.map.isTexture)
            data.map = this.map.toJSON(meta).uuid;
          if (this.matcap && this.matcap.isTexture)
            data.matcap = this.matcap.toJSON(meta).uuid;
          if (this.alphaMap && this.alphaMap.isTexture)
            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
          if (this.lightMap && this.lightMap.isTexture) {
            data.lightMap = this.lightMap.toJSON(meta).uuid;
            data.lightMapIntensity = this.lightMapIntensity;
          }
          if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
          }
          if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
          }
          if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
          }
          if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
          }
          if (this.roughnessMap && this.roughnessMap.isTexture)
            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
          if (this.metalnessMap && this.metalnessMap.isTexture)
            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
          if (this.emissiveMap && this.emissiveMap.isTexture)
            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
          if (this.specularMap && this.specularMap.isTexture)
            data.specularMap = this.specularMap.toJSON(meta).uuid;
          if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
            data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
          if (this.specularColorMap && this.specularColorMap.isTexture)
            data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
          if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            if (this.combine !== void 0)
              data.combine = this.combine;
          }
          if (this.envMapIntensity !== void 0)
            data.envMapIntensity = this.envMapIntensity;
          if (this.reflectivity !== void 0)
            data.reflectivity = this.reflectivity;
          if (this.refractionRatio !== void 0)
            data.refractionRatio = this.refractionRatio;
          if (this.gradientMap && this.gradientMap.isTexture) {
            data.gradientMap = this.gradientMap.toJSON(meta).uuid;
          }
          if (this.transmission !== void 0)
            data.transmission = this.transmission;
          if (this.transmissionMap && this.transmissionMap.isTexture)
            data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
          if (this.thickness !== void 0)
            data.thickness = this.thickness;
          if (this.thicknessMap && this.thicknessMap.isTexture)
            data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
          if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity)
            data.attenuationDistance = this.attenuationDistance;
          if (this.attenuationColor !== void 0)
            data.attenuationColor = this.attenuationColor.getHex();
          if (this.size !== void 0)
            data.size = this.size;
          if (this.shadowSide !== null)
            data.shadowSide = this.shadowSide;
          if (this.sizeAttenuation !== void 0)
            data.sizeAttenuation = this.sizeAttenuation;
          if (this.blending !== NormalBlending)
            data.blending = this.blending;
          if (this.side !== FrontSide)
            data.side = this.side;
          if (this.vertexColors)
            data.vertexColors = true;
          if (this.opacity < 1)
            data.opacity = this.opacity;
          if (this.transparent === true)
            data.transparent = this.transparent;
          data.depthFunc = this.depthFunc;
          data.depthTest = this.depthTest;
          data.depthWrite = this.depthWrite;
          data.colorWrite = this.colorWrite;
          data.stencilWrite = this.stencilWrite;
          data.stencilWriteMask = this.stencilWriteMask;
          data.stencilFunc = this.stencilFunc;
          data.stencilRef = this.stencilRef;
          data.stencilFuncMask = this.stencilFuncMask;
          data.stencilFail = this.stencilFail;
          data.stencilZFail = this.stencilZFail;
          data.stencilZPass = this.stencilZPass;
          if (this.rotation !== void 0 && this.rotation !== 0)
            data.rotation = this.rotation;
          if (this.polygonOffset === true)
            data.polygonOffset = true;
          if (this.polygonOffsetFactor !== 0)
            data.polygonOffsetFactor = this.polygonOffsetFactor;
          if (this.polygonOffsetUnits !== 0)
            data.polygonOffsetUnits = this.polygonOffsetUnits;
          if (this.linewidth !== void 0 && this.linewidth !== 1)
            data.linewidth = this.linewidth;
          if (this.dashSize !== void 0)
            data.dashSize = this.dashSize;
          if (this.gapSize !== void 0)
            data.gapSize = this.gapSize;
          if (this.scale !== void 0)
            data.scale = this.scale;
          if (this.dithering === true)
            data.dithering = true;
          if (this.alphaTest > 0)
            data.alphaTest = this.alphaTest;
          if (this.alphaToCoverage === true)
            data.alphaToCoverage = this.alphaToCoverage;
          if (this.premultipliedAlpha === true)
            data.premultipliedAlpha = this.premultipliedAlpha;
          if (this.forceSinglePass === true)
            data.forceSinglePass = this.forceSinglePass;
          if (this.wireframe === true)
            data.wireframe = this.wireframe;
          if (this.wireframeLinewidth > 1)
            data.wireframeLinewidth = this.wireframeLinewidth;
          if (this.wireframeLinecap !== "round")
            data.wireframeLinecap = this.wireframeLinecap;
          if (this.wireframeLinejoin !== "round")
            data.wireframeLinejoin = this.wireframeLinejoin;
          if (this.flatShading === true)
            data.flatShading = this.flatShading;
          if (this.visible === false)
            data.visible = false;
          if (this.toneMapped === false)
            data.toneMapped = false;
          if (this.fog === false)
            data.fog = false;
          if (Object.keys(this.userData).length > 0)
            data.userData = this.userData;
          function extractFromCache(cache) {
            const values3 = [];
            for (const key in cache) {
              const data2 = cache[key];
              delete data2.metadata;
              values3.push(data2);
            }
            return values3;
          }
          if (isRootObject) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0)
              data.textures = textures;
            if (images.length > 0)
              data.images = images;
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.name = source.name;
          this.blending = source.blending;
          this.side = source.side;
          this.vertexColors = source.vertexColors;
          this.opacity = source.opacity;
          this.transparent = source.transparent;
          this.blendSrc = source.blendSrc;
          this.blendDst = source.blendDst;
          this.blendEquation = source.blendEquation;
          this.blendSrcAlpha = source.blendSrcAlpha;
          this.blendDstAlpha = source.blendDstAlpha;
          this.blendEquationAlpha = source.blendEquationAlpha;
          this.depthFunc = source.depthFunc;
          this.depthTest = source.depthTest;
          this.depthWrite = source.depthWrite;
          this.stencilWriteMask = source.stencilWriteMask;
          this.stencilFunc = source.stencilFunc;
          this.stencilRef = source.stencilRef;
          this.stencilFuncMask = source.stencilFuncMask;
          this.stencilFail = source.stencilFail;
          this.stencilZFail = source.stencilZFail;
          this.stencilZPass = source.stencilZPass;
          this.stencilWrite = source.stencilWrite;
          const srcPlanes = source.clippingPlanes;
          let dstPlanes = null;
          if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for (let i = 0; i !== n; ++i) {
              dstPlanes[i] = srcPlanes[i].clone();
            }
          }
          this.clippingPlanes = dstPlanes;
          this.clipIntersection = source.clipIntersection;
          this.clipShadows = source.clipShadows;
          this.shadowSide = source.shadowSide;
          this.colorWrite = source.colorWrite;
          this.precision = source.precision;
          this.polygonOffset = source.polygonOffset;
          this.polygonOffsetFactor = source.polygonOffsetFactor;
          this.polygonOffsetUnits = source.polygonOffsetUnits;
          this.dithering = source.dithering;
          this.alphaTest = source.alphaTest;
          this.alphaToCoverage = source.alphaToCoverage;
          this.premultipliedAlpha = source.premultipliedAlpha;
          this.forceSinglePass = source.forceSinglePass;
          this.visible = source.visible;
          this.toneMapped = source.toneMapped;
          this.userData = JSON.parse(JSON.stringify(source.userData));
          return this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
      };
      MeshBasicMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshBasicMaterial = true;
          this.type = "MeshBasicMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.fog = source.fog;
          return this;
        }
      };
      _vector$9 = /* @__PURE__ */ new Vector3();
      _vector2$1 = /* @__PURE__ */ new Vector2();
      BufferAttribute = class {
        constructor(array, itemSize, normalized = false) {
          if (Array.isArray(array)) {
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          }
          this.isBufferAttribute = true;
          this.name = "";
          this.array = array;
          this.itemSize = itemSize;
          this.count = array !== void 0 ? array.length / itemSize : 0;
          this.normalized = normalized;
          this.usage = StaticDrawUsage;
          this.updateRange = { offset: 0, count: -1 };
          this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.name = source.name;
          this.array = new source.array.constructor(source.array);
          this.itemSize = source.itemSize;
          this.count = source.count;
          this.normalized = source.normalized;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.itemSize;
          index2 *= attribute.itemSize;
          for (let i = 0, l = this.itemSize; i < l; i++) {
            this.array[index1 + i] = attribute.array[index2 + i];
          }
          return this;
        }
        copyArray(array) {
          this.array.set(array);
          return this;
        }
        applyMatrix3(m) {
          if (this.itemSize === 2) {
            for (let i = 0, l = this.count; i < l; i++) {
              _vector2$1.fromBufferAttribute(this, i);
              _vector2$1.applyMatrix3(m);
              this.setXY(i, _vector2$1.x, _vector2$1.y);
            }
          } else if (this.itemSize === 3) {
            for (let i = 0, l = this.count; i < l; i++) {
              _vector$9.fromBufferAttribute(this, i);
              _vector$9.applyMatrix3(m);
              this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
            }
          }
          return this;
        }
        applyMatrix4(m) {
          for (let i = 0, l = this.count; i < l; i++) {
            _vector$9.fromBufferAttribute(this, i);
            _vector$9.applyMatrix4(m);
            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        applyNormalMatrix(m) {
          for (let i = 0, l = this.count; i < l; i++) {
            _vector$9.fromBufferAttribute(this, i);
            _vector$9.applyNormalMatrix(m);
            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        transformDirection(m) {
          for (let i = 0, l = this.count; i < l; i++) {
            _vector$9.fromBufferAttribute(this, i);
            _vector$9.transformDirection(m);
            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        getX(index) {
          let x = this.array[index * this.itemSize];
          if (this.normalized)
            x = denormalize(x, this.array);
          return x;
        }
        setX(index, x) {
          if (this.normalized)
            x = normalize(x, this.array);
          this.array[index * this.itemSize] = x;
          return this;
        }
        getY(index) {
          let y = this.array[index * this.itemSize + 1];
          if (this.normalized)
            y = denormalize(y, this.array);
          return y;
        }
        setY(index, y) {
          if (this.normalized)
            y = normalize(y, this.array);
          this.array[index * this.itemSize + 1] = y;
          return this;
        }
        getZ(index) {
          let z = this.array[index * this.itemSize + 2];
          if (this.normalized)
            z = denormalize(z, this.array);
          return z;
        }
        setZ(index, z) {
          if (this.normalized)
            z = normalize(z, this.array);
          this.array[index * this.itemSize + 2] = z;
          return this;
        }
        getW(index) {
          let w = this.array[index * this.itemSize + 3];
          if (this.normalized)
            w = denormalize(w, this.array);
          return w;
        }
        setW(index, w) {
          if (this.normalized)
            w = normalize(w, this.array);
          this.array[index * this.itemSize + 3] = w;
          return this;
        }
        setXY(index, x, y) {
          index *= this.itemSize;
          if (this.normalized) {
            x = normalize(x, this.array);
            y = normalize(y, this.array);
          }
          this.array[index + 0] = x;
          this.array[index + 1] = y;
          return this;
        }
        setXYZ(index, x, y, z) {
          index *= this.itemSize;
          if (this.normalized) {
            x = normalize(x, this.array);
            y = normalize(y, this.array);
            z = normalize(z, this.array);
          }
          this.array[index + 0] = x;
          this.array[index + 1] = y;
          this.array[index + 2] = z;
          return this;
        }
        setXYZW(index, x, y, z, w) {
          index *= this.itemSize;
          if (this.normalized) {
            x = normalize(x, this.array);
            y = normalize(y, this.array);
            z = normalize(z, this.array);
            w = normalize(w, this.array);
          }
          this.array[index + 0] = x;
          this.array[index + 1] = y;
          this.array[index + 2] = z;
          this.array[index + 3] = w;
          return this;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const data = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
          };
          if (this.name !== "")
            data.name = this.name;
          if (this.usage !== StaticDrawUsage)
            data.usage = this.usage;
          if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
            data.updateRange = this.updateRange;
          return data;
        }
        copyColorsArray() {
          console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
        }
        copyVector2sArray() {
          console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
        }
        copyVector3sArray() {
          console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
        }
        copyVector4sArray() {
          console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
        }
      };
      Int8BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int8Array(array), itemSize, normalized);
        }
      };
      Uint8BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint8Array(array), itemSize, normalized);
        }
      };
      Uint8ClampedBufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint8ClampedArray(array), itemSize, normalized);
        }
      };
      Int16BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int16Array(array), itemSize, normalized);
        }
      };
      Uint16BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
        }
      };
      Int32BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Int32Array(array), itemSize, normalized);
        }
      };
      Uint32BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint32Array(array), itemSize, normalized);
        }
      };
      Float16BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Uint16Array(array), itemSize, normalized);
          this.isFloat16BufferAttribute = true;
        }
      };
      Float32BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Float32Array(array), itemSize, normalized);
        }
      };
      Float64BufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized) {
          super(new Float64Array(array), itemSize, normalized);
        }
      };
      _id$1 = 0;
      _m1 = /* @__PURE__ */ new Matrix4();
      _obj = /* @__PURE__ */ new Object3D();
      _offset = /* @__PURE__ */ new Vector3();
      _box$1 = /* @__PURE__ */ new Box3();
      _boxMorphTargets = /* @__PURE__ */ new Box3();
      _vector$8 = /* @__PURE__ */ new Vector3();
      BufferGeometry = class extends EventDispatcher {
        constructor() {
          super();
          this.isBufferGeometry = true;
          Object.defineProperty(this, "id", { value: _id$1++ });
          this.uuid = generateUUID();
          this.name = "";
          this.type = "BufferGeometry";
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.morphTargetsRelative = false;
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          this.drawRange = { start: 0, count: Infinity };
          this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(index) {
          if (Array.isArray(index)) {
            this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
          } else {
            this.index = index;
          }
          return this;
        }
        getAttribute(name) {
          return this.attributes[name];
        }
        setAttribute(name, attribute) {
          this.attributes[name] = attribute;
          return this;
        }
        deleteAttribute(name) {
          delete this.attributes[name];
          return this;
        }
        hasAttribute(name) {
          return this.attributes[name] !== void 0;
        }
        addGroup(start2, count, materialIndex = 0) {
          this.groups.push({
            start: start2,
            count,
            materialIndex
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(start2, count) {
          this.drawRange.start = start2;
          this.drawRange.count = count;
        }
        applyMatrix4(matrix) {
          const position = this.attributes.position;
          if (position !== void 0) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
          }
          const normal = this.attributes.normal;
          if (normal !== void 0) {
            const normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
          }
          const tangent = this.attributes.tangent;
          if (tangent !== void 0) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
          }
          if (this.boundingBox !== null) {
            this.computeBoundingBox();
          }
          if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
          }
          return this;
        }
        applyQuaternion(q) {
          _m1.makeRotationFromQuaternion(q);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateX(angle) {
          _m1.makeRotationX(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateY(angle) {
          _m1.makeRotationY(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        rotateZ(angle) {
          _m1.makeRotationZ(angle);
          this.applyMatrix4(_m1);
          return this;
        }
        translate(x, y, z) {
          _m1.makeTranslation(x, y, z);
          this.applyMatrix4(_m1);
          return this;
        }
        scale(x, y, z) {
          _m1.makeScale(x, y, z);
          this.applyMatrix4(_m1);
          return this;
        }
        lookAt(vector) {
          _obj.lookAt(vector);
          _obj.updateMatrix();
          this.applyMatrix4(_obj.matrix);
          return this;
        }
        center() {
          this.computeBoundingBox();
          this.boundingBox.getCenter(_offset).negate();
          this.translate(_offset.x, _offset.y, _offset.z);
          return this;
        }
        setFromPoints(points) {
          const position = [];
          for (let i = 0, l = points.length; i < l; i++) {
            const point = points[i];
            position.push(point.x, point.y, point.z || 0);
          }
          this.setAttribute("position", new Float32BufferAttribute(position, 3));
          return this;
        }
        computeBoundingBox() {
          if (this.boundingBox === null) {
            this.boundingBox = new Box3();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(
              new Vector3(-Infinity, -Infinity, -Infinity),
              new Vector3(Infinity, Infinity, Infinity)
            );
            return;
          }
          if (position !== void 0) {
            this.boundingBox.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                const morphAttribute = morphAttributesPosition[i];
                _box$1.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$8.addVectors(this.boundingBox.min, _box$1.min);
                  this.boundingBox.expandByPoint(_vector$8);
                  _vector$8.addVectors(this.boundingBox.max, _box$1.max);
                  this.boundingBox.expandByPoint(_vector$8);
                } else {
                  this.boundingBox.expandByPoint(_box$1.min);
                  this.boundingBox.expandByPoint(_box$1.max);
                }
              }
            }
          } else {
            this.boundingBox.makeEmpty();
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeBoundingSphere() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new Sphere();
          }
          const position = this.attributes.position;
          const morphAttributesPosition = this.morphAttributes.position;
          if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new Vector3(), Infinity);
            return;
          }
          if (position) {
            const center = this.boundingSphere.center;
            _box$1.setFromBufferAttribute(position);
            if (morphAttributesPosition) {
              for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                const morphAttribute = morphAttributesPosition[i];
                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                  _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
                  _box$1.expandByPoint(_vector$8);
                  _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
                  _box$1.expandByPoint(_vector$8);
                } else {
                  _box$1.expandByPoint(_boxMorphTargets.min);
                  _box$1.expandByPoint(_boxMorphTargets.max);
                }
              }
            }
            _box$1.getCenter(center);
            let maxRadiusSq = 0;
            for (let i = 0, il = position.count; i < il; i++) {
              _vector$8.fromBufferAttribute(position, i);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
            if (morphAttributesPosition) {
              for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                const morphAttribute = morphAttributesPosition[i];
                const morphTargetsRelative = this.morphTargetsRelative;
                for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
                  _vector$8.fromBufferAttribute(morphAttribute, j);
                  if (morphTargetsRelative) {
                    _offset.fromBufferAttribute(position, j);
                    _vector$8.add(_offset);
                  }
                  maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                }
              }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
          }
        }
        computeTangents() {
          const index = this.index;
          const attributes = this.attributes;
          if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const indices = index.array;
          const positions = attributes.position.array;
          const normals = attributes.normal.array;
          const uvs = attributes.uv.array;
          const nVertices = positions.length / 3;
          if (this.hasAttribute("tangent") === false) {
            this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
          }
          const tangents = this.getAttribute("tangent").array;
          const tan1 = [], tan2 = [];
          for (let i = 0; i < nVertices; i++) {
            tan1[i] = new Vector3();
            tan2[i] = new Vector3();
          }
          const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
          function handleTriangle(a, b, c) {
            vA.fromArray(positions, a * 3);
            vB.fromArray(positions, b * 3);
            vC.fromArray(positions, c * 3);
            uvA.fromArray(uvs, a * 2);
            uvB.fromArray(uvs, b * 2);
            uvC.fromArray(uvs, c * 2);
            vB.sub(vA);
            vC.sub(vA);
            uvB.sub(uvA);
            uvC.sub(uvA);
            const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
            if (!isFinite(r))
              return;
            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
            tan1[a].add(sdir);
            tan1[b].add(sdir);
            tan1[c].add(sdir);
            tan2[a].add(tdir);
            tan2[b].add(tdir);
            tan2[c].add(tdir);
          }
          let groups = this.groups;
          if (groups.length === 0) {
            groups = [{
              start: 0,
              count: indices.length
            }];
          }
          for (let i = 0, il = groups.length; i < il; ++i) {
            const group = groups[i];
            const start2 = group.start;
            const count = group.count;
            for (let j = start2, jl = start2 + count; j < jl; j += 3) {
              handleTriangle(
                indices[j + 0],
                indices[j + 1],
                indices[j + 2]
              );
            }
          }
          const tmp2 = new Vector3(), tmp22 = new Vector3();
          const n = new Vector3(), n2 = new Vector3();
          function handleVertex(v) {
            n.fromArray(normals, v * 3);
            n2.copy(n);
            const t = tan1[v];
            tmp2.copy(t);
            tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
            tmp22.crossVectors(n2, t);
            const test = tmp22.dot(tan2[v]);
            const w = test < 0 ? -1 : 1;
            tangents[v * 4] = tmp2.x;
            tangents[v * 4 + 1] = tmp2.y;
            tangents[v * 4 + 2] = tmp2.z;
            tangents[v * 4 + 3] = w;
          }
          for (let i = 0, il = groups.length; i < il; ++i) {
            const group = groups[i];
            const start2 = group.start;
            const count = group.count;
            for (let j = start2, jl = start2 + count; j < jl; j += 3) {
              handleVertex(indices[j + 0]);
              handleVertex(indices[j + 1]);
              handleVertex(indices[j + 2]);
            }
          }
        }
        computeVertexNormals() {
          const index = this.index;
          const positionAttribute = this.getAttribute("position");
          if (positionAttribute !== void 0) {
            let normalAttribute = this.getAttribute("normal");
            if (normalAttribute === void 0) {
              normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
              this.setAttribute("normal", normalAttribute);
            } else {
              for (let i = 0, il = normalAttribute.count; i < il; i++) {
                normalAttribute.setXYZ(i, 0, 0, 0);
              }
            }
            const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
            const cb = new Vector3(), ab = new Vector3();
            if (index) {
              for (let i = 0, il = index.count; i < il; i += 3) {
                const vA = index.getX(i + 0);
                const vB = index.getX(i + 1);
                const vC = index.getX(i + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
              }
            } else {
              for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
                pA.fromBufferAttribute(positionAttribute, i + 0);
                pB.fromBufferAttribute(positionAttribute, i + 1);
                pC.fromBufferAttribute(positionAttribute, i + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
              }
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
          }
        }
        merge() {
          console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.");
          return this;
        }
        normalizeNormals() {
          const normals = this.attributes.normal;
          for (let i = 0, il = normals.count; i < il; i++) {
            _vector$8.fromBufferAttribute(normals, i);
            _vector$8.normalize();
            normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
          }
        }
        toNonIndexed() {
          function convertBufferAttribute(attribute, indices2) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices2.length * itemSize);
            let index = 0, index2 = 0;
            for (let i = 0, l = indices2.length; i < l; i++) {
              if (attribute.isInterleavedBufferAttribute) {
                index = indices2[i] * attribute.data.stride + attribute.offset;
              } else {
                index = indices2[i] * itemSize;
              }
              for (let j = 0; j < itemSize; j++) {
                array2[index2++] = array[index++];
              }
            }
            return new BufferAttribute(array2, itemSize, normalized);
          }
          if (this.index === null) {
            console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
            return this;
          }
          const geometry2 = new BufferGeometry();
          const indices = this.index.array;
          const attributes = this.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices);
            geometry2.setAttribute(name, newAttribute);
          }
          const morphAttributes = this.morphAttributes;
          for (const name in morphAttributes) {
            const morphArray = [];
            const morphAttribute = morphAttributes[name];
            for (let i = 0, il = morphAttribute.length; i < il; i++) {
              const attribute = morphAttribute[i];
              const newAttribute = convertBufferAttribute(attribute, indices);
              morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name] = morphArray;
          }
          geometry2.morphTargetsRelative = this.morphTargetsRelative;
          const groups = this.groups;
          for (let i = 0, l = groups.length; i < l; i++) {
            const group = groups[i];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
          }
          return geometry2;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          data.uuid = this.uuid;
          data.type = this.type;
          if (this.name !== "")
            data.name = this.name;
          if (Object.keys(this.userData).length > 0)
            data.userData = this.userData;
          if (this.parameters !== void 0) {
            const parameters = this.parameters;
            for (const key in parameters) {
              if (parameters[key] !== void 0)
                data[key] = parameters[key];
            }
            return data;
          }
          data.data = { attributes: {} };
          const index = this.index;
          if (index !== null) {
            data.data.index = {
              type: index.array.constructor.name,
              array: Array.prototype.slice.call(index.array)
            };
          }
          const attributes = this.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            data.data.attributes[key] = attribute.toJSON(data.data);
          }
          const morphAttributes = {};
          let hasMorphAttributes = false;
          for (const key in this.morphAttributes) {
            const attributeArray = this.morphAttributes[key];
            const array = [];
            for (let i = 0, il = attributeArray.length; i < il; i++) {
              const attribute = attributeArray[i];
              array.push(attribute.toJSON(data.data));
            }
            if (array.length > 0) {
              morphAttributes[key] = array;
              hasMorphAttributes = true;
            }
          }
          if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
          }
          const groups = this.groups;
          if (groups.length > 0) {
            data.data.groups = JSON.parse(JSON.stringify(groups));
          }
          const boundingSphere = this.boundingSphere;
          if (boundingSphere !== null) {
            data.data.boundingSphere = {
              center: boundingSphere.center.toArray(),
              radius: boundingSphere.radius
            };
          }
          return data;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          const data = {};
          this.name = source.name;
          const index = source.index;
          if (index !== null) {
            this.setIndex(index.clone(data));
          }
          const attributes = source.attributes;
          for (const name in attributes) {
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
          }
          const morphAttributes = source.morphAttributes;
          for (const name in morphAttributes) {
            const array = [];
            const morphAttribute = morphAttributes[name];
            for (let i = 0, l = morphAttribute.length; i < l; i++) {
              array.push(morphAttribute[i].clone(data));
            }
            this.morphAttributes[name] = array;
          }
          this.morphTargetsRelative = source.morphTargetsRelative;
          const groups = source.groups;
          for (let i = 0, l = groups.length; i < l; i++) {
            const group = groups[i];
            this.addGroup(group.start, group.count, group.materialIndex);
          }
          const boundingBox = source.boundingBox;
          if (boundingBox !== null) {
            this.boundingBox = boundingBox.clone();
          }
          const boundingSphere = source.boundingSphere;
          if (boundingSphere !== null) {
            this.boundingSphere = boundingSphere.clone();
          }
          this.drawRange.start = source.drawRange.start;
          this.drawRange.count = source.drawRange.count;
          this.userData = source.userData;
          if (source.parameters !== void 0)
            this.parameters = Object.assign({}, source.parameters);
          return this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      };
      _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
      _ray$2 = /* @__PURE__ */ new Ray();
      _sphere$3 = /* @__PURE__ */ new Sphere();
      _vA$1 = /* @__PURE__ */ new Vector3();
      _vB$1 = /* @__PURE__ */ new Vector3();
      _vC$1 = /* @__PURE__ */ new Vector3();
      _tempA = /* @__PURE__ */ new Vector3();
      _morphA = /* @__PURE__ */ new Vector3();
      _uvA$1 = /* @__PURE__ */ new Vector2();
      _uvB$1 = /* @__PURE__ */ new Vector2();
      _uvC$1 = /* @__PURE__ */ new Vector2();
      _intersectionPoint = /* @__PURE__ */ new Vector3();
      _intersectionPointWorld = /* @__PURE__ */ new Vector3();
      Mesh = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
          super();
          this.isMesh = true;
          this.type = "Mesh";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          if (source.morphTargetInfluences !== void 0) {
            this.morphTargetInfluences = source.morphTargetInfluences.slice();
          }
          if (source.morphTargetDictionary !== void 0) {
            this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
          }
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          const morphAttributes = geometry.morphAttributes;
          const keys4 = Object.keys(morphAttributes);
          if (keys4.length > 0) {
            const morphAttribute = morphAttributes[keys4[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                const name = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m;
              }
            }
          }
        }
        getVertexPosition(index, target) {
          const geometry = this.geometry;
          const position = geometry.attributes.position;
          const morphPosition = geometry.morphAttributes.position;
          const morphTargetsRelative = geometry.morphTargetsRelative;
          target.fromBufferAttribute(position, index);
          const morphInfluences = this.morphTargetInfluences;
          if (morphPosition && morphInfluences) {
            _morphA.set(0, 0, 0);
            for (let i = 0, il = morphPosition.length; i < il; i++) {
              const influence = morphInfluences[i];
              const morphAttribute = morphPosition[i];
              if (influence === 0)
                continue;
              _tempA.fromBufferAttribute(morphAttribute, index);
              if (morphTargetsRelative) {
                _morphA.addScaledVector(_tempA, influence);
              } else {
                _morphA.addScaledVector(_tempA.sub(target), influence);
              }
            }
            target.add(_morphA);
          }
          if (this.isSkinnedMesh) {
            this.boneTransform(index, target);
          }
          return target;
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const material = this.material;
          const matrixWorld = this.matrixWorld;
          if (material === void 0)
            return;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$3.copy(geometry.boundingSphere);
          _sphere$3.applyMatrix4(matrixWorld);
          if (raycaster.ray.intersectsSphere(_sphere$3) === false)
            return;
          _inverseMatrix$2.copy(matrixWorld).invert();
          _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
          if (geometry.boundingBox !== null) {
            if (_ray$2.intersectsBox(geometry.boundingBox) === false)
              return;
          }
          let intersection;
          const index = geometry.index;
          const position = geometry.attributes.position;
          const uv = geometry.attributes.uv;
          const uv2 = geometry.attributes.uv2;
          const groups = geometry.groups;
          const drawRange = geometry.drawRange;
          if (index !== null) {
            if (Array.isArray(material)) {
              for (let i = 0, il = groups.length; i < il; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                const start2 = Math.max(group.start, drawRange.start);
                const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                for (let j = start2, jl = end; j < jl; j += 3) {
                  const a = index.getX(j);
                  const b = index.getX(j + 1);
                  const c = index.getX(j + 2);
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              const start2 = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i = start2, il = end; i < il; i += 3) {
                const a = index.getX(i);
                const b = index.getX(i + 1);
                const c = index.getX(i + 2);
                intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i / 3);
                  intersects2.push(intersection);
                }
              }
            }
          } else if (position !== void 0) {
            if (Array.isArray(material)) {
              for (let i = 0, il = groups.length; i < il; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                const start2 = Math.max(group.start, drawRange.start);
                const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                for (let j = start2, jl = end; j < jl; j += 3) {
                  const a = j;
                  const b = j + 1;
                  const c = j + 2;
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, uv, uv2, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              const start2 = Math.max(0, drawRange.start);
              const end = Math.min(position.count, drawRange.start + drawRange.count);
              for (let i = start2, il = end; i < il; i += 3) {
                const a = i;
                const b = i + 1;
                const c = i + 2;
                intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i / 3);
                  intersects2.push(intersection);
                }
              }
            }
          }
        }
      };
      BoxGeometry = class extends BufferGeometry {
        constructor(width2 = 1, height2 = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
          super();
          this.type = "BoxGeometry";
          this.parameters = {
            width: width2,
            height: height2,
            depth,
            widthSegments,
            heightSegments,
            depthSegments
          };
          const scope = this;
          widthSegments = Math.floor(widthSegments);
          heightSegments = Math.floor(heightSegments);
          depthSegments = Math.floor(depthSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let numberOfVertices = 0;
          let groupStart = 0;
          buildPlane("z", "y", "x", -1, -1, depth, height2, width2, depthSegments, heightSegments, 0);
          buildPlane("z", "y", "x", 1, -1, depth, height2, -width2, depthSegments, heightSegments, 1);
          buildPlane("x", "z", "y", 1, 1, width2, depth, height2, widthSegments, depthSegments, 2);
          buildPlane("x", "z", "y", 1, -1, width2, depth, -height2, widthSegments, depthSegments, 3);
          buildPlane("x", "y", "z", 1, -1, width2, height2, depth, widthSegments, heightSegments, 4);
          buildPlane("x", "y", "z", -1, -1, width2, height2, -depth, widthSegments, heightSegments, 5);
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function buildPlane(u, v, w, udir, vdir, width3, height3, depth2, gridX, gridY, materialIndex) {
            const segmentWidth = width3 / gridX;
            const segmentHeight = height3 / gridY;
            const widthHalf = width3 / 2;
            const heightHalf = height3 / 2;
            const depthHalf = depth2 / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector3();
            for (let iy = 0; iy < gridY1; iy++) {
              const y = iy * segmentHeight - heightHalf;
              for (let ix = 0; ix < gridX1; ix++) {
                const x = ix * segmentWidth - widthHalf;
                vector[u] = x * udir;
                vector[v] = y * vdir;
                vector[w] = depthHalf;
                vertices.push(vector.x, vector.y, vector.z);
                vector[u] = 0;
                vector[v] = 0;
                vector[w] = depth2 > 0 ? 1 : -1;
                normals.push(vector.x, vector.y, vector.z);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
                vertexCounter += 1;
              }
            }
            for (let iy = 0; iy < gridY; iy++) {
              for (let ix = 0; ix < gridX; ix++) {
                const a = numberOfVertices + ix + gridX1 * iy;
                const b = numberOfVertices + ix + gridX1 * (iy + 1);
                const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                const d = numberOfVertices + (ix + 1) + gridX1 * iy;
                indices.push(a, b, d);
                indices.push(b, c, d);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, materialIndex);
            groupStart += groupCount;
            numberOfVertices += vertexCounter;
          }
        }
        static fromJSON(data) {
          return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
        }
      };
      UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
      default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
      default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
      ShaderMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isShaderMaterial = true;
          this.type = "ShaderMaterial";
          this.defines = {};
          this.uniforms = {};
          this.uniformsGroups = [];
          this.vertexShader = default_vertex;
          this.fragmentShader = default_fragment;
          this.linewidth = 1;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.lights = false;
          this.clipping = false;
          this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
          };
          this.defaultAttributeValues = {
            "color": [1, 1, 1],
            "uv": [0, 0],
            "uv2": [0, 0]
          };
          this.index0AttributeName = void 0;
          this.uniformsNeedUpdate = false;
          this.glslVersion = null;
          if (parameters !== void 0) {
            this.setValues(parameters);
          }
        }
        copy(source) {
          super.copy(source);
          this.fragmentShader = source.fragmentShader;
          this.vertexShader = source.vertexShader;
          this.uniforms = cloneUniforms(source.uniforms);
          this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
          this.defines = Object.assign({}, source.defines);
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.fog = source.fog;
          this.lights = source.lights;
          this.clipping = source.clipping;
          this.extensions = Object.assign({}, source.extensions);
          this.glslVersion = source.glslVersion;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.glslVersion = this.glslVersion;
          data.uniforms = {};
          for (const name in this.uniforms) {
            const uniform = this.uniforms[name];
            const value = uniform.value;
            if (value && value.isTexture) {
              data.uniforms[name] = {
                type: "t",
                value: value.toJSON(meta).uuid
              };
            } else if (value && value.isColor) {
              data.uniforms[name] = {
                type: "c",
                value: value.getHex()
              };
            } else if (value && value.isVector2) {
              data.uniforms[name] = {
                type: "v2",
                value: value.toArray()
              };
            } else if (value && value.isVector3) {
              data.uniforms[name] = {
                type: "v3",
                value: value.toArray()
              };
            } else if (value && value.isVector4) {
              data.uniforms[name] = {
                type: "v4",
                value: value.toArray()
              };
            } else if (value && value.isMatrix3) {
              data.uniforms[name] = {
                type: "m3",
                value: value.toArray()
              };
            } else if (value && value.isMatrix4) {
              data.uniforms[name] = {
                type: "m4",
                value: value.toArray()
              };
            } else {
              data.uniforms[name] = {
                value
              };
            }
          }
          if (Object.keys(this.defines).length > 0)
            data.defines = this.defines;
          data.vertexShader = this.vertexShader;
          data.fragmentShader = this.fragmentShader;
          const extensions = {};
          for (const key in this.extensions) {
            if (this.extensions[key] === true)
              extensions[key] = true;
          }
          if (Object.keys(extensions).length > 0)
            data.extensions = extensions;
          return data;
        }
      };
      Camera = class extends Object3D {
        constructor() {
          super();
          this.isCamera = true;
          this.type = "Camera";
          this.matrixWorldInverse = new Matrix4();
          this.projectionMatrix = new Matrix4();
          this.projectionMatrixInverse = new Matrix4();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.matrixWorldInverse.copy(source.matrixWorldInverse);
          this.projectionMatrix.copy(source.projectionMatrix);
          this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
          return this;
        }
        getWorldDirection(target) {
          this.updateWorldMatrix(true, false);
          const e = this.matrixWorld.elements;
          return target.set(-e[8], -e[9], -e[10]).normalize();
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(updateParents, updateChildren) {
          super.updateWorldMatrix(updateParents, updateChildren);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      PerspectiveCamera = class extends Camera {
        constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
          super();
          this.isPerspectiveCamera = true;
          this.type = "PerspectiveCamera";
          this.fov = fov2;
          this.zoom = 1;
          this.near = near;
          this.far = far;
          this.focus = 10;
          this.aspect = aspect2;
          this.view = null;
          this.filmGauge = 35;
          this.filmOffset = 0;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.fov = source.fov;
          this.zoom = source.zoom;
          this.near = source.near;
          this.far = source.far;
          this.focus = source.focus;
          this.aspect = source.aspect;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          this.filmGauge = source.filmGauge;
          this.filmOffset = source.filmOffset;
          return this;
        }
        setFocalLength(focalLength) {
          const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
          this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
          this.updateProjectionMatrix();
        }
        getFocalLength() {
          const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / vExtentSlope;
        }
        getEffectiveFOV() {
          return RAD2DEG * 2 * Math.atan(
            Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
          );
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(fullWidth, fullHeight, x, y, width2, height2) {
          this.aspect = fullWidth / fullHeight;
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x;
          this.view.offsetY = y;
          this.view.width = width2;
          this.view.height = height2;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const near = this.near;
          let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
          let height2 = 2 * top;
          let width2 = this.aspect * height2;
          let left = -0.5 * width2;
          const view = this.view;
          if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width2 / fullWidth;
            top -= view.offsetY * height2 / fullHeight;
            width2 *= view.width / fullWidth;
            height2 *= view.height / fullHeight;
          }
          const skew = this.filmOffset;
          if (skew !== 0)
            left += near * skew / this.getFilmWidth();
          this.projectionMatrix.makePerspective(left, left + width2, top, top - height2, near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.fov = this.fov;
          data.object.zoom = this.zoom;
          data.object.near = this.near;
          data.object.far = this.far;
          data.object.focus = this.focus;
          data.object.aspect = this.aspect;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          data.object.filmGauge = this.filmGauge;
          data.object.filmOffset = this.filmOffset;
          return data;
        }
      };
      fov = -90;
      aspect = 1;
      CubeCamera = class extends Object3D {
        constructor(near, far, renderTarget) {
          super();
          this.type = "CubeCamera";
          this.renderTarget = renderTarget;
          const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
          cameraPX.layers = this.layers;
          cameraPX.up.set(0, 1, 0);
          cameraPX.lookAt(1, 0, 0);
          this.add(cameraPX);
          const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
          cameraNX.layers = this.layers;
          cameraNX.up.set(0, 1, 0);
          cameraNX.lookAt(-1, 0, 0);
          this.add(cameraNX);
          const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
          cameraPY.layers = this.layers;
          cameraPY.up.set(0, 0, -1);
          cameraPY.lookAt(0, 1, 0);
          this.add(cameraPY);
          const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
          cameraNY.layers = this.layers;
          cameraNY.up.set(0, 0, 1);
          cameraNY.lookAt(0, -1, 0);
          this.add(cameraNY);
          const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
          cameraPZ.layers = this.layers;
          cameraPZ.up.set(0, 1, 0);
          cameraPZ.lookAt(0, 0, 1);
          this.add(cameraPZ);
          const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
          cameraNZ.layers = this.layers;
          cameraNZ.up.set(0, 1, 0);
          cameraNZ.lookAt(0, 0, -1);
          this.add(cameraNZ);
        }
        update(renderer, scene) {
          if (this.parent === null)
            this.updateMatrixWorld();
          const renderTarget = this.renderTarget;
          const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
          const currentRenderTarget = renderer.getRenderTarget();
          const currentToneMapping = renderer.toneMapping;
          const currentXrEnabled = renderer.xr.enabled;
          renderer.toneMapping = NoToneMapping;
          renderer.xr.enabled = false;
          const generateMipmaps = renderTarget.texture.generateMipmaps;
          renderTarget.texture.generateMipmaps = false;
          renderer.setRenderTarget(renderTarget, 0);
          renderer.render(scene, cameraPX);
          renderer.setRenderTarget(renderTarget, 1);
          renderer.render(scene, cameraNX);
          renderer.setRenderTarget(renderTarget, 2);
          renderer.render(scene, cameraPY);
          renderer.setRenderTarget(renderTarget, 3);
          renderer.render(scene, cameraNY);
          renderer.setRenderTarget(renderTarget, 4);
          renderer.render(scene, cameraPZ);
          renderTarget.texture.generateMipmaps = generateMipmaps;
          renderer.setRenderTarget(renderTarget, 5);
          renderer.render(scene, cameraNZ);
          renderer.setRenderTarget(currentRenderTarget);
          renderer.toneMapping = currentToneMapping;
          renderer.xr.enabled = currentXrEnabled;
          renderTarget.texture.needsPMREMUpdate = true;
        }
      };
      CubeTexture = class extends Texture {
        constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type3, anisotropy, encoding) {
          images = images !== void 0 ? images : [];
          mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
          super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type3, anisotropy, encoding);
          this.isCubeTexture = true;
          this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(value) {
          this.image = value;
        }
      };
      WebGLCubeRenderTarget = class extends WebGLRenderTarget {
        constructor(size = 1, options = {}) {
          super(size, size, options);
          this.isWebGLCubeRenderTarget = true;
          const image = { width: size, height: size, depth: 1 };
          const images = [image, image, image, image, image, image];
          this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
          this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
        }
        fromEquirectangularTexture(renderer, texture) {
          this.texture.type = texture.type;
          this.texture.encoding = texture.encoding;
          this.texture.generateMipmaps = texture.generateMipmaps;
          this.texture.minFilter = texture.minFilter;
          this.texture.magFilter = texture.magFilter;
          const shader = {
            uniforms: {
              tEquirect: { value: null }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          };
          const geometry = new BoxGeometry(5, 5, 5);
          const material = new ShaderMaterial({
            name: "CubemapFromEquirect",
            uniforms: cloneUniforms(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: BackSide,
            blending: NoBlending
          });
          material.uniforms.tEquirect.value = texture;
          const mesh = new Mesh(geometry, material);
          const currentMinFilter = texture.minFilter;
          if (texture.minFilter === LinearMipmapLinearFilter)
            texture.minFilter = LinearFilter;
          const camera = new CubeCamera(1, 10, this);
          camera.update(renderer, mesh);
          texture.minFilter = currentMinFilter;
          mesh.geometry.dispose();
          mesh.material.dispose();
          return this;
        }
        clear(renderer, color, depth, stencil) {
          const currentRenderTarget = renderer.getRenderTarget();
          for (let i = 0; i < 6; i++) {
            renderer.setRenderTarget(this, i);
            renderer.clear(color, depth, stencil);
          }
          renderer.setRenderTarget(currentRenderTarget);
        }
      };
      _vector1 = /* @__PURE__ */ new Vector3();
      _vector2 = /* @__PURE__ */ new Vector3();
      _normalMatrix = /* @__PURE__ */ new Matrix3();
      Plane = class {
        constructor(normal = new Vector3(1, 0, 0), constant = 0) {
          this.isPlane = true;
          this.normal = normal;
          this.constant = constant;
        }
        set(normal, constant) {
          this.normal.copy(normal);
          this.constant = constant;
          return this;
        }
        setComponents(x, y, z, w) {
          this.normal.set(x, y, z);
          this.constant = w;
          return this;
        }
        setFromNormalAndCoplanarPoint(normal, point) {
          this.normal.copy(normal);
          this.constant = -point.dot(this.normal);
          return this;
        }
        setFromCoplanarPoints(a, b, c) {
          const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
          this.setFromNormalAndCoplanarPoint(normal, a);
          return this;
        }
        copy(plane) {
          this.normal.copy(plane.normal);
          this.constant = plane.constant;
          return this;
        }
        normalize() {
          const inverseNormalLength = 1 / this.normal.length();
          this.normal.multiplyScalar(inverseNormalLength);
          this.constant *= inverseNormalLength;
          return this;
        }
        negate() {
          this.constant *= -1;
          this.normal.negate();
          return this;
        }
        distanceToPoint(point) {
          return this.normal.dot(point) + this.constant;
        }
        distanceToSphere(sphere) {
          return this.distanceToPoint(sphere.center) - sphere.radius;
        }
        projectPoint(point, target) {
          return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        }
        intersectLine(line, target) {
          const direction = line.delta(_vector1);
          const denominator = this.normal.dot(direction);
          if (denominator === 0) {
            if (this.distanceToPoint(line.start) === 0) {
              return target.copy(line.start);
            }
            return null;
          }
          const t = -(line.start.dot(this.normal) + this.constant) / denominator;
          if (t < 0 || t > 1) {
            return null;
          }
          return target.copy(direction).multiplyScalar(t).add(line.start);
        }
        intersectsLine(line) {
          const startSign = this.distanceToPoint(line.start);
          const endSign = this.distanceToPoint(line.end);
          return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        }
        intersectsBox(box) {
          return box.intersectsPlane(this);
        }
        intersectsSphere(sphere) {
          return sphere.intersectsPlane(this);
        }
        coplanarPoint(target) {
          return target.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(matrix, optionalNormalMatrix) {
          const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
          const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
          const normal = this.normal.applyMatrix3(normalMatrix).normalize();
          this.constant = -referencePoint.dot(normal);
          return this;
        }
        translate(offset) {
          this.constant -= offset.dot(this.normal);
          return this;
        }
        equals(plane) {
          return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      _sphere$2 = /* @__PURE__ */ new Sphere();
      _vector$7 = /* @__PURE__ */ new Vector3();
      Frustum = class {
        constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p52 = new Plane()) {
          this.planes = [p0, p1, p2, p3, p4, p52];
        }
        set(p0, p1, p2, p3, p4, p52) {
          const planes = this.planes;
          planes[0].copy(p0);
          planes[1].copy(p1);
          planes[2].copy(p2);
          planes[3].copy(p3);
          planes[4].copy(p4);
          planes[5].copy(p52);
          return this;
        }
        copy(frustum) {
          const planes = this.planes;
          for (let i = 0; i < 6; i++) {
            planes[i].copy(frustum.planes[i]);
          }
          return this;
        }
        setFromProjectionMatrix(m) {
          const planes = this.planes;
          const me = m.elements;
          const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
          const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
          const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
          const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
          planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
          planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
          planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
          planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
          planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
          planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
          return this;
        }
        intersectsObject(object) {
          const geometry = object.geometry;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
          return this.intersectsSphere(_sphere$2);
        }
        intersectsSprite(sprite) {
          _sphere$2.center.set(0, 0, 0);
          _sphere$2.radius = 0.7071067811865476;
          _sphere$2.applyMatrix4(sprite.matrixWorld);
          return this.intersectsSphere(_sphere$2);
        }
        intersectsSphere(sphere) {
          const planes = this.planes;
          const center = sphere.center;
          const negRadius = -sphere.radius;
          for (let i = 0; i < 6; i++) {
            const distance = planes[i].distanceToPoint(center);
            if (distance < negRadius) {
              return false;
            }
          }
          return true;
        }
        intersectsBox(box) {
          const planes = this.planes;
          for (let i = 0; i < 6; i++) {
            const plane = planes[i];
            _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector$7) < 0) {
              return false;
            }
          }
          return true;
        }
        containsPoint(point) {
          const planes = this.planes;
          for (let i = 0; i < 6; i++) {
            if (planes[i].distanceToPoint(point) < 0) {
              return false;
            }
          }
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      PlaneGeometry = class extends BufferGeometry {
        constructor(width2 = 1, height2 = 1, widthSegments = 1, heightSegments = 1) {
          super();
          this.type = "PlaneGeometry";
          this.parameters = {
            width: width2,
            height: height2,
            widthSegments,
            heightSegments
          };
          const width_half = width2 / 2;
          const height_half = height2 / 2;
          const gridX = Math.floor(widthSegments);
          const gridY = Math.floor(heightSegments);
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          const segment_width = width2 / gridX;
          const segment_height = height2 / gridY;
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy < gridY1; iy++) {
            const y = iy * segment_height - height_half;
            for (let ix = 0; ix < gridX1; ix++) {
              const x = ix * segment_width - width_half;
              vertices.push(x, -y, 0);
              normals.push(0, 0, 1);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a = ix + gridX1 * iy;
              const b = ix + gridX1 * (iy + 1);
              const c = ix + 1 + gridX1 * (iy + 1);
              const d = ix + 1 + gridX1 * iy;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
        }
      };
      alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
      alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
      alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
      aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
      aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
      begin_vertex = "vec3 transformed = vec3( position );";
      beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
      bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
      iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			 return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float R21 = R12;\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
      bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = dFdx( surf_pos.xyz );\n		vec3 vSigmaY = dFdy( surf_pos.xyz );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
      clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
      clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
      clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
      clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
      color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
      color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
      color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
      color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
      common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
      cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_v0 0.339\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_v1 0.276\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_v4 0.046\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_v5 0.016\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_v6 0.0038\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
      defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
      displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
      displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
      emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
      emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
      encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
      encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
      envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
      envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
      envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
      envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
      envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
      fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
      fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
      fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
      fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
      gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
      lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
      lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
      lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
      lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
      lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
      envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
      lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
      lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
      lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
      lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
      lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
      lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	#ifdef USE_IRIDESCENCE\n		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
      lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometry.viewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
      lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
      lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
      logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
      logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
      logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
      logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
      map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
      map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
      map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
      map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
      metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
      metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
      morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
      morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
      morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
      morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
      normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
      normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
      normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
      normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
      normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
      clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
      clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
      clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
      iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
      output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
      packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
      premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
      project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
      dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
      dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
      roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
      roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
      shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
      shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
      shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
      shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
      skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
      skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif";
      skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
      skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
      specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
      specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
      tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
      tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
      transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif";
      transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
      uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
      uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
      uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
      uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
      uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
      uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
      worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
      vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
      fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
      fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
      fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
      fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
      vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
      fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
      vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
      fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
      vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
      fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
      fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
      vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
      fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
      vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
      fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
      vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
      fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
      fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
      ShaderChunk = {
        alphamap_fragment,
        alphamap_pars_fragment,
        alphatest_fragment,
        alphatest_pars_fragment,
        aomap_fragment,
        aomap_pars_fragment,
        begin_vertex,
        beginnormal_vertex,
        bsdfs,
        iridescence_fragment,
        bumpmap_pars_fragment,
        clipping_planes_fragment,
        clipping_planes_pars_fragment,
        clipping_planes_pars_vertex,
        clipping_planes_vertex,
        color_fragment,
        color_pars_fragment,
        color_pars_vertex,
        color_vertex,
        common,
        cube_uv_reflection_fragment,
        defaultnormal_vertex,
        displacementmap_pars_vertex,
        displacementmap_vertex,
        emissivemap_fragment,
        emissivemap_pars_fragment,
        encodings_fragment,
        encodings_pars_fragment,
        envmap_fragment,
        envmap_common_pars_fragment,
        envmap_pars_fragment,
        envmap_pars_vertex,
        envmap_physical_pars_fragment,
        envmap_vertex,
        fog_vertex,
        fog_pars_vertex,
        fog_fragment,
        fog_pars_fragment,
        gradientmap_pars_fragment,
        lightmap_fragment,
        lightmap_pars_fragment,
        lights_lambert_fragment,
        lights_lambert_pars_fragment,
        lights_pars_begin,
        lights_toon_fragment,
        lights_toon_pars_fragment,
        lights_phong_fragment,
        lights_phong_pars_fragment,
        lights_physical_fragment,
        lights_physical_pars_fragment,
        lights_fragment_begin,
        lights_fragment_maps,
        lights_fragment_end,
        logdepthbuf_fragment,
        logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex,
        logdepthbuf_vertex,
        map_fragment,
        map_pars_fragment,
        map_particle_fragment,
        map_particle_pars_fragment,
        metalnessmap_fragment,
        metalnessmap_pars_fragment,
        morphcolor_vertex,
        morphnormal_vertex,
        morphtarget_pars_vertex,
        morphtarget_vertex,
        normal_fragment_begin,
        normal_fragment_maps,
        normal_pars_fragment,
        normal_pars_vertex,
        normal_vertex,
        normalmap_pars_fragment,
        clearcoat_normal_fragment_begin,
        clearcoat_normal_fragment_maps,
        clearcoat_pars_fragment,
        iridescence_pars_fragment,
        output_fragment,
        packing,
        premultiplied_alpha_fragment,
        project_vertex,
        dithering_fragment,
        dithering_pars_fragment,
        roughnessmap_fragment,
        roughnessmap_pars_fragment,
        shadowmap_pars_fragment,
        shadowmap_pars_vertex,
        shadowmap_vertex,
        shadowmask_pars_fragment,
        skinbase_vertex,
        skinning_pars_vertex,
        skinning_vertex,
        skinnormal_vertex,
        specularmap_fragment,
        specularmap_pars_fragment,
        tonemapping_fragment,
        tonemapping_pars_fragment,
        transmission_fragment,
        transmission_pars_fragment,
        uv_pars_fragment,
        uv_pars_vertex,
        uv_vertex,
        uv2_pars_fragment,
        uv2_pars_vertex,
        uv2_vertex,
        worldpos_vertex,
        background_vert: vertex$h,
        background_frag: fragment$h,
        backgroundCube_vert: vertex$g,
        backgroundCube_frag: fragment$g,
        cube_vert: vertex$f,
        cube_frag: fragment$f,
        depth_vert: vertex$e,
        depth_frag: fragment$e,
        distanceRGBA_vert: vertex$d,
        distanceRGBA_frag: fragment$d,
        equirect_vert: vertex$c,
        equirect_frag: fragment$c,
        linedashed_vert: vertex$b,
        linedashed_frag: fragment$b,
        meshbasic_vert: vertex$a,
        meshbasic_frag: fragment$a,
        meshlambert_vert: vertex$9,
        meshlambert_frag: fragment$9,
        meshmatcap_vert: vertex$8,
        meshmatcap_frag: fragment$8,
        meshnormal_vert: vertex$7,
        meshnormal_frag: fragment$7,
        meshphong_vert: vertex$6,
        meshphong_frag: fragment$6,
        meshphysical_vert: vertex$5,
        meshphysical_frag: fragment$5,
        meshtoon_vert: vertex$4,
        meshtoon_frag: fragment$4,
        points_vert: vertex$3,
        points_frag: fragment$3,
        shadow_vert: vertex$2,
        shadow_frag: fragment$2,
        sprite_vert: vertex$1,
        sprite_frag: fragment$1
      };
      UniformsLib = {
        common: {
          diffuse: { value: /* @__PURE__ */ new Color(16777215) },
          opacity: { value: 1 },
          map: { value: null },
          uvTransform: { value: /* @__PURE__ */ new Matrix3() },
          uv2Transform: { value: /* @__PURE__ */ new Matrix3() },
          alphaMap: { value: null },
          alphaTest: { value: 0 }
        },
        specularmap: {
          specularMap: { value: null }
        },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          ior: { value: 1.5 },
          refractionRatio: { value: 0.98 }
        },
        aomap: {
          aoMap: { value: null },
          aoMapIntensity: { value: 1 }
        },
        lightmap: {
          lightMap: { value: null },
          lightMapIntensity: { value: 1 }
        },
        emissivemap: {
          emissiveMap: { value: null }
        },
        bumpmap: {
          bumpMap: { value: null },
          bumpScale: { value: 1 }
        },
        normalmap: {
          normalMap: { value: null },
          normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
        },
        displacementmap: {
          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 }
        },
        roughnessmap: {
          roughnessMap: { value: null }
        },
        metalnessmap: {
          metalnessMap: { value: null }
        },
        gradientmap: {
          gradientMap: { value: null }
        },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: /* @__PURE__ */ new Color(16777215) }
        },
        lights: {
          ambientLightColor: { value: [] },
          lightProbe: { value: [] },
          directionalLights: { value: [], properties: {
            direction: {},
            color: {}
          } },
          directionalLightShadows: { value: [], properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          } },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: { value: [], properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {}
          } },
          spotLightShadows: { value: [], properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          } },
          spotLightMap: { value: [] },
          spotShadowMap: { value: [] },
          spotLightMatrix: { value: [] },
          pointLights: { value: [], properties: {
            color: {},
            position: {},
            decay: {},
            distance: {}
          } },
          pointLightShadows: { value: [], properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {}
          } },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: { value: [], properties: {
            direction: {},
            skyColor: {},
            groundColor: {}
          } },
          rectAreaLights: { value: [], properties: {
            color: {},
            position: {},
            width: {},
            height: {}
          } },
          ltc_1: { value: null },
          ltc_2: { value: null }
        },
        points: {
          diffuse: { value: /* @__PURE__ */ new Color(16777215) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
          uvTransform: { value: /* @__PURE__ */ new Matrix3() }
        },
        sprite: {
          diffuse: { value: /* @__PURE__ */ new Color(16777215) },
          opacity: { value: 1 },
          center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
          rotation: { value: 0 },
          map: { value: null },
          alphaMap: { value: null },
          alphaTest: { value: 0 },
          uvTransform: { value: /* @__PURE__ */ new Matrix3() }
        }
      };
      ShaderLib = {
        basic: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.fog
          ]),
          vertexShader: ShaderChunk.meshbasic_vert,
          fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: /* @__PURE__ */ new Color(0) }
            }
          ]),
          vertexShader: ShaderChunk.meshlambert_vert,
          fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: /* @__PURE__ */ new Color(0) },
              specular: { value: /* @__PURE__ */ new Color(1118481) },
              shininess: { value: 30 }
            }
          ]),
          vertexShader: ShaderChunk.meshphong_vert,
          fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.roughnessmap,
            UniformsLib.metalnessmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: /* @__PURE__ */ new Color(0) },
              roughness: { value: 1 },
              metalness: { value: 0 },
              envMapIntensity: { value: 1 }
            }
          ]),
          vertexShader: ShaderChunk.meshphysical_vert,
          fragmentShader: ShaderChunk.meshphysical_frag
        },
        toon: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.gradientmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
              emissive: { value: /* @__PURE__ */ new Color(0) }
            }
          ]),
          vertexShader: ShaderChunk.meshtoon_vert,
          fragmentShader: ShaderChunk.meshtoon_frag
        },
        matcap: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            {
              matcap: { value: null }
            }
          ]),
          vertexShader: ShaderChunk.meshmatcap_vert,
          fragmentShader: ShaderChunk.meshmatcap_frag
        },
        points: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.points,
            UniformsLib.fog
          ]),
          vertexShader: ShaderChunk.points_vert,
          fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.fog,
            {
              scale: { value: 1 },
              dashSize: { value: 1 },
              totalSize: { value: 2 }
            }
          ]),
          vertexShader: ShaderChunk.linedashed_vert,
          fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap
          ]),
          vertexShader: ShaderChunk.depth_vert,
          fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            {
              opacity: { value: 1 }
            }
          ]),
          vertexShader: ShaderChunk.meshnormal_vert,
          fragmentShader: ShaderChunk.meshnormal_frag
        },
        sprite: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.sprite,
            UniformsLib.fog
          ]),
          vertexShader: ShaderChunk.sprite_vert,
          fragmentShader: ShaderChunk.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: { value: /* @__PURE__ */ new Matrix3() },
            t2D: { value: null },
            backgroundIntensity: { value: 1 }
          },
          vertexShader: ShaderChunk.background_vert,
          fragmentShader: ShaderChunk.background_frag
        },
        backgroundCube: {
          uniforms: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            backgroundBlurriness: { value: 0 },
            backgroundIntensity: { value: 1 }
          },
          vertexShader: ShaderChunk.backgroundCube_vert,
          fragmentShader: ShaderChunk.backgroundCube_frag
        },
        cube: {
          uniforms: {
            tCube: { value: null },
            tFlip: { value: -1 },
            opacity: { value: 1 }
          },
          vertexShader: ShaderChunk.cube_vert,
          fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: { value: null }
          },
          vertexShader: ShaderChunk.equirect_vert,
          fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap,
            {
              referencePosition: { value: /* @__PURE__ */ new Vector3() },
              nearDistance: { value: 1 },
              farDistance: { value: 1e3 }
            }
          ]),
          vertexShader: ShaderChunk.distanceRGBA_vert,
          fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
          uniforms: /* @__PURE__ */ mergeUniforms([
            UniformsLib.lights,
            UniformsLib.fog,
            {
              color: { value: /* @__PURE__ */ new Color(0) },
              opacity: { value: 1 }
            }
          ]),
          vertexShader: ShaderChunk.shadow_vert,
          fragmentShader: ShaderChunk.shadow_frag
        }
      };
      ShaderLib.physical = {
        uniforms: /* @__PURE__ */ mergeUniforms([
          ShaderLib.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
            clearcoatNormalMap: { value: null },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: /* @__PURE__ */ new Color(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: /* @__PURE__ */ new Color(0) },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
            specularColorMap: { value: null }
          }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      };
      _rgb = { r: 0, b: 0, g: 0 };
      OrthographicCamera = class extends Camera {
        constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
          super();
          this.isOrthographicCamera = true;
          this.type = "OrthographicCamera";
          this.zoom = 1;
          this.view = null;
          this.left = left;
          this.right = right;
          this.top = top;
          this.bottom = bottom;
          this.near = near;
          this.far = far;
          this.updateProjectionMatrix();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.left = source.left;
          this.right = source.right;
          this.top = source.top;
          this.bottom = source.bottom;
          this.near = source.near;
          this.far = source.far;
          this.zoom = source.zoom;
          this.view = source.view === null ? null : Object.assign({}, source.view);
          return this;
        }
        setViewOffset(fullWidth, fullHeight, x, y, width2, height2) {
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x;
          this.view.offsetY = y;
          this.view.width = width2;
          this.view.height = height2;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const dx = (this.right - this.left) / (2 * this.zoom);
          const dy = (this.top - this.bottom) / (2 * this.zoom);
          const cx = (this.right + this.left) / 2;
          const cy = (this.top + this.bottom) / 2;
          let left = cx - dx;
          let right = cx + dx;
          let top = cy + dy;
          let bottom = cy - dy;
          if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.zoom = this.zoom;
          data.object.left = this.left;
          data.object.right = this.right;
          data.object.top = this.top;
          data.object.bottom = this.bottom;
          data.object.near = this.near;
          data.object.far = this.far;
          if (this.view !== null)
            data.object.view = Object.assign({}, this.view);
          return data;
        }
      };
      LOD_MIN = 4;
      EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
      MAX_SAMPLES = 20;
      _flatCamera = /* @__PURE__ */ new OrthographicCamera();
      _clearColor = /* @__PURE__ */ new Color();
      _oldTarget = null;
      PHI = (1 + Math.sqrt(5)) / 2;
      INV_PHI = 1 / PHI;
      _axisDirections = [
        /* @__PURE__ */ new Vector3(1, 1, 1),
        /* @__PURE__ */ new Vector3(-1, 1, 1),
        /* @__PURE__ */ new Vector3(1, 1, -1),
        /* @__PURE__ */ new Vector3(-1, 1, -1),
        /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
        /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
        /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
        /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
        /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
        /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
      ];
      PMREMGenerator = class {
        constructor(renderer) {
          this._renderer = renderer;
          this._pingPongRenderTarget = null;
          this._lodMax = 0;
          this._cubeSize = 0;
          this._lodPlanes = [];
          this._sizeLods = [];
          this._sigmas = [];
          this._blurMaterial = null;
          this._cubemapMaterial = null;
          this._equirectMaterial = null;
          this._compileMaterial(this._blurMaterial);
        }
        fromScene(scene, sigma = 0, near = 0.1, far = 100) {
          _oldTarget = this._renderer.getRenderTarget();
          this._setSize(256);
          const cubeUVRenderTarget = this._allocateTargets();
          cubeUVRenderTarget.depthBuffer = true;
          this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
          if (sigma > 0) {
            this._blur(cubeUVRenderTarget, 0, 0, sigma);
          }
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        fromEquirectangular(equirectangular, renderTarget = null) {
          return this._fromTexture(equirectangular, renderTarget);
        }
        fromCubemap(cubemap, renderTarget = null) {
          return this._fromTexture(cubemap, renderTarget);
        }
        compileCubemapShader() {
          if (this._cubemapMaterial === null) {
            this._cubemapMaterial = _getCubemapMaterial();
            this._compileMaterial(this._cubemapMaterial);
          }
        }
        compileEquirectangularShader() {
          if (this._equirectMaterial === null) {
            this._equirectMaterial = _getEquirectMaterial();
            this._compileMaterial(this._equirectMaterial);
          }
        }
        dispose() {
          this._dispose();
          if (this._cubemapMaterial !== null)
            this._cubemapMaterial.dispose();
          if (this._equirectMaterial !== null)
            this._equirectMaterial.dispose();
        }
        _setSize(cubeSize) {
          this._lodMax = Math.floor(Math.log2(cubeSize));
          this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          if (this._blurMaterial !== null)
            this._blurMaterial.dispose();
          if (this._pingPongRenderTarget !== null)
            this._pingPongRenderTarget.dispose();
          for (let i = 0; i < this._lodPlanes.length; i++) {
            this._lodPlanes[i].dispose();
          }
        }
        _cleanup(outputTarget) {
          this._renderer.setRenderTarget(_oldTarget);
          outputTarget.scissorTest = false;
          _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
        }
        _fromTexture(texture, renderTarget) {
          if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
            this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
          } else {
            this._setSize(texture.image.width / 4);
          }
          _oldTarget = this._renderer.getRenderTarget();
          const cubeUVRenderTarget = renderTarget || this._allocateTargets();
          this._textureToCubeUV(texture, cubeUVRenderTarget);
          this._applyPMREM(cubeUVRenderTarget);
          this._cleanup(cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        _allocateTargets() {
          const width2 = 3 * Math.max(this._cubeSize, 16 * 7);
          const height2 = 4 * this._cubeSize;
          const params2 = {
            magFilter: LinearFilter,
            minFilter: LinearFilter,
            generateMipmaps: false,
            type: HalfFloatType,
            format: RGBAFormat,
            encoding: LinearEncoding,
            depthBuffer: false
          };
          const cubeUVRenderTarget = _createRenderTarget(width2, height2, params2);
          if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width2 || this._pingPongRenderTarget.height !== height2) {
            if (this._pingPongRenderTarget !== null) {
              this._dispose();
            }
            this._pingPongRenderTarget = _createRenderTarget(width2, height2, params2);
            const { _lodMax } = this;
            ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
            this._blurMaterial = _getBlurShader(_lodMax, width2, height2);
          }
          return cubeUVRenderTarget;
        }
        _compileMaterial(material) {
          const tmpMesh = new Mesh(this._lodPlanes[0], material);
          this._renderer.compile(tmpMesh, _flatCamera);
        }
        _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
          const fov2 = 90;
          const aspect2 = 1;
          const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
          const upSign = [1, -1, 1, 1, 1, 1];
          const forwardSign = [1, 1, 1, -1, -1, -1];
          const renderer = this._renderer;
          const originalAutoClear = renderer.autoClear;
          const toneMapping = renderer.toneMapping;
          renderer.getClearColor(_clearColor);
          renderer.toneMapping = NoToneMapping;
          renderer.autoClear = false;
          const backgroundMaterial = new MeshBasicMaterial({
            name: "PMREM.Background",
            side: BackSide,
            depthWrite: false,
            depthTest: false
          });
          const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
          let useSolidColor = false;
          const background = scene.background;
          if (background) {
            if (background.isColor) {
              backgroundMaterial.color.copy(background);
              scene.background = null;
              useSolidColor = true;
            }
          } else {
            backgroundMaterial.color.copy(_clearColor);
            useSolidColor = true;
          }
          for (let i = 0; i < 6; i++) {
            const col = i % 3;
            if (col === 0) {
              cubeCamera.up.set(0, upSign[i], 0);
              cubeCamera.lookAt(forwardSign[i], 0, 0);
            } else if (col === 1) {
              cubeCamera.up.set(0, 0, upSign[i]);
              cubeCamera.lookAt(0, forwardSign[i], 0);
            } else {
              cubeCamera.up.set(0, upSign[i], 0);
              cubeCamera.lookAt(0, 0, forwardSign[i]);
            }
            const size = this._cubeSize;
            _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
            renderer.setRenderTarget(cubeUVRenderTarget);
            if (useSolidColor) {
              renderer.render(backgroundBox, cubeCamera);
            }
            renderer.render(scene, cubeCamera);
          }
          backgroundBox.geometry.dispose();
          backgroundBox.material.dispose();
          renderer.toneMapping = toneMapping;
          renderer.autoClear = originalAutoClear;
          scene.background = background;
        }
        _textureToCubeUV(texture, cubeUVRenderTarget) {
          const renderer = this._renderer;
          const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
          if (isCubeTexture) {
            if (this._cubemapMaterial === null) {
              this._cubemapMaterial = _getCubemapMaterial();
            }
            this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
          } else {
            if (this._equirectMaterial === null) {
              this._equirectMaterial = _getEquirectMaterial();
            }
          }
          const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
          const mesh = new Mesh(this._lodPlanes[0], material);
          const uniforms = material.uniforms;
          uniforms["envMap"].value = texture;
          const size = this._cubeSize;
          _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
          renderer.setRenderTarget(cubeUVRenderTarget);
          renderer.render(mesh, _flatCamera);
        }
        _applyPMREM(cubeUVRenderTarget) {
          const renderer = this._renderer;
          const autoClear = renderer.autoClear;
          renderer.autoClear = false;
          for (let i = 1; i < this._lodPlanes.length; i++) {
            const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
            const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
            this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
          }
          renderer.autoClear = autoClear;
        }
        _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
          const pingPongRenderTarget = this._pingPongRenderTarget;
          this._halfBlur(
            cubeUVRenderTarget,
            pingPongRenderTarget,
            lodIn,
            lodOut,
            sigma,
            "latitudinal",
            poleAxis
          );
          this._halfBlur(
            pingPongRenderTarget,
            cubeUVRenderTarget,
            lodOut,
            lodOut,
            sigma,
            "longitudinal",
            poleAxis
          );
        }
        _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
          const renderer = this._renderer;
          const blurMaterial = this._blurMaterial;
          if (direction !== "latitudinal" && direction !== "longitudinal") {
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          }
          const STANDARD_DEVIATIONS = 3;
          const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
          const blurUniforms = blurMaterial.uniforms;
          const pixels = this._sizeLods[lodIn] - 1;
          const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
          const sigmaPixels = sigmaRadians / radiansPerPixel;
          const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
          if (samples > MAX_SAMPLES) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
          }
          const weights = [];
          let sum2 = 0;
          for (let i = 0; i < MAX_SAMPLES; ++i) {
            const x2 = i / sigmaPixels;
            const weight = Math.exp(-x2 * x2 / 2);
            weights.push(weight);
            if (i === 0) {
              sum2 += weight;
            } else if (i < samples) {
              sum2 += 2 * weight;
            }
          }
          for (let i = 0; i < weights.length; i++) {
            weights[i] = weights[i] / sum2;
          }
          blurUniforms["envMap"].value = targetIn.texture;
          blurUniforms["samples"].value = samples;
          blurUniforms["weights"].value = weights;
          blurUniforms["latitudinal"].value = direction === "latitudinal";
          if (poleAxis) {
            blurUniforms["poleAxis"].value = poleAxis;
          }
          const { _lodMax } = this;
          blurUniforms["dTheta"].value = radiansPerPixel;
          blurUniforms["mipInt"].value = _lodMax - lodIn;
          const outputSize = this._sizeLods[lodOut];
          const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
          const y = 4 * (this._cubeSize - outputSize);
          _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
          renderer.setRenderTarget(targetOut);
          renderer.render(blurMesh, _flatCamera);
        }
      };
      emptyTexture = /* @__PURE__ */ new Texture();
      emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
      empty3dTexture = /* @__PURE__ */ new Data3DTexture();
      emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
      arrayCacheF32 = [];
      arrayCacheI32 = [];
      mat4array = new Float32Array(16);
      mat3array = new Float32Array(9);
      mat2array = new Float32Array(4);
      SingleUniform = class {
        constructor(id2, activeInfo, addr) {
          this.id = id2;
          this.addr = addr;
          this.cache = [];
          this.setValue = getSingularSetter(activeInfo.type);
        }
      };
      PureArrayUniform = class {
        constructor(id2, activeInfo, addr) {
          this.id = id2;
          this.addr = addr;
          this.cache = [];
          this.size = activeInfo.size;
          this.setValue = getPureArraySetter(activeInfo.type);
        }
      };
      StructuredUniform = class {
        constructor(id2) {
          this.id = id2;
          this.seq = [];
          this.map = {};
        }
        setValue(gl, value, textures) {
          const seq = this.seq;
          for (let i = 0, n = seq.length; i !== n; ++i) {
            const u = seq[i];
            u.setValue(gl, value[u.id], textures);
          }
        }
      };
      RePathPart = /(\w+)(\])?(\[|\.)?/g;
      WebGLUniforms = class {
        constructor(gl, program) {
          this.seq = [];
          this.map = {};
          const n = gl.getProgramParameter(program, 35718);
          for (let i = 0; i < n; ++i) {
            const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
            parseUniform(info, addr, this);
          }
        }
        setValue(gl, name, value, textures) {
          const u = this.map[name];
          if (u !== void 0)
            u.setValue(gl, value, textures);
        }
        setOptional(gl, object, name) {
          const v = object[name];
          if (v !== void 0)
            this.setValue(gl, name, v);
        }
        static upload(gl, seq, values3, textures) {
          for (let i = 0, n = seq.length; i !== n; ++i) {
            const u = seq[i], v = values3[u.id];
            if (v.needsUpdate !== false) {
              u.setValue(gl, v.value, textures);
            }
          }
        }
        static seqWithValue(seq, values3) {
          const r = [];
          for (let i = 0, n = seq.length; i !== n; ++i) {
            const u = seq[i];
            if (u.id in values3)
              r.push(u);
          }
          return r;
        }
      };
      programIdCount = 0;
      includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
      unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      _id = 0;
      WebGLShaderCache = class {
        constructor() {
          this.shaderCache = /* @__PURE__ */ new Map();
          this.materialCache = /* @__PURE__ */ new Map();
        }
        update(material) {
          const vertexShader = material.vertexShader;
          const fragmentShader = material.fragmentShader;
          const vertexShaderStage = this._getShaderStage(vertexShader);
          const fragmentShaderStage = this._getShaderStage(fragmentShader);
          const materialShaders = this._getShaderCacheForMaterial(material);
          if (materialShaders.has(vertexShaderStage) === false) {
            materialShaders.add(vertexShaderStage);
            vertexShaderStage.usedTimes++;
          }
          if (materialShaders.has(fragmentShaderStage) === false) {
            materialShaders.add(fragmentShaderStage);
            fragmentShaderStage.usedTimes++;
          }
          return this;
        }
        remove(material) {
          const materialShaders = this.materialCache.get(material);
          for (const shaderStage of materialShaders) {
            shaderStage.usedTimes--;
            if (shaderStage.usedTimes === 0)
              this.shaderCache.delete(shaderStage.code);
          }
          this.materialCache.delete(material);
          return this;
        }
        getVertexShaderID(material) {
          return this._getShaderStage(material.vertexShader).id;
        }
        getFragmentShaderID(material) {
          return this._getShaderStage(material.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear();
          this.materialCache.clear();
        }
        _getShaderCacheForMaterial(material) {
          const cache = this.materialCache;
          let set = cache.get(material);
          if (set === void 0) {
            set = /* @__PURE__ */ new Set();
            cache.set(material, set);
          }
          return set;
        }
        _getShaderStage(code) {
          const cache = this.shaderCache;
          let stage = cache.get(code);
          if (stage === void 0) {
            stage = new WebGLShaderStage(code);
            cache.set(code, stage);
          }
          return stage;
        }
      };
      WebGLShaderStage = class {
        constructor(code) {
          this.id = _id++;
          this.code = code;
          this.usedTimes = 0;
        }
      };
      nextVersion = 0;
      MeshDepthMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshDepthMaterial = true;
          this.type = "MeshDepthMaterial";
          this.depthPacking = BasicDepthPacking;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.depthPacking = source.depthPacking;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          return this;
        }
      };
      MeshDistanceMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshDistanceMaterial = true;
          this.type = "MeshDistanceMaterial";
          this.referencePosition = new Vector3();
          this.nearDistance = 1;
          this.farDistance = 1e3;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.referencePosition.copy(source.referencePosition);
          this.nearDistance = source.nearDistance;
          this.farDistance = source.farDistance;
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          return this;
        }
      };
      vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
      fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
      ArrayCamera = class extends PerspectiveCamera {
        constructor(array = []) {
          super();
          this.isArrayCamera = true;
          this.cameras = array;
        }
      };
      Group = class extends Object3D {
        constructor() {
          super();
          this.isGroup = true;
          this.type = "Group";
        }
      };
      _moveEvent = { type: "move" };
      WebXRController = class {
        constructor() {
          this._targetRay = null;
          this._grip = null;
          this._hand = null;
        }
        getHandSpace() {
          if (this._hand === null) {
            this._hand = new Group();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {};
            this._hand.inputState = { pinching: false };
          }
          return this._hand;
        }
        getTargetRaySpace() {
          if (this._targetRay === null) {
            this._targetRay = new Group();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
            this._targetRay.hasLinearVelocity = false;
            this._targetRay.linearVelocity = new Vector3();
            this._targetRay.hasAngularVelocity = false;
            this._targetRay.angularVelocity = new Vector3();
          }
          return this._targetRay;
        }
        getGripSpace() {
          if (this._grip === null) {
            this._grip = new Group();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
            this._grip.hasLinearVelocity = false;
            this._grip.linearVelocity = new Vector3();
            this._grip.hasAngularVelocity = false;
            this._grip.angularVelocity = new Vector3();
          }
          return this._grip;
        }
        dispatchEvent(event) {
          if (this._targetRay !== null) {
            this._targetRay.dispatchEvent(event);
          }
          if (this._grip !== null) {
            this._grip.dispatchEvent(event);
          }
          if (this._hand !== null) {
            this._hand.dispatchEvent(event);
          }
          return this;
        }
        connect(inputSource) {
          if (inputSource && inputSource.hand) {
            const hand = this._hand;
            if (hand) {
              for (const inputjoint of inputSource.hand.values()) {
                this._getHandJoint(hand, inputjoint);
              }
            }
          }
          this.dispatchEvent({ type: "connected", data: inputSource });
          return this;
        }
        disconnect(inputSource) {
          this.dispatchEvent({ type: "disconnected", data: inputSource });
          if (this._targetRay !== null) {
            this._targetRay.visible = false;
          }
          if (this._grip !== null) {
            this._grip.visible = false;
          }
          if (this._hand !== null) {
            this._hand.visible = false;
          }
          return this;
        }
        update(inputSource, frame, referenceSpace) {
          let inputPose = null;
          let gripPose = null;
          let handPose = null;
          const targetRay = this._targetRay;
          const grip = this._grip;
          const hand = this._hand;
          if (inputSource && frame.session.visibilityState !== "visible-blurred") {
            if (hand && inputSource.hand) {
              handPose = true;
              for (const inputjoint of inputSource.hand.values()) {
                const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                const joint = this._getHandJoint(hand, inputjoint);
                if (jointPose !== null) {
                  joint.matrix.fromArray(jointPose.transform.matrix);
                  joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                  joint.jointRadius = jointPose.radius;
                }
                joint.visible = jointPose !== null;
              }
              const indexTip = hand.joints["index-finger-tip"];
              const thumbTip = hand.joints["thumb-tip"];
              const distance = indexTip.position.distanceTo(thumbTip.position);
              const distanceToPinch = 0.02;
              const threshold = 5e-3;
              if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                hand.inputState.pinching = false;
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: inputSource.handedness,
                  target: this
                });
              } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                hand.inputState.pinching = true;
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: inputSource.handedness,
                  target: this
                });
              }
            } else {
              if (grip !== null && inputSource.gripSpace) {
                gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                if (gripPose !== null) {
                  grip.matrix.fromArray(gripPose.transform.matrix);
                  grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                  if (gripPose.linearVelocity) {
                    grip.hasLinearVelocity = true;
                    grip.linearVelocity.copy(gripPose.linearVelocity);
                  } else {
                    grip.hasLinearVelocity = false;
                  }
                  if (gripPose.angularVelocity) {
                    grip.hasAngularVelocity = true;
                    grip.angularVelocity.copy(gripPose.angularVelocity);
                  } else {
                    grip.hasAngularVelocity = false;
                  }
                }
              }
            }
            if (targetRay !== null) {
              inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
              if (inputPose === null && gripPose !== null) {
                inputPose = gripPose;
              }
              if (inputPose !== null) {
                targetRay.matrix.fromArray(inputPose.transform.matrix);
                targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                if (inputPose.linearVelocity) {
                  targetRay.hasLinearVelocity = true;
                  targetRay.linearVelocity.copy(inputPose.linearVelocity);
                } else {
                  targetRay.hasLinearVelocity = false;
                }
                if (inputPose.angularVelocity) {
                  targetRay.hasAngularVelocity = true;
                  targetRay.angularVelocity.copy(inputPose.angularVelocity);
                } else {
                  targetRay.hasAngularVelocity = false;
                }
                this.dispatchEvent(_moveEvent);
              }
            }
          }
          if (targetRay !== null) {
            targetRay.visible = inputPose !== null;
          }
          if (grip !== null) {
            grip.visible = gripPose !== null;
          }
          if (hand !== null) {
            hand.visible = handPose !== null;
          }
          return this;
        }
        _getHandJoint(hand, inputjoint) {
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint = new Group();
            joint.matrixAutoUpdate = false;
            joint.visible = false;
            hand.joints[inputjoint.jointName] = joint;
            hand.add(joint);
          }
          return hand.joints[inputjoint.jointName];
        }
      };
      DepthTexture = class extends Texture {
        constructor(width2, height2, type3, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
          format = format !== void 0 ? format : DepthFormat;
          if (format !== DepthFormat && format !== DepthStencilFormat) {
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          }
          if (type3 === void 0 && format === DepthFormat)
            type3 = UnsignedIntType;
          if (type3 === void 0 && format === DepthStencilFormat)
            type3 = UnsignedInt248Type;
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type3, anisotropy);
          this.isDepthTexture = true;
          this.image = { width: width2, height: height2 };
          this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
          this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      };
      WebXRManager = class extends EventDispatcher {
        constructor(renderer, gl) {
          super();
          const scope = this;
          let session = null;
          let framebufferScaleFactor = 1;
          let referenceSpace = null;
          let referenceSpaceType = "local-floor";
          let foveation = 1;
          let customReferenceSpace = null;
          let pose = null;
          let glBinding = null;
          let glProjLayer = null;
          let glBaseLayer = null;
          let xrFrame = null;
          const attributes = gl.getContextAttributes();
          let initialRenderTarget = null;
          let newRenderTarget = null;
          const controllers = [];
          const controllerInputSources = [];
          const planes = /* @__PURE__ */ new Set();
          const planesLastChangedTimes = /* @__PURE__ */ new Map();
          const cameraL = new PerspectiveCamera();
          cameraL.layers.enable(1);
          cameraL.viewport = new Vector4();
          const cameraR = new PerspectiveCamera();
          cameraR.layers.enable(2);
          cameraR.viewport = new Vector4();
          const cameras = [cameraL, cameraR];
          const cameraVR = new ArrayCamera();
          cameraVR.layers.enable(1);
          cameraVR.layers.enable(2);
          let _currentDepthNear = null;
          let _currentDepthFar = null;
          this.cameraAutoUpdate = true;
          this.enabled = false;
          this.isPresenting = false;
          this.getController = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getTargetRaySpace();
          };
          this.getControllerGrip = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getGripSpace();
          };
          this.getHand = function(index) {
            let controller = controllers[index];
            if (controller === void 0) {
              controller = new WebXRController();
              controllers[index] = controller;
            }
            return controller.getHandSpace();
          };
          function onSessionEvent(event) {
            const controllerIndex = controllerInputSources.indexOf(event.inputSource);
            if (controllerIndex === -1) {
              return;
            }
            const controller = controllers[controllerIndex];
            if (controller !== void 0) {
              controller.dispatchEvent({ type: event.type, data: event.inputSource });
            }
          }
          function onSessionEnd() {
            session.removeEventListener("select", onSessionEvent);
            session.removeEventListener("selectstart", onSessionEvent);
            session.removeEventListener("selectend", onSessionEvent);
            session.removeEventListener("squeeze", onSessionEvent);
            session.removeEventListener("squeezestart", onSessionEvent);
            session.removeEventListener("squeezeend", onSessionEvent);
            session.removeEventListener("end", onSessionEnd);
            session.removeEventListener("inputsourceschange", onInputSourcesChange);
            for (let i = 0; i < controllers.length; i++) {
              const inputSource = controllerInputSources[i];
              if (inputSource === null)
                continue;
              controllerInputSources[i] = null;
              controllers[i].disconnect(inputSource);
            }
            _currentDepthNear = null;
            _currentDepthFar = null;
            renderer.setRenderTarget(initialRenderTarget);
            glBaseLayer = null;
            glProjLayer = null;
            glBinding = null;
            session = null;
            newRenderTarget = null;
            animation.stop();
            scope.isPresenting = false;
            scope.dispatchEvent({ type: "sessionend" });
          }
          this.setFramebufferScaleFactor = function(value) {
            framebufferScaleFactor = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }
          };
          this.setReferenceSpaceType = function(value) {
            referenceSpaceType = value;
            if (scope.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }
          };
          this.getReferenceSpace = function() {
            return customReferenceSpace || referenceSpace;
          };
          this.setReferenceSpace = function(space) {
            customReferenceSpace = space;
          };
          this.getBaseLayer = function() {
            return glProjLayer !== null ? glProjLayer : glBaseLayer;
          };
          this.getBinding = function() {
            return glBinding;
          };
          this.getFrame = function() {
            return xrFrame;
          };
          this.getSession = function() {
            return session;
          };
          this.setSession = async function(value) {
            session = value;
            if (session !== null) {
              initialRenderTarget = renderer.getRenderTarget();
              session.addEventListener("select", onSessionEvent);
              session.addEventListener("selectstart", onSessionEvent);
              session.addEventListener("selectend", onSessionEvent);
              session.addEventListener("squeeze", onSessionEvent);
              session.addEventListener("squeezestart", onSessionEvent);
              session.addEventListener("squeezeend", onSessionEvent);
              session.addEventListener("end", onSessionEnd);
              session.addEventListener("inputsourceschange", onInputSourcesChange);
              if (attributes.xrCompatible !== true) {
                await gl.makeXRCompatible();
              }
              if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
                const layerInit = {
                  antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
                  alpha: attributes.alpha,
                  depth: attributes.depth,
                  stencil: attributes.stencil,
                  framebufferScaleFactor
                };
                glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                session.updateRenderState({ baseLayer: glBaseLayer });
                newRenderTarget = new WebGLRenderTarget(
                  glBaseLayer.framebufferWidth,
                  glBaseLayer.framebufferHeight,
                  {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    encoding: renderer.outputEncoding,
                    stencilBuffer: attributes.stencil
                  }
                );
              } else {
                let depthFormat = null;
                let depthType = null;
                let glDepthFormat = null;
                if (attributes.depth) {
                  glDepthFormat = attributes.stencil ? 35056 : 33190;
                  depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                  depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
                }
                const projectionlayerInit = {
                  colorFormat: 32856,
                  depthFormat: glDepthFormat,
                  scaleFactor: framebufferScaleFactor
                };
                glBinding = new XRWebGLBinding(session, gl);
                glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                session.updateRenderState({ layers: [glProjLayer] });
                newRenderTarget = new WebGLRenderTarget(
                  glProjLayer.textureWidth,
                  glProjLayer.textureHeight,
                  {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                    stencilBuffer: attributes.stencil,
                    encoding: renderer.outputEncoding,
                    samples: attributes.antialias ? 4 : 0
                  }
                );
                const renderTargetProperties = renderer.properties.get(newRenderTarget);
                renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
              }
              newRenderTarget.isXRRenderTarget = true;
              this.setFoveation(foveation);
              customReferenceSpace = null;
              referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
              animation.setContext(session);
              animation.start();
              scope.isPresenting = true;
              scope.dispatchEvent({ type: "sessionstart" });
            }
          };
          function onInputSourcesChange(event) {
            for (let i = 0; i < event.removed.length; i++) {
              const inputSource = event.removed[i];
              const index = controllerInputSources.indexOf(inputSource);
              if (index >= 0) {
                controllerInputSources[index] = null;
                controllers[index].disconnect(inputSource);
              }
            }
            for (let i = 0; i < event.added.length; i++) {
              const inputSource = event.added[i];
              let controllerIndex = controllerInputSources.indexOf(inputSource);
              if (controllerIndex === -1) {
                for (let i2 = 0; i2 < controllers.length; i2++) {
                  if (i2 >= controllerInputSources.length) {
                    controllerInputSources.push(inputSource);
                    controllerIndex = i2;
                    break;
                  } else if (controllerInputSources[i2] === null) {
                    controllerInputSources[i2] = inputSource;
                    controllerIndex = i2;
                    break;
                  }
                }
                if (controllerIndex === -1)
                  break;
              }
              const controller = controllers[controllerIndex];
              if (controller) {
                controller.connect(inputSource);
              }
            }
          }
          const cameraLPos = new Vector3();
          const cameraRPos = new Vector3();
          function setProjectionFromUnion(camera, cameraL2, cameraR2) {
            cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
            const ipd = cameraLPos.distanceTo(cameraRPos);
            const projL = cameraL2.projectionMatrix.elements;
            const projR = cameraR2.projectionMatrix.elements;
            const near = projL[14] / (projL[10] - 1);
            const far = projL[14] / (projL[10] + 1);
            const topFov = (projL[9] + 1) / projL[5];
            const bottomFov = (projL[9] - 1) / projL[5];
            const leftFov = (projL[8] - 1) / projL[0];
            const rightFov = (projR[8] + 1) / projR[0];
            const left = near * leftFov;
            const right = near * rightFov;
            const zOffset = ipd / (-leftFov + rightFov);
            const xOffset = zOffset * -leftFov;
            cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            const near2 = near + zOffset;
            const far2 = far + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far / far2 * near2;
            const bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
          }
          function updateCamera(camera, parent) {
            if (parent === null) {
              camera.matrixWorld.copy(camera.matrix);
            } else {
              camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            }
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
          }
          this.updateCamera = function(camera) {
            if (session === null)
              return;
            cameraVR.near = cameraR.near = cameraL.near = camera.near;
            cameraVR.far = cameraR.far = cameraL.far = camera.far;
            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
              session.updateRenderState({
                depthNear: cameraVR.near,
                depthFar: cameraVR.far
              });
              _currentDepthNear = cameraVR.near;
              _currentDepthFar = cameraVR.far;
            }
            const parent = camera.parent;
            const cameras2 = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for (let i = 0; i < cameras2.length; i++) {
              updateCamera(cameras2[i], parent);
            }
            cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
            camera.matrix.copy(cameraVR.matrix);
            camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
            const children = camera.children;
            for (let i = 0, l = children.length; i < l; i++) {
              children[i].updateMatrixWorld(true);
            }
            if (cameras2.length === 2) {
              setProjectionFromUnion(cameraVR, cameraL, cameraR);
            } else {
              cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
            }
          };
          this.getCamera = function() {
            return cameraVR;
          };
          this.getFoveation = function() {
            if (glProjLayer === null && glBaseLayer === null) {
              return void 0;
            }
            return foveation;
          };
          this.setFoveation = function(value) {
            foveation = value;
            if (glProjLayer !== null) {
              glProjLayer.fixedFoveation = value;
            }
            if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
              glBaseLayer.fixedFoveation = value;
            }
          };
          this.getPlanes = function() {
            return planes;
          };
          let onAnimationFrameCallback = null;
          function onAnimationFrame(time2, frame) {
            pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
            xrFrame = frame;
            if (pose !== null) {
              const views = pose.views;
              if (glBaseLayer !== null) {
                renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
                renderer.setRenderTarget(newRenderTarget);
              }
              let cameraVRNeedsUpdate = false;
              if (views.length !== cameraVR.cameras.length) {
                cameraVR.cameras.length = 0;
                cameraVRNeedsUpdate = true;
              }
              for (let i = 0; i < views.length; i++) {
                const view = views[i];
                let viewport = null;
                if (glBaseLayer !== null) {
                  viewport = glBaseLayer.getViewport(view);
                } else {
                  const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                  viewport = glSubImage.viewport;
                  if (i === 0) {
                    renderer.setRenderTargetTextures(
                      newRenderTarget,
                      glSubImage.colorTexture,
                      glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
                    );
                    renderer.setRenderTarget(newRenderTarget);
                  }
                }
                let camera = cameras[i];
                if (camera === void 0) {
                  camera = new PerspectiveCamera();
                  camera.layers.enable(i);
                  camera.viewport = new Vector4();
                  cameras[i] = camera;
                }
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i === 0) {
                  cameraVR.matrix.copy(camera.matrix);
                }
                if (cameraVRNeedsUpdate === true) {
                  cameraVR.cameras.push(camera);
                }
              }
            }
            for (let i = 0; i < controllers.length; i++) {
              const inputSource = controllerInputSources[i];
              const controller = controllers[i];
              if (inputSource !== null && controller !== void 0) {
                controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
              }
            }
            if (onAnimationFrameCallback)
              onAnimationFrameCallback(time2, frame);
            if (frame.detectedPlanes) {
              scope.dispatchEvent({ type: "planesdetected", data: frame.detectedPlanes });
              let planesToRemove = null;
              for (const plane of planes) {
                if (!frame.detectedPlanes.has(plane)) {
                  if (planesToRemove === null) {
                    planesToRemove = [];
                  }
                  planesToRemove.push(plane);
                }
              }
              if (planesToRemove !== null) {
                for (const plane of planesToRemove) {
                  planes.delete(plane);
                  planesLastChangedTimes.delete(plane);
                  scope.dispatchEvent({ type: "planeremoved", data: plane });
                }
              }
              for (const plane of frame.detectedPlanes) {
                if (!planes.has(plane)) {
                  planes.add(plane);
                  planesLastChangedTimes.set(plane, frame.lastChangedTime);
                  scope.dispatchEvent({ type: "planeadded", data: plane });
                } else {
                  const lastKnownTime = planesLastChangedTimes.get(plane);
                  if (plane.lastChangedTime > lastKnownTime) {
                    planesLastChangedTimes.set(plane, plane.lastChangedTime);
                    scope.dispatchEvent({ type: "planechanged", data: plane });
                  }
                }
              }
            }
            xrFrame = null;
          }
          const animation = new WebGLAnimation();
          animation.setAnimationLoop(onAnimationFrame);
          this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
          };
          this.dispose = function() {
          };
        }
      };
      WebGL1Renderer = class extends WebGLRenderer {
      };
      WebGL1Renderer.prototype.isWebGL1Renderer = true;
      FogExp2 = class {
        constructor(color, density = 25e-5) {
          this.isFogExp2 = true;
          this.name = "";
          this.color = new Color(color);
          this.density = density;
        }
        clone() {
          return new FogExp2(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
          };
        }
      };
      Fog = class {
        constructor(color, near = 1, far = 1e3) {
          this.isFog = true;
          this.name = "";
          this.color = new Color(color);
          this.near = near;
          this.far = far;
        }
        clone() {
          return new Fog(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
          };
        }
      };
      Scene = class extends Object3D {
        constructor() {
          super();
          this.isScene = true;
          this.type = "Scene";
          this.background = null;
          this.environment = null;
          this.fog = null;
          this.backgroundBlurriness = 0;
          this.backgroundIntensity = 1;
          this.overrideMaterial = null;
          if (typeof __THREE_DEVTOOLS__ !== "undefined") {
            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
          }
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          if (source.background !== null)
            this.background = source.background.clone();
          if (source.environment !== null)
            this.environment = source.environment.clone();
          if (source.fog !== null)
            this.fog = source.fog.clone();
          this.backgroundBlurriness = source.backgroundBlurriness;
          this.backgroundIntensity = source.backgroundIntensity;
          if (source.overrideMaterial !== null)
            this.overrideMaterial = source.overrideMaterial.clone();
          this.matrixAutoUpdate = source.matrixAutoUpdate;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.fog !== null)
            data.object.fog = this.fog.toJSON();
          if (this.backgroundBlurriness > 0)
            data.object.backgroundBlurriness = this.backgroundBlurriness;
          if (this.backgroundIntensity !== 1)
            data.object.backgroundIntensity = this.backgroundIntensity;
          return data;
        }
        get autoUpdate() {
          console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.");
          return this.matrixWorldAutoUpdate;
        }
        set autoUpdate(value) {
          console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.");
          this.matrixWorldAutoUpdate = value;
        }
      };
      InterleavedBuffer = class {
        constructor(array, stride) {
          this.isInterleavedBuffer = true;
          this.array = array;
          this.stride = stride;
          this.count = array !== void 0 ? array.length / stride : 0;
          this.usage = StaticDrawUsage;
          this.updateRange = { offset: 0, count: -1 };
          this.version = 0;
          this.uuid = generateUUID();
        }
        onUploadCallback() {
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        copy(source) {
          this.array = new source.array.constructor(source.array);
          this.count = source.count;
          this.stride = source.stride;
          this.usage = source.usage;
          return this;
        }
        copyAt(index1, attribute, index2) {
          index1 *= this.stride;
          index2 *= attribute.stride;
          for (let i = 0, l = this.stride; i < l; i++) {
            this.array[index1 + i] = attribute.array[index2 + i];
          }
          return this;
        }
        set(value, offset = 0) {
          this.array.set(value, offset);
          return this;
        }
        clone(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
          }
          const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
          const ib = new this.constructor(array, this.stride);
          ib.setUsage(this.usage);
          return ib;
        }
        onUpload(callback) {
          this.onUploadCallback = callback;
          return this;
        }
        toJSON(data) {
          if (data.arrayBuffers === void 0) {
            data.arrayBuffers = {};
          }
          if (this.array.buffer._uuid === void 0) {
            this.array.buffer._uuid = generateUUID();
          }
          if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
            data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
          }
          return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      };
      _vector$6 = /* @__PURE__ */ new Vector3();
      InterleavedBufferAttribute = class {
        constructor(interleavedBuffer, itemSize, offset, normalized = false) {
          this.isInterleavedBufferAttribute = true;
          this.name = "";
          this.data = interleavedBuffer;
          this.itemSize = itemSize;
          this.offset = offset;
          this.normalized = normalized;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(value) {
          this.data.needsUpdate = value;
        }
        applyMatrix4(m) {
          for (let i = 0, l = this.data.count; i < l; i++) {
            _vector$6.fromBufferAttribute(this, i);
            _vector$6.applyMatrix4(m);
            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        applyNormalMatrix(m) {
          for (let i = 0, l = this.count; i < l; i++) {
            _vector$6.fromBufferAttribute(this, i);
            _vector$6.applyNormalMatrix(m);
            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        transformDirection(m) {
          for (let i = 0, l = this.count; i < l; i++) {
            _vector$6.fromBufferAttribute(this, i);
            _vector$6.transformDirection(m);
            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
          }
          return this;
        }
        setX(index, x) {
          if (this.normalized)
            x = normalize(x, this.array);
          this.data.array[index * this.data.stride + this.offset] = x;
          return this;
        }
        setY(index, y) {
          if (this.normalized)
            y = normalize(y, this.array);
          this.data.array[index * this.data.stride + this.offset + 1] = y;
          return this;
        }
        setZ(index, z) {
          if (this.normalized)
            z = normalize(z, this.array);
          this.data.array[index * this.data.stride + this.offset + 2] = z;
          return this;
        }
        setW(index, w) {
          if (this.normalized)
            w = normalize(w, this.array);
          this.data.array[index * this.data.stride + this.offset + 3] = w;
          return this;
        }
        getX(index) {
          let x = this.data.array[index * this.data.stride + this.offset];
          if (this.normalized)
            x = denormalize(x, this.array);
          return x;
        }
        getY(index) {
          let y = this.data.array[index * this.data.stride + this.offset + 1];
          if (this.normalized)
            y = denormalize(y, this.array);
          return y;
        }
        getZ(index) {
          let z = this.data.array[index * this.data.stride + this.offset + 2];
          if (this.normalized)
            z = denormalize(z, this.array);
          return z;
        }
        getW(index) {
          let w = this.data.array[index * this.data.stride + this.offset + 3];
          if (this.normalized)
            w = denormalize(w, this.array);
          return w;
        }
        setXY(index, x, y) {
          index = index * this.data.stride + this.offset;
          if (this.normalized) {
            x = normalize(x, this.array);
            y = normalize(y, this.array);
          }
          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;
          return this;
        }
        setXYZ(index, x, y, z) {
          index = index * this.data.stride + this.offset;
          if (this.normalized) {
            x = normalize(x, this.array);
            y = normalize(y, this.array);
            z = normalize(z, this.array);
          }
          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;
          this.data.array[index + 2] = z;
          return this;
        }
        setXYZW(index, x, y, z, w) {
          index = index * this.data.stride + this.offset;
          if (this.normalized) {
            x = normalize(x, this.array);
            y = normalize(y, this.array);
            z = normalize(z, this.array);
            w = normalize(w, this.array);
          }
          this.data.array[index + 0] = x;
          this.data.array[index + 1] = y;
          this.data.array[index + 2] = z;
          this.data.array[index + 3] = w;
          return this;
        }
        clone(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const array = [];
            for (let i = 0; i < this.count; i++) {
              const index = i * this.data.stride + this.offset;
              for (let j = 0; j < this.itemSize; j++) {
                array.push(this.data.array[index + j]);
              }
            }
            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            }
            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
          }
        }
        toJSON(data) {
          if (data === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const array = [];
            for (let i = 0; i < this.count; i++) {
              const index = i * this.data.stride + this.offset;
              for (let j = 0; j < this.itemSize; j++) {
                array.push(this.data.array[index + j]);
              }
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array,
              normalized: this.normalized
            };
          } else {
            if (data.interleavedBuffers === void 0) {
              data.interleavedBuffers = {};
            }
            if (data.interleavedBuffers[this.data.uuid] === void 0) {
              data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            }
            return {
              isInterleavedBufferAttribute: true,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized
            };
          }
        }
      };
      SpriteMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isSpriteMaterial = true;
          this.type = "SpriteMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.alphaMap = null;
          this.rotation = 0;
          this.sizeAttenuation = true;
          this.transparent = true;
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.rotation = source.rotation;
          this.sizeAttenuation = source.sizeAttenuation;
          this.fog = source.fog;
          return this;
        }
      };
      _intersectPoint = /* @__PURE__ */ new Vector3();
      _worldScale = /* @__PURE__ */ new Vector3();
      _mvPosition = /* @__PURE__ */ new Vector3();
      _alignedPosition = /* @__PURE__ */ new Vector2();
      _rotatedPosition = /* @__PURE__ */ new Vector2();
      _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
      _vA = /* @__PURE__ */ new Vector3();
      _vB = /* @__PURE__ */ new Vector3();
      _vC = /* @__PURE__ */ new Vector3();
      _uvA = /* @__PURE__ */ new Vector2();
      _uvB = /* @__PURE__ */ new Vector2();
      _uvC = /* @__PURE__ */ new Vector2();
      Sprite = class extends Object3D {
        constructor(material) {
          super();
          this.isSprite = true;
          this.type = "Sprite";
          if (_geometry === void 0) {
            _geometry = new BufferGeometry();
            const float32Array = new Float32Array([
              -0.5,
              -0.5,
              0,
              0,
              0,
              0.5,
              -0.5,
              0,
              1,
              0,
              0.5,
              0.5,
              0,
              1,
              1,
              -0.5,
              0.5,
              0,
              0,
              1
            ]);
            const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
            _geometry.setIndex([0, 1, 2, 0, 2, 3]);
            _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
            _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
          }
          this.geometry = _geometry;
          this.material = material !== void 0 ? material : new SpriteMaterial();
          this.center = new Vector2(0.5, 0.5);
        }
        raycast(raycaster, intersects2) {
          if (raycaster.camera === null) {
            console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
          }
          _worldScale.setFromMatrixScale(this.matrixWorld);
          _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
          this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
          _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
          if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
            _worldScale.multiplyScalar(-_mvPosition.z);
          }
          const rotation = this.material.rotation;
          let sin, cos;
          if (rotation !== 0) {
            cos = Math.cos(rotation);
            sin = Math.sin(rotation);
          }
          const center = this.center;
          transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          _uvA.set(0, 0);
          _uvB.set(1, 0);
          _uvC.set(1, 1);
          let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
          if (intersect === null) {
            transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            _uvB.set(0, 1);
            intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
            if (intersect === null) {
              return;
            }
          }
          const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
          if (distance < raycaster.near || distance > raycaster.far)
            return;
          intersects2.push({
            distance,
            point: _intersectPoint.clone(),
            uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
            face: null,
            object: this
          });
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          if (source.center !== void 0)
            this.center.copy(source.center);
          this.material = source.material;
          return this;
        }
      };
      _v1$2 = /* @__PURE__ */ new Vector3();
      _v2$1 = /* @__PURE__ */ new Vector3();
      LOD = class extends Object3D {
        constructor() {
          super();
          this._currentLevel = 0;
          this.type = "LOD";
          Object.defineProperties(this, {
            levels: {
              enumerable: true,
              value: []
            },
            isLOD: {
              value: true
            }
          });
          this.autoUpdate = true;
        }
        copy(source) {
          super.copy(source, false);
          const levels = source.levels;
          for (let i = 0, l = levels.length; i < l; i++) {
            const level = levels[i];
            this.addLevel(level.object.clone(), level.distance, level.hysteresis);
          }
          this.autoUpdate = source.autoUpdate;
          return this;
        }
        addLevel(object, distance = 0, hysteresis = 0) {
          distance = Math.abs(distance);
          const levels = this.levels;
          let l;
          for (l = 0; l < levels.length; l++) {
            if (distance < levels[l].distance) {
              break;
            }
          }
          levels.splice(l, 0, { distance, hysteresis, object });
          this.add(object);
          return this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(distance) {
          const levels = this.levels;
          if (levels.length > 0) {
            let i, l;
            for (i = 1, l = levels.length; i < l; i++) {
              let levelDistance = levels[i].distance;
              if (levels[i].object.visible) {
                levelDistance -= levelDistance * levels[i].hysteresis;
              }
              if (distance < levelDistance) {
                break;
              }
            }
            return levels[i - 1].object;
          }
          return null;
        }
        raycast(raycaster, intersects2) {
          const levels = this.levels;
          if (levels.length > 0) {
            _v1$2.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(_v1$2);
            this.getObjectForDistance(distance).raycast(raycaster, intersects2);
          }
        }
        update(camera) {
          const levels = this.levels;
          if (levels.length > 1) {
            _v1$2.setFromMatrixPosition(camera.matrixWorld);
            _v2$1.setFromMatrixPosition(this.matrixWorld);
            const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
            levels[0].object.visible = true;
            let i, l;
            for (i = 1, l = levels.length; i < l; i++) {
              let levelDistance = levels[i].distance;
              if (levels[i].object.visible) {
                levelDistance -= levelDistance * levels[i].hysteresis;
              }
              if (distance >= levelDistance) {
                levels[i - 1].object.visible = false;
                levels[i].object.visible = true;
              } else {
                break;
              }
            }
            this._currentLevel = i - 1;
            for (; i < l; i++) {
              levels[i].object.visible = false;
            }
          }
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          if (this.autoUpdate === false)
            data.object.autoUpdate = false;
          data.object.levels = [];
          const levels = this.levels;
          for (let i = 0, l = levels.length; i < l; i++) {
            const level = levels[i];
            data.object.levels.push({
              object: level.object.uuid,
              distance: level.distance,
              hysteresis: level.hysteresis
            });
          }
          return data;
        }
      };
      _basePosition = /* @__PURE__ */ new Vector3();
      _skinIndex = /* @__PURE__ */ new Vector4();
      _skinWeight = /* @__PURE__ */ new Vector4();
      _vector$5 = /* @__PURE__ */ new Vector3();
      _matrix = /* @__PURE__ */ new Matrix4();
      SkinnedMesh = class extends Mesh {
        constructor(geometry, material) {
          super(geometry, material);
          this.isSkinnedMesh = true;
          this.type = "SkinnedMesh";
          this.bindMode = "attached";
          this.bindMatrix = new Matrix4();
          this.bindMatrixInverse = new Matrix4();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.bindMode = source.bindMode;
          this.bindMatrix.copy(source.bindMatrix);
          this.bindMatrixInverse.copy(source.bindMatrixInverse);
          this.skeleton = source.skeleton;
          return this;
        }
        bind(skeleton, bindMatrix) {
          this.skeleton = skeleton;
          if (bindMatrix === void 0) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
          }
          this.bindMatrix.copy(bindMatrix);
          this.bindMatrixInverse.copy(bindMatrix).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const vector = new Vector4();
          const skinWeight = this.geometry.attributes.skinWeight;
          for (let i = 0, l = skinWeight.count; i < l; i++) {
            vector.fromBufferAttribute(skinWeight, i);
            const scale = 1 / vector.manhattanLength();
            if (scale !== Infinity) {
              vector.multiplyScalar(scale);
            } else {
              vector.set(1, 0, 0, 0);
            }
            skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
          }
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.bindMode === "attached") {
            this.bindMatrixInverse.copy(this.matrixWorld).invert();
          } else if (this.bindMode === "detached") {
            this.bindMatrixInverse.copy(this.bindMatrix).invert();
          } else {
            console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
          }
        }
        boneTransform(index, target) {
          const skeleton = this.skeleton;
          const geometry = this.geometry;
          _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
          _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
          _basePosition.copy(target).applyMatrix4(this.bindMatrix);
          target.set(0, 0, 0);
          for (let i = 0; i < 4; i++) {
            const weight = _skinWeight.getComponent(i);
            if (weight !== 0) {
              const boneIndex = _skinIndex.getComponent(i);
              _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
              target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
            }
          }
          return target.applyMatrix4(this.bindMatrixInverse);
        }
      };
      Bone = class extends Object3D {
        constructor() {
          super();
          this.isBone = true;
          this.type = "Bone";
        }
      };
      DataTexture = class extends Texture {
        constructor(data = null, width2 = 1, height2 = 1, format, type3, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type3, anisotropy, encoding);
          this.isDataTexture = true;
          this.image = { data, width: width2, height: height2 };
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      };
      _offsetMatrix = /* @__PURE__ */ new Matrix4();
      _identityMatrix = /* @__PURE__ */ new Matrix4();
      Skeleton = class {
        constructor(bones = [], boneInverses = []) {
          this.uuid = generateUUID();
          this.bones = bones.slice(0);
          this.boneInverses = boneInverses;
          this.boneMatrices = null;
          this.boneTexture = null;
          this.boneTextureSize = 0;
          this.frame = -1;
          this.init();
        }
        init() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          this.boneMatrices = new Float32Array(bones.length * 16);
          if (boneInverses.length === 0) {
            this.calculateInverses();
          } else {
            if (bones.length !== boneInverses.length) {
              console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
              this.boneInverses = [];
              for (let i = 0, il = this.bones.length; i < il; i++) {
                this.boneInverses.push(new Matrix4());
              }
            }
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let i = 0, il = this.bones.length; i < il; i++) {
            const inverse = new Matrix4();
            if (this.bones[i]) {
              inverse.copy(this.bones[i].matrixWorld).invert();
            }
            this.boneInverses.push(inverse);
          }
        }
        pose() {
          for (let i = 0, il = this.bones.length; i < il; i++) {
            const bone = this.bones[i];
            if (bone) {
              bone.matrixWorld.copy(this.boneInverses[i]).invert();
            }
          }
          for (let i = 0, il = this.bones.length; i < il; i++) {
            const bone = this.bones[i];
            if (bone) {
              if (bone.parent && bone.parent.isBone) {
                bone.matrix.copy(bone.parent.matrixWorld).invert();
                bone.matrix.multiply(bone.matrixWorld);
              } else {
                bone.matrix.copy(bone.matrixWorld);
              }
              bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
          }
        }
        update() {
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          const boneMatrices = this.boneMatrices;
          const boneTexture = this.boneTexture;
          for (let i = 0, il = bones.length; i < il; i++) {
            const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
            _offsetMatrix.toArray(boneMatrices, i * 16);
          }
          if (boneTexture !== null) {
            boneTexture.needsUpdate = true;
          }
        }
        clone() {
          return new Skeleton(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let size = Math.sqrt(this.bones.length * 4);
          size = ceilPowerOfTwo(size);
          size = Math.max(size, 4);
          const boneMatrices = new Float32Array(size * size * 4);
          boneMatrices.set(this.boneMatrices);
          const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
          boneTexture.needsUpdate = true;
          this.boneMatrices = boneMatrices;
          this.boneTexture = boneTexture;
          this.boneTextureSize = size;
          return this;
        }
        getBoneByName(name) {
          for (let i = 0, il = this.bones.length; i < il; i++) {
            const bone = this.bones[i];
            if (bone.name === name) {
              return bone;
            }
          }
          return void 0;
        }
        dispose() {
          if (this.boneTexture !== null) {
            this.boneTexture.dispose();
            this.boneTexture = null;
          }
        }
        fromJSON(json, bones) {
          this.uuid = json.uuid;
          for (let i = 0, l = json.bones.length; i < l; i++) {
            const uuid = json.bones[i];
            let bone = bones[uuid];
            if (bone === void 0) {
              console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
              bone = new Bone();
            }
            this.bones.push(bone);
            this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
          }
          this.init();
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Skeleton",
              generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
          };
          data.uuid = this.uuid;
          const bones = this.bones;
          const boneInverses = this.boneInverses;
          for (let i = 0, l = bones.length; i < l; i++) {
            const bone = bones[i];
            data.bones.push(bone.uuid);
            const boneInverse = boneInverses[i];
            data.boneInverses.push(boneInverse.toArray());
          }
          return data;
        }
      };
      InstancedBufferAttribute = class extends BufferAttribute {
        constructor(array, itemSize, normalized, meshPerAttribute = 1) {
          super(array, itemSize, normalized);
          this.isInstancedBufferAttribute = true;
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.meshPerAttribute = this.meshPerAttribute;
          data.isInstancedBufferAttribute = true;
          return data;
        }
      };
      _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
      _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
      _instanceIntersects = [];
      _identity2 = /* @__PURE__ */ new Matrix4();
      _mesh = /* @__PURE__ */ new Mesh();
      InstancedMesh = class extends Mesh {
        constructor(geometry, material, count) {
          super(geometry, material);
          this.isInstancedMesh = true;
          this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
          this.instanceColor = null;
          this.count = count;
          this.frustumCulled = false;
          for (let i = 0; i < count; i++) {
            this.setMatrixAt(i, _identity2);
          }
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.instanceMatrix.copy(source.instanceMatrix);
          if (source.instanceColor !== null)
            this.instanceColor = source.instanceColor.clone();
          this.count = source.count;
          return this;
        }
        getColorAt(index, color) {
          color.fromArray(this.instanceColor.array, index * 3);
        }
        getMatrixAt(index, matrix) {
          matrix.fromArray(this.instanceMatrix.array, index * 16);
        }
        raycast(raycaster, intersects2) {
          const matrixWorld = this.matrixWorld;
          const raycastTimes = this.count;
          _mesh.geometry = this.geometry;
          _mesh.material = this.material;
          if (_mesh.material === void 0)
            return;
          for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
              const intersect = _instanceIntersects[i];
              intersect.instanceId = instanceId;
              intersect.object = this;
              intersects2.push(intersect);
            }
            _instanceIntersects.length = 0;
          }
        }
        setColorAt(index, color) {
          if (this.instanceColor === null) {
            this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
          }
          color.toArray(this.instanceColor.array, index * 3);
        }
        setMatrixAt(index, matrix) {
          matrix.toArray(this.instanceMatrix.array, index * 16);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      };
      LineBasicMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isLineBasicMaterial = true;
          this.type = "LineBasicMaterial";
          this.color = new Color(16777215);
          this.linewidth = 1;
          this.linecap = "round";
          this.linejoin = "round";
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.linewidth = source.linewidth;
          this.linecap = source.linecap;
          this.linejoin = source.linejoin;
          this.fog = source.fog;
          return this;
        }
      };
      _start$1 = /* @__PURE__ */ new Vector3();
      _end$1 = /* @__PURE__ */ new Vector3();
      _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
      _ray$1 = /* @__PURE__ */ new Ray();
      _sphere$1 = /* @__PURE__ */ new Sphere();
      Line = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
          super();
          this.isLine = true;
          this.type = "Line";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [0];
            for (let i = 1, l = positionAttribute.count; i < l; i++) {
              _start$1.fromBufferAttribute(positionAttribute, i - 1);
              _end$1.fromBufferAttribute(positionAttribute, i);
              lineDistances[i] = lineDistances[i - 1];
              lineDistances[i] += _start$1.distanceTo(_end$1);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
          return this;
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Line.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere$1.copy(geometry.boundingSphere);
          _sphere$1.applyMatrix4(matrixWorld);
          _sphere$1.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere$1) === false)
            return;
          _inverseMatrix$1.copy(matrixWorld).invert();
          _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          const vStart = new Vector3();
          const vEnd = new Vector3();
          const interSegment = new Vector3();
          const interRay = new Vector3();
          const step = this.isLineSegments ? 2 : 1;
          const index = geometry.index;
          const attributes = geometry.attributes;
          const positionAttribute = attributes.position;
          if (index !== null) {
            const start2 = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for (let i = start2, l = end - 1; i < l; i += step) {
              const a = index.getX(i);
              const b = index.getX(i + 1);
              vStart.fromBufferAttribute(positionAttribute, a);
              vEnd.fromBufferAttribute(positionAttribute, b);
              const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              const distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          } else {
            const start2 = Math.max(0, drawRange.start);
            const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for (let i = start2, l = end - 1; i < l; i += step) {
              vStart.fromBufferAttribute(positionAttribute, i);
              vEnd.fromBufferAttribute(positionAttribute, i + 1);
              const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              const distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          const morphAttributes = geometry.morphAttributes;
          const keys4 = Object.keys(morphAttributes);
          if (keys4.length > 0) {
            const morphAttribute = morphAttributes[keys4[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                const name = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m;
              }
            }
          }
        }
      };
      _start = /* @__PURE__ */ new Vector3();
      _end = /* @__PURE__ */ new Vector3();
      LineSegments = class extends Line {
        constructor(geometry, material) {
          super(geometry, material);
          this.isLineSegments = true;
          this.type = "LineSegments";
        }
        computeLineDistances() {
          const geometry = this.geometry;
          if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [];
            for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
              _start.fromBufferAttribute(positionAttribute, i);
              _end.fromBufferAttribute(positionAttribute, i + 1);
              lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
              lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
          return this;
        }
      };
      LineLoop = class extends Line {
        constructor(geometry, material) {
          super(geometry, material);
          this.isLineLoop = true;
          this.type = "LineLoop";
        }
      };
      PointsMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isPointsMaterial = true;
          this.type = "PointsMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.alphaMap = null;
          this.size = 1;
          this.sizeAttenuation = true;
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.alphaMap = source.alphaMap;
          this.size = source.size;
          this.sizeAttenuation = source.sizeAttenuation;
          this.fog = source.fog;
          return this;
        }
      };
      _inverseMatrix = /* @__PURE__ */ new Matrix4();
      _ray = /* @__PURE__ */ new Ray();
      _sphere = /* @__PURE__ */ new Sphere();
      _position$2 = /* @__PURE__ */ new Vector3();
      Points = class extends Object3D {
        constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
          super();
          this.isPoints = true;
          this.type = "Points";
          this.geometry = geometry;
          this.material = material;
          this.updateMorphTargets();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.material = source.material;
          this.geometry = source.geometry;
          return this;
        }
        raycast(raycaster, intersects2) {
          const geometry = this.geometry;
          const matrixWorld = this.matrixWorld;
          const threshold = raycaster.params.Points.threshold;
          const drawRange = geometry.drawRange;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          _sphere.copy(geometry.boundingSphere);
          _sphere.applyMatrix4(matrixWorld);
          _sphere.radius += threshold;
          if (raycaster.ray.intersectsSphere(_sphere) === false)
            return;
          _inverseMatrix.copy(matrixWorld).invert();
          _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
          const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
          const localThresholdSq = localThreshold * localThreshold;
          const index = geometry.index;
          const attributes = geometry.attributes;
          const positionAttribute = attributes.position;
          if (index !== null) {
            const start2 = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for (let i = start2, il = end; i < il; i++) {
              const a = index.getX(i);
              _position$2.fromBufferAttribute(positionAttribute, a);
              testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
            }
          } else {
            const start2 = Math.max(0, drawRange.start);
            const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for (let i = start2, l = end; i < l; i++) {
              _position$2.fromBufferAttribute(positionAttribute, i);
              testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
            }
          }
        }
        updateMorphTargets() {
          const geometry = this.geometry;
          const morphAttributes = geometry.morphAttributes;
          const keys4 = Object.keys(morphAttributes);
          if (keys4.length > 0) {
            const morphAttribute = morphAttributes[keys4[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                const name = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m;
              }
            }
          }
        }
      };
      VideoTexture = class extends Texture {
        constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type3, anisotropy) {
          super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type3, anisotropy);
          this.isVideoTexture = true;
          this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
          this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
          this.generateMipmaps = false;
          const scope = this;
          function updateVideo() {
            scope.needsUpdate = true;
            video.requestVideoFrameCallback(updateVideo);
          }
          if ("requestVideoFrameCallback" in video) {
            video.requestVideoFrameCallback(updateVideo);
          }
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const video = this.image;
          const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
          if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
            this.needsUpdate = true;
          }
        }
      };
      FramebufferTexture = class extends Texture {
        constructor(width2, height2, format) {
          super({ width: width2, height: height2 });
          this.isFramebufferTexture = true;
          this.format = format;
          this.magFilter = NearestFilter;
          this.minFilter = NearestFilter;
          this.generateMipmaps = false;
          this.needsUpdate = true;
        }
      };
      CompressedTexture = class extends Texture {
        constructor(mipmaps, width2, height2, format, type3, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
          super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type3, anisotropy, encoding);
          this.isCompressedTexture = true;
          this.image = { width: width2, height: height2 };
          this.mipmaps = mipmaps;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      };
      CompressedArrayTexture = class extends CompressedTexture {
        constructor(mipmaps, width2, height2, depth, format, type3) {
          super(mipmaps, width2, height2, format, type3);
          this.isCompressedArrayTexture = true;
          this.image.depth = depth;
          this.wrapR = ClampToEdgeWrapping;
        }
      };
      CanvasTexture = class extends Texture {
        constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type3, anisotropy) {
          super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type3, anisotropy);
          this.isCanvasTexture = true;
          this.needsUpdate = true;
        }
      };
      Curve = class {
        constructor() {
          this.type = "Curve";
          this.arcLengthDivisions = 200;
        }
        getPoint() {
          console.warn("THREE.Curve: .getPoint() not implemented.");
          return null;
        }
        getPointAt(u, optionalTarget) {
          const t = this.getUtoTmapping(u);
          return this.getPoint(t, optionalTarget);
        }
        getPoints(divisions = 5) {
          const points = [];
          for (let d = 0; d <= divisions; d++) {
            points.push(this.getPoint(d / divisions));
          }
          return points;
        }
        getSpacedPoints(divisions = 5) {
          const points = [];
          for (let d = 0; d <= divisions; d++) {
            points.push(this.getPointAt(d / divisions));
          }
          return points;
        }
        getLength() {
          const lengths = this.getLengths();
          return lengths[lengths.length - 1];
        }
        getLengths(divisions = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
            return this.cacheArcLengths;
          }
          this.needsUpdate = false;
          const cache = [];
          let current, last = this.getPoint(0);
          let sum2 = 0;
          cache.push(0);
          for (let p = 1; p <= divisions; p++) {
            current = this.getPoint(p / divisions);
            sum2 += current.distanceTo(last);
            cache.push(sum2);
            last = current;
          }
          this.cacheArcLengths = cache;
          return cache;
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.getLengths();
        }
        getUtoTmapping(u, distance) {
          const arcLengths = this.getLengths();
          let i = 0;
          const il = arcLengths.length;
          let targetArcLength;
          if (distance) {
            targetArcLength = distance;
          } else {
            targetArcLength = u * arcLengths[il - 1];
          }
          let low = 0, high = il - 1, comparison;
          while (low <= high) {
            i = Math.floor(low + (high - low) / 2);
            comparison = arcLengths[i] - targetArcLength;
            if (comparison < 0) {
              low = i + 1;
            } else if (comparison > 0) {
              high = i - 1;
            } else {
              high = i;
              break;
            }
          }
          i = high;
          if (arcLengths[i] === targetArcLength) {
            return i / (il - 1);
          }
          const lengthBefore = arcLengths[i];
          const lengthAfter = arcLengths[i + 1];
          const segmentLength = lengthAfter - lengthBefore;
          const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
          const t = (i + segmentFraction) / (il - 1);
          return t;
        }
        getTangent(t, optionalTarget) {
          const delta = 1e-4;
          let t1 = t - delta;
          let t2 = t + delta;
          if (t1 < 0)
            t1 = 0;
          if (t2 > 1)
            t2 = 1;
          const pt1 = this.getPoint(t1);
          const pt2 = this.getPoint(t2);
          const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
          tangent.copy(pt2).sub(pt1).normalize();
          return tangent;
        }
        getTangentAt(u, optionalTarget) {
          const t = this.getUtoTmapping(u);
          return this.getTangent(t, optionalTarget);
        }
        computeFrenetFrames(segments, closed) {
          const normal = new Vector3();
          const tangents = [];
          const normals = [];
          const binormals = [];
          const vec = new Vector3();
          const mat = new Matrix4();
          for (let i = 0; i <= segments; i++) {
            const u = i / segments;
            tangents[i] = this.getTangentAt(u, new Vector3());
          }
          normals[0] = new Vector3();
          binormals[0] = new Vector3();
          let min = Number.MAX_VALUE;
          const tx = Math.abs(tangents[0].x);
          const ty = Math.abs(tangents[0].y);
          const tz = Math.abs(tangents[0].z);
          if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
          }
          if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
          }
          if (tz <= min) {
            normal.set(0, 0, 1);
          }
          vec.crossVectors(tangents[0], normal).normalize();
          normals[0].crossVectors(tangents[0], vec);
          binormals[0].crossVectors(tangents[0], normals[0]);
          for (let i = 1; i <= segments; i++) {
            normals[i] = normals[i - 1].clone();
            binormals[i] = binormals[i - 1].clone();
            vec.crossVectors(tangents[i - 1], tangents[i]);
            if (vec.length() > Number.EPSILON) {
              vec.normalize();
              const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
              normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i].crossVectors(tangents[i], normals[i]);
          }
          if (closed === true) {
            let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
              theta = -theta;
            }
            for (let i = 1; i <= segments; i++) {
              normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
              binormals[i].crossVectors(tangents[i], normals[i]);
            }
          }
          return {
            tangents,
            normals,
            binormals
          };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(source) {
          this.arcLengthDivisions = source.arcLengthDivisions;
          return this;
        }
        toJSON() {
          const data = {
            metadata: {
              version: 4.5,
              type: "Curve",
              generator: "Curve.toJSON"
            }
          };
          data.arcLengthDivisions = this.arcLengthDivisions;
          data.type = this.type;
          return data;
        }
        fromJSON(json) {
          this.arcLengthDivisions = json.arcLengthDivisions;
          return this;
        }
      };
      EllipseCurve = class extends Curve {
        constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
          super();
          this.isEllipseCurve = true;
          this.type = "EllipseCurve";
          this.aX = aX;
          this.aY = aY;
          this.xRadius = xRadius;
          this.yRadius = yRadius;
          this.aStartAngle = aStartAngle;
          this.aEndAngle = aEndAngle;
          this.aClockwise = aClockwise;
          this.aRotation = aRotation;
        }
        getPoint(t, optionalTarget) {
          const point = optionalTarget || new Vector2();
          const twoPi = Math.PI * 2;
          let deltaAngle = this.aEndAngle - this.aStartAngle;
          const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
          while (deltaAngle < 0)
            deltaAngle += twoPi;
          while (deltaAngle > twoPi)
            deltaAngle -= twoPi;
          if (deltaAngle < Number.EPSILON) {
            if (samePoints) {
              deltaAngle = 0;
            } else {
              deltaAngle = twoPi;
            }
          }
          if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) {
              deltaAngle = -twoPi;
            } else {
              deltaAngle = deltaAngle - twoPi;
            }
          }
          const angle = this.aStartAngle + t * deltaAngle;
          let x = this.aX + this.xRadius * Math.cos(angle);
          let y = this.aY + this.yRadius * Math.sin(angle);
          if (this.aRotation !== 0) {
            const cos = Math.cos(this.aRotation);
            const sin = Math.sin(this.aRotation);
            const tx = x - this.aX;
            const ty = y - this.aY;
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
          }
          return point.set(x, y);
        }
        copy(source) {
          super.copy(source);
          this.aX = source.aX;
          this.aY = source.aY;
          this.xRadius = source.xRadius;
          this.yRadius = source.yRadius;
          this.aStartAngle = source.aStartAngle;
          this.aEndAngle = source.aEndAngle;
          this.aClockwise = source.aClockwise;
          this.aRotation = source.aRotation;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.aX = this.aX;
          data.aY = this.aY;
          data.xRadius = this.xRadius;
          data.yRadius = this.yRadius;
          data.aStartAngle = this.aStartAngle;
          data.aEndAngle = this.aEndAngle;
          data.aClockwise = this.aClockwise;
          data.aRotation = this.aRotation;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.aX = json.aX;
          this.aY = json.aY;
          this.xRadius = json.xRadius;
          this.yRadius = json.yRadius;
          this.aStartAngle = json.aStartAngle;
          this.aEndAngle = json.aEndAngle;
          this.aClockwise = json.aClockwise;
          this.aRotation = json.aRotation;
          return this;
        }
      };
      ArcCurve = class extends EllipseCurve {
        constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          this.isArcCurve = true;
          this.type = "ArcCurve";
        }
      };
      tmp = /* @__PURE__ */ new Vector3();
      px = /* @__PURE__ */ new CubicPoly();
      py = /* @__PURE__ */ new CubicPoly();
      pz = /* @__PURE__ */ new CubicPoly();
      CatmullRomCurve3 = class extends Curve {
        constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
          super();
          this.isCatmullRomCurve3 = true;
          this.type = "CatmullRomCurve3";
          this.points = points;
          this.closed = closed;
          this.curveType = curveType;
          this.tension = tension;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const points = this.points;
          const l = points.length;
          const p = (l - (this.closed ? 0 : 1)) * t;
          let intPoint = Math.floor(p);
          let weight = p - intPoint;
          if (this.closed) {
            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
          } else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
          }
          let p0, p3;
          if (this.closed || intPoint > 0) {
            p0 = points[(intPoint - 1) % l];
          } else {
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
          }
          const p1 = points[intPoint % l];
          const p2 = points[(intPoint + 1) % l];
          if (this.closed || intPoint + 2 < l) {
            p3 = points[(intPoint + 2) % l];
          } else {
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
          }
          if (this.curveType === "centripetal" || this.curveType === "chordal") {
            const pow = this.curveType === "chordal" ? 0.5 : 0.25;
            let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            if (dt1 < 1e-4)
              dt1 = 1;
            if (dt0 < 1e-4)
              dt0 = dt1;
            if (dt2 < 1e-4)
              dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
          } else if (this.curveType === "catmullrom") {
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
          }
          point.set(
            px.calc(weight),
            py.calc(weight),
            pz.calc(weight)
          );
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i = 0, l = source.points.length; i < l; i++) {
            const point = source.points[i];
            this.points.push(point.clone());
          }
          this.closed = source.closed;
          this.curveType = source.curveType;
          this.tension = source.tension;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i = 0, l = this.points.length; i < l; i++) {
            const point = this.points[i];
            data.points.push(point.toArray());
          }
          data.closed = this.closed;
          data.curveType = this.curveType;
          data.tension = this.tension;
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i = 0, l = json.points.length; i < l; i++) {
            const point = json.points[i];
            this.points.push(new Vector3().fromArray(point));
          }
          this.closed = json.closed;
          this.curveType = json.curveType;
          this.tension = json.tension;
          return this;
        }
      };
      CubicBezierCurve = class extends Curve {
        constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
          super();
          this.isCubicBezierCurve = true;
          this.type = "CubicBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(
            CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
            CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
          );
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      };
      CubicBezierCurve3 = class extends Curve {
        constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
          super();
          this.isCubicBezierCurve3 = true;
          this.type = "CubicBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
          this.v3 = v3;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
          point.set(
            CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
            CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
            CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
          );
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          this.v3.copy(source.v3);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          data.v3 = this.v3.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          this.v3.fromArray(json.v3);
          return this;
        }
      };
      LineCurve = class extends Curve {
        constructor(v1 = new Vector2(), v2 = new Vector2()) {
          super();
          this.isLineCurve = true;
          this.type = "LineCurve";
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          if (t === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
          }
          return point;
        }
        getPointAt(u, optionalTarget) {
          return this.getPoint(u, optionalTarget);
        }
        getTangent(t, optionalTarget) {
          const tangent = optionalTarget || new Vector2();
          tangent.copy(this.v2).sub(this.v1).normalize();
          return tangent;
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      LineCurve3 = class extends Curve {
        constructor(v1 = new Vector3(), v2 = new Vector3()) {
          super();
          this.isLineCurve3 = true;
          this.type = "LineCurve3";
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          if (t === 1) {
            point.copy(this.v2);
          } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
          }
          return point;
        }
        getPointAt(u, optionalTarget) {
          return this.getPoint(u, optionalTarget);
        }
        copy(source) {
          super.copy(source);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      QuadraticBezierCurve = class extends Curve {
        constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
          super();
          this.isQuadraticBezierCurve = true;
          this.type = "QuadraticBezierCurve";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(
            QuadraticBezier(t, v0.x, v1.x, v2.x),
            QuadraticBezier(t, v0.y, v1.y, v2.y)
          );
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      QuadraticBezierCurve3 = class extends Curve {
        constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
          super();
          this.isQuadraticBezierCurve3 = true;
          this.type = "QuadraticBezierCurve3";
          this.v0 = v0;
          this.v1 = v1;
          this.v2 = v2;
        }
        getPoint(t, optionalTarget = new Vector3()) {
          const point = optionalTarget;
          const v0 = this.v0, v1 = this.v1, v2 = this.v2;
          point.set(
            QuadraticBezier(t, v0.x, v1.x, v2.x),
            QuadraticBezier(t, v0.y, v1.y, v2.y),
            QuadraticBezier(t, v0.z, v1.z, v2.z)
          );
          return point;
        }
        copy(source) {
          super.copy(source);
          this.v0.copy(source.v0);
          this.v1.copy(source.v1);
          this.v2.copy(source.v2);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.v0 = this.v0.toArray();
          data.v1 = this.v1.toArray();
          data.v2 = this.v2.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.v0.fromArray(json.v0);
          this.v1.fromArray(json.v1);
          this.v2.fromArray(json.v2);
          return this;
        }
      };
      SplineCurve = class extends Curve {
        constructor(points = []) {
          super();
          this.isSplineCurve = true;
          this.type = "SplineCurve";
          this.points = points;
        }
        getPoint(t, optionalTarget = new Vector2()) {
          const point = optionalTarget;
          const points = this.points;
          const p = (points.length - 1) * t;
          const intPoint = Math.floor(p);
          const weight = p - intPoint;
          const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
          const p1 = points[intPoint];
          const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
          const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
          point.set(
            CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
            CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
          );
          return point;
        }
        copy(source) {
          super.copy(source);
          this.points = [];
          for (let i = 0, l = source.points.length; i < l; i++) {
            const point = source.points[i];
            this.points.push(point.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.points = [];
          for (let i = 0, l = this.points.length; i < l; i++) {
            const point = this.points[i];
            data.points.push(point.toArray());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.points = [];
          for (let i = 0, l = json.points.length; i < l; i++) {
            const point = json.points[i];
            this.points.push(new Vector2().fromArray(point));
          }
          return this;
        }
      };
      Curves = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ArcCurve,
        CatmullRomCurve3,
        CubicBezierCurve,
        CubicBezierCurve3,
        EllipseCurve,
        LineCurve,
        LineCurve3,
        QuadraticBezierCurve,
        QuadraticBezierCurve3,
        SplineCurve
      });
      CurvePath = class extends Curve {
        constructor() {
          super();
          this.type = "CurvePath";
          this.curves = [];
          this.autoClose = false;
        }
        add(curve) {
          this.curves.push(curve);
        }
        closePath() {
          const startPoint = this.curves[0].getPoint(0);
          const endPoint = this.curves[this.curves.length - 1].getPoint(1);
          if (!startPoint.equals(endPoint)) {
            this.curves.push(new LineCurve(endPoint, startPoint));
          }
        }
        getPoint(t, optionalTarget) {
          const d = t * this.getLength();
          const curveLengths = this.getCurveLengths();
          let i = 0;
          while (i < curveLengths.length) {
            if (curveLengths[i] >= d) {
              const diff = curveLengths[i] - d;
              const curve = this.curves[i];
              const segmentLength = curve.getLength();
              const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
              return curve.getPointAt(u, optionalTarget);
            }
            i++;
          }
          return null;
        }
        getLength() {
          const lens = this.getCurveLengths();
          return lens[lens.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = true;
          this.cacheLengths = null;
          this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
            return this.cacheLengths;
          }
          const lengths = [];
          let sums = 0;
          for (let i = 0, l = this.curves.length; i < l; i++) {
            sums += this.curves[i].getLength();
            lengths.push(sums);
          }
          this.cacheLengths = lengths;
          return lengths;
        }
        getSpacedPoints(divisions = 40) {
          const points = [];
          for (let i = 0; i <= divisions; i++) {
            points.push(this.getPoint(i / divisions));
          }
          if (this.autoClose) {
            points.push(points[0]);
          }
          return points;
        }
        getPoints(divisions = 12) {
          const points = [];
          let last;
          for (let i = 0, curves = this.curves; i < curves.length; i++) {
            const curve = curves[i];
            const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for (let j = 0; j < pts.length; j++) {
              const point = pts[j];
              if (last && last.equals(point))
                continue;
              points.push(point);
              last = point;
            }
          }
          if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
            points.push(points[0]);
          }
          return points;
        }
        copy(source) {
          super.copy(source);
          this.curves = [];
          for (let i = 0, l = source.curves.length; i < l; i++) {
            const curve = source.curves[i];
            this.curves.push(curve.clone());
          }
          this.autoClose = source.autoClose;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.autoClose = this.autoClose;
          data.curves = [];
          for (let i = 0, l = this.curves.length; i < l; i++) {
            const curve = this.curves[i];
            data.curves.push(curve.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.autoClose = json.autoClose;
          this.curves = [];
          for (let i = 0, l = json.curves.length; i < l; i++) {
            const curve = json.curves[i];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
          }
          return this;
        }
      };
      Path = class extends CurvePath {
        constructor(points) {
          super();
          this.type = "Path";
          this.currentPoint = new Vector2();
          if (points) {
            this.setFromPoints(points);
          }
        }
        setFromPoints(points) {
          this.moveTo(points[0].x, points[0].y);
          for (let i = 1, l = points.length; i < l; i++) {
            this.lineTo(points[i].x, points[i].y);
          }
          return this;
        }
        moveTo(x, y) {
          this.currentPoint.set(x, y);
          return this;
        }
        lineTo(x, y) {
          const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
          this.curves.push(curve);
          this.currentPoint.set(x, y);
          return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
          const curve = new QuadraticBezierCurve(
            this.currentPoint.clone(),
            new Vector2(aCPx, aCPy),
            new Vector2(aX, aY)
          );
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          const curve = new CubicBezierCurve(
            this.currentPoint.clone(),
            new Vector2(aCP1x, aCP1y),
            new Vector2(aCP2x, aCP2y),
            new Vector2(aX, aY)
          );
          this.curves.push(curve);
          this.currentPoint.set(aX, aY);
          return this;
        }
        splineThru(pts) {
          const npts = [this.currentPoint.clone()].concat(pts);
          const curve = new SplineCurve(npts);
          this.curves.push(curve);
          this.currentPoint.copy(pts[pts.length - 1]);
          return this;
        }
        arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absarc(
            aX + x0,
            aY + y0,
            aRadius,
            aStartAngle,
            aEndAngle,
            aClockwise
          );
          return this;
        }
        absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
          this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
          return this;
        }
        ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const x0 = this.currentPoint.x;
          const y0 = this.currentPoint.y;
          this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          return this;
        }
        absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
          const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
          if (this.curves.length > 0) {
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) {
              this.lineTo(firstPoint.x, firstPoint.y);
            }
          }
          this.curves.push(curve);
          const lastPoint = curve.getPoint(1);
          this.currentPoint.copy(lastPoint);
          return this;
        }
        copy(source) {
          super.copy(source);
          this.currentPoint.copy(source.currentPoint);
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.currentPoint = this.currentPoint.toArray();
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.currentPoint.fromArray(json.currentPoint);
          return this;
        }
      };
      LatheGeometry = class extends BufferGeometry {
        constructor(points = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
          super();
          this.type = "LatheGeometry";
          this.parameters = {
            points,
            segments,
            phiStart,
            phiLength
          };
          segments = Math.floor(segments);
          phiLength = clamp(phiLength, 0, Math.PI * 2);
          const indices = [];
          const vertices = [];
          const uvs = [];
          const initNormals = [];
          const normals = [];
          const inverseSegments = 1 / segments;
          const vertex2 = new Vector3();
          const uv = new Vector2();
          const normal = new Vector3();
          const curNormal = new Vector3();
          const prevNormal = new Vector3();
          let dx = 0;
          let dy = 0;
          for (let j = 0; j <= points.length - 1; j++) {
            switch (j) {
              case 0:
                dx = points[j + 1].x - points[j].x;
                dy = points[j + 1].y - points[j].y;
                normal.x = dy * 1;
                normal.y = -dx;
                normal.z = dy * 0;
                prevNormal.copy(normal);
                normal.normalize();
                initNormals.push(normal.x, normal.y, normal.z);
                break;
              case points.length - 1:
                initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
                break;
              default:
                dx = points[j + 1].x - points[j].x;
                dy = points[j + 1].y - points[j].y;
                normal.x = dy * 1;
                normal.y = -dx;
                normal.z = dy * 0;
                curNormal.copy(normal);
                normal.x += prevNormal.x;
                normal.y += prevNormal.y;
                normal.z += prevNormal.z;
                normal.normalize();
                initNormals.push(normal.x, normal.y, normal.z);
                prevNormal.copy(curNormal);
            }
          }
          for (let i = 0; i <= segments; i++) {
            const phi = phiStart + i * inverseSegments * phiLength;
            const sin = Math.sin(phi);
            const cos = Math.cos(phi);
            for (let j = 0; j <= points.length - 1; j++) {
              vertex2.x = points[j].x * sin;
              vertex2.y = points[j].y;
              vertex2.z = points[j].x * cos;
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              uv.x = i / segments;
              uv.y = j / (points.length - 1);
              uvs.push(uv.x, uv.y);
              const x = initNormals[3 * j + 0] * sin;
              const y = initNormals[3 * j + 1];
              const z = initNormals[3 * j + 0] * cos;
              normals.push(x, y, z);
            }
          }
          for (let i = 0; i < segments; i++) {
            for (let j = 0; j < points.length - 1; j++) {
              const base = j + i * points.length;
              const a = base;
              const b = base + points.length;
              const c = base + points.length + 1;
              const d = base + 1;
              indices.push(a, b, d);
              indices.push(c, d, b);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        }
        static fromJSON(data) {
          return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
        }
      };
      CapsuleGeometry = class extends LatheGeometry {
        constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
          const path = new Path();
          path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
          path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
          super(path.getPoints(capSegments), radialSegments);
          this.type = "CapsuleGeometry";
          this.parameters = {
            radius,
            height: length,
            capSegments,
            radialSegments
          };
        }
        static fromJSON(data) {
          return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
        }
      };
      CircleGeometry = class extends BufferGeometry {
        constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "CircleGeometry";
          this.parameters = {
            radius,
            segments,
            thetaStart,
            thetaLength
          };
          segments = Math.max(3, segments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const vertex2 = new Vector3();
          const uv = new Vector2();
          vertices.push(0, 0, 0);
          normals.push(0, 0, 1);
          uvs.push(0.5, 0.5);
          for (let s = 0, i = 3; s <= segments; s++, i += 3) {
            const segment = thetaStart + s / segments * thetaLength;
            vertex2.x = radius * Math.cos(segment);
            vertex2.y = radius * Math.sin(segment);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            normals.push(0, 0, 1);
            uv.x = (vertices[i] / radius + 1) / 2;
            uv.y = (vertices[i + 1] / radius + 1) / 2;
            uvs.push(uv.x, uv.y);
          }
          for (let i = 1; i <= segments; i++) {
            indices.push(i, i + 1, 0);
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
        }
      };
      CylinderGeometry = class extends BufferGeometry {
        constructor(radiusTop = 1, radiusBottom = 1, height2 = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "CylinderGeometry";
          this.parameters = {
            radiusTop,
            radiusBottom,
            height: height2,
            radialSegments,
            heightSegments,
            openEnded,
            thetaStart,
            thetaLength
          };
          const scope = this;
          radialSegments = Math.floor(radialSegments);
          heightSegments = Math.floor(heightSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let index = 0;
          const indexArray = [];
          const halfHeight = height2 / 2;
          let groupStart = 0;
          generateTorso();
          if (openEnded === false) {
            if (radiusTop > 0)
              generateCap(true);
            if (radiusBottom > 0)
              generateCap(false);
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function generateTorso() {
            const normal = new Vector3();
            const vertex2 = new Vector3();
            let groupCount = 0;
            const slope = (radiusBottom - radiusTop) / height2;
            for (let y = 0; y <= heightSegments; y++) {
              const indexRow = [];
              const v = y / heightSegments;
              const radius = v * (radiusBottom - radiusTop) + radiusTop;
              for (let x = 0; x <= radialSegments; x++) {
                const u = x / radialSegments;
                const theta = u * thetaLength + thetaStart;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                vertex2.x = radius * sinTheta;
                vertex2.y = -v * height2 + halfHeight;
                vertex2.z = radius * cosTheta;
                vertices.push(vertex2.x, vertex2.y, vertex2.z);
                normal.set(sinTheta, slope, cosTheta).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(u, 1 - v);
                indexRow.push(index++);
              }
              indexArray.push(indexRow);
            }
            for (let x = 0; x < radialSegments; x++) {
              for (let y = 0; y < heightSegments; y++) {
                const a = indexArray[y][x];
                const b = indexArray[y + 1][x];
                const c = indexArray[y + 1][x + 1];
                const d = indexArray[y][x + 1];
                indices.push(a, b, d);
                indices.push(b, c, d);
                groupCount += 6;
              }
            }
            scope.addGroup(groupStart, groupCount, 0);
            groupStart += groupCount;
          }
          function generateCap(top) {
            const centerIndexStart = index;
            const uv = new Vector2();
            const vertex2 = new Vector3();
            let groupCount = 0;
            const radius = top === true ? radiusTop : radiusBottom;
            const sign2 = top === true ? 1 : -1;
            for (let x = 1; x <= radialSegments; x++) {
              vertices.push(0, halfHeight * sign2, 0);
              normals.push(0, sign2, 0);
              uvs.push(0.5, 0.5);
              index++;
            }
            const centerIndexEnd = index;
            for (let x = 0; x <= radialSegments; x++) {
              const u = x / radialSegments;
              const theta = u * thetaLength + thetaStart;
              const cosTheta = Math.cos(theta);
              const sinTheta = Math.sin(theta);
              vertex2.x = radius * sinTheta;
              vertex2.y = halfHeight * sign2;
              vertex2.z = radius * cosTheta;
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normals.push(0, sign2, 0);
              uv.x = cosTheta * 0.5 + 0.5;
              uv.y = sinTheta * 0.5 * sign2 + 0.5;
              uvs.push(uv.x, uv.y);
              index++;
            }
            for (let x = 0; x < radialSegments; x++) {
              const c = centerIndexStart + x;
              const i = centerIndexEnd + x;
              if (top === true) {
                indices.push(i, i + 1, c);
              } else {
                indices.push(i + 1, i, c);
              }
              groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            groupStart += groupCount;
          }
        }
        static fromJSON(data) {
          return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
      };
      ConeGeometry = class extends CylinderGeometry {
        constructor(radius = 1, height2 = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
          super(0, radius, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
          this.type = "ConeGeometry";
          this.parameters = {
            radius,
            height: height2,
            radialSegments,
            heightSegments,
            openEnded,
            thetaStart,
            thetaLength
          };
        }
        static fromJSON(data) {
          return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
        }
      };
      PolyhedronGeometry = class extends BufferGeometry {
        constructor(vertices = [], indices = [], radius = 1, detail = 0) {
          super();
          this.type = "PolyhedronGeometry";
          this.parameters = {
            vertices,
            indices,
            radius,
            detail
          };
          const vertexBuffer = [];
          const uvBuffer = [];
          subdivide(detail);
          applyRadius(radius);
          generateUVs();
          this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
          this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
          if (detail === 0) {
            this.computeVertexNormals();
          } else {
            this.normalizeNormals();
          }
          function subdivide(detail2) {
            const a = new Vector3();
            const b = new Vector3();
            const c = new Vector3();
            for (let i = 0; i < indices.length; i += 3) {
              getVertexByIndex(indices[i + 0], a);
              getVertexByIndex(indices[i + 1], b);
              getVertexByIndex(indices[i + 2], c);
              subdivideFace(a, b, c, detail2);
            }
          }
          function subdivideFace(a, b, c, detail2) {
            const cols = detail2 + 1;
            const v = [];
            for (let i = 0; i <= cols; i++) {
              v[i] = [];
              const aj = a.clone().lerp(c, i / cols);
              const bj = b.clone().lerp(c, i / cols);
              const rows = cols - i;
              for (let j = 0; j <= rows; j++) {
                if (j === 0 && i === cols) {
                  v[i][j] = aj;
                } else {
                  v[i][j] = aj.clone().lerp(bj, j / rows);
                }
              }
            }
            for (let i = 0; i < cols; i++) {
              for (let j = 0; j < 2 * (cols - i) - 1; j++) {
                const k = Math.floor(j / 2);
                if (j % 2 === 0) {
                  pushVertex(v[i][k + 1]);
                  pushVertex(v[i + 1][k]);
                  pushVertex(v[i][k]);
                } else {
                  pushVertex(v[i][k + 1]);
                  pushVertex(v[i + 1][k + 1]);
                  pushVertex(v[i + 1][k]);
                }
              }
            }
          }
          function applyRadius(radius2) {
            const vertex2 = new Vector3();
            for (let i = 0; i < vertexBuffer.length; i += 3) {
              vertex2.x = vertexBuffer[i + 0];
              vertex2.y = vertexBuffer[i + 1];
              vertex2.z = vertexBuffer[i + 2];
              vertex2.normalize().multiplyScalar(radius2);
              vertexBuffer[i + 0] = vertex2.x;
              vertexBuffer[i + 1] = vertex2.y;
              vertexBuffer[i + 2] = vertex2.z;
            }
          }
          function generateUVs() {
            const vertex2 = new Vector3();
            for (let i = 0; i < vertexBuffer.length; i += 3) {
              vertex2.x = vertexBuffer[i + 0];
              vertex2.y = vertexBuffer[i + 1];
              vertex2.z = vertexBuffer[i + 2];
              const u = azimuth(vertex2) / 2 / Math.PI + 0.5;
              const v = inclination(vertex2) / Math.PI + 0.5;
              uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
          }
          function correctSeam() {
            for (let i = 0; i < uvBuffer.length; i += 6) {
              const x0 = uvBuffer[i + 0];
              const x1 = uvBuffer[i + 2];
              const x2 = uvBuffer[i + 4];
              const max = Math.max(x0, x1, x2);
              const min = Math.min(x0, x1, x2);
              if (max > 0.9 && min < 0.1) {
                if (x0 < 0.2)
                  uvBuffer[i + 0] += 1;
                if (x1 < 0.2)
                  uvBuffer[i + 2] += 1;
                if (x2 < 0.2)
                  uvBuffer[i + 4] += 1;
              }
            }
          }
          function pushVertex(vertex2) {
            vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
          }
          function getVertexByIndex(index, vertex2) {
            const stride = index * 3;
            vertex2.x = vertices[stride + 0];
            vertex2.y = vertices[stride + 1];
            vertex2.z = vertices[stride + 2];
          }
          function correctUVs() {
            const a = new Vector3();
            const b = new Vector3();
            const c = new Vector3();
            const centroid = new Vector3();
            const uvA = new Vector2();
            const uvB = new Vector2();
            const uvC = new Vector2();
            for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
              a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
              b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
              c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
              uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
              uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
              uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
              centroid.copy(a).add(b).add(c).divideScalar(3);
              const azi = azimuth(centroid);
              correctUV(uvA, j + 0, a, azi);
              correctUV(uvB, j + 2, b, azi);
              correctUV(uvC, j + 4, c, azi);
            }
          }
          function correctUV(uv, stride, vector, azimuth2) {
            if (azimuth2 < 0 && uv.x === 1) {
              uvBuffer[stride] = uv.x - 1;
            }
            if (vector.x === 0 && vector.z === 0) {
              uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
            }
          }
          function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
          }
          function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
          }
        }
        static fromJSON(data) {
          return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
        }
      };
      DodecahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const t = (1 + Math.sqrt(5)) / 2;
          const r = 1 / t;
          const vertices = [
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            0,
            -r,
            -t,
            0,
            -r,
            t,
            0,
            r,
            -t,
            0,
            r,
            t,
            -r,
            -t,
            0,
            -r,
            t,
            0,
            r,
            -t,
            0,
            r,
            t,
            0,
            -t,
            0,
            -r,
            t,
            0,
            -r,
            -t,
            0,
            r,
            t,
            0,
            r
          ];
          const indices = [
            3,
            11,
            7,
            3,
            7,
            15,
            3,
            15,
            13,
            7,
            19,
            17,
            7,
            17,
            6,
            7,
            6,
            15,
            17,
            4,
            8,
            17,
            8,
            10,
            17,
            10,
            6,
            8,
            0,
            16,
            8,
            16,
            2,
            8,
            2,
            10,
            0,
            12,
            1,
            0,
            1,
            18,
            0,
            18,
            16,
            6,
            10,
            2,
            6,
            2,
            13,
            6,
            13,
            15,
            2,
            16,
            18,
            2,
            18,
            3,
            2,
            3,
            13,
            18,
            1,
            9,
            18,
            9,
            11,
            18,
            11,
            3,
            4,
            14,
            12,
            4,
            12,
            0,
            4,
            0,
            8,
            11,
            9,
            5,
            11,
            5,
            19,
            11,
            19,
            7,
            19,
            5,
            14,
            19,
            14,
            4,
            19,
            4,
            17,
            1,
            12,
            14,
            1,
            14,
            5,
            1,
            5,
            9
          ];
          super(vertices, indices, radius, detail);
          this.type = "DodecahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new DodecahedronGeometry(data.radius, data.detail);
        }
      };
      _v0 = /* @__PURE__ */ new Vector3();
      _v1$1 = /* @__PURE__ */ new Vector3();
      _normal = /* @__PURE__ */ new Vector3();
      _triangle = /* @__PURE__ */ new Triangle();
      EdgesGeometry = class extends BufferGeometry {
        constructor(geometry = null, thresholdAngle = 1) {
          super();
          this.type = "EdgesGeometry";
          this.parameters = {
            geometry,
            thresholdAngle
          };
          if (geometry !== null) {
            const precisionPoints = 4;
            const precision = Math.pow(10, precisionPoints);
            const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
            const indexAttr = geometry.getIndex();
            const positionAttr = geometry.getAttribute("position");
            const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
            const indexArr = [0, 0, 0];
            const vertKeys = ["a", "b", "c"];
            const hashes = new Array(3);
            const edgeData = {};
            const vertices = [];
            for (let i = 0; i < indexCount; i += 3) {
              if (indexAttr) {
                indexArr[0] = indexAttr.getX(i);
                indexArr[1] = indexAttr.getX(i + 1);
                indexArr[2] = indexAttr.getX(i + 2);
              } else {
                indexArr[0] = i;
                indexArr[1] = i + 1;
                indexArr[2] = i + 2;
              }
              const { a, b, c } = _triangle;
              a.fromBufferAttribute(positionAttr, indexArr[0]);
              b.fromBufferAttribute(positionAttr, indexArr[1]);
              c.fromBufferAttribute(positionAttr, indexArr[2]);
              _triangle.getNormal(_normal);
              hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
              hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
              hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
              if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
                continue;
              }
              for (let j = 0; j < 3; j++) {
                const jNext = (j + 1) % 3;
                const vecHash0 = hashes[j];
                const vecHash1 = hashes[jNext];
                const v0 = _triangle[vertKeys[j]];
                const v1 = _triangle[vertKeys[jNext]];
                const hash = `${vecHash0}_${vecHash1}`;
                const reverseHash = `${vecHash1}_${vecHash0}`;
                if (reverseHash in edgeData && edgeData[reverseHash]) {
                  if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                    vertices.push(v0.x, v0.y, v0.z);
                    vertices.push(v1.x, v1.y, v1.z);
                  }
                  edgeData[reverseHash] = null;
                } else if (!(hash in edgeData)) {
                  edgeData[hash] = {
                    index0: indexArr[j],
                    index1: indexArr[jNext],
                    normal: _normal.clone()
                  };
                }
              }
            }
            for (const key in edgeData) {
              if (edgeData[key]) {
                const { index0, index1 } = edgeData[key];
                _v0.fromBufferAttribute(positionAttr, index0);
                _v1$1.fromBufferAttribute(positionAttr, index1);
                vertices.push(_v0.x, _v0.y, _v0.z);
                vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
              }
            }
            this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          }
        }
      };
      Shape = class extends Path {
        constructor(points) {
          super(points);
          this.uuid = generateUUID();
          this.type = "Shape";
          this.holes = [];
        }
        getPointsHoles(divisions) {
          const holesPts = [];
          for (let i = 0, l = this.holes.length; i < l; i++) {
            holesPts[i] = this.holes[i].getPoints(divisions);
          }
          return holesPts;
        }
        extractPoints(divisions) {
          return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
          };
        }
        copy(source) {
          super.copy(source);
          this.holes = [];
          for (let i = 0, l = source.holes.length; i < l; i++) {
            const hole = source.holes[i];
            this.holes.push(hole.clone());
          }
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.uuid = this.uuid;
          data.holes = [];
          for (let i = 0, l = this.holes.length; i < l; i++) {
            const hole = this.holes[i];
            data.holes.push(hole.toJSON());
          }
          return data;
        }
        fromJSON(json) {
          super.fromJSON(json);
          this.uuid = json.uuid;
          this.holes = [];
          for (let i = 0, l = json.holes.length; i < l; i++) {
            const hole = json.holes[i];
            this.holes.push(new Path().fromJSON(hole));
          }
          return this;
        }
      };
      Earcut = {
        triangulate: function(data, holeIndices, dim = 2) {
          const hasHoles = holeIndices && holeIndices.length;
          const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
          let outerNode = linkedList(data, 0, outerLen, dim, true);
          const triangles = [];
          if (!outerNode || outerNode.next === outerNode.prev)
            return triangles;
          let minX, minY, maxX, maxY, x, y, invSize;
          if (hasHoles)
            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
          if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (let i = dim; i < outerLen; i += dim) {
              x = data[i];
              y = data[i + 1];
              if (x < minX)
                minX = x;
              if (y < minY)
                minY = y;
              if (x > maxX)
                maxX = x;
              if (y > maxY)
                maxY = y;
            }
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 32767 / invSize : 0;
          }
          earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
          return triangles;
        }
      };
      ShapeUtils = class {
        static area(contour) {
          const n = contour.length;
          let a = 0;
          for (let p = n - 1, q = 0; q < n; p = q++) {
            a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
          }
          return a * 0.5;
        }
        static isClockWise(pts) {
          return ShapeUtils.area(pts) < 0;
        }
        static triangulateShape(contour, holes) {
          const vertices = [];
          const holeIndices = [];
          const faces = [];
          removeDupEndPts(contour);
          addContour(vertices, contour);
          let holeIndex = contour.length;
          holes.forEach(removeDupEndPts);
          for (let i = 0; i < holes.length; i++) {
            holeIndices.push(holeIndex);
            holeIndex += holes[i].length;
            addContour(vertices, holes[i]);
          }
          const triangles = Earcut.triangulate(vertices, holeIndices);
          for (let i = 0; i < triangles.length; i += 3) {
            faces.push(triangles.slice(i, i + 3));
          }
          return faces;
        }
      };
      ExtrudeGeometry = class extends BufferGeometry {
        constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
          super();
          this.type = "ExtrudeGeometry";
          this.parameters = {
            shapes,
            options
          };
          shapes = Array.isArray(shapes) ? shapes : [shapes];
          const scope = this;
          const verticesArray = [];
          const uvArray = [];
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            addShape(shape);
          }
          this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
          this.computeVertexNormals();
          function addShape(shape) {
            const placeholder = [];
            const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
            const steps = options.steps !== void 0 ? options.steps : 1;
            const depth = options.depth !== void 0 ? options.depth : 1;
            let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
            let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
            let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
            let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
            let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
            const extrudePath = options.extrudePath;
            const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal, position2;
            if (extrudePath) {
              extrudePts = extrudePath.getSpacedPoints(steps);
              extrudeByPath = true;
              bevelEnabled = false;
              splineTube = extrudePath.computeFrenetFrames(steps, false);
              binormal = new Vector3();
              normal = new Vector3();
              position2 = new Vector3();
            }
            if (!bevelEnabled) {
              bevelSegments = 0;
              bevelThickness = 0;
              bevelSize = 0;
              bevelOffset = 0;
            }
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
              vertices = vertices.reverse();
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                if (ShapeUtils.isClockWise(ahole)) {
                  holes[h] = ahole.reverse();
                }
              }
            }
            const faces = ShapeUtils.triangulateShape(vertices, holes);
            const contour = vertices;
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
              if (!vec)
                console.error("THREE.ExtrudeGeometry: vec does not exist");
              return vec.clone().multiplyScalar(size).add(pt);
            }
            const vlen = vertices.length, flen = faces.length;
            function getBevelVec(inPt, inPrev, inNext) {
              let v_trans_x, v_trans_y, shrink_by;
              const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
              const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
              const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
              const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
              if (Math.abs(collinear0) > Number.EPSILON) {
                const v_prev_len = Math.sqrt(v_prev_lensq);
                const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) {
                  return new Vector2(v_trans_x, v_trans_y);
                } else {
                  shrink_by = Math.sqrt(v_trans_lensq / 2);
                }
              } else {
                let direction_eq = false;
                if (v_prev_x > Number.EPSILON) {
                  if (v_next_x > Number.EPSILON) {
                    direction_eq = true;
                  }
                } else {
                  if (v_prev_x < -Number.EPSILON) {
                    if (v_next_x < -Number.EPSILON) {
                      direction_eq = true;
                    }
                  } else {
                    if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                      direction_eq = true;
                    }
                  }
                }
                if (direction_eq) {
                  v_trans_x = -v_prev_y;
                  v_trans_y = v_prev_x;
                  shrink_by = Math.sqrt(v_prev_lensq);
                } else {
                  v_trans_x = v_prev_x;
                  v_trans_y = v_prev_y;
                  shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
              }
              return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
              if (j === il)
                j = 0;
              if (k === il)
                k = 0;
              contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              oneHoleMovements = [];
              for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                if (j === il)
                  j = 0;
                if (k === il)
                  k = 0;
                oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
              }
              holesMovements.push(oneHoleMovements);
              verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            for (let b = 0; b < bevelSegments; b++) {
              const t = b / bevelSegments;
              const z = bevelThickness * Math.cos(t * Math.PI / 2);
              const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
              for (let i = 0, il = contour.length; i < il; i++) {
                const vert = scalePt2(contour[i], contourMovements[i], bs2);
                v(vert.x, vert.y, -z);
              }
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (let i = 0, il = ahole.length; i < il; i++) {
                  const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
                  v(vert.x, vert.y, -z);
                }
              }
            }
            const bs = bevelSize + bevelOffset;
            for (let i = 0; i < vlen; i++) {
              const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
              if (!extrudeByPath) {
                v(vert.x, vert.y, 0);
              } else {
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
              }
            }
            for (let s = 1; s <= steps; s++) {
              for (let i = 0; i < vlen; i++) {
                const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                if (!extrudeByPath) {
                  v(vert.x, vert.y, depth / steps * s);
                } else {
                  normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                  binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                  position2.copy(extrudePts[s]).add(normal).add(binormal);
                  v(position2.x, position2.y, position2.z);
                }
              }
            }
            for (let b = bevelSegments - 1; b >= 0; b--) {
              const t = b / bevelSegments;
              const z = bevelThickness * Math.cos(t * Math.PI / 2);
              const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
              for (let i = 0, il = contour.length; i < il; i++) {
                const vert = scalePt2(contour[i], contourMovements[i], bs2);
                v(vert.x, vert.y, depth + z);
              }
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (let i = 0, il = ahole.length; i < il; i++) {
                  const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
                  if (!extrudeByPath) {
                    v(vert.x, vert.y, depth + z);
                  } else {
                    v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                  }
                }
              }
            }
            buildLidFaces();
            buildSideFaces();
            function buildLidFaces() {
              const start2 = verticesArray.length / 3;
              if (bevelEnabled) {
                let layer = 0;
                let offset = vlen * layer;
                for (let i = 0; i < flen; i++) {
                  const face = faces[i];
                  f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                for (let i = 0; i < flen; i++) {
                  const face = faces[i];
                  f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
              } else {
                for (let i = 0; i < flen; i++) {
                  const face = faces[i];
                  f3(face[2], face[1], face[0]);
                }
                for (let i = 0; i < flen; i++) {
                  const face = faces[i];
                  f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
              }
              scope.addGroup(start2, verticesArray.length / 3 - start2, 0);
            }
            function buildSideFaces() {
              const start2 = verticesArray.length / 3;
              let layeroffset = 0;
              sidewalls(contour, layeroffset);
              layeroffset += contour.length;
              for (let h = 0, hl = holes.length; h < hl; h++) {
                const ahole = holes[h];
                sidewalls(ahole, layeroffset);
                layeroffset += ahole.length;
              }
              scope.addGroup(start2, verticesArray.length / 3 - start2, 1);
            }
            function sidewalls(contour2, layeroffset) {
              let i = contour2.length;
              while (--i >= 0) {
                const j = i;
                let k = i - 1;
                if (k < 0)
                  k = contour2.length - 1;
                for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
                  const slen1 = vlen * s;
                  const slen2 = vlen * (s + 1);
                  const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                  f4(a, b, c, d);
                }
              }
            }
            function v(x, y, z) {
              placeholder.push(x);
              placeholder.push(y);
              placeholder.push(z);
            }
            function f3(a, b, c) {
              addVertex(a);
              addVertex(b);
              addVertex(c);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[2]);
            }
            function f4(a, b, c, d) {
              addVertex(a);
              addVertex(b);
              addVertex(d);
              addVertex(b);
              addVertex(c);
              addVertex(d);
              const nextIndex = verticesArray.length / 3;
              const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
              addUV(uvs[0]);
              addUV(uvs[1]);
              addUV(uvs[3]);
              addUV(uvs[1]);
              addUV(uvs[2]);
              addUV(uvs[3]);
            }
            function addVertex(index) {
              verticesArray.push(placeholder[index * 3 + 0]);
              verticesArray.push(placeholder[index * 3 + 1]);
              verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
              uvArray.push(vector2.x);
              uvArray.push(vector2.y);
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          const options = this.parameters.options;
          return toJSON$1(shapes, options, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j = 0, jl = data.shapes.length; j < jl; j++) {
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
          }
          const extrudePath = data.options.extrudePath;
          if (extrudePath !== void 0) {
            data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
          }
          return new ExtrudeGeometry(geometryShapes, data.options);
        }
      };
      WorldUVGenerator = {
        generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          return [
            new Vector2(a_x, a_y),
            new Vector2(b_x, b_y),
            new Vector2(c_x, c_y)
          ];
        },
        generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
          const a_x = vertices[indexA * 3];
          const a_y = vertices[indexA * 3 + 1];
          const a_z = vertices[indexA * 3 + 2];
          const b_x = vertices[indexB * 3];
          const b_y = vertices[indexB * 3 + 1];
          const b_z = vertices[indexB * 3 + 2];
          const c_x = vertices[indexC * 3];
          const c_y = vertices[indexC * 3 + 1];
          const c_z = vertices[indexC * 3 + 2];
          const d_x = vertices[indexD * 3];
          const d_y = vertices[indexD * 3 + 1];
          const d_z = vertices[indexD * 3 + 2];
          if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
            return [
              new Vector2(a_x, 1 - a_z),
              new Vector2(b_x, 1 - b_z),
              new Vector2(c_x, 1 - c_z),
              new Vector2(d_x, 1 - d_z)
            ];
          } else {
            return [
              new Vector2(a_y, 1 - a_z),
              new Vector2(b_y, 1 - b_z),
              new Vector2(c_y, 1 - c_z),
              new Vector2(d_y, 1 - d_z)
            ];
          }
        }
      };
      IcosahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const t = (1 + Math.sqrt(5)) / 2;
          const vertices = [
            -1,
            t,
            0,
            1,
            t,
            0,
            -1,
            -t,
            0,
            1,
            -t,
            0,
            0,
            -1,
            t,
            0,
            1,
            t,
            0,
            -1,
            -t,
            0,
            1,
            -t,
            t,
            0,
            -1,
            t,
            0,
            1,
            -t,
            0,
            -1,
            -t,
            0,
            1
          ];
          const indices = [
            0,
            11,
            5,
            0,
            5,
            1,
            0,
            1,
            7,
            0,
            7,
            10,
            0,
            10,
            11,
            1,
            5,
            9,
            5,
            11,
            4,
            11,
            10,
            2,
            10,
            7,
            6,
            7,
            1,
            8,
            3,
            9,
            4,
            3,
            4,
            2,
            3,
            2,
            6,
            3,
            6,
            8,
            3,
            8,
            9,
            4,
            9,
            5,
            2,
            4,
            11,
            6,
            2,
            10,
            8,
            6,
            7,
            9,
            8,
            1
          ];
          super(vertices, indices, radius, detail);
          this.type = "IcosahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new IcosahedronGeometry(data.radius, data.detail);
        }
      };
      OctahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const vertices = [
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1
          ];
          const indices = [
            0,
            2,
            4,
            0,
            4,
            3,
            0,
            3,
            5,
            0,
            5,
            2,
            1,
            2,
            5,
            1,
            5,
            3,
            1,
            3,
            4,
            1,
            4,
            2
          ];
          super(vertices, indices, radius, detail);
          this.type = "OctahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new OctahedronGeometry(data.radius, data.detail);
        }
      };
      RingGeometry = class extends BufferGeometry {
        constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
          super();
          this.type = "RingGeometry";
          this.parameters = {
            innerRadius,
            outerRadius,
            thetaSegments,
            phiSegments,
            thetaStart,
            thetaLength
          };
          thetaSegments = Math.max(3, thetaSegments);
          phiSegments = Math.max(1, phiSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let radius = innerRadius;
          const radiusStep = (outerRadius - innerRadius) / phiSegments;
          const vertex2 = new Vector3();
          const uv = new Vector2();
          for (let j = 0; j <= phiSegments; j++) {
            for (let i = 0; i <= thetaSegments; i++) {
              const segment = thetaStart + i / thetaSegments * thetaLength;
              vertex2.x = radius * Math.cos(segment);
              vertex2.y = radius * Math.sin(segment);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normals.push(0, 0, 1);
              uv.x = (vertex2.x / outerRadius + 1) / 2;
              uv.y = (vertex2.y / outerRadius + 1) / 2;
              uvs.push(uv.x, uv.y);
            }
            radius += radiusStep;
          }
          for (let j = 0; j < phiSegments; j++) {
            const thetaSegmentLevel = j * (thetaSegments + 1);
            for (let i = 0; i < thetaSegments; i++) {
              const segment = i + thetaSegmentLevel;
              const a = segment;
              const b = segment + thetaSegments + 1;
              const c = segment + thetaSegments + 2;
              const d = segment + 1;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
        }
      };
      ShapeGeometry = class extends BufferGeometry {
        constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
          super();
          this.type = "ShapeGeometry";
          this.parameters = {
            shapes,
            curveSegments
          };
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          let groupStart = 0;
          let groupCount = 0;
          if (Array.isArray(shapes) === false) {
            addShape(shapes);
          } else {
            for (let i = 0; i < shapes.length; i++) {
              addShape(shapes[i]);
              this.addGroup(groupStart, groupCount, i);
              groupStart += groupCount;
              groupCount = 0;
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function addShape(shape) {
            const indexOffset = vertices.length / 3;
            const points = shape.extractPoints(curveSegments);
            let shapeVertices = points.shape;
            const shapeHoles = points.holes;
            if (ShapeUtils.isClockWise(shapeVertices) === false) {
              shapeVertices = shapeVertices.reverse();
            }
            for (let i = 0, l = shapeHoles.length; i < l; i++) {
              const shapeHole = shapeHoles[i];
              if (ShapeUtils.isClockWise(shapeHole) === true) {
                shapeHoles[i] = shapeHole.reverse();
              }
            }
            const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            for (let i = 0, l = shapeHoles.length; i < l; i++) {
              const shapeHole = shapeHoles[i];
              shapeVertices = shapeVertices.concat(shapeHole);
            }
            for (let i = 0, l = shapeVertices.length; i < l; i++) {
              const vertex2 = shapeVertices[i];
              vertices.push(vertex2.x, vertex2.y, 0);
              normals.push(0, 0, 1);
              uvs.push(vertex2.x, vertex2.y);
            }
            for (let i = 0, l = faces.length; i < l; i++) {
              const face = faces[i];
              const a = face[0] + indexOffset;
              const b = face[1] + indexOffset;
              const c = face[2] + indexOffset;
              indices.push(a, b, c);
              groupCount += 3;
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          const shapes = this.parameters.shapes;
          return toJSON(shapes, data);
        }
        static fromJSON(data, shapes) {
          const geometryShapes = [];
          for (let j = 0, jl = data.shapes.length; j < jl; j++) {
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
          }
          return new ShapeGeometry(geometryShapes, data.curveSegments);
        }
      };
      SphereGeometry = class extends BufferGeometry {
        constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
          super();
          this.type = "SphereGeometry";
          this.parameters = {
            radius,
            widthSegments,
            heightSegments,
            phiStart,
            phiLength,
            thetaStart,
            thetaLength
          };
          widthSegments = Math.max(3, Math.floor(widthSegments));
          heightSegments = Math.max(2, Math.floor(heightSegments));
          const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
          let index = 0;
          const grid = [];
          const vertex2 = new Vector3();
          const normal = new Vector3();
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          for (let iy = 0; iy <= heightSegments; iy++) {
            const verticesRow = [];
            const v = iy / heightSegments;
            let uOffset = 0;
            if (iy == 0 && thetaStart == 0) {
              uOffset = 0.5 / widthSegments;
            } else if (iy == heightSegments && thetaEnd == Math.PI) {
              uOffset = -0.5 / widthSegments;
            }
            for (let ix = 0; ix <= widthSegments; ix++) {
              const u = ix / widthSegments;
              vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
              vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
              vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normal.copy(vertex2).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(u + uOffset, 1 - v);
              verticesRow.push(index++);
            }
            grid.push(verticesRow);
          }
          for (let iy = 0; iy < heightSegments; iy++) {
            for (let ix = 0; ix < widthSegments; ix++) {
              const a = grid[iy][ix + 1];
              const b = grid[iy][ix];
              const c = grid[iy + 1][ix];
              const d = grid[iy + 1][ix + 1];
              if (iy !== 0 || thetaStart > 0)
                indices.push(a, b, d);
              if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
        }
      };
      TetrahedronGeometry = class extends PolyhedronGeometry {
        constructor(radius = 1, detail = 0) {
          const vertices = [
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            1,
            -1,
            -1
          ];
          const indices = [
            2,
            1,
            0,
            0,
            3,
            2,
            1,
            3,
            0,
            2,
            3,
            1
          ];
          super(vertices, indices, radius, detail);
          this.type = "TetrahedronGeometry";
          this.parameters = {
            radius,
            detail
          };
        }
        static fromJSON(data) {
          return new TetrahedronGeometry(data.radius, data.detail);
        }
      };
      TorusGeometry = class extends BufferGeometry {
        constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
          super();
          this.type = "TorusGeometry";
          this.parameters = {
            radius,
            tube,
            radialSegments,
            tubularSegments,
            arc
          };
          radialSegments = Math.floor(radialSegments);
          tubularSegments = Math.floor(tubularSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const center = new Vector3();
          const vertex2 = new Vector3();
          const normal = new Vector3();
          for (let j = 0; j <= radialSegments; j++) {
            for (let i = 0; i <= tubularSegments; i++) {
              const u = i / tubularSegments * arc;
              const v = j / radialSegments * Math.PI * 2;
              vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u);
              vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u);
              vertex2.z = tube * Math.sin(v);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              center.x = radius * Math.cos(u);
              center.y = radius * Math.sin(u);
              normal.subVectors(vertex2, center).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(i / tubularSegments);
              uvs.push(j / radialSegments);
            }
          }
          for (let j = 1; j <= radialSegments; j++) {
            for (let i = 1; i <= tubularSegments; i++) {
              const a = (tubularSegments + 1) * j + i - 1;
              const b = (tubularSegments + 1) * (j - 1) + i - 1;
              const c = (tubularSegments + 1) * (j - 1) + i;
              const d = (tubularSegments + 1) * j + i;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        }
        static fromJSON(data) {
          return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
        }
      };
      TorusKnotGeometry = class extends BufferGeometry {
        constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
          super();
          this.type = "TorusKnotGeometry";
          this.parameters = {
            radius,
            tube,
            tubularSegments,
            radialSegments,
            p,
            q
          };
          tubularSegments = Math.floor(tubularSegments);
          radialSegments = Math.floor(radialSegments);
          const indices = [];
          const vertices = [];
          const normals = [];
          const uvs = [];
          const vertex2 = new Vector3();
          const normal = new Vector3();
          const P1 = new Vector3();
          const P2 = new Vector3();
          const B = new Vector3();
          const T = new Vector3();
          const N = new Vector3();
          for (let i = 0; i <= tubularSegments; ++i) {
            const u = i / tubularSegments * p * Math.PI * 2;
            calculatePositionOnCurve(u, p, q, radius, P1);
            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            B.normalize();
            N.normalize();
            for (let j = 0; j <= radialSegments; ++j) {
              const v = j / radialSegments * Math.PI * 2;
              const cx = -tube * Math.cos(v);
              const cy = tube * Math.sin(v);
              vertex2.x = P1.x + (cx * N.x + cy * B.x);
              vertex2.y = P1.y + (cx * N.y + cy * B.y);
              vertex2.z = P1.z + (cx * N.z + cy * B.z);
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normal.subVectors(vertex2, P1).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(i / tubularSegments);
              uvs.push(j / radialSegments);
            }
          }
          for (let j = 1; j <= tubularSegments; j++) {
            for (let i = 1; i <= radialSegments; i++) {
              const a = (radialSegments + 1) * (j - 1) + (i - 1);
              const b = (radialSegments + 1) * j + (i - 1);
              const c = (radialSegments + 1) * j + i;
              const d = (radialSegments + 1) * (j - 1) + i;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
          }
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function calculatePositionOnCurve(u, p2, q2, radius2, position) {
            const cu = Math.cos(u);
            const su = Math.sin(u);
            const quOverP = q2 / p2 * u;
            const cs = Math.cos(quOverP);
            position.x = radius2 * (2 + cs) * 0.5 * cu;
            position.y = radius2 * (2 + cs) * su * 0.5;
            position.z = radius2 * Math.sin(quOverP) * 0.5;
          }
        }
        static fromJSON(data) {
          return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
        }
      };
      TubeGeometry = class extends BufferGeometry {
        constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
          super();
          this.type = "TubeGeometry";
          this.parameters = {
            path,
            tubularSegments,
            radius,
            radialSegments,
            closed
          };
          const frames = path.computeFrenetFrames(tubularSegments, closed);
          this.tangents = frames.tangents;
          this.normals = frames.normals;
          this.binormals = frames.binormals;
          const vertex2 = new Vector3();
          const normal = new Vector3();
          const uv = new Vector2();
          let P = new Vector3();
          const vertices = [];
          const normals = [];
          const uvs = [];
          const indices = [];
          generateBufferData();
          this.setIndex(indices);
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
          this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
          function generateBufferData() {
            for (let i = 0; i < tubularSegments; i++) {
              generateSegment(i);
            }
            generateSegment(closed === false ? tubularSegments : 0);
            generateUVs();
            generateIndices();
          }
          function generateSegment(i) {
            P = path.getPointAt(i / tubularSegments, P);
            const N = frames.normals[i];
            const B = frames.binormals[i];
            for (let j = 0; j <= radialSegments; j++) {
              const v = j / radialSegments * Math.PI * 2;
              const sin = Math.sin(v);
              const cos = -Math.cos(v);
              normal.x = cos * N.x + sin * B.x;
              normal.y = cos * N.y + sin * B.y;
              normal.z = cos * N.z + sin * B.z;
              normal.normalize();
              normals.push(normal.x, normal.y, normal.z);
              vertex2.x = P.x + radius * normal.x;
              vertex2.y = P.y + radius * normal.y;
              vertex2.z = P.z + radius * normal.z;
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
            }
          }
          function generateIndices() {
            for (let j = 1; j <= tubularSegments; j++) {
              for (let i = 1; i <= radialSegments; i++) {
                const a = (radialSegments + 1) * (j - 1) + (i - 1);
                const b = (radialSegments + 1) * j + (i - 1);
                const c = (radialSegments + 1) * j + i;
                const d = (radialSegments + 1) * (j - 1) + i;
                indices.push(a, b, d);
                indices.push(b, c, d);
              }
            }
          }
          function generateUVs() {
            for (let i = 0; i <= tubularSegments; i++) {
              for (let j = 0; j <= radialSegments; j++) {
                uv.x = i / tubularSegments;
                uv.y = j / radialSegments;
                uvs.push(uv.x, uv.y);
              }
            }
          }
        }
        toJSON() {
          const data = super.toJSON();
          data.path = this.parameters.path.toJSON();
          return data;
        }
        static fromJSON(data) {
          return new TubeGeometry(
            new Curves[data.path.type]().fromJSON(data.path),
            data.tubularSegments,
            data.radius,
            data.radialSegments,
            data.closed
          );
        }
      };
      WireframeGeometry = class extends BufferGeometry {
        constructor(geometry = null) {
          super();
          this.type = "WireframeGeometry";
          this.parameters = {
            geometry
          };
          if (geometry !== null) {
            const vertices = [];
            const edges = /* @__PURE__ */ new Set();
            const start2 = new Vector3();
            const end = new Vector3();
            if (geometry.index !== null) {
              const position = geometry.attributes.position;
              const indices = geometry.index;
              let groups = geometry.groups;
              if (groups.length === 0) {
                groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
              }
              for (let o = 0, ol = groups.length; o < ol; ++o) {
                const group = groups[o];
                const groupStart = group.start;
                const groupCount = group.count;
                for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
                  for (let j = 0; j < 3; j++) {
                    const index1 = indices.getX(i + j);
                    const index2 = indices.getX(i + (j + 1) % 3);
                    start2.fromBufferAttribute(position, index1);
                    end.fromBufferAttribute(position, index2);
                    if (isUniqueEdge(start2, end, edges) === true) {
                      vertices.push(start2.x, start2.y, start2.z);
                      vertices.push(end.x, end.y, end.z);
                    }
                  }
                }
              }
            } else {
              const position = geometry.attributes.position;
              for (let i = 0, l = position.count / 3; i < l; i++) {
                for (let j = 0; j < 3; j++) {
                  const index1 = 3 * i + j;
                  const index2 = 3 * i + (j + 1) % 3;
                  start2.fromBufferAttribute(position, index1);
                  end.fromBufferAttribute(position, index2);
                  if (isUniqueEdge(start2, end, edges) === true) {
                    vertices.push(start2.x, start2.y, start2.z);
                    vertices.push(end.x, end.y, end.z);
                  }
                }
              }
            }
            this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          }
        }
      };
      Geometries = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        BoxGeometry,
        CapsuleGeometry,
        CircleGeometry,
        ConeGeometry,
        CylinderGeometry,
        DodecahedronGeometry,
        EdgesGeometry,
        ExtrudeGeometry,
        IcosahedronGeometry,
        LatheGeometry,
        OctahedronGeometry,
        PlaneGeometry,
        PolyhedronGeometry,
        RingGeometry,
        ShapeGeometry,
        SphereGeometry,
        TetrahedronGeometry,
        TorusGeometry,
        TorusKnotGeometry,
        TubeGeometry,
        WireframeGeometry
      });
      ShadowMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isShadowMaterial = true;
          this.type = "ShadowMaterial";
          this.color = new Color(0);
          this.transparent = true;
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.fog = source.fog;
          return this;
        }
      };
      RawShaderMaterial = class extends ShaderMaterial {
        constructor(parameters) {
          super(parameters);
          this.isRawShaderMaterial = true;
          this.type = "RawShaderMaterial";
        }
      };
      MeshStandardMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshStandardMaterial = true;
          this.defines = { "STANDARD": "" };
          this.type = "MeshStandardMaterial";
          this.color = new Color(16777215);
          this.roughness = 1;
          this.metalness = 0;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.roughnessMap = null;
          this.metalnessMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.envMapIntensity = 1;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = { "STANDARD": "" };
          this.color.copy(source.color);
          this.roughness = source.roughness;
          this.metalness = source.metalness;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.roughnessMap = source.roughnessMap;
          this.metalnessMap = source.metalnessMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.envMapIntensity = source.envMapIntensity;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          this.fog = source.fog;
          return this;
        }
      };
      MeshPhysicalMaterial = class extends MeshStandardMaterial {
        constructor(parameters) {
          super();
          this.isMeshPhysicalMaterial = true;
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.type = "MeshPhysicalMaterial";
          this.clearcoatMap = null;
          this.clearcoatRoughness = 0;
          this.clearcoatRoughnessMap = null;
          this.clearcoatNormalScale = new Vector2(1, 1);
          this.clearcoatNormalMap = null;
          this.ior = 1.5;
          Object.defineProperty(this, "reflectivity", {
            get: function() {
              return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(reflectivity) {
              this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
            }
          });
          this.iridescenceMap = null;
          this.iridescenceIOR = 1.3;
          this.iridescenceThicknessRange = [100, 400];
          this.iridescenceThicknessMap = null;
          this.sheenColor = new Color(0);
          this.sheenColorMap = null;
          this.sheenRoughness = 1;
          this.sheenRoughnessMap = null;
          this.transmissionMap = null;
          this.thickness = 0;
          this.thicknessMap = null;
          this.attenuationDistance = Infinity;
          this.attenuationColor = new Color(1, 1, 1);
          this.specularIntensity = 1;
          this.specularIntensityMap = null;
          this.specularColor = new Color(1, 1, 1);
          this.specularColorMap = null;
          this._sheen = 0;
          this._clearcoat = 0;
          this._iridescence = 0;
          this._transmission = 0;
          this.setValues(parameters);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(value) {
          if (this._sheen > 0 !== value > 0) {
            this.version++;
          }
          this._sheen = value;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(value) {
          if (this._clearcoat > 0 !== value > 0) {
            this.version++;
          }
          this._clearcoat = value;
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(value) {
          if (this._iridescence > 0 !== value > 0) {
            this.version++;
          }
          this._iridescence = value;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(value) {
          if (this._transmission > 0 !== value > 0) {
            this.version++;
          }
          this._transmission = value;
        }
        copy(source) {
          super.copy(source);
          this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
          };
          this.clearcoat = source.clearcoat;
          this.clearcoatMap = source.clearcoatMap;
          this.clearcoatRoughness = source.clearcoatRoughness;
          this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
          this.clearcoatNormalMap = source.clearcoatNormalMap;
          this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
          this.ior = source.ior;
          this.iridescence = source.iridescence;
          this.iridescenceMap = source.iridescenceMap;
          this.iridescenceIOR = source.iridescenceIOR;
          this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
          this.iridescenceThicknessMap = source.iridescenceThicknessMap;
          this.sheen = source.sheen;
          this.sheenColor.copy(source.sheenColor);
          this.sheenColorMap = source.sheenColorMap;
          this.sheenRoughness = source.sheenRoughness;
          this.sheenRoughnessMap = source.sheenRoughnessMap;
          this.transmission = source.transmission;
          this.transmissionMap = source.transmissionMap;
          this.thickness = source.thickness;
          this.thicknessMap = source.thicknessMap;
          this.attenuationDistance = source.attenuationDistance;
          this.attenuationColor.copy(source.attenuationColor);
          this.specularIntensity = source.specularIntensity;
          this.specularIntensityMap = source.specularIntensityMap;
          this.specularColor.copy(source.specularColor);
          this.specularColorMap = source.specularColorMap;
          return this;
        }
      };
      MeshPhongMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshPhongMaterial = true;
          this.type = "MeshPhongMaterial";
          this.color = new Color(16777215);
          this.specular = new Color(1118481);
          this.shininess = 30;
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.specular.copy(source.specular);
          this.shininess = source.shininess;
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          this.fog = source.fog;
          return this;
        }
      };
      MeshToonMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshToonMaterial = true;
          this.defines = { "TOON": "" };
          this.type = "MeshToonMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.gradientMap = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.gradientMap = source.gradientMap;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.fog = source.fog;
          return this;
        }
      };
      MeshNormalMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshNormalMaterial = true;
          this.type = "MeshNormalMaterial";
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.flatShading = false;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.flatShading = source.flatShading;
          return this;
        }
      };
      MeshLambertMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshLambertMaterial = true;
          this.type = "MeshLambertMaterial";
          this.color = new Color(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.emissive = new Color(0);
          this.emissiveIntensity = 1;
          this.emissiveMap = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = MultiplyOperation;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.flatShading = false;
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.color.copy(source.color);
          this.map = source.map;
          this.lightMap = source.lightMap;
          this.lightMapIntensity = source.lightMapIntensity;
          this.aoMap = source.aoMap;
          this.aoMapIntensity = source.aoMapIntensity;
          this.emissive.copy(source.emissive);
          this.emissiveMap = source.emissiveMap;
          this.emissiveIntensity = source.emissiveIntensity;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.specularMap = source.specularMap;
          this.alphaMap = source.alphaMap;
          this.envMap = source.envMap;
          this.combine = source.combine;
          this.reflectivity = source.reflectivity;
          this.refractionRatio = source.refractionRatio;
          this.wireframe = source.wireframe;
          this.wireframeLinewidth = source.wireframeLinewidth;
          this.wireframeLinecap = source.wireframeLinecap;
          this.wireframeLinejoin = source.wireframeLinejoin;
          this.flatShading = source.flatShading;
          this.fog = source.fog;
          return this;
        }
      };
      MeshMatcapMaterial = class extends Material {
        constructor(parameters) {
          super();
          this.isMeshMatcapMaterial = true;
          this.defines = { "MATCAP": "" };
          this.type = "MeshMatcapMaterial";
          this.color = new Color(16777215);
          this.matcap = null;
          this.map = null;
          this.bumpMap = null;
          this.bumpScale = 1;
          this.normalMap = null;
          this.normalMapType = TangentSpaceNormalMap;
          this.normalScale = new Vector2(1, 1);
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.alphaMap = null;
          this.flatShading = false;
          this.fog = true;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.defines = { "MATCAP": "" };
          this.color.copy(source.color);
          this.matcap = source.matcap;
          this.map = source.map;
          this.bumpMap = source.bumpMap;
          this.bumpScale = source.bumpScale;
          this.normalMap = source.normalMap;
          this.normalMapType = source.normalMapType;
          this.normalScale.copy(source.normalScale);
          this.displacementMap = source.displacementMap;
          this.displacementScale = source.displacementScale;
          this.displacementBias = source.displacementBias;
          this.alphaMap = source.alphaMap;
          this.flatShading = source.flatShading;
          this.fog = source.fog;
          return this;
        }
      };
      LineDashedMaterial = class extends LineBasicMaterial {
        constructor(parameters) {
          super();
          this.isLineDashedMaterial = true;
          this.type = "LineDashedMaterial";
          this.scale = 1;
          this.dashSize = 3;
          this.gapSize = 1;
          this.setValues(parameters);
        }
        copy(source) {
          super.copy(source);
          this.scale = source.scale;
          this.dashSize = source.dashSize;
          this.gapSize = source.gapSize;
          return this;
        }
      };
      AnimationUtils = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        arraySlice,
        convertArray,
        flattenJSON,
        getKeyframeOrder,
        isTypedArray,
        makeClipAdditive,
        sortedArray,
        subclip
      });
      Interpolant = class {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          this.parameterPositions = parameterPositions;
          this._cachedIndex = 0;
          this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
          this.sampleValues = sampleValues;
          this.valueSize = sampleSize;
          this.settings = null;
          this.DefaultSettings_ = {};
        }
        evaluate(t) {
          const pp = this.parameterPositions;
          let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
          validate_interval: {
            seek: {
              let right;
              linear_scan: {
                forward_scan:
                  if (!(t < t1)) {
                    for (let giveUpAt = i1 + 2; ; ) {
                      if (t1 === void 0) {
                        if (t < t0)
                          break forward_scan;
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.copySampleValue_(i1 - 1);
                      }
                      if (i1 === giveUpAt)
                        break;
                      t0 = t1;
                      t1 = pp[++i1];
                      if (t < t1) {
                        break seek;
                      }
                    }
                    right = pp.length;
                    break linear_scan;
                  }
                if (!(t >= t0)) {
                  const t1global = pp[1];
                  if (t < t1global) {
                    i1 = 2;
                    t0 = t1global;
                  }
                  for (let giveUpAt = i1 - 2; ; ) {
                    if (t0 === void 0) {
                      this._cachedIndex = 0;
                      return this.copySampleValue_(0);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t1 = t0;
                    t0 = pp[--i1 - 1];
                    if (t >= t0) {
                      break seek;
                    }
                  }
                  right = i1;
                  i1 = 0;
                  break linear_scan;
                }
                break validate_interval;
              }
              while (i1 < right) {
                const mid = i1 + right >>> 1;
                if (t < pp[mid]) {
                  right = mid;
                } else {
                  i1 = mid + 1;
                }
              }
              t1 = pp[i1];
              t0 = pp[i1 - 1];
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (t1 === void 0) {
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.copySampleValue_(i1 - 1);
              }
            }
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
          }
          return this.interpolate_(i1, t0, t, t1);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(index) {
          const result = this.resultBuffer, values3 = this.sampleValues, stride = this.valueSize, offset = index * stride;
          for (let i = 0; i !== stride; ++i) {
            result[i] = values3[offset + i];
          }
          return result;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      };
      CubicInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
          this._weightPrev = -0;
          this._offsetPrev = -0;
          this._weightNext = -0;
          this._offsetNext = -0;
          this.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
        }
        intervalChanged_(i1, t0, t1) {
          const pp = this.parameterPositions;
          let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
          if (tPrev === void 0) {
            switch (this.getSettings_().endingStart) {
              case ZeroSlopeEnding:
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
              case WrapAroundEnding:
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
              default:
                iPrev = i1;
                tPrev = t1;
            }
          }
          if (tNext === void 0) {
            switch (this.getSettings_().endingEnd) {
              case ZeroSlopeEnding:
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
              case WrapAroundEnding:
                iNext = 1;
                tNext = t1 + pp[1] - pp[0];
                break;
              default:
                iNext = i1 - 1;
                tNext = t0;
            }
          }
          const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
          this._weightPrev = halfDt / (t0 - tPrev);
          this._weightNext = halfDt / (tNext - t1);
          this._offsetPrev = iPrev * stride;
          this._offsetNext = iNext * stride;
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values3 = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
          const sP = -wP * ppp + 2 * wP * pp - wP * p;
          const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
          const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
          const sN = wN * ppp - wN * pp;
          for (let i = 0; i !== stride; ++i) {
            result[i] = sP * values3[oP + i] + s0 * values3[o0 + i] + s1 * values3[o1 + i] + sN * values3[oN + i];
          }
          return result;
        }
      };
      LinearInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values3 = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
          for (let i = 0; i !== stride; ++i) {
            result[i] = values3[offset0 + i] * weight0 + values3[offset1 + i] * weight1;
          }
          return result;
        }
      };
      DiscreteInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1) {
          return this.copySampleValue_(i1 - 1);
        }
      };
      KeyframeTrack = class {
        constructor(name, times, values3, interpolation) {
          if (name === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (times === void 0 || times.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
          this.name = name;
          this.times = convertArray(times, this.TimeBufferType);
          this.values = convertArray(values3, this.ValueBufferType);
          this.setInterpolation(interpolation || this.DefaultInterpolation);
        }
        static toJSON(track) {
          const trackType = track.constructor;
          let json;
          if (trackType.toJSON !== this.toJSON) {
            json = trackType.toJSON(track);
          } else {
            json = {
              "name": track.name,
              "times": convertArray(track.times, Array),
              "values": convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) {
              json.interpolation = interpolation;
            }
          }
          json.type = track.ValueTypeName;
          return json;
        }
        InterpolantFactoryMethodDiscrete(result) {
          return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodLinear(result) {
          return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodSmooth(result) {
          return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        setInterpolation(interpolation) {
          let factoryMethod;
          switch (interpolation) {
            case InterpolateDiscrete:
              factoryMethod = this.InterpolantFactoryMethodDiscrete;
              break;
            case InterpolateLinear:
              factoryMethod = this.InterpolantFactoryMethodLinear;
              break;
            case InterpolateSmooth:
              factoryMethod = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (factoryMethod === void 0) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) {
              if (interpolation !== this.DefaultInterpolation) {
                this.setInterpolation(this.DefaultInterpolation);
              } else {
                throw new Error(message);
              }
            }
            console.warn("THREE.KeyframeTrack:", message);
            return this;
          }
          this.createInterpolant = factoryMethod;
          return this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
              return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
              return InterpolateSmooth;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(timeOffset) {
          if (timeOffset !== 0) {
            const times = this.times;
            for (let i = 0, n = times.length; i !== n; ++i) {
              times[i] += timeOffset;
            }
          }
          return this;
        }
        scale(timeScale) {
          if (timeScale !== 1) {
            const times = this.times;
            for (let i = 0, n = times.length; i !== n; ++i) {
              times[i] *= timeScale;
            }
          }
          return this;
        }
        trim(startTime, endTime) {
          const times = this.times, nKeys = times.length;
          let from = 0, to = nKeys - 1;
          while (from !== nKeys && times[from] < startTime) {
            ++from;
          }
          while (to !== -1 && times[to] > endTime) {
            --to;
          }
          ++to;
          if (from !== 0 || to !== nKeys) {
            if (from >= to) {
              to = Math.max(to, 1);
              from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = arraySlice(times, from, to);
            this.values = arraySlice(this.values, from * stride, to * stride);
          }
          return this;
        }
        validate() {
          let valid = true;
          const valueSize = this.getValueSize();
          if (valueSize - Math.floor(valueSize) !== 0) {
            console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
            valid = false;
          }
          const times = this.times, values3 = this.values, nKeys = times.length;
          if (nKeys === 0) {
            console.error("THREE.KeyframeTrack: Track is empty.", this);
            valid = false;
          }
          let prevTime = null;
          for (let i = 0; i !== nKeys; i++) {
            const currTime = times[i];
            if (typeof currTime === "number" && isNaN(currTime)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
              valid = false;
              break;
            }
            if (prevTime !== null && prevTime > currTime) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
              valid = false;
              break;
            }
            prevTime = currTime;
          }
          if (values3 !== void 0) {
            if (isTypedArray(values3)) {
              for (let i = 0, n = values3.length; i !== n; ++i) {
                const value = values3[i];
                if (isNaN(value)) {
                  console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
                  valid = false;
                  break;
                }
              }
            }
          }
          return valid;
        }
        optimize() {
          const times = arraySlice(this.times), values3 = arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
          let writeIndex = 1;
          for (let i = 1; i < lastIndex; ++i) {
            let keep = false;
            const time2 = times[i];
            const timeNext = times[i + 1];
            if (time2 !== timeNext && (i !== 1 || time2 !== times[0])) {
              if (!smoothInterpolation) {
                const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
                for (let j = 0; j !== stride; ++j) {
                  const value = values3[offset + j];
                  if (value !== values3[offsetP + j] || value !== values3[offsetN + j]) {
                    keep = true;
                    break;
                  }
                }
              } else {
                keep = true;
              }
            }
            if (keep) {
              if (i !== writeIndex) {
                times[writeIndex] = times[i];
                const readOffset = i * stride, writeOffset = writeIndex * stride;
                for (let j = 0; j !== stride; ++j) {
                  values3[writeOffset + j] = values3[readOffset + j];
                }
              }
              ++writeIndex;
            }
          }
          if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
              values3[writeOffset + j] = values3[readOffset + j];
            }
            ++writeIndex;
          }
          if (writeIndex !== times.length) {
            this.times = arraySlice(times, 0, writeIndex);
            this.values = arraySlice(values3, 0, writeIndex * stride);
          } else {
            this.times = times;
            this.values = values3;
          }
          return this;
        }
        clone() {
          const times = arraySlice(this.times, 0);
          const values3 = arraySlice(this.values, 0);
          const TypedKeyframeTrack = this.constructor;
          const track = new TypedKeyframeTrack(this.name, times, values3);
          track.createInterpolant = this.createInterpolant;
          return track;
        }
      };
      KeyframeTrack.prototype.TimeBufferType = Float32Array;
      KeyframeTrack.prototype.ValueBufferType = Float32Array;
      KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      BooleanKeyframeTrack = class extends KeyframeTrack {
      };
      BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
      BooleanKeyframeTrack.prototype.ValueBufferType = Array;
      BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      ColorKeyframeTrack = class extends KeyframeTrack {
      };
      ColorKeyframeTrack.prototype.ValueTypeName = "color";
      NumberKeyframeTrack = class extends KeyframeTrack {
      };
      NumberKeyframeTrack.prototype.ValueTypeName = "number";
      QuaternionLinearInterpolant = class extends Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
          const result = this.resultBuffer, values3 = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
          let offset = i1 * stride;
          for (let end = offset + stride; offset !== end; offset += 4) {
            Quaternion.slerpFlat(result, 0, values3, offset - stride, values3, offset, alpha);
          }
          return result;
        }
      };
      QuaternionKeyframeTrack = class extends KeyframeTrack {
        InterpolantFactoryMethodLinear(result) {
          return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
      };
      QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
      QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
      QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      StringKeyframeTrack = class extends KeyframeTrack {
      };
      StringKeyframeTrack.prototype.ValueTypeName = "string";
      StringKeyframeTrack.prototype.ValueBufferType = Array;
      StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
      StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
      VectorKeyframeTrack = class extends KeyframeTrack {
      };
      VectorKeyframeTrack.prototype.ValueTypeName = "vector";
      AnimationClip = class {
        constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
          this.name = name;
          this.tracks = tracks;
          this.duration = duration;
          this.blendMode = blendMode;
          this.uuid = generateUUID();
          if (this.duration < 0) {
            this.resetDuration();
          }
        }
        static parse(json) {
          const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
          for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
            tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
          }
          const clip = new this(json.name, json.duration, tracks, json.blendMode);
          clip.uuid = json.uuid;
          return clip;
        }
        static toJSON(clip) {
          const tracks = [], clipTracks = clip.tracks;
          const json = {
            "name": clip.name,
            "duration": clip.duration,
            "tracks": tracks,
            "uuid": clip.uuid,
            "blendMode": clip.blendMode
          };
          for (let i = 0, n = clipTracks.length; i !== n; ++i) {
            tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
          }
          return json;
        }
        static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
          const numMorphTargets = morphTargetSequence.length;
          const tracks = [];
          for (let i = 0; i < numMorphTargets; i++) {
            let times = [];
            let values3 = [];
            times.push(
              (i + numMorphTargets - 1) % numMorphTargets,
              i,
              (i + 1) % numMorphTargets
            );
            values3.push(0, 1, 0);
            const order = getKeyframeOrder(times);
            times = sortedArray(times, 1, order);
            values3 = sortedArray(values3, 1, order);
            if (!noLoop && times[0] === 0) {
              times.push(numMorphTargets);
              values3.push(values3[0]);
            }
            tracks.push(
              new NumberKeyframeTrack(
                ".morphTargetInfluences[" + morphTargetSequence[i].name + "]",
                times,
                values3
              ).scale(1 / fps)
            );
          }
          return new this(name, -1, tracks);
        }
        static findByName(objectOrClipArray, name) {
          let clipArray = objectOrClipArray;
          if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
          }
          for (let i = 0; i < clipArray.length; i++) {
            if (clipArray[i].name === name) {
              return clipArray[i];
            }
          }
          return null;
        }
        static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
          const animationToMorphTargets = {};
          const pattern = /^([\w-]*?)([\d]+)$/;
          for (let i = 0, il = morphTargets.length; i < il; i++) {
            const morphTarget = morphTargets[i];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
              const name = parts[1];
              let animationMorphTargets = animationToMorphTargets[name];
              if (!animationMorphTargets) {
                animationToMorphTargets[name] = animationMorphTargets = [];
              }
              animationMorphTargets.push(morphTarget);
            }
          }
          const clips = [];
          for (const name in animationToMorphTargets) {
            clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
          }
          return clips;
        }
        static parseAnimation(animation, bones) {
          if (!animation) {
            console.error("THREE.AnimationClip: No animation in JSONLoader data.");
            return null;
          }
          const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            if (animationKeys.length !== 0) {
              const times = [];
              const values3 = [];
              flattenJSON(animationKeys, times, values3, propertyName);
              if (times.length !== 0) {
                destTracks.push(new trackType(trackName, times, values3));
              }
            }
          };
          const tracks = [];
          const clipName = animation.name || "default";
          const fps = animation.fps || 30;
          const blendMode = animation.blendMode;
          let duration = animation.length || -1;
          const hierarchyTracks = animation.hierarchy || [];
          for (let h = 0; h < hierarchyTracks.length; h++) {
            const animationKeys = hierarchyTracks[h].keys;
            if (!animationKeys || animationKeys.length === 0)
              continue;
            if (animationKeys[0].morphTargets) {
              const morphTargetNames = {};
              let k;
              for (k = 0; k < animationKeys.length; k++) {
                if (animationKeys[k].morphTargets) {
                  for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
                    morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                  }
                }
              }
              for (const morphTargetName in morphTargetNames) {
                const times = [];
                const values3 = [];
                for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                  const animationKey = animationKeys[k];
                  times.push(animationKey.time);
                  values3.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                }
                tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values3));
              }
              duration = morphTargetNames.length * fps;
            } else {
              const boneName = ".bones[" + bones[h].name + "]";
              addNonemptyTrack(
                VectorKeyframeTrack,
                boneName + ".position",
                animationKeys,
                "pos",
                tracks
              );
              addNonemptyTrack(
                QuaternionKeyframeTrack,
                boneName + ".quaternion",
                animationKeys,
                "rot",
                tracks
              );
              addNonemptyTrack(
                VectorKeyframeTrack,
                boneName + ".scale",
                animationKeys,
                "scl",
                tracks
              );
            }
          }
          if (tracks.length === 0) {
            return null;
          }
          const clip = new this(clipName, duration, tracks, blendMode);
          return clip;
        }
        resetDuration() {
          const tracks = this.tracks;
          let duration = 0;
          for (let i = 0, n = tracks.length; i !== n; ++i) {
            const track = this.tracks[i];
            duration = Math.max(duration, track.times[track.times.length - 1]);
          }
          this.duration = duration;
          return this;
        }
        trim() {
          for (let i = 0; i < this.tracks.length; i++) {
            this.tracks[i].trim(0, this.duration);
          }
          return this;
        }
        validate() {
          let valid = true;
          for (let i = 0; i < this.tracks.length; i++) {
            valid = valid && this.tracks[i].validate();
          }
          return valid;
        }
        optimize() {
          for (let i = 0; i < this.tracks.length; i++) {
            this.tracks[i].optimize();
          }
          return this;
        }
        clone() {
          const tracks = [];
          for (let i = 0; i < this.tracks.length; i++) {
            tracks.push(this.tracks[i].clone());
          }
          return new this.constructor(this.name, this.duration, tracks, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      };
      Cache = {
        enabled: false,
        files: {},
        add: function(key, file) {
          if (this.enabled === false)
            return;
          this.files[key] = file;
        },
        get: function(key) {
          if (this.enabled === false)
            return;
          return this.files[key];
        },
        remove: function(key) {
          delete this.files[key];
        },
        clear: function() {
          this.files = {};
        }
      };
      LoadingManager = class {
        constructor(onLoad, onProgress, onError) {
          const scope = this;
          let isLoading = false;
          let itemsLoaded = 0;
          let itemsTotal = 0;
          let urlModifier = void 0;
          const handlers = [];
          this.onStart = void 0;
          this.onLoad = onLoad;
          this.onProgress = onProgress;
          this.onError = onError;
          this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
              if (scope.onStart !== void 0) {
                scope.onStart(url, itemsLoaded, itemsTotal);
              }
            }
            isLoading = true;
          };
          this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== void 0) {
              scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
              isLoading = false;
              if (scope.onLoad !== void 0) {
                scope.onLoad();
              }
            }
          };
          this.itemError = function(url) {
            if (scope.onError !== void 0) {
              scope.onError(url);
            }
          };
          this.resolveURL = function(url) {
            if (urlModifier) {
              return urlModifier(url);
            }
            return url;
          };
          this.setURLModifier = function(transform) {
            urlModifier = transform;
            return this;
          };
          this.addHandler = function(regex, loader) {
            handlers.push(regex, loader);
            return this;
          };
          this.removeHandler = function(regex) {
            const index = handlers.indexOf(regex);
            if (index !== -1) {
              handlers.splice(index, 2);
            }
            return this;
          };
          this.getHandler = function(file) {
            for (let i = 0, l = handlers.length; i < l; i += 2) {
              const regex = handlers[i];
              const loader = handlers[i + 1];
              if (regex.global)
                regex.lastIndex = 0;
              if (regex.test(file)) {
                return loader;
              }
            }
            return null;
          };
        }
      };
      DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
      Loader = class {
        constructor(manager) {
          this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
          this.crossOrigin = "anonymous";
          this.withCredentials = false;
          this.path = "";
          this.resourcePath = "";
          this.requestHeader = {};
        }
        load() {
        }
        loadAsync(url, onProgress) {
          const scope = this;
          return new Promise(function(resolve, reject) {
            scope.load(url, resolve, onProgress, reject);
          });
        }
        parse() {
        }
        setCrossOrigin(crossOrigin) {
          this.crossOrigin = crossOrigin;
          return this;
        }
        setWithCredentials(value) {
          this.withCredentials = value;
          return this;
        }
        setPath(path) {
          this.path = path;
          return this;
        }
        setResourcePath(resourcePath) {
          this.resourcePath = resourcePath;
          return this;
        }
        setRequestHeader(requestHeader) {
          this.requestHeader = requestHeader;
          return this;
        }
      };
      loading = {};
      HttpError = class extends Error {
        constructor(message, response) {
          super(message);
          this.response = response;
        }
      };
      FileLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const cached = Cache.get(url);
          if (cached !== void 0) {
            this.manager.itemStart(url);
            setTimeout(() => {
              if (onLoad)
                onLoad(cached);
              this.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          if (loading[url] !== void 0) {
            loading[url].push({
              onLoad,
              onProgress,
              onError
            });
            return;
          }
          loading[url] = [];
          loading[url].push({
            onLoad,
            onProgress,
            onError
          });
          const req = new Request(url, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
          });
          const mimeType = this.mimeType;
          const responseType = this.responseType;
          fetch(req).then((response) => {
            if (response.status === 200 || response.status === 0) {
              if (response.status === 0) {
                console.warn("THREE.FileLoader: HTTP Status 0 received.");
              }
              if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
                return response;
              }
              const callbacks = loading[url];
              const reader = response.body.getReader();
              const contentLength = response.headers.get("Content-Length") || response.headers.get("X-File-Size");
              const total = contentLength ? parseInt(contentLength) : 0;
              const lengthComputable = total !== 0;
              let loaded = 0;
              const stream = new ReadableStream({
                start(controller) {
                  readData();
                  function readData() {
                    reader.read().then(({ done, value }) => {
                      if (done) {
                        controller.close();
                      } else {
                        loaded += value.byteLength;
                        const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                        for (let i = 0, il = callbacks.length; i < il; i++) {
                          const callback = callbacks[i];
                          if (callback.onProgress)
                            callback.onProgress(event);
                        }
                        controller.enqueue(value);
                        readData();
                      }
                    });
                  }
                }
              });
              return new Response(stream);
            } else {
              throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
            }
          }).then((response) => {
            switch (responseType) {
              case "arraybuffer":
                return response.arrayBuffer();
              case "blob":
                return response.blob();
              case "document":
                return response.text().then((text) => {
                  const parser = new DOMParser();
                  return parser.parseFromString(text, mimeType);
                });
              case "json":
                return response.json();
              default:
                if (mimeType === void 0) {
                  return response.text();
                } else {
                  const re = /charset="?([^;"\s]*)"?/i;
                  const exec = re.exec(mimeType);
                  const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
                  const decoder = new TextDecoder(label);
                  return response.arrayBuffer().then((ab) => decoder.decode(ab));
                }
            }
          }).then((data) => {
            Cache.add(url, data);
            const callbacks = loading[url];
            delete loading[url];
            for (let i = 0, il = callbacks.length; i < il; i++) {
              const callback = callbacks[i];
              if (callback.onLoad)
                callback.onLoad(data);
            }
          }).catch((err) => {
            const callbacks = loading[url];
            if (callbacks === void 0) {
              this.manager.itemError(url);
              throw err;
            }
            delete loading[url];
            for (let i = 0, il = callbacks.length; i < il; i++) {
              const callback = callbacks[i];
              if (callback.onError)
                callback.onError(err);
            }
            this.manager.itemError(url);
          }).finally(() => {
            this.manager.itemEnd(url);
          });
          this.manager.itemStart(url);
        }
        setResponseType(value) {
          this.responseType = value;
          return this;
        }
        setMimeType(value) {
          this.mimeType = value;
          return this;
        }
      };
      AnimationLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const animations = [];
          for (let i = 0; i < json.length; i++) {
            const clip = AnimationClip.parse(json[i]);
            animations.push(clip);
          }
          return animations;
        }
      };
      CompressedTextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const images = [];
          const texture = new CompressedTexture();
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          let loaded = 0;
          function loadTexture(i) {
            loader.load(url[i], function(buffer) {
              const texDatas = scope.parse(buffer, true);
              images[i] = {
                width: texDatas.width,
                height: texDatas.height,
                format: texDatas.format,
                mipmaps: texDatas.mipmaps
              };
              loaded += 1;
              if (loaded === 6) {
                if (texDatas.mipmapCount === 1)
                  texture.minFilter = LinearFilter;
                texture.image = images;
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, onProgress, onError);
          }
          if (Array.isArray(url)) {
            for (let i = 0, il = url.length; i < il; ++i) {
              loadTexture(i);
            }
          } else {
            loader.load(url, function(buffer) {
              const texDatas = scope.parse(buffer, true);
              if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for (let f = 0; f < faces; f++) {
                  images[f] = { mipmaps: [] };
                  for (let i = 0; i < texDatas.mipmapCount; i++) {
                    images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                    images[f].format = texDatas.format;
                    images[f].width = texDatas.width;
                    images[f].height = texDatas.height;
                  }
                }
                texture.image = images;
              } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
              }
              if (texDatas.mipmapCount === 1) {
                texture.minFilter = LinearFilter;
              }
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }, onProgress, onError);
          }
          return texture;
        }
      };
      ImageLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const image = createElementNS("img");
          function onImageLoad() {
            removeEventListeners();
            Cache.add(url, this);
            if (onLoad)
              onLoad(this);
            scope.manager.itemEnd(url);
          }
          function onImageError(event) {
            removeEventListeners();
            if (onError)
              onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
          function removeEventListeners() {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
          }
          image.addEventListener("load", onImageLoad, false);
          image.addEventListener("error", onImageError, false);
          if (url.slice(0, 5) !== "data:") {
            if (this.crossOrigin !== void 0)
              image.crossOrigin = this.crossOrigin;
          }
          scope.manager.itemStart(url);
          image.src = url;
          return image;
        }
      };
      CubeTextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(urls, onLoad, onProgress, onError) {
          const texture = new CubeTexture();
          const loader = new ImageLoader(this.manager);
          loader.setCrossOrigin(this.crossOrigin);
          loader.setPath(this.path);
          let loaded = 0;
          function loadTexture(i) {
            loader.load(urls[i], function(image) {
              texture.images[i] = image;
              loaded++;
              if (loaded === 6) {
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, void 0, onError);
          }
          for (let i = 0; i < urls.length; ++i) {
            loadTexture(i);
          }
          return texture;
        }
      };
      DataTextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const texture = new DataTexture();
          const loader = new FileLoader(this.manager);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          loader.setPath(this.path);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(buffer) {
            const texData = scope.parse(buffer);
            if (!texData)
              return;
            if (texData.image !== void 0) {
              texture.image = texData.image;
            } else if (texData.data !== void 0) {
              texture.image.width = texData.width;
              texture.image.height = texData.height;
              texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
            texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
            texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
            texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
            texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
            if (texData.encoding !== void 0) {
              texture.encoding = texData.encoding;
            }
            if (texData.flipY !== void 0) {
              texture.flipY = texData.flipY;
            }
            if (texData.format !== void 0) {
              texture.format = texData.format;
            }
            if (texData.type !== void 0) {
              texture.type = texData.type;
            }
            if (texData.mipmaps !== void 0) {
              texture.mipmaps = texData.mipmaps;
              texture.minFilter = LinearMipmapLinearFilter;
            }
            if (texData.mipmapCount === 1) {
              texture.minFilter = LinearFilter;
            }
            if (texData.generateMipmaps !== void 0) {
              texture.generateMipmaps = texData.generateMipmaps;
            }
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture, texData);
          }, onProgress, onError);
          return texture;
        }
      };
      TextureLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const texture = new Texture();
          const loader = new ImageLoader(this.manager);
          loader.setCrossOrigin(this.crossOrigin);
          loader.setPath(this.path);
          loader.load(url, function(image) {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad !== void 0) {
              onLoad(texture);
            }
          }, onProgress, onError);
          return texture;
        }
      };
      Light = class extends Object3D {
        constructor(color, intensity = 1) {
          super();
          this.isLight = true;
          this.type = "Light";
          this.color = new Color(color);
          this.intensity = intensity;
        }
        dispose() {
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.color.copy(source.color);
          this.intensity = source.intensity;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.color = this.color.getHex();
          data.object.intensity = this.intensity;
          if (this.groundColor !== void 0)
            data.object.groundColor = this.groundColor.getHex();
          if (this.distance !== void 0)
            data.object.distance = this.distance;
          if (this.angle !== void 0)
            data.object.angle = this.angle;
          if (this.decay !== void 0)
            data.object.decay = this.decay;
          if (this.penumbra !== void 0)
            data.object.penumbra = this.penumbra;
          if (this.shadow !== void 0)
            data.object.shadow = this.shadow.toJSON();
          return data;
        }
      };
      HemisphereLight = class extends Light {
        constructor(skyColor, groundColor, intensity) {
          super(skyColor, intensity);
          this.isHemisphereLight = true;
          this.type = "HemisphereLight";
          this.position.copy(Object3D.DEFAULT_UP);
          this.updateMatrix();
          this.groundColor = new Color(groundColor);
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.groundColor.copy(source.groundColor);
          return this;
        }
      };
      _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
      _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
      _lookTarget$1 = /* @__PURE__ */ new Vector3();
      LightShadow = class {
        constructor(camera) {
          this.camera = camera;
          this.bias = 0;
          this.normalBias = 0;
          this.radius = 1;
          this.blurSamples = 8;
          this.mapSize = new Vector2(512, 512);
          this.map = null;
          this.mapPass = null;
          this.matrix = new Matrix4();
          this.autoUpdate = true;
          this.needsUpdate = false;
          this._frustum = new Frustum();
          this._frameExtents = new Vector2(1, 1);
          this._viewportCount = 1;
          this._viewports = [
            new Vector4(0, 0, 1, 1)
          ];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(light) {
          const shadowCamera = this.camera;
          const shadowMatrix = this.matrix;
          _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
          shadowCamera.position.copy(_lightPositionWorld$1);
          _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
          shadowCamera.lookAt(_lookTarget$1);
          shadowCamera.updateMatrixWorld();
          _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
          shadowMatrix.set(
            0.5,
            0,
            0,
            0.5,
            0,
            0.5,
            0,
            0.5,
            0,
            0,
            0.5,
            0.5,
            0,
            0,
            0,
            1
          );
          shadowMatrix.multiply(_projScreenMatrix$1);
        }
        getViewport(viewportIndex) {
          return this._viewports[viewportIndex];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          if (this.map) {
            this.map.dispose();
          }
          if (this.mapPass) {
            this.mapPass.dispose();
          }
        }
        copy(source) {
          this.camera = source.camera.clone();
          this.bias = source.bias;
          this.radius = source.radius;
          this.mapSize.copy(source.mapSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const object = {};
          if (this.bias !== 0)
            object.bias = this.bias;
          if (this.normalBias !== 0)
            object.normalBias = this.normalBias;
          if (this.radius !== 1)
            object.radius = this.radius;
          if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
            object.mapSize = this.mapSize.toArray();
          object.camera = this.camera.toJSON(false).object;
          delete object.camera.matrix;
          return object;
        }
      };
      SpotLightShadow = class extends LightShadow {
        constructor() {
          super(new PerspectiveCamera(50, 1, 0.5, 500));
          this.isSpotLightShadow = true;
          this.focus = 1;
        }
        updateMatrices(light) {
          const camera = this.camera;
          const fov2 = RAD2DEG * 2 * light.angle * this.focus;
          const aspect2 = this.mapSize.width / this.mapSize.height;
          const far = light.distance || camera.far;
          if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
            camera.fov = fov2;
            camera.aspect = aspect2;
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          super.updateMatrices(light);
        }
        copy(source) {
          super.copy(source);
          this.focus = source.focus;
          return this;
        }
      };
      SpotLight = class extends Light {
        constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
          super(color, intensity);
          this.isSpotLight = true;
          this.type = "SpotLight";
          this.position.copy(Object3D.DEFAULT_UP);
          this.updateMatrix();
          this.target = new Object3D();
          this.distance = distance;
          this.angle = angle;
          this.penumbra = penumbra;
          this.decay = decay;
          this.map = null;
          this.shadow = new SpotLightShadow();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(power) {
          this.intensity = power / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.distance = source.distance;
          this.angle = source.angle;
          this.penumbra = source.penumbra;
          this.decay = source.decay;
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      _projScreenMatrix = /* @__PURE__ */ new Matrix4();
      _lightPositionWorld = /* @__PURE__ */ new Vector3();
      _lookTarget = /* @__PURE__ */ new Vector3();
      PointLightShadow = class extends LightShadow {
        constructor() {
          super(new PerspectiveCamera(90, 1, 0.5, 500));
          this.isPointLightShadow = true;
          this._frameExtents = new Vector2(4, 2);
          this._viewportCount = 6;
          this._viewports = [
            new Vector4(2, 1, 1, 1),
            new Vector4(0, 1, 1, 1),
            new Vector4(3, 1, 1, 1),
            new Vector4(1, 1, 1, 1),
            new Vector4(3, 0, 1, 1),
            new Vector4(1, 0, 1, 1)
          ];
          this._cubeDirections = [
            new Vector3(1, 0, 0),
            new Vector3(-1, 0, 0),
            new Vector3(0, 0, 1),
            new Vector3(0, 0, -1),
            new Vector3(0, 1, 0),
            new Vector3(0, -1, 0)
          ];
          this._cubeUps = [
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 0, 1),
            new Vector3(0, 0, -1)
          ];
        }
        updateMatrices(light, viewportIndex = 0) {
          const camera = this.camera;
          const shadowMatrix = this.matrix;
          const far = light.distance || camera.far;
          if (far !== camera.far) {
            camera.far = far;
            camera.updateProjectionMatrix();
          }
          _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
          camera.position.copy(_lightPositionWorld);
          _lookTarget.copy(camera.position);
          _lookTarget.add(this._cubeDirections[viewportIndex]);
          camera.up.copy(this._cubeUps[viewportIndex]);
          camera.lookAt(_lookTarget);
          camera.updateMatrixWorld();
          shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
          _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          this._frustum.setFromProjectionMatrix(_projScreenMatrix);
        }
      };
      PointLight = class extends Light {
        constructor(color, intensity, distance = 0, decay = 2) {
          super(color, intensity);
          this.isPointLight = true;
          this.type = "PointLight";
          this.distance = distance;
          this.decay = decay;
          this.shadow = new PointLightShadow();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(power) {
          this.intensity = power / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.distance = source.distance;
          this.decay = source.decay;
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      DirectionalLightShadow = class extends LightShadow {
        constructor() {
          super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
          this.isDirectionalLightShadow = true;
        }
      };
      DirectionalLight = class extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.isDirectionalLight = true;
          this.type = "DirectionalLight";
          this.position.copy(Object3D.DEFAULT_UP);
          this.updateMatrix();
          this.target = new Object3D();
          this.shadow = new DirectionalLightShadow();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(source) {
          super.copy(source);
          this.target = source.target.clone();
          this.shadow = source.shadow.clone();
          return this;
        }
      };
      AmbientLight = class extends Light {
        constructor(color, intensity) {
          super(color, intensity);
          this.isAmbientLight = true;
          this.type = "AmbientLight";
        }
      };
      RectAreaLight = class extends Light {
        constructor(color, intensity, width2 = 10, height2 = 10) {
          super(color, intensity);
          this.isRectAreaLight = true;
          this.type = "RectAreaLight";
          this.width = width2;
          this.height = height2;
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(power) {
          this.intensity = power / (this.width * this.height * Math.PI);
        }
        copy(source) {
          super.copy(source);
          this.width = source.width;
          this.height = source.height;
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.width = this.width;
          data.object.height = this.height;
          return data;
        }
      };
      SphericalHarmonics3 = class {
        constructor() {
          this.isSphericalHarmonics3 = true;
          this.coefficients = [];
          for (let i = 0; i < 9; i++) {
            this.coefficients.push(new Vector3());
          }
        }
        set(coefficients) {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].copy(coefficients[i]);
          }
          return this;
        }
        zero() {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].set(0, 0, 0);
          }
          return this;
        }
        getAt(normal, target) {
          const x = normal.x, y = normal.y, z = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.282095);
          target.addScaledVector(coeff[1], 0.488603 * y);
          target.addScaledVector(coeff[2], 0.488603 * z);
          target.addScaledVector(coeff[3], 0.488603 * x);
          target.addScaledVector(coeff[4], 1.092548 * (x * y));
          target.addScaledVector(coeff[5], 1.092548 * (y * z));
          target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
          target.addScaledVector(coeff[7], 1.092548 * (x * z));
          target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
          return target;
        }
        getIrradianceAt(normal, target) {
          const x = normal.x, y = normal.y, z = normal.z;
          const coeff = this.coefficients;
          target.copy(coeff[0]).multiplyScalar(0.886227);
          target.addScaledVector(coeff[1], 2 * 0.511664 * y);
          target.addScaledVector(coeff[2], 2 * 0.511664 * z);
          target.addScaledVector(coeff[3], 2 * 0.511664 * x);
          target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
          target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
          target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
          target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
          target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
          return target;
        }
        add(sh) {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].add(sh.coefficients[i]);
          }
          return this;
        }
        addScaledSH(sh, s) {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].addScaledVector(sh.coefficients[i], s);
          }
          return this;
        }
        scale(s) {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].multiplyScalar(s);
          }
          return this;
        }
        lerp(sh, alpha) {
          for (let i = 0; i < 9; i++) {
            this.coefficients[i].lerp(sh.coefficients[i], alpha);
          }
          return this;
        }
        equals(sh) {
          for (let i = 0; i < 9; i++) {
            if (!this.coefficients[i].equals(sh.coefficients[i])) {
              return false;
            }
          }
          return true;
        }
        copy(sh) {
          return this.set(sh.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(array, offset = 0) {
          const coefficients = this.coefficients;
          for (let i = 0; i < 9; i++) {
            coefficients[i].fromArray(array, offset + i * 3);
          }
          return this;
        }
        toArray(array = [], offset = 0) {
          const coefficients = this.coefficients;
          for (let i = 0; i < 9; i++) {
            coefficients[i].toArray(array, offset + i * 3);
          }
          return array;
        }
        static getBasisAt(normal, shBasis) {
          const x = normal.x, y = normal.y, z = normal.z;
          shBasis[0] = 0.282095;
          shBasis[1] = 0.488603 * y;
          shBasis[2] = 0.488603 * z;
          shBasis[3] = 0.488603 * x;
          shBasis[4] = 1.092548 * x * y;
          shBasis[5] = 1.092548 * y * z;
          shBasis[6] = 0.315392 * (3 * z * z - 1);
          shBasis[7] = 1.092548 * x * z;
          shBasis[8] = 0.546274 * (x * x - y * y);
        }
      };
      LightProbe = class extends Light {
        constructor(sh = new SphericalHarmonics3(), intensity = 1) {
          super(void 0, intensity);
          this.isLightProbe = true;
          this.sh = sh;
        }
        copy(source) {
          super.copy(source);
          this.sh.copy(source.sh);
          return this;
        }
        fromJSON(json) {
          this.intensity = json.intensity;
          this.sh.fromArray(json.sh);
          return this;
        }
        toJSON(meta) {
          const data = super.toJSON(meta);
          data.object.sh = this.sh.toArray();
          return data;
        }
      };
      MaterialLoader = class extends Loader {
        constructor(manager) {
          super(manager);
          this.textures = {};
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.setRequestHeader(scope.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const textures = this.textures;
          function getTexture(name) {
            if (textures[name] === void 0) {
              console.warn("THREE.MaterialLoader: Undefined texture", name);
            }
            return textures[name];
          }
          const material = MaterialLoader.createMaterialFromType(json.type);
          if (json.uuid !== void 0)
            material.uuid = json.uuid;
          if (json.name !== void 0)
            material.name = json.name;
          if (json.color !== void 0 && material.color !== void 0)
            material.color.setHex(json.color);
          if (json.roughness !== void 0)
            material.roughness = json.roughness;
          if (json.metalness !== void 0)
            material.metalness = json.metalness;
          if (json.sheen !== void 0)
            material.sheen = json.sheen;
          if (json.sheenColor !== void 0)
            material.sheenColor = new Color().setHex(json.sheenColor);
          if (json.sheenRoughness !== void 0)
            material.sheenRoughness = json.sheenRoughness;
          if (json.emissive !== void 0 && material.emissive !== void 0)
            material.emissive.setHex(json.emissive);
          if (json.specular !== void 0 && material.specular !== void 0)
            material.specular.setHex(json.specular);
          if (json.specularIntensity !== void 0)
            material.specularIntensity = json.specularIntensity;
          if (json.specularColor !== void 0 && material.specularColor !== void 0)
            material.specularColor.setHex(json.specularColor);
          if (json.shininess !== void 0)
            material.shininess = json.shininess;
          if (json.clearcoat !== void 0)
            material.clearcoat = json.clearcoat;
          if (json.clearcoatRoughness !== void 0)
            material.clearcoatRoughness = json.clearcoatRoughness;
          if (json.iridescence !== void 0)
            material.iridescence = json.iridescence;
          if (json.iridescenceIOR !== void 0)
            material.iridescenceIOR = json.iridescenceIOR;
          if (json.iridescenceThicknessRange !== void 0)
            material.iridescenceThicknessRange = json.iridescenceThicknessRange;
          if (json.transmission !== void 0)
            material.transmission = json.transmission;
          if (json.thickness !== void 0)
            material.thickness = json.thickness;
          if (json.attenuationDistance !== void 0)
            material.attenuationDistance = json.attenuationDistance;
          if (json.attenuationColor !== void 0 && material.attenuationColor !== void 0)
            material.attenuationColor.setHex(json.attenuationColor);
          if (json.fog !== void 0)
            material.fog = json.fog;
          if (json.flatShading !== void 0)
            material.flatShading = json.flatShading;
          if (json.blending !== void 0)
            material.blending = json.blending;
          if (json.combine !== void 0)
            material.combine = json.combine;
          if (json.side !== void 0)
            material.side = json.side;
          if (json.shadowSide !== void 0)
            material.shadowSide = json.shadowSide;
          if (json.opacity !== void 0)
            material.opacity = json.opacity;
          if (json.transparent !== void 0)
            material.transparent = json.transparent;
          if (json.alphaTest !== void 0)
            material.alphaTest = json.alphaTest;
          if (json.depthTest !== void 0)
            material.depthTest = json.depthTest;
          if (json.depthWrite !== void 0)
            material.depthWrite = json.depthWrite;
          if (json.colorWrite !== void 0)
            material.colorWrite = json.colorWrite;
          if (json.stencilWrite !== void 0)
            material.stencilWrite = json.stencilWrite;
          if (json.stencilWriteMask !== void 0)
            material.stencilWriteMask = json.stencilWriteMask;
          if (json.stencilFunc !== void 0)
            material.stencilFunc = json.stencilFunc;
          if (json.stencilRef !== void 0)
            material.stencilRef = json.stencilRef;
          if (json.stencilFuncMask !== void 0)
            material.stencilFuncMask = json.stencilFuncMask;
          if (json.stencilFail !== void 0)
            material.stencilFail = json.stencilFail;
          if (json.stencilZFail !== void 0)
            material.stencilZFail = json.stencilZFail;
          if (json.stencilZPass !== void 0)
            material.stencilZPass = json.stencilZPass;
          if (json.wireframe !== void 0)
            material.wireframe = json.wireframe;
          if (json.wireframeLinewidth !== void 0)
            material.wireframeLinewidth = json.wireframeLinewidth;
          if (json.wireframeLinecap !== void 0)
            material.wireframeLinecap = json.wireframeLinecap;
          if (json.wireframeLinejoin !== void 0)
            material.wireframeLinejoin = json.wireframeLinejoin;
          if (json.rotation !== void 0)
            material.rotation = json.rotation;
          if (json.linewidth !== 1)
            material.linewidth = json.linewidth;
          if (json.dashSize !== void 0)
            material.dashSize = json.dashSize;
          if (json.gapSize !== void 0)
            material.gapSize = json.gapSize;
          if (json.scale !== void 0)
            material.scale = json.scale;
          if (json.polygonOffset !== void 0)
            material.polygonOffset = json.polygonOffset;
          if (json.polygonOffsetFactor !== void 0)
            material.polygonOffsetFactor = json.polygonOffsetFactor;
          if (json.polygonOffsetUnits !== void 0)
            material.polygonOffsetUnits = json.polygonOffsetUnits;
          if (json.dithering !== void 0)
            material.dithering = json.dithering;
          if (json.alphaToCoverage !== void 0)
            material.alphaToCoverage = json.alphaToCoverage;
          if (json.premultipliedAlpha !== void 0)
            material.premultipliedAlpha = json.premultipliedAlpha;
          if (json.forceSinglePass !== void 0)
            material.forceSinglePass = json.forceSinglePass;
          if (json.visible !== void 0)
            material.visible = json.visible;
          if (json.toneMapped !== void 0)
            material.toneMapped = json.toneMapped;
          if (json.userData !== void 0)
            material.userData = json.userData;
          if (json.vertexColors !== void 0) {
            if (typeof json.vertexColors === "number") {
              material.vertexColors = json.vertexColors > 0 ? true : false;
            } else {
              material.vertexColors = json.vertexColors;
            }
          }
          if (json.uniforms !== void 0) {
            for (const name in json.uniforms) {
              const uniform = json.uniforms[name];
              material.uniforms[name] = {};
              switch (uniform.type) {
                case "t":
                  material.uniforms[name].value = getTexture(uniform.value);
                  break;
                case "c":
                  material.uniforms[name].value = new Color().setHex(uniform.value);
                  break;
                case "v2":
                  material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                  break;
                case "v3":
                  material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                  break;
                case "v4":
                  material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                  break;
                case "m3":
                  material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                  break;
                case "m4":
                  material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                  break;
                default:
                  material.uniforms[name].value = uniform.value;
              }
            }
          }
          if (json.defines !== void 0)
            material.defines = json.defines;
          if (json.vertexShader !== void 0)
            material.vertexShader = json.vertexShader;
          if (json.fragmentShader !== void 0)
            material.fragmentShader = json.fragmentShader;
          if (json.glslVersion !== void 0)
            material.glslVersion = json.glslVersion;
          if (json.extensions !== void 0) {
            for (const key in json.extensions) {
              material.extensions[key] = json.extensions[key];
            }
          }
          if (json.size !== void 0)
            material.size = json.size;
          if (json.sizeAttenuation !== void 0)
            material.sizeAttenuation = json.sizeAttenuation;
          if (json.map !== void 0)
            material.map = getTexture(json.map);
          if (json.matcap !== void 0)
            material.matcap = getTexture(json.matcap);
          if (json.alphaMap !== void 0)
            material.alphaMap = getTexture(json.alphaMap);
          if (json.bumpMap !== void 0)
            material.bumpMap = getTexture(json.bumpMap);
          if (json.bumpScale !== void 0)
            material.bumpScale = json.bumpScale;
          if (json.normalMap !== void 0)
            material.normalMap = getTexture(json.normalMap);
          if (json.normalMapType !== void 0)
            material.normalMapType = json.normalMapType;
          if (json.normalScale !== void 0) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) {
              normalScale = [normalScale, normalScale];
            }
            material.normalScale = new Vector2().fromArray(normalScale);
          }
          if (json.displacementMap !== void 0)
            material.displacementMap = getTexture(json.displacementMap);
          if (json.displacementScale !== void 0)
            material.displacementScale = json.displacementScale;
          if (json.displacementBias !== void 0)
            material.displacementBias = json.displacementBias;
          if (json.roughnessMap !== void 0)
            material.roughnessMap = getTexture(json.roughnessMap);
          if (json.metalnessMap !== void 0)
            material.metalnessMap = getTexture(json.metalnessMap);
          if (json.emissiveMap !== void 0)
            material.emissiveMap = getTexture(json.emissiveMap);
          if (json.emissiveIntensity !== void 0)
            material.emissiveIntensity = json.emissiveIntensity;
          if (json.specularMap !== void 0)
            material.specularMap = getTexture(json.specularMap);
          if (json.specularIntensityMap !== void 0)
            material.specularIntensityMap = getTexture(json.specularIntensityMap);
          if (json.specularColorMap !== void 0)
            material.specularColorMap = getTexture(json.specularColorMap);
          if (json.envMap !== void 0)
            material.envMap = getTexture(json.envMap);
          if (json.envMapIntensity !== void 0)
            material.envMapIntensity = json.envMapIntensity;
          if (json.reflectivity !== void 0)
            material.reflectivity = json.reflectivity;
          if (json.refractionRatio !== void 0)
            material.refractionRatio = json.refractionRatio;
          if (json.lightMap !== void 0)
            material.lightMap = getTexture(json.lightMap);
          if (json.lightMapIntensity !== void 0)
            material.lightMapIntensity = json.lightMapIntensity;
          if (json.aoMap !== void 0)
            material.aoMap = getTexture(json.aoMap);
          if (json.aoMapIntensity !== void 0)
            material.aoMapIntensity = json.aoMapIntensity;
          if (json.gradientMap !== void 0)
            material.gradientMap = getTexture(json.gradientMap);
          if (json.clearcoatMap !== void 0)
            material.clearcoatMap = getTexture(json.clearcoatMap);
          if (json.clearcoatRoughnessMap !== void 0)
            material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
          if (json.clearcoatNormalMap !== void 0)
            material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
          if (json.clearcoatNormalScale !== void 0)
            material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
          if (json.iridescenceMap !== void 0)
            material.iridescenceMap = getTexture(json.iridescenceMap);
          if (json.iridescenceThicknessMap !== void 0)
            material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
          if (json.transmissionMap !== void 0)
            material.transmissionMap = getTexture(json.transmissionMap);
          if (json.thicknessMap !== void 0)
            material.thicknessMap = getTexture(json.thicknessMap);
          if (json.sheenColorMap !== void 0)
            material.sheenColorMap = getTexture(json.sheenColorMap);
          if (json.sheenRoughnessMap !== void 0)
            material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
          return material;
        }
        setTextures(value) {
          this.textures = value;
          return this;
        }
        static createMaterialFromType(type3) {
          const materialLib = {
            ShadowMaterial,
            SpriteMaterial,
            RawShaderMaterial,
            ShaderMaterial,
            PointsMaterial,
            MeshPhysicalMaterial,
            MeshStandardMaterial,
            MeshPhongMaterial,
            MeshToonMaterial,
            MeshNormalMaterial,
            MeshLambertMaterial,
            MeshDepthMaterial,
            MeshDistanceMaterial,
            MeshBasicMaterial,
            MeshMatcapMaterial,
            LineDashedMaterial,
            LineBasicMaterial,
            Material
          };
          return new materialLib[type3]();
        }
      };
      LoaderUtils = class {
        static decodeText(array) {
          if (typeof TextDecoder !== "undefined") {
            return new TextDecoder().decode(array);
          }
          let s = "";
          for (let i = 0, il = array.length; i < il; i++) {
            s += String.fromCharCode(array[i]);
          }
          try {
            return decodeURIComponent(escape(s));
          } catch (e) {
            return s;
          }
        }
        static extractUrlBase(url) {
          const index = url.lastIndexOf("/");
          if (index === -1)
            return "./";
          return url.slice(0, index + 1);
        }
        static resolveURL(url, path) {
          if (typeof url !== "string" || url === "")
            return "";
          if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
            path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
          }
          if (/^(https?:)?\/\//i.test(url))
            return url;
          if (/^data:.*,.*$/i.test(url))
            return url;
          if (/^blob:.*$/i.test(url))
            return url;
          return path + url;
        }
      };
      InstancedBufferGeometry = class extends BufferGeometry {
        constructor() {
          super();
          this.isInstancedBufferGeometry = true;
          this.type = "InstancedBufferGeometry";
          this.instanceCount = Infinity;
        }
        copy(source) {
          super.copy(source);
          this.instanceCount = source.instanceCount;
          return this;
        }
        toJSON() {
          const data = super.toJSON();
          data.instanceCount = this.instanceCount;
          data.isInstancedBufferGeometry = true;
          return data;
        }
      };
      BufferGeometryLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.setRequestHeader(scope.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(json) {
          const interleavedBufferMap = {};
          const arrayBufferMap = {};
          function getInterleavedBuffer(json2, uuid) {
            if (interleavedBufferMap[uuid] !== void 0)
              return interleavedBufferMap[uuid];
            const interleavedBuffers = json2.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
            const array = getTypedArray(interleavedBuffer.type, buffer);
            const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
          }
          function getArrayBuffer(json2, uuid) {
            if (arrayBufferMap[uuid] !== void 0)
              return arrayBufferMap[uuid];
            const arrayBuffers = json2.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
          }
          const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
          const index = json.data.index;
          if (index !== void 0) {
            const typedArray = getTypedArray(index.type, index.array);
            geometry.setIndex(new BufferAttribute(typedArray, 1));
          }
          const attributes = json.data.attributes;
          for (const key in attributes) {
            const attribute = attributes[key];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
              const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
              bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
              const typedArray = getTypedArray(attribute.type, attribute.array);
              const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
              bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== void 0)
              bufferAttribute.name = attribute.name;
            if (attribute.usage !== void 0)
              bufferAttribute.setUsage(attribute.usage);
            if (attribute.updateRange !== void 0) {
              bufferAttribute.updateRange.offset = attribute.updateRange.offset;
              bufferAttribute.updateRange.count = attribute.updateRange.count;
            }
            geometry.setAttribute(key, bufferAttribute);
          }
          const morphAttributes = json.data.morphAttributes;
          if (morphAttributes) {
            for (const key in morphAttributes) {
              const attributeArray = morphAttributes[key];
              const array = [];
              for (let i = 0, il = attributeArray.length; i < il; i++) {
                const attribute = attributeArray[i];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                  const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                  bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                  const typedArray = getTypedArray(attribute.type, attribute.array);
                  bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== void 0)
                  bufferAttribute.name = attribute.name;
                array.push(bufferAttribute);
              }
              geometry.morphAttributes[key] = array;
            }
          }
          const morphTargetsRelative = json.data.morphTargetsRelative;
          if (morphTargetsRelative) {
            geometry.morphTargetsRelative = true;
          }
          const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
          if (groups !== void 0) {
            for (let i = 0, n = groups.length; i !== n; ++i) {
              const group = groups[i];
              geometry.addGroup(group.start, group.count, group.materialIndex);
            }
          }
          const boundingSphere = json.data.boundingSphere;
          if (boundingSphere !== void 0) {
            const center = new Vector3();
            if (boundingSphere.center !== void 0) {
              center.fromArray(boundingSphere.center);
            }
            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
          }
          if (json.name)
            geometry.name = json.name;
          if (json.userData)
            geometry.userData = json.userData;
          return geometry;
        }
      };
      ObjectLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(text) {
            let json = null;
            try {
              json = JSON.parse(text);
            } catch (error) {
              if (onError !== void 0)
                onError(error);
              console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
              return;
            }
            const metadata = json.metadata;
            if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
              if (onError !== void 0)
                onError(new Error("THREE.ObjectLoader: Can't load " + url));
              console.error("THREE.ObjectLoader: Can't load " + url);
              return;
            }
            scope.parse(json, onLoad);
          }, onProgress, onError);
        }
        async loadAsync(url, onProgress) {
          const scope = this;
          const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          const loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          const text = await loader.loadAsync(url, onProgress);
          const json = JSON.parse(text);
          const metadata = json.metadata;
          if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
            throw new Error("THREE.ObjectLoader: Can't load " + url);
          }
          return await scope.parseAsync(json);
        }
        parse(json, onLoad) {
          const animations = this.parseAnimations(json.animations);
          const shapes = this.parseShapes(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);
          const images = this.parseImages(json.images, function() {
            if (onLoad !== void 0)
              onLoad(object);
          });
          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);
          const object = this.parseObject(json.object, geometries, materials, textures, animations);
          const skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          if (onLoad !== void 0) {
            let hasImages = false;
            for (const uuid in images) {
              if (images[uuid].data instanceof HTMLImageElement) {
                hasImages = true;
                break;
              }
            }
            if (hasImages === false)
              onLoad(object);
          }
          return object;
        }
        async parseAsync(json) {
          const animations = this.parseAnimations(json.animations);
          const shapes = this.parseShapes(json.shapes);
          const geometries = this.parseGeometries(json.geometries, shapes);
          const images = await this.parseImagesAsync(json.images);
          const textures = this.parseTextures(json.textures, images);
          const materials = this.parseMaterials(json.materials, textures);
          const object = this.parseObject(json.object, geometries, materials, textures, animations);
          const skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          return object;
        }
        parseShapes(json) {
          const shapes = {};
          if (json !== void 0) {
            for (let i = 0, l = json.length; i < l; i++) {
              const shape = new Shape().fromJSON(json[i]);
              shapes[shape.uuid] = shape;
            }
          }
          return shapes;
        }
        parseSkeletons(json, object) {
          const skeletons = {};
          const bones = {};
          object.traverse(function(child) {
            if (child.isBone)
              bones[child.uuid] = child;
          });
          if (json !== void 0) {
            for (let i = 0, l = json.length; i < l; i++) {
              const skeleton = new Skeleton().fromJSON(json[i], bones);
              skeletons[skeleton.uuid] = skeleton;
            }
          }
          return skeletons;
        }
        parseGeometries(json, shapes) {
          const geometries = {};
          if (json !== void 0) {
            const bufferGeometryLoader = new BufferGeometryLoader();
            for (let i = 0, l = json.length; i < l; i++) {
              let geometry;
              const data = json[i];
              switch (data.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  geometry = bufferGeometryLoader.parse(data);
                  break;
                default:
                  if (data.type in Geometries) {
                    geometry = Geometries[data.type].fromJSON(data, shapes);
                  } else {
                    console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                  }
              }
              geometry.uuid = data.uuid;
              if (data.name !== void 0)
                geometry.name = data.name;
              if (geometry.isBufferGeometry === true && data.userData !== void 0)
                geometry.userData = data.userData;
              geometries[data.uuid] = geometry;
            }
          }
          return geometries;
        }
        parseMaterials(json, textures) {
          const cache = {};
          const materials = {};
          if (json !== void 0) {
            const loader = new MaterialLoader();
            loader.setTextures(textures);
            for (let i = 0, l = json.length; i < l; i++) {
              const data = json[i];
              if (cache[data.uuid] === void 0) {
                cache[data.uuid] = loader.parse(data);
              }
              materials[data.uuid] = cache[data.uuid];
            }
          }
          return materials;
        }
        parseAnimations(json) {
          const animations = {};
          if (json !== void 0) {
            for (let i = 0; i < json.length; i++) {
              const data = json[i];
              const clip = AnimationClip.parse(data);
              animations[clip.uuid] = clip;
            }
          }
          return animations;
        }
        parseImages(json, onLoad) {
          const scope = this;
          const images = {};
          let loader;
          function loadImage(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function() {
              scope.manager.itemEnd(url);
            }, void 0, function() {
              scope.manager.itemError(url);
              scope.manager.itemEnd(url);
            });
          }
          function deserializeImage(image) {
            if (typeof image === "string") {
              const url = image;
              const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
              return loadImage(path);
            } else {
              if (image.data) {
                return {
                  data: getTypedArray(image.type, image.data),
                  width: image.width,
                  height: image.height
                };
              } else {
                return null;
              }
            }
          }
          if (json !== void 0 && json.length > 0) {
            const manager = new LoadingManager(onLoad);
            loader = new ImageLoader(manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (let i = 0, il = json.length; i < il; i++) {
              const image = json[i];
              const url = image.url;
              if (Array.isArray(url)) {
                const imageArray = [];
                for (let j = 0, jl = url.length; j < jl; j++) {
                  const currentUrl = url[j];
                  const deserializedImage = deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      imageArray.push(deserializedImage);
                    } else {
                      imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
                images[image.uuid] = new Source(imageArray);
              } else {
                const deserializedImage = deserializeImage(image.url);
                images[image.uuid] = new Source(deserializedImage);
              }
            }
          }
          return images;
        }
        async parseImagesAsync(json) {
          const scope = this;
          const images = {};
          let loader;
          async function deserializeImage(image) {
            if (typeof image === "string") {
              const url = image;
              const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
              return await loader.loadAsync(path);
            } else {
              if (image.data) {
                return {
                  data: getTypedArray(image.type, image.data),
                  width: image.width,
                  height: image.height
                };
              } else {
                return null;
              }
            }
          }
          if (json !== void 0 && json.length > 0) {
            loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (let i = 0, il = json.length; i < il; i++) {
              const image = json[i];
              const url = image.url;
              if (Array.isArray(url)) {
                const imageArray = [];
                for (let j = 0, jl = url.length; j < jl; j++) {
                  const currentUrl = url[j];
                  const deserializedImage = await deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      imageArray.push(deserializedImage);
                    } else {
                      imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
                images[image.uuid] = new Source(imageArray);
              } else {
                const deserializedImage = await deserializeImage(image.url);
                images[image.uuid] = new Source(deserializedImage);
              }
            }
          }
          return images;
        }
        parseTextures(json, images) {
          function parseConstant(value, type3) {
            if (typeof value === "number")
              return value;
            console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
            return type3[value];
          }
          const textures = {};
          if (json !== void 0) {
            for (let i = 0, l = json.length; i < l; i++) {
              const data = json[i];
              if (data.image === void 0) {
                console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
              }
              if (images[data.image] === void 0) {
                console.warn("THREE.ObjectLoader: Undefined image", data.image);
              }
              const source = images[data.image];
              const image = source.data;
              let texture;
              if (Array.isArray(image)) {
                texture = new CubeTexture();
                if (image.length === 6)
                  texture.needsUpdate = true;
              } else {
                if (image && image.data) {
                  texture = new DataTexture();
                } else {
                  texture = new Texture();
                }
                if (image)
                  texture.needsUpdate = true;
              }
              texture.source = source;
              texture.uuid = data.uuid;
              if (data.name !== void 0)
                texture.name = data.name;
              if (data.mapping !== void 0)
                texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
              if (data.offset !== void 0)
                texture.offset.fromArray(data.offset);
              if (data.repeat !== void 0)
                texture.repeat.fromArray(data.repeat);
              if (data.center !== void 0)
                texture.center.fromArray(data.center);
              if (data.rotation !== void 0)
                texture.rotation = data.rotation;
              if (data.wrap !== void 0) {
                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
              }
              if (data.format !== void 0)
                texture.format = data.format;
              if (data.type !== void 0)
                texture.type = data.type;
              if (data.encoding !== void 0)
                texture.encoding = data.encoding;
              if (data.minFilter !== void 0)
                texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
              if (data.magFilter !== void 0)
                texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
              if (data.anisotropy !== void 0)
                texture.anisotropy = data.anisotropy;
              if (data.flipY !== void 0)
                texture.flipY = data.flipY;
              if (data.generateMipmaps !== void 0)
                texture.generateMipmaps = data.generateMipmaps;
              if (data.premultiplyAlpha !== void 0)
                texture.premultiplyAlpha = data.premultiplyAlpha;
              if (data.unpackAlignment !== void 0)
                texture.unpackAlignment = data.unpackAlignment;
              if (data.userData !== void 0)
                texture.userData = data.userData;
              textures[data.uuid] = texture;
            }
          }
          return textures;
        }
        parseObject(data, geometries, materials, textures, animations) {
          let object;
          function getGeometry(name) {
            if (geometries[name] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined geometry", name);
            }
            return geometries[name];
          }
          function getMaterial(name) {
            if (name === void 0)
              return void 0;
            if (Array.isArray(name)) {
              const array = [];
              for (let i = 0, l = name.length; i < l; i++) {
                const uuid = name[i];
                if (materials[uuid] === void 0) {
                  console.warn("THREE.ObjectLoader: Undefined material", uuid);
                }
                array.push(materials[uuid]);
              }
              return array;
            }
            if (materials[name] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined material", name);
            }
            return materials[name];
          }
          function getTexture(uuid) {
            if (textures[uuid] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined texture", uuid);
            }
            return textures[uuid];
          }
          let geometry, material;
          switch (data.type) {
            case "Scene":
              object = new Scene();
              if (data.background !== void 0) {
                if (Number.isInteger(data.background)) {
                  object.background = new Color(data.background);
                } else {
                  object.background = getTexture(data.background);
                }
              }
              if (data.environment !== void 0) {
                object.environment = getTexture(data.environment);
              }
              if (data.fog !== void 0) {
                if (data.fog.type === "Fog") {
                  object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                } else if (data.fog.type === "FogExp2") {
                  object.fog = new FogExp2(data.fog.color, data.fog.density);
                }
              }
              if (data.backgroundBlurriness !== void 0)
                object.backgroundBlurriness = data.backgroundBlurriness;
              if (data.backgroundIntensity !== void 0)
                object.backgroundIntensity = data.backgroundIntensity;
              break;
            case "PerspectiveCamera":
              object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
              if (data.focus !== void 0)
                object.focus = data.focus;
              if (data.zoom !== void 0)
                object.zoom = data.zoom;
              if (data.filmGauge !== void 0)
                object.filmGauge = data.filmGauge;
              if (data.filmOffset !== void 0)
                object.filmOffset = data.filmOffset;
              if (data.view !== void 0)
                object.view = Object.assign({}, data.view);
              break;
            case "OrthographicCamera":
              object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
              if (data.zoom !== void 0)
                object.zoom = data.zoom;
              if (data.view !== void 0)
                object.view = Object.assign({}, data.view);
              break;
            case "AmbientLight":
              object = new AmbientLight(data.color, data.intensity);
              break;
            case "DirectionalLight":
              object = new DirectionalLight(data.color, data.intensity);
              break;
            case "PointLight":
              object = new PointLight(data.color, data.intensity, data.distance, data.decay);
              break;
            case "RectAreaLight":
              object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
              break;
            case "SpotLight":
              object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
              break;
            case "HemisphereLight":
              object = new HemisphereLight(data.color, data.groundColor, data.intensity);
              break;
            case "LightProbe":
              object = new LightProbe().fromJSON(data);
              break;
            case "SkinnedMesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              object = new SkinnedMesh(geometry, material);
              if (data.bindMode !== void 0)
                object.bindMode = data.bindMode;
              if (data.bindMatrix !== void 0)
                object.bindMatrix.fromArray(data.bindMatrix);
              if (data.skeleton !== void 0)
                object.skeleton = data.skeleton;
              break;
            case "Mesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              object = new Mesh(geometry, material);
              break;
            case "InstancedMesh":
              geometry = getGeometry(data.geometry);
              material = getMaterial(data.material);
              const count = data.count;
              const instanceMatrix = data.instanceMatrix;
              const instanceColor = data.instanceColor;
              object = new InstancedMesh(geometry, material, count);
              object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
              if (instanceColor !== void 0)
                object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
              break;
            case "LOD":
              object = new LOD();
              break;
            case "Line":
              object = new Line(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "LineLoop":
              object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "LineSegments":
              object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "PointCloud":
            case "Points":
              object = new Points(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case "Sprite":
              object = new Sprite(getMaterial(data.material));
              break;
            case "Group":
              object = new Group();
              break;
            case "Bone":
              object = new Bone();
              break;
            default:
              object = new Object3D();
          }
          object.uuid = data.uuid;
          if (data.name !== void 0)
            object.name = data.name;
          if (data.matrix !== void 0) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== void 0)
              object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate)
              object.matrix.decompose(object.position, object.quaternion, object.scale);
          } else {
            if (data.position !== void 0)
              object.position.fromArray(data.position);
            if (data.rotation !== void 0)
              object.rotation.fromArray(data.rotation);
            if (data.quaternion !== void 0)
              object.quaternion.fromArray(data.quaternion);
            if (data.scale !== void 0)
              object.scale.fromArray(data.scale);
          }
          if (data.castShadow !== void 0)
            object.castShadow = data.castShadow;
          if (data.receiveShadow !== void 0)
            object.receiveShadow = data.receiveShadow;
          if (data.shadow) {
            if (data.shadow.bias !== void 0)
              object.shadow.bias = data.shadow.bias;
            if (data.shadow.normalBias !== void 0)
              object.shadow.normalBias = data.shadow.normalBias;
            if (data.shadow.radius !== void 0)
              object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== void 0)
              object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== void 0)
              object.shadow.camera = this.parseObject(data.shadow.camera);
          }
          if (data.visible !== void 0)
            object.visible = data.visible;
          if (data.frustumCulled !== void 0)
            object.frustumCulled = data.frustumCulled;
          if (data.renderOrder !== void 0)
            object.renderOrder = data.renderOrder;
          if (data.userData !== void 0)
            object.userData = data.userData;
          if (data.layers !== void 0)
            object.layers.mask = data.layers;
          if (data.children !== void 0) {
            const children = data.children;
            for (let i = 0; i < children.length; i++) {
              object.add(this.parseObject(children[i], geometries, materials, textures, animations));
            }
          }
          if (data.animations !== void 0) {
            const objectAnimations = data.animations;
            for (let i = 0; i < objectAnimations.length; i++) {
              const uuid = objectAnimations[i];
              object.animations.push(animations[uuid]);
            }
          }
          if (data.type === "LOD") {
            if (data.autoUpdate !== void 0)
              object.autoUpdate = data.autoUpdate;
            const levels = data.levels;
            for (let l = 0; l < levels.length; l++) {
              const level = levels[l];
              const child = object.getObjectByProperty("uuid", level.object);
              if (child !== void 0) {
                object.addLevel(child, level.distance, level.hysteresis);
              }
            }
          }
          return object;
        }
        bindSkeletons(object, skeletons) {
          if (Object.keys(skeletons).length === 0)
            return;
          object.traverse(function(child) {
            if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
              const skeleton = skeletons[child.skeleton];
              if (skeleton === void 0) {
                console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
              } else {
                child.bind(skeleton, child.bindMatrix);
              }
            }
          });
        }
      };
      TEXTURE_MAPPING = {
        UVMapping,
        CubeReflectionMapping,
        CubeRefractionMapping,
        EquirectangularReflectionMapping,
        EquirectangularRefractionMapping,
        CubeUVReflectionMapping
      };
      TEXTURE_WRAPPING = {
        RepeatWrapping,
        ClampToEdgeWrapping,
        MirroredRepeatWrapping
      };
      TEXTURE_FILTER = {
        NearestFilter,
        NearestMipmapNearestFilter,
        NearestMipmapLinearFilter,
        LinearFilter,
        LinearMipmapNearestFilter,
        LinearMipmapLinearFilter
      };
      ImageBitmapLoader = class extends Loader {
        constructor(manager) {
          super(manager);
          this.isImageBitmapLoader = true;
          if (typeof createImageBitmap === "undefined") {
            console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
          }
          if (typeof fetch === "undefined") {
            console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
          }
          this.options = { premultiplyAlpha: "none" };
        }
        setOptions(options) {
          this.options = options;
          return this;
        }
        load(url, onLoad, onProgress, onError) {
          if (url === void 0)
            url = "";
          if (this.path !== void 0)
            url = this.path + url;
          url = this.manager.resolveURL(url);
          const scope = this;
          const cached = Cache.get(url);
          if (cached !== void 0) {
            scope.manager.itemStart(url);
            setTimeout(function() {
              if (onLoad)
                onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
            return cached;
          }
          const fetchOptions = {};
          fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
          fetchOptions.headers = this.requestHeader;
          fetch(url, fetchOptions).then(function(res) {
            return res.blob();
          }).then(function(blob) {
            return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
          }).then(function(imageBitmap) {
            Cache.add(url, imageBitmap);
            if (onLoad)
              onLoad(imageBitmap);
            scope.manager.itemEnd(url);
          }).catch(function(e) {
            if (onError)
              onError(e);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          });
          scope.manager.itemStart(url);
        }
      };
      AudioContext = class {
        static getContext() {
          if (_context === void 0) {
            _context = new (window.AudioContext || window.webkitAudioContext)();
          }
          return _context;
        }
        static setContext(value) {
          _context = value;
        }
      };
      AudioLoader = class extends Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new FileLoader(this.manager);
          loader.setResponseType("arraybuffer");
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(buffer) {
            try {
              const bufferCopy = buffer.slice(0);
              const context = AudioContext.getContext();
              context.decodeAudioData(bufferCopy, function(audioBuffer) {
                onLoad(audioBuffer);
              });
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
      };
      HemisphereLightProbe = class extends LightProbe {
        constructor(skyColor, groundColor, intensity = 1) {
          super(void 0, intensity);
          this.isHemisphereLightProbe = true;
          const color1 = new Color().set(skyColor);
          const color2 = new Color().set(groundColor);
          const sky = new Vector3(color1.r, color1.g, color1.b);
          const ground = new Vector3(color2.r, color2.g, color2.b);
          const c0 = Math.sqrt(Math.PI);
          const c1 = c0 * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
          this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
        }
      };
      AmbientLightProbe = class extends LightProbe {
        constructor(color, intensity = 1) {
          super(void 0, intensity);
          this.isAmbientLightProbe = true;
          const color1 = new Color().set(color);
          this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      };
      _eyeRight = /* @__PURE__ */ new Matrix4();
      _eyeLeft = /* @__PURE__ */ new Matrix4();
      _projectionMatrix = /* @__PURE__ */ new Matrix4();
      StereoCamera = class {
        constructor() {
          this.type = "StereoCamera";
          this.aspect = 1;
          this.eyeSep = 0.064;
          this.cameraL = new PerspectiveCamera();
          this.cameraL.layers.enable(1);
          this.cameraL.matrixAutoUpdate = false;
          this.cameraR = new PerspectiveCamera();
          this.cameraR.layers.enable(2);
          this.cameraR.matrixAutoUpdate = false;
          this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
          };
        }
        update(camera) {
          const cache = this._cache;
          const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
          if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            _projectionMatrix.copy(camera.projectionMatrix);
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            _eyeLeft.elements[12] = -eyeSepHalf;
            _eyeRight.elements[12] = eyeSepHalf;
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(_projectionMatrix);
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(_projectionMatrix);
          }
          this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
          this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
        }
      };
      Clock = class {
        constructor(autoStart = true) {
          this.autoStart = autoStart;
          this.startTime = 0;
          this.oldTime = 0;
          this.elapsedTime = 0;
          this.running = false;
        }
        start() {
          this.startTime = now();
          this.oldTime = this.startTime;
          this.elapsedTime = 0;
          this.running = true;
        }
        stop() {
          this.getElapsedTime();
          this.running = false;
          this.autoStart = false;
        }
        getElapsedTime() {
          this.getDelta();
          return this.elapsedTime;
        }
        getDelta() {
          let diff = 0;
          if (this.autoStart && !this.running) {
            this.start();
            return 0;
          }
          if (this.running) {
            const newTime = now();
            diff = (newTime - this.oldTime) / 1e3;
            this.oldTime = newTime;
            this.elapsedTime += diff;
          }
          return diff;
        }
      };
      _position$1 = /* @__PURE__ */ new Vector3();
      _quaternion$1 = /* @__PURE__ */ new Quaternion();
      _scale$1 = /* @__PURE__ */ new Vector3();
      _orientation$1 = /* @__PURE__ */ new Vector3();
      AudioListener = class extends Object3D {
        constructor() {
          super();
          this.type = "AudioListener";
          this.context = AudioContext.getContext();
          this.gain = this.context.createGain();
          this.gain.connect(this.context.destination);
          this.filter = null;
          this.timeDelta = 0;
          this._clock = new Clock();
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
          }
          return this;
        }
        getFilter() {
          return this.filter;
        }
        setFilter(value) {
          if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
          } else {
            this.gain.disconnect(this.context.destination);
          }
          this.filter = value;
          this.gain.connect(this.filter);
          this.filter.connect(this.context.destination);
          return this;
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(value) {
          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
          return this;
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          const listener = this.context.listener;
          const up = this.up;
          this.timeDelta = this._clock.getDelta();
          this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
          _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
          if (listener.positionX) {
            const endTime = this.context.currentTime + this.timeDelta;
            listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
            listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
            listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
            listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
            listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
            listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
            listener.upX.linearRampToValueAtTime(up.x, endTime);
            listener.upY.linearRampToValueAtTime(up.y, endTime);
            listener.upZ.linearRampToValueAtTime(up.z, endTime);
          } else {
            listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
            listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
          }
        }
      };
      Audio = class extends Object3D {
        constructor(listener) {
          super();
          this.type = "Audio";
          this.listener = listener;
          this.context = listener.context;
          this.gain = this.context.createGain();
          this.gain.connect(listener.getInput());
          this.autoplay = false;
          this.buffer = null;
          this.detune = 0;
          this.loop = false;
          this.loopStart = 0;
          this.loopEnd = 0;
          this.offset = 0;
          this.duration = void 0;
          this.playbackRate = 1;
          this.isPlaying = false;
          this.hasPlaybackControl = true;
          this.source = null;
          this.sourceType = "empty";
          this._startedAt = 0;
          this._progress = 0;
          this._connected = false;
          this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(audioNode) {
          this.hasPlaybackControl = false;
          this.sourceType = "audioNode";
          this.source = audioNode;
          this.connect();
          return this;
        }
        setMediaElementSource(mediaElement) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaNode";
          this.source = this.context.createMediaElementSource(mediaElement);
          this.connect();
          return this;
        }
        setMediaStreamSource(mediaStream) {
          this.hasPlaybackControl = false;
          this.sourceType = "mediaStreamNode";
          this.source = this.context.createMediaStreamSource(mediaStream);
          this.connect();
          return this;
        }
        setBuffer(audioBuffer) {
          this.buffer = audioBuffer;
          this.sourceType = "buffer";
          if (this.autoplay)
            this.play();
          return this;
        }
        play(delay = 0) {
          if (this.isPlaying === true) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + delay;
          const source = this.context.createBufferSource();
          source.buffer = this.buffer;
          source.loop = this.loop;
          source.loopStart = this.loopStart;
          source.loopEnd = this.loopEnd;
          source.onended = this.onEnded.bind(this);
          source.start(this._startedAt, this._progress + this.offset, this.duration);
          this.isPlaying = true;
          this.source = source;
          this.setDetune(this.detune);
          this.setPlaybackRate(this.playbackRate);
          return this.connect();
        }
        pause() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          if (this.isPlaying === true) {
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) {
              this._progress = this._progress % (this.duration || this.buffer.duration);
            }
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
          }
          return this;
        }
        stop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._progress = 0;
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
          return this;
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let i = 1, l = this.filters.length; i < l; i++) {
              this.filters[i - 1].connect(this.filters[i]);
            }
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else {
            this.source.connect(this.getOutput());
          }
          this._connected = true;
          return this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let i = 1, l = this.filters.length; i < l; i++) {
              this.filters[i - 1].disconnect(this.filters[i]);
            }
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else {
            this.source.disconnect(this.getOutput());
          }
          this._connected = false;
          return this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(value) {
          if (!value)
            value = [];
          if (this._connected === true) {
            this.disconnect();
            this.filters = value.slice();
            this.connect();
          } else {
            this.filters = value.slice();
          }
          return this;
        }
        setDetune(value) {
          this.detune = value;
          if (this.source.detune === void 0)
            return;
          if (this.isPlaying === true) {
            this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
          }
          return this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(filter2) {
          return this.setFilters(filter2 ? [filter2] : []);
        }
        setPlaybackRate(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.playbackRate = value;
          if (this.isPlaying === true) {
            this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
          }
          return this;
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = false;
        }
        getLoop() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return false;
          }
          return this.loop;
        }
        setLoop(value) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this.loop = value;
          if (this.isPlaying === true) {
            this.source.loop = this.loop;
          }
          return this;
        }
        setLoopStart(value) {
          this.loopStart = value;
          return this;
        }
        setLoopEnd(value) {
          this.loopEnd = value;
          return this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(value) {
          this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
          return this;
        }
      };
      _position = /* @__PURE__ */ new Vector3();
      _quaternion = /* @__PURE__ */ new Quaternion();
      _scale = /* @__PURE__ */ new Vector3();
      _orientation = /* @__PURE__ */ new Vector3();
      PositionalAudio = class extends Audio {
        constructor(listener) {
          super(listener);
          this.panner = this.context.createPanner();
          this.panner.panningModel = "HRTF";
          this.panner.connect(this.gain);
        }
        disconnect() {
          super.disconnect();
          this.panner.disconnect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(value) {
          this.panner.refDistance = value;
          return this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(value) {
          this.panner.rolloffFactor = value;
          return this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(value) {
          this.panner.distanceModel = value;
          return this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(value) {
          this.panner.maxDistance = value;
          return this;
        }
        setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
          this.panner.coneInnerAngle = coneInnerAngle;
          this.panner.coneOuterAngle = coneOuterAngle;
          this.panner.coneOuterGain = coneOuterGain;
          return this;
        }
        updateMatrixWorld(force) {
          super.updateMatrixWorld(force);
          if (this.hasPlaybackControl === true && this.isPlaying === false)
            return;
          this.matrixWorld.decompose(_position, _quaternion, _scale);
          _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
          const panner = this.panner;
          if (panner.positionX) {
            const endTime = this.context.currentTime + this.listener.timeDelta;
            panner.positionX.linearRampToValueAtTime(_position.x, endTime);
            panner.positionY.linearRampToValueAtTime(_position.y, endTime);
            panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
            panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
            panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
            panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
          } else {
            panner.setPosition(_position.x, _position.y, _position.z);
            panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
          }
        }
      };
      AudioAnalyser = class {
        constructor(audio, fftSize = 2048) {
          this.analyser = audio.context.createAnalyser();
          this.analyser.fftSize = fftSize;
          this.data = new Uint8Array(this.analyser.frequencyBinCount);
          audio.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          this.analyser.getByteFrequencyData(this.data);
          return this.data;
        }
        getAverageFrequency() {
          let value = 0;
          const data = this.getFrequencyData();
          for (let i = 0; i < data.length; i++) {
            value += data[i];
          }
          return value / data.length;
        }
      };
      PropertyMixer = class {
        constructor(binding, typeName, valueSize) {
          this.binding = binding;
          this.valueSize = valueSize;
          let mixFunction, mixFunctionAdditive, setIdentity;
          switch (typeName) {
            case "quaternion":
              mixFunction = this._slerp;
              mixFunctionAdditive = this._slerpAdditive;
              setIdentity = this._setAdditiveIdentityQuaternion;
              this.buffer = new Float64Array(valueSize * 6);
              this._workIndex = 5;
              break;
            case "string":
            case "bool":
              mixFunction = this._select;
              mixFunctionAdditive = this._select;
              setIdentity = this._setAdditiveIdentityOther;
              this.buffer = new Array(valueSize * 5);
              break;
            default:
              mixFunction = this._lerp;
              mixFunctionAdditive = this._lerpAdditive;
              setIdentity = this._setAdditiveIdentityNumeric;
              this.buffer = new Float64Array(valueSize * 5);
          }
          this._mixBufferRegion = mixFunction;
          this._mixBufferRegionAdditive = mixFunctionAdditive;
          this._setIdentity = setIdentity;
          this._origIndex = 3;
          this._addIndex = 4;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          this.useCount = 0;
          this.referenceCount = 0;
        }
        accumulate(accuIndex, weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
          let currentWeight = this.cumulativeWeight;
          if (currentWeight === 0) {
            for (let i = 0; i !== stride; ++i) {
              buffer[offset + i] = buffer[i];
            }
            currentWeight = weight;
          } else {
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
          }
          this.cumulativeWeight = currentWeight;
        }
        accumulateAdditive(weight) {
          const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
          if (this.cumulativeWeightAdditive === 0) {
            this._setIdentity();
          }
          this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
          this.cumulativeWeightAdditive += weight;
        }
        apply(accuIndex) {
          const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
          if (weight < 1) {
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(
              buffer,
              offset,
              originalValueOffset,
              1 - weight,
              stride
            );
          }
          if (weightAdditive > 0) {
            this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
          }
          for (let i = stride, e = stride + stride; i !== e; ++i) {
            if (buffer[i] !== buffer[i + stride]) {
              binding.setValue(buffer, offset);
              break;
            }
          }
        }
        saveOriginalState() {
          const binding = this.binding;
          const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
          binding.getValue(buffer, originalValueOffset);
          for (let i = stride, e = originalValueOffset; i !== e; ++i) {
            buffer[i] = buffer[originalValueOffset + i % stride];
          }
          this._setIdentity();
          this.cumulativeWeight = 0;
          this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const originalValueOffset = this.valueSize * 3;
          this.binding.setValue(this.buffer, originalValueOffset);
        }
        _setAdditiveIdentityNumeric() {
          const startIndex = this._addIndex * this.valueSize;
          const endIndex = startIndex + this.valueSize;
          for (let i = startIndex; i < endIndex; i++) {
            this.buffer[i] = 0;
          }
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric();
          this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const startIndex = this._origIndex * this.valueSize;
          const targetIndex = this._addIndex * this.valueSize;
          for (let i = 0; i < this.valueSize; i++) {
            this.buffer[targetIndex + i] = this.buffer[startIndex + i];
          }
        }
        _select(buffer, dstOffset, srcOffset, t, stride) {
          if (t >= 0.5) {
            for (let i = 0; i !== stride; ++i) {
              buffer[dstOffset + i] = buffer[srcOffset + i];
            }
          }
        }
        _slerp(buffer, dstOffset, srcOffset, t) {
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        }
        _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
          const workOffset = this._workIndex * stride;
          Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
          Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
        }
        _lerp(buffer, dstOffset, srcOffset, t, stride) {
          const s = 1 - t;
          for (let i = 0; i !== stride; ++i) {
            const j = dstOffset + i;
            buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
          }
        }
        _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
          for (let i = 0; i !== stride; ++i) {
            const j = dstOffset + i;
            buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
          }
        }
      };
      _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
      _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
      _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
      _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
      _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
      _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
      _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
      _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
      _trackRe = new RegExp(
        "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
      );
      _supportedObjectNames = ["material", "materials", "bones", "map"];
      Composite = class {
        constructor(targetGroup, path, optionalParsedPath) {
          const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
          this._targetGroup = targetGroup;
          this._bindings = targetGroup.subscribe_(path, parsedPath);
        }
        getValue(array, offset) {
          this.bind();
          const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
          if (binding !== void 0)
            binding.getValue(array, offset);
        }
        setValue(array, offset) {
          const bindings = this._bindings;
          for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
            bindings[i].setValue(array, offset);
          }
        }
        bind() {
          const bindings = this._bindings;
          for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
            bindings[i].bind();
          }
        }
        unbind() {
          const bindings = this._bindings;
          for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
            bindings[i].unbind();
          }
        }
      };
      PropertyBinding = class {
        constructor(rootNode, path, parsedPath) {
          this.path = path;
          this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
          this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
          this.rootNode = rootNode;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
        static create(root, path, parsedPath) {
          if (!(root && root.isAnimationObjectGroup)) {
            return new PropertyBinding(root, path, parsedPath);
          } else {
            return new PropertyBinding.Composite(root, path, parsedPath);
          }
        }
        static sanitizeNodeName(name) {
          return name.replace(/\s/g, "_").replace(_reservedRe, "");
        }
        static parseTrackName(trackName) {
          const matches = _trackRe.exec(trackName);
          if (matches === null) {
            throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
          }
          const results = {
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
          };
          const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
          if (lastDot !== void 0 && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
              results.nodeName = results.nodeName.substring(0, lastDot);
              results.objectName = objectName;
            }
          }
          if (results.propertyName === null || results.propertyName.length === 0) {
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
          }
          return results;
        }
        static findNode(root, nodeName) {
          if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
            return root;
          }
          if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== void 0) {
              return bone;
            }
          }
          if (root.children) {
            const searchNodeSubtree = function(children) {
              for (let i = 0; i < children.length; i++) {
                const childNode = children[i];
                if (childNode.name === nodeName || childNode.uuid === nodeName) {
                  return childNode;
                }
                const result = searchNodeSubtree(childNode.children);
                if (result)
                  return result;
              }
              return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) {
              return subTreeNode;
            }
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(buffer, offset) {
          buffer[offset] = this.targetObject[this.propertyName];
        }
        _getValue_array(buffer, offset) {
          const source = this.resolvedProperty;
          for (let i = 0, n = source.length; i !== n; ++i) {
            buffer[offset++] = source[i];
          }
        }
        _getValue_arrayElement(buffer, offset) {
          buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(buffer, offset) {
          this.resolvedProperty.toArray(buffer, offset);
        }
        _setValue_direct(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
        }
        _setValue_direct_setNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
        }
        _setValue_array_setNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }
        _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
        }
        _setValue_fromArray_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(targetArray, offset) {
          this.bind();
          this.getValue(targetArray, offset);
        }
        _setValue_unbound(sourceArray, offset) {
          this.bind();
          this.setValue(sourceArray, offset);
        }
        bind() {
          let targetObject = this.node;
          const parsedPath = this.parsedPath;
          const objectName = parsedPath.objectName;
          const propertyName = parsedPath.propertyName;
          let propertyIndex = parsedPath.propertyIndex;
          if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
          }
          this.getValue = this._getValue_unavailable;
          this.setValue = this._setValue_unavailable;
          if (!targetObject) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return;
          }
          if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            switch (objectName) {
              case "materials":
                if (!targetObject.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!targetObject.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                targetObject = targetObject.material.materials;
                break;
              case "bones":
                if (!targetObject.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                targetObject = targetObject.skeleton.bones;
                for (let i = 0; i < targetObject.length; i++) {
                  if (targetObject[i].name === objectIndex) {
                    objectIndex = i;
                    break;
                  }
                }
                break;
              case "map":
                if ("map" in targetObject) {
                  targetObject = targetObject.map;
                  break;
                }
                if (!targetObject.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!targetObject.material.map) {
                  console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                  return;
                }
                targetObject = targetObject.material.map;
                break;
              default:
                if (targetObject[objectName] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                targetObject = targetObject[objectName];
            }
            if (objectIndex !== void 0) {
              if (targetObject[objectIndex] === void 0) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                return;
              }
              targetObject = targetObject[objectIndex];
            }
          }
          const nodeProperty = targetObject[propertyName];
          if (nodeProperty === void 0) {
            const nodeName = parsedPath.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            return;
          }
          let versioning = this.Versioning.None;
          this.targetObject = targetObject;
          if (targetObject.needsUpdate !== void 0) {
            versioning = this.Versioning.NeedsUpdate;
          } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
            versioning = this.Versioning.MatrixWorldNeedsUpdate;
          }
          let bindingType = this.BindingType.Direct;
          if (propertyIndex !== void 0) {
            if (propertyName === "morphTargetInfluences") {
              if (!targetObject.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (!targetObject.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
                propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
              }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
          } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
          } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
          } else {
            this.propertyName = propertyName;
          }
          this.getValue = this.GetterByBindingType[bindingType];
          this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        }
        unbind() {
          this.node = null;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
      };
      PropertyBinding.Composite = Composite;
      PropertyBinding.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      };
      PropertyBinding.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      };
      PropertyBinding.prototype.GetterByBindingType = [
        PropertyBinding.prototype._getValue_direct,
        PropertyBinding.prototype._getValue_array,
        PropertyBinding.prototype._getValue_arrayElement,
        PropertyBinding.prototype._getValue_toArray
      ];
      PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
        [
          PropertyBinding.prototype._setValue_direct,
          PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
          PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
        ],
        [
          PropertyBinding.prototype._setValue_array,
          PropertyBinding.prototype._setValue_array_setNeedsUpdate,
          PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
        ],
        [
          PropertyBinding.prototype._setValue_arrayElement,
          PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
          PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
        ],
        [
          PropertyBinding.prototype._setValue_fromArray,
          PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
          PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
        ]
      ];
      AnimationObjectGroup = class {
        constructor() {
          this.isAnimationObjectGroup = true;
          this.uuid = generateUUID();
          this._objects = Array.prototype.slice.call(arguments);
          this.nCachedObjects_ = 0;
          const indices = {};
          this._indicesByUUID = indices;
          for (let i = 0, n = arguments.length; i !== n; ++i) {
            indices[arguments[i].uuid] = i;
          }
          this._paths = [];
          this._parsedPaths = [];
          this._bindings = [];
          this._bindingsIndicesByPath = {};
          const scope = this;
          this.stats = {
            objects: {
              get total() {
                return scope._objects.length;
              },
              get inUse() {
                return this.total - scope.nCachedObjects_;
              }
            },
            get bindingsPerObject() {
              return scope._bindings.length;
            }
          };
        }
        add() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
          let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
          for (let i = 0, n = arguments.length; i !== n; ++i) {
            const object = arguments[i], uuid = object.uuid;
            let index = indicesByUUID[uuid];
            if (index === void 0) {
              index = nObjects++;
              indicesByUUID[uuid] = index;
              objects.push(object);
              for (let j = 0, m = nBindings; j !== m; ++j) {
                bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
              }
            } else if (index < nCachedObjects) {
              knownObject = objects[index];
              const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
              indicesByUUID[lastCachedObject.uuid] = index;
              objects[index] = lastCachedObject;
              indicesByUUID[uuid] = firstActiveIndex;
              objects[firstActiveIndex] = object;
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
                let binding = bindingsForPath[index];
                bindingsForPath[index] = lastCached;
                if (binding === void 0) {
                  binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                }
                bindingsForPath[firstActiveIndex] = binding;
              }
            } else if (objects[index] !== knownObject) {
              console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        remove() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_;
          for (let i = 0, n = arguments.length; i !== n; ++i) {
            const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== void 0 && index >= nCachedObjects) {
              const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
              indicesByUUID[firstActiveObject.uuid] = index;
              objects[index] = firstActiveObject;
              indicesByUUID[uuid] = lastCachedIndex;
              objects[lastCachedIndex] = object;
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                bindingsForPath[index] = firstActive;
                bindingsForPath[lastCachedIndex] = binding;
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        uncache() {
          const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
          let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
          for (let i = 0, n = arguments.length; i !== n; ++i) {
            const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== void 0) {
              delete indicesByUUID[uuid];
              if (index < nCachedObjects) {
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[lastObject.uuid] = firstActiveIndex;
                objects[firstActiveIndex] = lastObject;
                objects.pop();
                for (let j = 0, m = nBindings; j !== m; ++j) {
                  const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                  bindingsForPath[index] = lastCached;
                  bindingsForPath[firstActiveIndex] = last;
                  bindingsForPath.pop();
                }
              } else {
                const lastIndex = --nObjects, lastObject = objects[lastIndex];
                if (lastIndex > 0) {
                  indicesByUUID[lastObject.uuid] = index;
                }
                objects[index] = lastObject;
                objects.pop();
                for (let j = 0, m = nBindings; j !== m; ++j) {
                  const bindingsForPath = bindings[j];
                  bindingsForPath[index] = bindingsForPath[lastIndex];
                  bindingsForPath.pop();
                }
              }
            }
          }
          this.nCachedObjects_ = nCachedObjects;
        }
        subscribe_(path, parsedPath) {
          const indicesByPath = this._bindingsIndicesByPath;
          let index = indicesByPath[path];
          const bindings = this._bindings;
          if (index !== void 0)
            return bindings[index];
          const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
          index = bindings.length;
          indicesByPath[path] = index;
          paths.push(path);
          parsedPaths.push(parsedPath);
          bindings.push(bindingsForPath);
          for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
            const object = objects[i];
            bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
          }
          return bindingsForPath;
        }
        unsubscribe_(path) {
          const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
          if (index !== void 0) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
          }
        }
      };
      AnimationAction = class {
        constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
          this._mixer = mixer;
          this._clip = clip;
          this._localRoot = localRoot;
          this.blendMode = blendMode;
          const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
          const interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
          };
          for (let i = 0; i !== nTracks; ++i) {
            const interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant;
            interpolant.settings = interpolantSettings;
          }
          this._interpolantSettings = interpolantSettings;
          this._interpolants = interpolants;
          this._propertyBindings = new Array(nTracks);
          this._cacheIndex = null;
          this._byClipCacheIndex = null;
          this._timeScaleInterpolant = null;
          this._weightInterpolant = null;
          this.loop = LoopRepeat;
          this._loopCount = -1;
          this._startTime = null;
          this.time = 0;
          this.timeScale = 1;
          this._effectiveTimeScale = 1;
          this.weight = 1;
          this._effectiveWeight = 1;
          this.repetitions = Infinity;
          this.paused = false;
          this.enabled = true;
          this.clampWhenFinished = false;
          this.zeroSlopeAtStart = true;
          this.zeroSlopeAtEnd = true;
        }
        play() {
          this._mixer._activateAction(this);
          return this;
        }
        stop() {
          this._mixer._deactivateAction(this);
          return this.reset();
        }
        reset() {
          this.paused = false;
          this.enabled = true;
          this.time = 0;
          this._loopCount = -1;
          this._startTime = null;
          return this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(time2) {
          this._startTime = time2;
          return this;
        }
        setLoop(mode, repetitions) {
          this.loop = mode;
          this.repetitions = repetitions;
          return this;
        }
        setEffectiveWeight(weight) {
          this.weight = weight;
          this._effectiveWeight = this.enabled ? weight : 0;
          return this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(duration) {
          return this._scheduleFading(duration, 0, 1);
        }
        fadeOut(duration) {
          return this._scheduleFading(duration, 1, 0);
        }
        crossFadeFrom(fadeOutAction, duration, warp) {
          fadeOutAction.fadeOut(duration);
          this.fadeIn(duration);
          if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
          }
          return this;
        }
        crossFadeTo(fadeInAction, duration, warp) {
          return fadeInAction.crossFadeFrom(this, duration, warp);
        }
        stopFading() {
          const weightInterpolant = this._weightInterpolant;
          if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
          }
          return this;
        }
        setEffectiveTimeScale(timeScale) {
          this.timeScale = timeScale;
          this._effectiveTimeScale = this.paused ? 0 : timeScale;
          return this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(duration) {
          this.timeScale = this._clip.duration / duration;
          return this.stopWarping();
        }
        syncWith(action) {
          this.time = action.time;
          this.timeScale = action.timeScale;
          return this.stopWarping();
        }
        halt(duration) {
          return this.warp(this._effectiveTimeScale, 0, duration);
        }
        warp(startTimeScale, endTimeScale, duration) {
          const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
          let interpolant = this._timeScaleInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values3 = interpolant.sampleValues;
          times[0] = now2;
          times[1] = now2 + duration;
          values3[0] = startTimeScale / timeScale;
          values3[1] = endTimeScale / timeScale;
          return this;
        }
        stopWarping() {
          const timeScaleInterpolant = this._timeScaleInterpolant;
          if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
          }
          return this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(time2, deltaTime, timeDirection, accuIndex) {
          if (!this.enabled) {
            this._updateWeight(time2);
            return;
          }
          const startTime = this._startTime;
          if (startTime !== null) {
            const timeRunning = (time2 - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) {
              deltaTime = 0;
            } else {
              this._startTime = null;
              deltaTime = timeDirection * timeRunning;
            }
          }
          deltaTime *= this._updateTimeScale(time2);
          const clipTime = this._updateTime(deltaTime);
          const weight = this._updateWeight(time2);
          if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch (this.blendMode) {
              case AdditiveAnimationBlendMode:
                for (let j = 0, m = interpolants.length; j !== m; ++j) {
                  interpolants[j].evaluate(clipTime);
                  propertyMixers[j].accumulateAdditive(weight);
                }
                break;
              case NormalAnimationBlendMode:
              default:
                for (let j = 0, m = interpolants.length; j !== m; ++j) {
                  interpolants[j].evaluate(clipTime);
                  propertyMixers[j].accumulate(accuIndex, weight);
                }
            }
          }
        }
        _updateWeight(time2) {
          let weight = 0;
          if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time2)[0];
              weight *= interpolantValue;
              if (time2 > interpolant.parameterPositions[1]) {
                this.stopFading();
                if (interpolantValue === 0) {
                  this.enabled = false;
                }
              }
            }
          }
          this._effectiveWeight = weight;
          return weight;
        }
        _updateTimeScale(time2) {
          let timeScale = 0;
          if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
              const interpolantValue = interpolant.evaluate(time2)[0];
              timeScale *= interpolantValue;
              if (time2 > interpolant.parameterPositions[1]) {
                this.stopWarping();
                if (timeScale === 0) {
                  this.paused = true;
                } else {
                  this.timeScale = timeScale;
                }
              }
            }
          }
          this._effectiveTimeScale = timeScale;
          return timeScale;
        }
        _updateTime(deltaTime) {
          const duration = this._clip.duration;
          const loop = this.loop;
          let time2 = this.time + deltaTime;
          let loopCount = this._loopCount;
          const pingPong = loop === LoopPingPong;
          if (deltaTime === 0) {
            if (loopCount === -1)
              return time2;
            return pingPong && (loopCount & 1) === 1 ? duration - time2 : time2;
          }
          if (loop === LoopOnce) {
            if (loopCount === -1) {
              this._loopCount = 0;
              this._setEndings(true, true, false);
            }
            handle_stop: {
              if (time2 >= duration) {
                time2 = duration;
              } else if (time2 < 0) {
                time2 = 0;
              } else {
                this.time = time2;
                break handle_stop;
              }
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              this.time = time2;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime < 0 ? -1 : 1
              });
            }
          } else {
            if (loopCount === -1) {
              if (deltaTime >= 0) {
                loopCount = 0;
                this._setEndings(true, this.repetitions === 0, pingPong);
              } else {
                this._setEndings(this.repetitions === 0, true, pingPong);
              }
            }
            if (time2 >= duration || time2 < 0) {
              const loopDelta = Math.floor(time2 / duration);
              time2 -= duration * loopDelta;
              loopCount += Math.abs(loopDelta);
              const pending = this.repetitions - loopCount;
              if (pending <= 0) {
                if (this.clampWhenFinished)
                  this.paused = true;
                else
                  this.enabled = false;
                time2 = deltaTime > 0 ? duration : 0;
                this.time = time2;
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: deltaTime > 0 ? 1 : -1
                });
              } else {
                if (pending === 1) {
                  const atStart = deltaTime < 0;
                  this._setEndings(atStart, !atStart, pingPong);
                } else {
                  this._setEndings(false, false, pingPong);
                }
                this._loopCount = loopCount;
                this.time = time2;
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta
                });
              }
            } else {
              this.time = time2;
            }
            if (pingPong && (loopCount & 1) === 1) {
              return duration - time2;
            }
          }
          return time2;
        }
        _setEndings(atStart, atEnd, pingPong) {
          const settings = this._interpolantSettings;
          if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
          } else {
            if (atStart) {
              settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingStart = WrapAroundEnding;
            }
            if (atEnd) {
              settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            } else {
              settings.endingEnd = WrapAroundEnding;
            }
          }
        }
        _scheduleFading(duration, weightNow, weightThen) {
          const mixer = this._mixer, now2 = mixer.time;
          let interpolant = this._weightInterpolant;
          if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
          }
          const times = interpolant.parameterPositions, values3 = interpolant.sampleValues;
          times[0] = now2;
          values3[0] = weightNow;
          times[1] = now2 + duration;
          values3[1] = weightThen;
          return this;
        }
      };
      _controlInterpolantsResultBuffer = new Float32Array(1);
      AnimationMixer = class extends EventDispatcher {
        constructor(root) {
          super();
          this._root = root;
          this._initMemoryManager();
          this._accuIndex = 0;
          this.time = 0;
          this.timeScale = 1;
        }
        _bindAction(action, prototypeAction) {
          const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
          let bindingsByName = bindingsByRoot[rootUuid];
          if (bindingsByName === void 0) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
          }
          for (let i = 0; i !== nTracks; ++i) {
            const track = tracks[i], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== void 0) {
              ++binding.referenceCount;
              bindings[i] = binding;
            } else {
              binding = bindings[i];
              if (binding !== void 0) {
                if (binding._cacheIndex === null) {
                  ++binding.referenceCount;
                  this._addInactiveBinding(binding, rootUuid, trackName);
                }
                continue;
              }
              const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
              binding = new PropertyMixer(
                PropertyBinding.create(root, trackName, path),
                track.ValueTypeName,
                track.getValueSize()
              );
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
              bindings[i] = binding;
            }
            interpolants[i].resultBuffer = binding.buffer;
          }
        }
        _activateAction(action) {
          if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
              const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
              this._bindAction(
                action,
                actionsForClip && actionsForClip.knownActions[0]
              );
              this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            for (let i = 0, n = bindings.length; i !== n; ++i) {
              const binding = bindings[i];
              if (binding.useCount++ === 0) {
                this._lendBinding(binding);
                binding.saveOriginalState();
              }
            }
            this._lendAction(action);
          }
        }
        _deactivateAction(action) {
          if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            for (let i = 0, n = bindings.length; i !== n; ++i) {
              const binding = bindings[i];
              if (--binding.useCount === 0) {
                binding.restoreOriginalState();
                this._takeBackBinding(binding);
              }
            }
            this._takeBackAction(action);
          }
        }
        _initMemoryManager() {
          this._actions = [];
          this._nActiveActions = 0;
          this._actionsByClip = {};
          this._bindings = [];
          this._nActiveBindings = 0;
          this._bindingsByRootAndName = {};
          this._controlInterpolants = [];
          this._nActiveControlInterpolants = 0;
          const scope = this;
          this.stats = {
            actions: {
              get total() {
                return scope._actions.length;
              },
              get inUse() {
                return scope._nActiveActions;
              }
            },
            bindings: {
              get total() {
                return scope._bindings.length;
              },
              get inUse() {
                return scope._nActiveBindings;
              }
            },
            controlInterpolants: {
              get total() {
                return scope._controlInterpolants.length;
              },
              get inUse() {
                return scope._nActiveControlInterpolants;
              }
            }
          };
        }
        _isActiveAction(action) {
          const index = action._cacheIndex;
          return index !== null && index < this._nActiveActions;
        }
        _addInactiveAction(action, clipUuid, rootUuid) {
          const actions = this._actions, actionsByClip = this._actionsByClip;
          let actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip === void 0) {
            actionsForClip = {
              knownActions: [action],
              actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
          } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
          }
          action._cacheIndex = actions.length;
          actions.push(action);
          actionsForClip.actionByRoot[rootUuid] = action;
        }
        _removeInactiveAction(action) {
          const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          action._cacheIndex = null;
          const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
          lastKnownAction._byClipCacheIndex = byClipCacheIndex;
          knownActionsForClip[byClipCacheIndex] = lastKnownAction;
          knownActionsForClip.pop();
          action._byClipCacheIndex = null;
          const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
          delete actionByRoot[rootUuid];
          if (knownActionsForClip.length === 0) {
            delete actionsByClip[clipUuid];
          }
          this._removeInactiveBindingsForAction(action);
        }
        _removeInactiveBindingsForAction(action) {
          const bindings = action._propertyBindings;
          for (let i = 0, n = bindings.length; i !== n; ++i) {
            const binding = bindings[i];
            if (--binding.referenceCount === 0) {
              this._removeInactiveBinding(binding);
            }
          }
        }
        _lendAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
          action._cacheIndex = lastActiveIndex;
          actions[lastActiveIndex] = action;
          firstInactiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = firstInactiveAction;
        }
        _takeBackAction(action) {
          const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
          action._cacheIndex = firstInactiveIndex;
          actions[firstInactiveIndex] = action;
          lastActiveAction._cacheIndex = prevIndex;
          actions[prevIndex] = lastActiveAction;
        }
        _addInactiveBinding(binding, rootUuid, trackName) {
          const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
          let bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName === void 0) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
          }
          bindingByName[trackName] = binding;
          binding._cacheIndex = bindings.length;
          bindings.push(binding);
        }
        _removeInactiveBinding(binding) {
          const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
          lastInactiveBinding._cacheIndex = cacheIndex;
          bindings[cacheIndex] = lastInactiveBinding;
          bindings.pop();
          delete bindingByName[trackName];
          if (Object.keys(bindingByName).length === 0) {
            delete bindingsByRoot[rootUuid];
          }
        }
        _lendBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
          binding._cacheIndex = lastActiveIndex;
          bindings[lastActiveIndex] = binding;
          firstInactiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = firstInactiveBinding;
        }
        _takeBackBinding(binding) {
          const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
          binding._cacheIndex = firstInactiveIndex;
          bindings[firstInactiveIndex] = binding;
          lastActiveBinding._cacheIndex = prevIndex;
          bindings[prevIndex] = lastActiveBinding;
        }
        _lendControlInterpolant() {
          const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
          let interpolant = interpolants[lastActiveIndex];
          if (interpolant === void 0) {
            interpolant = new LinearInterpolant(
              new Float32Array(2),
              new Float32Array(2),
              1,
              _controlInterpolantsResultBuffer
            );
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
          }
          return interpolant;
        }
        _takeBackControlInterpolant(interpolant) {
          const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
          interpolant.__cacheIndex = firstInactiveIndex;
          interpolants[firstInactiveIndex] = interpolant;
          lastActiveInterpolant.__cacheIndex = prevIndex;
          interpolants[prevIndex] = lastActiveInterpolant;
        }
        clipAction(clip, optionalRoot, blendMode) {
          const root = optionalRoot || this._root, rootUuid = root.uuid;
          let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
          const clipUuid = clipObject !== null ? clipObject.uuid : clip;
          const actionsForClip = this._actionsByClip[clipUuid];
          let prototypeAction = null;
          if (blendMode === void 0) {
            if (clipObject !== null) {
              blendMode = clipObject.blendMode;
            } else {
              blendMode = NormalAnimationBlendMode;
            }
          }
          if (actionsForClip !== void 0) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
              return existingAction;
            }
            prototypeAction = actionsForClip.knownActions[0];
            if (clipObject === null)
              clipObject = prototypeAction._clip;
          }
          if (clipObject === null)
            return null;
          const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
          this._bindAction(newAction, prototypeAction);
          this._addInactiveAction(newAction, clipUuid, rootUuid);
          return newAction;
        }
        existingAction(clip, optionalRoot) {
          const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            return actionsForClip.actionByRoot[rootUuid] || null;
          }
          return null;
        }
        stopAllAction() {
          const actions = this._actions, nActions = this._nActiveActions;
          for (let i = nActions - 1; i >= 0; --i) {
            actions[i].stop();
          }
          return this;
        }
        update(deltaTime) {
          deltaTime *= this.timeScale;
          const actions = this._actions, nActions = this._nActiveActions, time2 = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
          for (let i = 0; i !== nActions; ++i) {
            const action = actions[i];
            action._update(time2, deltaTime, timeDirection, accuIndex);
          }
          const bindings = this._bindings, nBindings = this._nActiveBindings;
          for (let i = 0; i !== nBindings; ++i) {
            bindings[i].apply(accuIndex);
          }
          return this;
        }
        setTime(timeInSeconds) {
          this.time = 0;
          for (let i = 0; i < this._actions.length; i++) {
            this._actions[i].time = 0;
          }
          return this.update(timeInSeconds);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(clip) {
          const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
          if (actionsForClip !== void 0) {
            const actionsToRemove = actionsForClip.knownActions;
            for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
              const action = actionsToRemove[i];
              this._deactivateAction(action);
              const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
              action._cacheIndex = null;
              action._byClipCacheIndex = null;
              lastInactiveAction._cacheIndex = cacheIndex;
              actions[cacheIndex] = lastInactiveAction;
              actions.pop();
              this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
          }
        }
        uncacheRoot(root) {
          const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
          for (const clipUuid in actionsByClip) {
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== void 0) {
              this._deactivateAction(action);
              this._removeInactiveAction(action);
            }
          }
          const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
          if (bindingByName !== void 0) {
            for (const trackName in bindingByName) {
              const binding = bindingByName[trackName];
              binding.restoreOriginalState();
              this._removeInactiveBinding(binding);
            }
          }
        }
        uncacheAction(clip, optionalRoot) {
          const action = this.existingAction(clip, optionalRoot);
          if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
      };
      Uniform = class {
        constructor(value) {
          this.value = value;
        }
        clone() {
          return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
        }
      };
      id = 0;
      UniformsGroup = class extends EventDispatcher {
        constructor() {
          super();
          this.isUniformsGroup = true;
          Object.defineProperty(this, "id", { value: id++ });
          this.name = "";
          this.usage = StaticDrawUsage;
          this.uniforms = [];
        }
        add(uniform) {
          this.uniforms.push(uniform);
          return this;
        }
        remove(uniform) {
          const index = this.uniforms.indexOf(uniform);
          if (index !== -1)
            this.uniforms.splice(index, 1);
          return this;
        }
        setName(name) {
          this.name = name;
          return this;
        }
        setUsage(value) {
          this.usage = value;
          return this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
          return this;
        }
        copy(source) {
          this.name = source.name;
          this.usage = source.usage;
          const uniformsSource = source.uniforms;
          this.uniforms.length = 0;
          for (let i = 0, l = uniformsSource.length; i < l; i++) {
            this.uniforms.push(uniformsSource[i].clone());
          }
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      InstancedInterleavedBuffer = class extends InterleavedBuffer {
        constructor(array, stride, meshPerAttribute = 1) {
          super(array, stride);
          this.isInstancedInterleavedBuffer = true;
          this.meshPerAttribute = meshPerAttribute;
        }
        copy(source) {
          super.copy(source);
          this.meshPerAttribute = source.meshPerAttribute;
          return this;
        }
        clone(data) {
          const ib = super.clone(data);
          ib.meshPerAttribute = this.meshPerAttribute;
          return ib;
        }
        toJSON(data) {
          const json = super.toJSON(data);
          json.isInstancedInterleavedBuffer = true;
          json.meshPerAttribute = this.meshPerAttribute;
          return json;
        }
      };
      GLBufferAttribute = class {
        constructor(buffer, type3, itemSize, elementSize, count) {
          this.isGLBufferAttribute = true;
          this.name = "";
          this.buffer = buffer;
          this.type = type3;
          this.itemSize = itemSize;
          this.elementSize = elementSize;
          this.count = count;
          this.version = 0;
        }
        set needsUpdate(value) {
          if (value === true)
            this.version++;
        }
        setBuffer(buffer) {
          this.buffer = buffer;
          return this;
        }
        setType(type3, elementSize) {
          this.type = type3;
          this.elementSize = elementSize;
          return this;
        }
        setItemSize(itemSize) {
          this.itemSize = itemSize;
          return this;
        }
        setCount(count) {
          this.count = count;
          return this;
        }
      };
      Raycaster = class {
        constructor(origin, direction, near = 0, far = Infinity) {
          this.ray = new Ray(origin, direction);
          this.near = near;
          this.far = far;
          this.camera = null;
          this.layers = new Layers();
          this.params = {
            Mesh: {},
            Line: { threshold: 1 },
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {}
          };
        }
        set(origin, direction) {
          this.ray.set(origin, direction);
        }
        setFromCamera(coords, camera) {
          if (camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
          } else if (camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
          } else {
            console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
          }
        }
        intersectObject(object, recursive = true, intersects2 = []) {
          intersectObject(object, this, intersects2, recursive);
          intersects2.sort(ascSort);
          return intersects2;
        }
        intersectObjects(objects, recursive = true, intersects2 = []) {
          for (let i = 0, l = objects.length; i < l; i++) {
            intersectObject(objects[i], this, intersects2, recursive);
          }
          intersects2.sort(ascSort);
          return intersects2;
        }
      };
      Spherical = class {
        constructor(radius = 1, phi = 0, theta = 0) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        set(radius, phi, theta) {
          this.radius = radius;
          this.phi = phi;
          this.theta = theta;
          return this;
        }
        copy(other) {
          this.radius = other.radius;
          this.phi = other.phi;
          this.theta = other.theta;
          return this;
        }
        makeSafe() {
          const EPS = 1e-6;
          this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
          return this;
        }
        setFromVector3(v) {
          return this.setFromCartesianCoords(v.x, v.y, v.z);
        }
        setFromCartesianCoords(x, y, z) {
          this.radius = Math.sqrt(x * x + y * y + z * z);
          if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
          } else {
            this.theta = Math.atan2(x, z);
            this.phi = Math.acos(clamp(y / this.radius, -1, 1));
          }
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      Cylindrical = class {
        constructor(radius = 1, theta = 0, y = 0) {
          this.radius = radius;
          this.theta = theta;
          this.y = y;
          return this;
        }
        set(radius, theta, y) {
          this.radius = radius;
          this.theta = theta;
          this.y = y;
          return this;
        }
        copy(other) {
          this.radius = other.radius;
          this.theta = other.theta;
          this.y = other.y;
          return this;
        }
        setFromVector3(v) {
          return this.setFromCartesianCoords(v.x, v.y, v.z);
        }
        setFromCartesianCoords(x, y, z) {
          this.radius = Math.sqrt(x * x + z * z);
          this.theta = Math.atan2(x, z);
          this.y = y;
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      _vector$4 = /* @__PURE__ */ new Vector2();
      Box2 = class {
        constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
          this.isBox2 = true;
          this.min = min;
          this.max = max;
        }
        set(min, max) {
          this.min.copy(min);
          this.max.copy(max);
          return this;
        }
        setFromPoints(points) {
          this.makeEmpty();
          for (let i = 0, il = points.length; i < il; i++) {
            this.expandByPoint(points[i]);
          }
          return this;
        }
        setFromCenterAndSize(center, size) {
          const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(box) {
          this.min.copy(box.min);
          this.max.copy(box.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = Infinity;
          this.max.x = this.max.y = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(target) {
          return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
          return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
          this.min.min(point);
          this.max.max(point);
          return this;
        }
        expandByVector(vector) {
          this.min.sub(vector);
          this.max.add(vector);
          return this;
        }
        expandByScalar(scalar) {
          this.min.addScalar(-scalar);
          this.max.addScalar(scalar);
          return this;
        }
        containsPoint(point) {
          return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
        }
        containsBox(box) {
          return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        }
        getParameter(point, target) {
          return target.set(
            (point.x - this.min.x) / (this.max.x - this.min.x),
            (point.y - this.min.y) / (this.max.y - this.min.y)
          );
        }
        intersectsBox(box) {
          return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        }
        clampPoint(point, target) {
          return target.copy(point).clamp(this.min, this.max);
        }
        distanceToPoint(point) {
          const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        }
        intersect(box) {
          this.min.max(box.min);
          this.max.min(box.max);
          return this;
        }
        union(box) {
          this.min.min(box.min);
          this.max.max(box.max);
          return this;
        }
        translate(offset) {
          this.min.add(offset);
          this.max.add(offset);
          return this;
        }
        equals(box) {
          return box.min.equals(this.min) && box.max.equals(this.max);
        }
      };
      _startP = /* @__PURE__ */ new Vector3();
      _startEnd = /* @__PURE__ */ new Vector3();
      Line3 = class {
        constructor(start2 = new Vector3(), end = new Vector3()) {
          this.start = start2;
          this.end = end;
        }
        set(start2, end) {
          this.start.copy(start2);
          this.end.copy(end);
          return this;
        }
        copy(line) {
          this.start.copy(line.start);
          this.end.copy(line.end);
          return this;
        }
        getCenter(target) {
          return target.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(target) {
          return target.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t, target) {
          return this.delta(target).multiplyScalar(t).add(this.start);
        }
        closestPointToPointParameter(point, clampToLine) {
          _startP.subVectors(point, this.start);
          _startEnd.subVectors(this.end, this.start);
          const startEnd2 = _startEnd.dot(_startEnd);
          const startEnd_startP = _startEnd.dot(_startP);
          let t = startEnd_startP / startEnd2;
          if (clampToLine) {
            t = clamp(t, 0, 1);
          }
          return t;
        }
        closestPointToPoint(point, clampToLine, target) {
          const t = this.closestPointToPointParameter(point, clampToLine);
          return this.delta(target).multiplyScalar(t).add(this.start);
        }
        applyMatrix4(matrix) {
          this.start.applyMatrix4(matrix);
          this.end.applyMatrix4(matrix);
          return this;
        }
        equals(line) {
          return line.start.equals(this.start) && line.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      _vector$3 = /* @__PURE__ */ new Vector3();
      SpotLightHelper = class extends Object3D {
        constructor(light, color) {
          super();
          this.light = light;
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          this.type = "SpotLightHelper";
          const geometry = new BufferGeometry();
          const positions = [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            -1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            -1,
            1
          ];
          for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
            const p1 = i / l * Math.PI * 2;
            const p2 = j / l * Math.PI * 2;
            positions.push(
              Math.cos(p1),
              Math.sin(p1),
              1,
              Math.cos(p2),
              Math.sin(p2),
              1
            );
          }
          geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
          const material = new LineBasicMaterial({ fog: false, toneMapped: false });
          this.cone = new LineSegments(geometry, material);
          this.add(this.cone);
          this.update();
        }
        dispose() {
          this.cone.geometry.dispose();
          this.cone.material.dispose();
        }
        update() {
          this.light.updateWorldMatrix(true, false);
          this.light.target.updateWorldMatrix(true, false);
          const coneLength = this.light.distance ? this.light.distance : 1e3;
          const coneWidth = coneLength * Math.tan(this.light.angle);
          this.cone.scale.set(coneWidth, coneWidth, coneLength);
          _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
          this.cone.lookAt(_vector$3);
          if (this.color !== void 0) {
            this.cone.material.color.set(this.color);
          } else {
            this.cone.material.color.copy(this.light.color);
          }
        }
      };
      _vector$2 = /* @__PURE__ */ new Vector3();
      _boneMatrix = /* @__PURE__ */ new Matrix4();
      _matrixWorldInv = /* @__PURE__ */ new Matrix4();
      SkeletonHelper = class extends LineSegments {
        constructor(object) {
          const bones = getBoneList(object);
          const geometry = new BufferGeometry();
          const vertices = [];
          const colors = [];
          const color1 = new Color(0, 0, 1);
          const color2 = new Color(0, 1, 0);
          for (let i = 0; i < bones.length; i++) {
            const bone = bones[i];
            if (bone.parent && bone.parent.isBone) {
              vertices.push(0, 0, 0);
              vertices.push(0, 0, 0);
              colors.push(color1.r, color1.g, color1.b);
              colors.push(color2.r, color2.g, color2.b);
            }
          }
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
          super(geometry, material);
          this.isSkeletonHelper = true;
          this.type = "SkeletonHelper";
          this.root = object;
          this.bones = bones;
          this.matrix = object.matrixWorld;
          this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(force) {
          const bones = this.bones;
          const geometry = this.geometry;
          const position = geometry.getAttribute("position");
          _matrixWorldInv.copy(this.root.matrixWorld).invert();
          for (let i = 0, j = 0; i < bones.length; i++) {
            const bone = bones[i];
            if (bone.parent && bone.parent.isBone) {
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
              _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
              _vector$2.setFromMatrixPosition(_boneMatrix);
              position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
              j += 2;
            }
          }
          geometry.getAttribute("position").needsUpdate = true;
          super.updateMatrixWorld(force);
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      PointLightHelper = class extends Mesh {
        constructor(light, sphereSize, color) {
          const geometry = new SphereGeometry(sphereSize, 4, 2);
          const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
          super(geometry, material);
          this.light = light;
          this.color = color;
          this.type = "PointLightHelper";
          this.matrix = this.light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.update();
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
        update() {
          this.light.updateWorldMatrix(true, false);
          if (this.color !== void 0) {
            this.material.color.set(this.color);
          } else {
            this.material.color.copy(this.light.color);
          }
        }
      };
      _vector$1 = /* @__PURE__ */ new Vector3();
      _color1 = /* @__PURE__ */ new Color();
      _color2 = /* @__PURE__ */ new Color();
      HemisphereLightHelper = class extends Object3D {
        constructor(light, size, color) {
          super();
          this.light = light;
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          this.type = "HemisphereLightHelper";
          const geometry = new OctahedronGeometry(size);
          geometry.rotateY(Math.PI * 0.5);
          this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
          if (this.color === void 0)
            this.material.vertexColors = true;
          const position = geometry.getAttribute("position");
          const colors = new Float32Array(position.count * 3);
          geometry.setAttribute("color", new BufferAttribute(colors, 3));
          this.add(new Mesh(geometry, this.material));
          this.update();
        }
        dispose() {
          this.children[0].geometry.dispose();
          this.children[0].material.dispose();
        }
        update() {
          const mesh = this.children[0];
          if (this.color !== void 0) {
            this.material.color.set(this.color);
          } else {
            const colors = mesh.geometry.getAttribute("color");
            _color1.copy(this.light.color);
            _color2.copy(this.light.groundColor);
            for (let i = 0, l = colors.count; i < l; i++) {
              const color = i < l / 2 ? _color1 : _color2;
              colors.setXYZ(i, color.r, color.g, color.b);
            }
            colors.needsUpdate = true;
          }
          this.light.updateWorldMatrix(true, false);
          mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      };
      GridHelper = class extends LineSegments {
        constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
          color1 = new Color(color1);
          color2 = new Color(color2);
          const center = divisions / 2;
          const step = size / divisions;
          const halfSize = size / 2;
          const vertices = [], colors = [];
          for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            const color = i === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
          }
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
          super(geometry, material);
          this.type = "GridHelper";
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      PolarGridHelper = class extends LineSegments {
        constructor(radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
          color1 = new Color(color1);
          color2 = new Color(color2);
          const vertices = [];
          const colors = [];
          if (sectors > 1) {
            for (let i = 0; i < sectors; i++) {
              const v = i / sectors * (Math.PI * 2);
              const x = Math.sin(v) * radius;
              const z = Math.cos(v) * radius;
              vertices.push(0, 0, 0);
              vertices.push(x, 0, z);
              const color = i & 1 ? color1 : color2;
              colors.push(color.r, color.g, color.b);
              colors.push(color.r, color.g, color.b);
            }
          }
          for (let i = 0; i < rings; i++) {
            const color = i & 1 ? color1 : color2;
            const r = radius - radius / rings * i;
            for (let j = 0; j < divisions; j++) {
              let v = j / divisions * (Math.PI * 2);
              let x = Math.sin(v) * r;
              let z = Math.cos(v) * r;
              vertices.push(x, 0, z);
              colors.push(color.r, color.g, color.b);
              v = (j + 1) / divisions * (Math.PI * 2);
              x = Math.sin(v) * r;
              z = Math.cos(v) * r;
              vertices.push(x, 0, z);
              colors.push(color.r, color.g, color.b);
            }
          }
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
          super(geometry, material);
          this.type = "PolarGridHelper";
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      _v1 = /* @__PURE__ */ new Vector3();
      _v2 = /* @__PURE__ */ new Vector3();
      _v3 = /* @__PURE__ */ new Vector3();
      DirectionalLightHelper = class extends Object3D {
        constructor(light, size, color) {
          super();
          this.light = light;
          this.matrix = light.matrixWorld;
          this.matrixAutoUpdate = false;
          this.color = color;
          this.type = "DirectionalLightHelper";
          if (size === void 0)
            size = 1;
          let geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute([
            -size,
            size,
            0,
            size,
            size,
            0,
            size,
            -size,
            0,
            -size,
            -size,
            0,
            -size,
            size,
            0
          ], 3));
          const material = new LineBasicMaterial({ fog: false, toneMapped: false });
          this.lightPlane = new Line(geometry, material);
          this.add(this.lightPlane);
          geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
          this.targetLine = new Line(geometry, material);
          this.add(this.targetLine);
          this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose();
          this.lightPlane.material.dispose();
          this.targetLine.geometry.dispose();
          this.targetLine.material.dispose();
        }
        update() {
          this.light.updateWorldMatrix(true, false);
          this.light.target.updateWorldMatrix(true, false);
          _v1.setFromMatrixPosition(this.light.matrixWorld);
          _v2.setFromMatrixPosition(this.light.target.matrixWorld);
          _v3.subVectors(_v2, _v1);
          this.lightPlane.lookAt(_v2);
          if (this.color !== void 0) {
            this.lightPlane.material.color.set(this.color);
            this.targetLine.material.color.set(this.color);
          } else {
            this.lightPlane.material.color.copy(this.light.color);
            this.targetLine.material.color.copy(this.light.color);
          }
          this.targetLine.lookAt(_v2);
          this.targetLine.scale.z = _v3.length();
        }
      };
      _vector = /* @__PURE__ */ new Vector3();
      _camera = /* @__PURE__ */ new Camera();
      CameraHelper = class extends LineSegments {
        constructor(camera) {
          const geometry = new BufferGeometry();
          const material = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
          const vertices = [];
          const colors = [];
          const pointMap = {};
          addLine("n1", "n2");
          addLine("n2", "n4");
          addLine("n4", "n3");
          addLine("n3", "n1");
          addLine("f1", "f2");
          addLine("f2", "f4");
          addLine("f4", "f3");
          addLine("f3", "f1");
          addLine("n1", "f1");
          addLine("n2", "f2");
          addLine("n3", "f3");
          addLine("n4", "f4");
          addLine("p", "n1");
          addLine("p", "n2");
          addLine("p", "n3");
          addLine("p", "n4");
          addLine("u1", "u2");
          addLine("u2", "u3");
          addLine("u3", "u1");
          addLine("c", "t");
          addLine("p", "c");
          addLine("cn1", "cn2");
          addLine("cn3", "cn4");
          addLine("cf1", "cf2");
          addLine("cf3", "cf4");
          function addLine(a, b) {
            addPoint(a);
            addPoint(b);
          }
          function addPoint(id2) {
            vertices.push(0, 0, 0);
            colors.push(0, 0, 0);
            if (pointMap[id2] === void 0) {
              pointMap[id2] = [];
            }
            pointMap[id2].push(vertices.length / 3 - 1);
          }
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          super(geometry, material);
          this.type = "CameraHelper";
          this.camera = camera;
          if (this.camera.updateProjectionMatrix)
            this.camera.updateProjectionMatrix();
          this.matrix = camera.matrixWorld;
          this.matrixAutoUpdate = false;
          this.pointMap = pointMap;
          this.update();
          const colorFrustum = new Color(16755200);
          const colorCone = new Color(16711680);
          const colorUp = new Color(43775);
          const colorTarget = new Color(16777215);
          const colorCross = new Color(3355443);
          this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
        }
        setColors(frustum, cone, up, target, cross) {
          const geometry = this.geometry;
          const colorAttribute = geometry.getAttribute("color");
          colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b);
          colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);
          colorAttribute.setXYZ(25, cone.r, cone.g, cone.b);
          colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);
          colorAttribute.setXYZ(27, cone.r, cone.g, cone.b);
          colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);
          colorAttribute.setXYZ(29, cone.r, cone.g, cone.b);
          colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);
          colorAttribute.setXYZ(31, cone.r, cone.g, cone.b);
          colorAttribute.setXYZ(32, up.r, up.g, up.b);
          colorAttribute.setXYZ(33, up.r, up.g, up.b);
          colorAttribute.setXYZ(34, up.r, up.g, up.b);
          colorAttribute.setXYZ(35, up.r, up.g, up.b);
          colorAttribute.setXYZ(36, up.r, up.g, up.b);
          colorAttribute.setXYZ(37, up.r, up.g, up.b);
          colorAttribute.setXYZ(38, target.r, target.g, target.b);
          colorAttribute.setXYZ(39, target.r, target.g, target.b);
          colorAttribute.setXYZ(40, cross.r, cross.g, cross.b);
          colorAttribute.setXYZ(41, cross.r, cross.g, cross.b);
          colorAttribute.setXYZ(42, cross.r, cross.g, cross.b);
          colorAttribute.setXYZ(43, cross.r, cross.g, cross.b);
          colorAttribute.setXYZ(44, cross.r, cross.g, cross.b);
          colorAttribute.setXYZ(45, cross.r, cross.g, cross.b);
          colorAttribute.setXYZ(46, cross.r, cross.g, cross.b);
          colorAttribute.setXYZ(47, cross.r, cross.g, cross.b);
          colorAttribute.setXYZ(48, cross.r, cross.g, cross.b);
          colorAttribute.setXYZ(49, cross.r, cross.g, cross.b);
          colorAttribute.needsUpdate = true;
        }
        update() {
          const geometry = this.geometry;
          const pointMap = this.pointMap;
          const w = 1, h = 1;
          _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
          setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
          setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
          setPoint("n1", pointMap, geometry, _camera, -w, -h, -1);
          setPoint("n2", pointMap, geometry, _camera, w, -h, -1);
          setPoint("n3", pointMap, geometry, _camera, -w, h, -1);
          setPoint("n4", pointMap, geometry, _camera, w, h, -1);
          setPoint("f1", pointMap, geometry, _camera, -w, -h, 1);
          setPoint("f2", pointMap, geometry, _camera, w, -h, 1);
          setPoint("f3", pointMap, geometry, _camera, -w, h, 1);
          setPoint("f4", pointMap, geometry, _camera, w, h, 1);
          setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
          setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
          setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1);
          setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
          setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
          setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1);
          setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
          setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
          setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
          setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1);
          setPoint("cn4", pointMap, geometry, _camera, 0, h, -1);
          geometry.getAttribute("position").needsUpdate = true;
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      _box = /* @__PURE__ */ new Box3();
      BoxHelper = class extends LineSegments {
        constructor(object, color = 16776960) {
          const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
          const positions = new Float32Array(8 * 3);
          const geometry = new BufferGeometry();
          geometry.setIndex(new BufferAttribute(indices, 1));
          geometry.setAttribute("position", new BufferAttribute(positions, 3));
          super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
          this.object = object;
          this.type = "BoxHelper";
          this.matrixAutoUpdate = false;
          this.update();
        }
        update(object) {
          if (object !== void 0) {
            console.warn("THREE.BoxHelper: .update() has no longer arguments.");
          }
          if (this.object !== void 0) {
            _box.setFromObject(this.object);
          }
          if (_box.isEmpty())
            return;
          const min = _box.min;
          const max = _box.max;
          const position = this.geometry.attributes.position;
          const array = position.array;
          array[0] = max.x;
          array[1] = max.y;
          array[2] = max.z;
          array[3] = min.x;
          array[4] = max.y;
          array[5] = max.z;
          array[6] = min.x;
          array[7] = min.y;
          array[8] = max.z;
          array[9] = max.x;
          array[10] = min.y;
          array[11] = max.z;
          array[12] = max.x;
          array[13] = max.y;
          array[14] = min.z;
          array[15] = min.x;
          array[16] = max.y;
          array[17] = min.z;
          array[18] = min.x;
          array[19] = min.y;
          array[20] = min.z;
          array[21] = max.x;
          array[22] = min.y;
          array[23] = min.z;
          position.needsUpdate = true;
          this.geometry.computeBoundingSphere();
        }
        setFromObject(object) {
          this.object = object;
          this.update();
          return this;
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.object = source.object;
          return this;
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      Box3Helper = class extends LineSegments {
        constructor(box, color = 16776960) {
          const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
          const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
          const geometry = new BufferGeometry();
          geometry.setIndex(new BufferAttribute(indices, 1));
          geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
          super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
          this.box = box;
          this.type = "Box3Helper";
          this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(force) {
          const box = this.box;
          if (box.isEmpty())
            return;
          box.getCenter(this.position);
          box.getSize(this.scale);
          this.scale.multiplyScalar(0.5);
          super.updateMatrixWorld(force);
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      PlaneHelper = class extends Line {
        constructor(plane, size = 1, hex = 16776960) {
          const color = hex;
          const positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
          geometry.computeBoundingSphere();
          super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
          this.type = "PlaneHelper";
          this.plane = plane;
          this.size = size;
          const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
          const geometry2 = new BufferGeometry();
          geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
          geometry2.computeBoundingSphere();
          this.add(new Mesh(geometry2, new MeshBasicMaterial({ color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
        }
        updateMatrixWorld(force) {
          this.position.set(0, 0, 0);
          this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
          this.lookAt(this.plane.normal);
          this.translateZ(-this.plane.constant);
          super.updateMatrixWorld(force);
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
          this.children[0].geometry.dispose();
          this.children[0].material.dispose();
        }
      };
      _axis = /* @__PURE__ */ new Vector3();
      ArrowHelper = class extends Object3D {
        constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
          super();
          this.type = "ArrowHelper";
          if (_lineGeometry === void 0) {
            _lineGeometry = new BufferGeometry();
            _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
            _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
            _coneGeometry.translate(0, -0.5, 0);
          }
          this.position.copy(origin);
          this.line = new Line(_lineGeometry, new LineBasicMaterial({ color, toneMapped: false }));
          this.line.matrixAutoUpdate = false;
          this.add(this.line);
          this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color, toneMapped: false }));
          this.cone.matrixAutoUpdate = false;
          this.add(this.cone);
          this.setDirection(dir);
          this.setLength(length, headLength, headWidth);
        }
        setDirection(dir) {
          if (dir.y > 0.99999) {
            this.quaternion.set(0, 0, 0, 1);
          } else if (dir.y < -0.99999) {
            this.quaternion.set(1, 0, 0, 0);
          } else {
            _axis.set(dir.z, 0, -dir.x).normalize();
            const radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(_axis, radians);
          }
        }
        setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
          this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
          this.line.updateMatrix();
          this.cone.scale.set(headWidth, headLength, headWidth);
          this.cone.position.y = length;
          this.cone.updateMatrix();
        }
        setColor(color) {
          this.line.material.color.set(color);
          this.cone.material.color.set(color);
        }
        copy(source) {
          super.copy(source, false);
          this.line.copy(source.line);
          this.cone.copy(source.cone);
          return this;
        }
        dispose() {
          this.line.geometry.dispose();
          this.line.material.dispose();
          this.cone.geometry.dispose();
          this.cone.material.dispose();
        }
      };
      AxesHelper = class extends LineSegments {
        constructor(size = 1) {
          const vertices = [
            0,
            0,
            0,
            size,
            0,
            0,
            0,
            0,
            0,
            0,
            size,
            0,
            0,
            0,
            0,
            0,
            0,
            size
          ];
          const colors = [
            1,
            0,
            0,
            1,
            0.6,
            0,
            0,
            1,
            0,
            0.6,
            1,
            0,
            0,
            0,
            1,
            0,
            0.6,
            1
          ];
          const geometry = new BufferGeometry();
          geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
          geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
          const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
          super(geometry, material);
          this.type = "AxesHelper";
        }
        setColors(xAxisColor, yAxisColor, zAxisColor) {
          const color = new Color();
          const array = this.geometry.attributes.color.array;
          color.set(xAxisColor);
          color.toArray(array, 0);
          color.toArray(array, 3);
          color.set(yAxisColor);
          color.toArray(array, 6);
          color.toArray(array, 9);
          color.set(zAxisColor);
          color.toArray(array, 12);
          color.toArray(array, 15);
          this.geometry.attributes.color.needsUpdate = true;
          return this;
        }
        dispose() {
          this.geometry.dispose();
          this.material.dispose();
        }
      };
      ShapePath = class {
        constructor() {
          this.type = "ShapePath";
          this.color = new Color();
          this.subPaths = [];
          this.currentPath = null;
        }
        moveTo(x, y) {
          this.currentPath = new Path();
          this.subPaths.push(this.currentPath);
          this.currentPath.moveTo(x, y);
          return this;
        }
        lineTo(x, y) {
          this.currentPath.lineTo(x, y);
          return this;
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
          this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
          return this;
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
          return this;
        }
        splineThru(pts) {
          this.currentPath.splineThru(pts);
          return this;
        }
        toShapes(isCCW) {
          function toShapesNoHoles(inSubpaths) {
            const shapes2 = [];
            for (let i = 0, l = inSubpaths.length; i < l; i++) {
              const tmpPath2 = inSubpaths[i];
              const tmpShape2 = new Shape();
              tmpShape2.curves = tmpPath2.curves;
              shapes2.push(tmpShape2);
            }
            return shapes2;
          }
          function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            let inside = false;
            for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
              let edgeLowPt = inPolygon[p];
              let edgeHighPt = inPolygon[q];
              let edgeDx = edgeHighPt.x - edgeLowPt.x;
              let edgeDy = edgeHighPt.y - edgeLowPt.y;
              if (Math.abs(edgeDy) > Number.EPSILON) {
                if (edgeDy < 0) {
                  edgeLowPt = inPolygon[q];
                  edgeDx = -edgeDx;
                  edgeHighPt = inPolygon[p];
                  edgeDy = -edgeDy;
                }
                if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                  continue;
                if (inPt.y === edgeLowPt.y) {
                  if (inPt.x === edgeLowPt.x)
                    return true;
                } else {
                  const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                  if (perpEdge === 0)
                    return true;
                  if (perpEdge < 0)
                    continue;
                  inside = !inside;
                }
              } else {
                if (inPt.y !== edgeLowPt.y)
                  continue;
                if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                  return true;
              }
            }
            return inside;
          }
          const isClockWise = ShapeUtils.isClockWise;
          const subPaths = this.subPaths;
          if (subPaths.length === 0)
            return [];
          let solid, tmpPath, tmpShape;
          const shapes = [];
          if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape();
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
            return shapes;
          }
          let holesFirst = !isClockWise(subPaths[0].getPoints());
          holesFirst = isCCW ? !holesFirst : holesFirst;
          const betterShapeHoles = [];
          const newShapes = [];
          let newShapeHoles = [];
          let mainIdx = 0;
          let tmpPoints;
          newShapes[mainIdx] = void 0;
          newShapeHoles[mainIdx] = [];
          for (let i = 0, l = subPaths.length; i < l; i++) {
            tmpPath = subPaths[i];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
              if (!holesFirst && newShapes[mainIdx])
                mainIdx++;
              newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
              newShapes[mainIdx].s.curves = tmpPath.curves;
              if (holesFirst)
                mainIdx++;
              newShapeHoles[mainIdx] = [];
            } else {
              newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
            }
          }
          if (!newShapes[0])
            return toShapesNoHoles(subPaths);
          if (newShapes.length > 1) {
            let ambiguous = false;
            let toChange = 0;
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
              betterShapeHoles[sIdx] = [];
            }
            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
              const sho = newShapeHoles[sIdx];
              for (let hIdx = 0; hIdx < sho.length; hIdx++) {
                const ho = sho[hIdx];
                let hole_unassigned = true;
                for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                  if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                    if (sIdx !== s2Idx)
                      toChange++;
                    if (hole_unassigned) {
                      hole_unassigned = false;
                      betterShapeHoles[s2Idx].push(ho);
                    } else {
                      ambiguous = true;
                    }
                  }
                }
                if (hole_unassigned) {
                  betterShapeHoles[sIdx].push(ho);
                }
              }
            }
            if (toChange > 0 && ambiguous === false) {
              newShapeHoles = betterShapeHoles;
            }
          }
          let tmpHoles;
          for (let i = 0, il = newShapes.length; i < il; i++) {
            tmpShape = newShapes[i].s;
            shapes.push(tmpShape);
            tmpHoles = newShapeHoles[i];
            for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
              tmpShape.holes.push(tmpHoles[j].h);
            }
          }
          return shapes;
        }
      };
      _tables = /* @__PURE__ */ _generateTables();
      DataUtils = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        fromHalfFloat,
        toHalfFloat
      });
      BoxBufferGeometry = class extends BoxGeometry {
        constructor(width2, height2, depth, widthSegments, heightSegments, depthSegments) {
          console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry.");
          super(width2, height2, depth, widthSegments, heightSegments, depthSegments);
        }
      };
      CapsuleBufferGeometry = class extends CapsuleGeometry {
        constructor(radius, length, capSegments, radialSegments) {
          console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry.");
          super(radius, length, capSegments, radialSegments);
        }
      };
      CircleBufferGeometry = class extends CircleGeometry {
        constructor(radius, segments, thetaStart, thetaLength) {
          console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry.");
          super(radius, segments, thetaStart, thetaLength);
        }
      };
      ConeBufferGeometry = class extends ConeGeometry {
        constructor(radius, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
          console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry.");
          super(radius, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        }
      };
      CylinderBufferGeometry = class extends CylinderGeometry {
        constructor(radiusTop, radiusBottom, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
          console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry.");
          super(radiusTop, radiusBottom, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        }
      };
      DodecahedronBufferGeometry = class extends DodecahedronGeometry {
        constructor(radius, detail) {
          console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry.");
          super(radius, detail);
        }
      };
      ExtrudeBufferGeometry = class extends ExtrudeGeometry {
        constructor(shapes, options) {
          console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry.");
          super(shapes, options);
        }
      };
      IcosahedronBufferGeometry = class extends IcosahedronGeometry {
        constructor(radius, detail) {
          console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry.");
          super(radius, detail);
        }
      };
      LatheBufferGeometry = class extends LatheGeometry {
        constructor(points, segments, phiStart, phiLength) {
          console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry.");
          super(points, segments, phiStart, phiLength);
        }
      };
      OctahedronBufferGeometry = class extends OctahedronGeometry {
        constructor(radius, detail) {
          console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry.");
          super(radius, detail);
        }
      };
      PlaneBufferGeometry = class extends PlaneGeometry {
        constructor(width2, height2, widthSegments, heightSegments) {
          console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry.");
          super(width2, height2, widthSegments, heightSegments);
        }
      };
      PolyhedronBufferGeometry = class extends PolyhedronGeometry {
        constructor(vertices, indices, radius, detail) {
          console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry.");
          super(vertices, indices, radius, detail);
        }
      };
      RingBufferGeometry = class extends RingGeometry {
        constructor(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
          console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry.");
          super(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength);
        }
      };
      ShapeBufferGeometry = class extends ShapeGeometry {
        constructor(shapes, curveSegments) {
          console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry.");
          super(shapes, curveSegments);
        }
      };
      SphereBufferGeometry = class extends SphereGeometry {
        constructor(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
          console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry.");
          super(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
        }
      };
      TetrahedronBufferGeometry = class extends TetrahedronGeometry {
        constructor(radius, detail) {
          console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry.");
          super(radius, detail);
        }
      };
      TorusBufferGeometry = class extends TorusGeometry {
        constructor(radius, tube, radialSegments, tubularSegments, arc) {
          console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry.");
          super(radius, tube, radialSegments, tubularSegments, arc);
        }
      };
      TorusKnotBufferGeometry = class extends TorusKnotGeometry {
        constructor(radius, tube, tubularSegments, radialSegments, p, q) {
          console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry.");
          super(radius, tube, tubularSegments, radialSegments, p, q);
        }
      };
      TubeBufferGeometry = class extends TubeGeometry {
        constructor(path, tubularSegments, radius, radialSegments, closed) {
          console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry.");
          super(path, tubularSegments, radius, radialSegments, closed);
        }
      };
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
          revision: REVISION
        } }));
      }
      if (typeof window !== "undefined") {
        if (window.__THREE__) {
          console.warn("WARNING: Multiple instances of Three.js being imported.");
        } else {
          window.__THREE__ = REVISION;
        }
      }
    }
  });

  // src/themes/waves.ts
  var waves_exports = {};
  __export(waves_exports, {
    tearDown: () => tearDown2
  });
  function App() {
    document.head.innerHTML += '<link id="theme-waves" rel="stylesheet" type="text/css" href="./themes/waves.css">';
    const conf = {
      nx: 40,
      ny: 100,
      cscale: import_chroma_js.default.scale(["#2175D8", "#DC5DCE", "#CC223D", "#F07414", "#FDEE61", "#74C425"]).mode("lch"),
      darken: -1,
      angle: Math.PI / 3,
      timeCoef: 0.1
    };
    console.debug("THREE", three_module_exports);
    let renderer, scene, camera;
    let width2, height2;
    const { randFloat: rnd } = MathUtils;
    const uTime = { value: 0 }, uTimeCoef = { value: conf.timeCoef };
    const polylines = [];
    init();
    function init() {
      const canvas = document.createElement("canvas");
      canvas.setAttribute("id", "canvas");
      document.body.appendChild(canvas);
      renderer = new WebGLRenderer({ canvas: document.getElementById("canvas"), antialias: true });
      camera = new PerspectiveCamera();
      updateSize();
      window.addEventListener("resize", updateSize, false);
      initScene();
      requestAnimationFrame(animate);
    }
    function initScene() {
      scene = new Scene();
      const vertexShader = `
      uniform float uTime, uTimeCoef;
      uniform float uSize;
      uniform mat2 uMat2;
      uniform vec3 uRnd1;
      uniform vec3 uRnd2;
      uniform vec3 uRnd3;
      uniform vec3 uRnd4;
      uniform vec3 uRnd5;
      attribute vec3 next, prev; 
      attribute float side;
      varying vec2 vUv;

      vec2 dp(vec2 sv) {
        return (1.5 * sv * uMat2);
      }

      void main() {
        vUv = uv;

        vec2 pos = dp(position.xy);

        // Well... I know I should update geometry instead...
        // Computing normal here is not needed
        // vec2 sprev = dp(prev.xy);
        // vec2 snext = dp(next.xy);
        // vec2 tangent = normalize(snext - sprev);
        // vec2 normal = vec2(-tangent.y, tangent.x);
        // float dist = length(snext - sprev);
        // normal *= smoothstep(0.0, 0.02, dist);

        vec2 normal = dp(vec2(1, 0));
        normal *= uSize;

        float time = uTime * uTimeCoef;
        vec3 rnd1 = vec3(cos(time * uRnd1.x + uRnd3.x), cos(time * uRnd1.y + uRnd3.y), cos(time * uRnd1.z + uRnd3.z));
        vec3 rnd2 = vec3(cos(time * uRnd2.x + uRnd4.x), cos(time * uRnd2.y + uRnd4.y), cos(time * uRnd2.z + uRnd4.z));
        normal *= 1.0
          + uRnd5.x * (cos((position.y + rnd1.x) * 20.0 * rnd1.y) + 1.0)
          + uRnd5.y * (sin((position.y + rnd2.x) * 20.0 * rnd2.y) + 1.0)
          + uRnd5.z * (cos((position.y + rnd1.z) * 20.0 * rnd2.z) + 1.0);
        pos.xy -= normal * side;

        gl_Position = vec4(pos, 0.0, 1.0);
      }
    `;
      const fragmentShader = `
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      varying vec2 vUv;
      void main() {
        gl_FragColor = vec4(mix(uColor1, uColor2, vUv.x), 1.0);
      }
    `;
      const dx = 2 / conf.nx, dy = -2 / (conf.ny - 1);
      const ox = -1 + dx / 2, oy = 1;
      const mat2 = Float32Array.from([Math.cos(conf.angle), -Math.sin(conf.angle), Math.sin(conf.angle), Math.cos(conf.angle)]);
      for (let i = 0; i < conf.nx; i++) {
        const points = [];
        for (let j = 0; j < conf.ny; j++) {
          const x = ox + i * dx, y = oy + j * dy;
          points.push(new Vector3(x, y, 0));
        }
        const polyline = new Polyline({ points });
        polylines.push(polyline);
        const material = new ShaderMaterial({
          uniforms: {
            uTime,
            uTimeCoef,
            uMat2: { value: mat2 },
            uSize: { value: 1.5 / conf.nx },
            uRnd1: { value: new Vector3(rnd(-1, 1), rnd(-1, 1), rnd(-1, 1)) },
            uRnd2: { value: new Vector3(rnd(-1, 1), rnd(-1, 1), rnd(-1, 1)) },
            uRnd3: { value: new Vector3(rnd(-1, 1), rnd(-1, 1), rnd(-1, 1)) },
            uRnd4: { value: new Vector3(rnd(-1, 1), rnd(-1, 1), rnd(-1, 1)) },
            uRnd5: { value: new Vector3(rnd(0.2, 0.5), rnd(0.3, 0.6), rnd(0.4, 0.7)) },
            uColor1: { value: new Color(conf.cscale(i / conf.nx).hex()) },
            uColor2: { value: new Color(conf.cscale(i / conf.nx).darken(conf.darken).hex()) }
          },
          vertexShader,
          fragmentShader
        });
        const mesh = new Mesh(polyline.geometry, material);
        scene.add(mesh);
      }
    }
    function disposeScene() {
      for (let i = 0; i < scene.children.length; i++) {
        const mesh = scene.children[i];
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
      }
      scene.dispose();
    }
    function randomCScale() {
      const colors = [], n = 2 + Math.floor(rnd(0, 4));
      for (let i = 0; i < n; i++) {
        colors.push(import_chroma_js.default.random());
      }
      return import_chroma_js.default.scale(colors).mode("lch");
    }
    function animate(t) {
      uTime.value = t * 1e-3;
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    function updateSize() {
      width2 = window.innerWidth;
      height2 = window.innerHeight;
      renderer.setSize(width2, height2);
    }
  }
  var import_chroma_js, Polyline, tearDown2;
  var init_waves = __esm({
    "src/themes/waves.ts"() {
      import_chroma_js = __toESM(require_chroma(), 1);
      init_three_module();
      Polyline = function() {
        const tmp2 = new Vector3();
        class Polyline2 {
          constructor(params2) {
            const { points } = params2;
            this.points = points;
            this.count = points.length;
            this.init();
            this.updateGeometry();
          }
          init() {
            this.geometry = new BufferGeometry();
            this.position = new Float32Array(this.count * 3 * 2);
            this.prev = new Float32Array(this.count * 3 * 2);
            this.next = new Float32Array(this.count * 3 * 2);
            const side = new Float32Array(this.count * 1 * 2);
            const uv = new Float32Array(this.count * 2 * 2);
            const index = new Uint16Array((this.count - 1) * 3 * 2);
            for (let i = 0; i < this.count; i++) {
              const i2 = i * 2;
              side.set([-1, 1], i2);
              const v = i / (this.count - 1);
              uv.set([0, v, 1, v], i * 4);
              if (i === this.count - 1)
                continue;
              index.set([i2 + 0, i2 + 1, i2 + 2], (i2 + 0) * 3);
              index.set([i2 + 2, i2 + 1, i2 + 3], (i2 + 1) * 3);
            }
            this.geometry.setAttribute("position", new BufferAttribute(this.position, 3));
            this.geometry.setAttribute("prev", new BufferAttribute(this.prev, 3));
            this.geometry.setAttribute("next", new BufferAttribute(this.next, 3));
            this.geometry.setAttribute("side", new BufferAttribute(side, 1));
            this.geometry.setAttribute("uv", new BufferAttribute(uv, 2));
            this.geometry.setIndex(new BufferAttribute(index, 1));
          }
          updateGeometry() {
            this.points.forEach((p, i) => {
              p.toArray(this.position, i * 3 * 2);
              p.toArray(this.position, i * 3 * 2 + 3);
              if (!i) {
                tmp2.copy(p).sub(this.points[i + 1]).add(p);
                tmp2.toArray(this.prev, i * 3 * 2);
                tmp2.toArray(this.prev, i * 3 * 2 + 3);
              } else {
                p.toArray(this.next, (i - 1) * 3 * 2);
                p.toArray(this.next, (i - 1) * 3 * 2 + 3);
              }
              if (i === this.points.length - 1) {
                tmp2.copy(p).sub(this.points[i - 1]).add(p);
                tmp2.toArray(this.next, i * 3 * 2);
                tmp2.toArray(this.next, i * 3 * 2 + 3);
              } else {
                p.toArray(this.prev, (i + 1) * 3 * 2);
                p.toArray(this.prev, (i + 1) * 3 * 2 + 3);
              }
            });
            this.geometry.attributes.position.needsUpdate = true;
            this.geometry.attributes.prev.needsUpdate = true;
            this.geometry.attributes.next.needsUpdate = true;
          }
        }
        return Polyline2;
      }();
      App();
      tearDown2 = () => {
        document.getElementById("theme-waves").remove();
      };
    }
  });

  // node_modules/ramda/es/internal/_isPlaceholder.js
  function _isPlaceholder(a) {
    return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
  }

  // node_modules/ramda/es/internal/_curry1.js
  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }

  // node_modules/ramda/es/internal/_curry2.js
  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;
        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
            return fn(a, _b);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a) {
            return fn(_a, b);
          }) : _isPlaceholder(b) ? _curry1(function(_b) {
            return fn(a, _b);
          }) : fn(a, b);
      }
    };
  }

  // node_modules/ramda/es/add.js
  var add = /* @__PURE__ */ _curry2(function add2(a, b) {
    return Number(a) + Number(b);
  });
  var add_default = add;

  // node_modules/ramda/es/internal/_arity.js
  function _arity(n, fn) {
    switch (n) {
      case 0:
        return function() {
          return fn.apply(this, arguments);
        };
      case 1:
        return function(a0) {
          return fn.apply(this, arguments);
        };
      case 2:
        return function(a0, a1) {
          return fn.apply(this, arguments);
        };
      case 3:
        return function(a0, a1, a2) {
          return fn.apply(this, arguments);
        };
      case 4:
        return function(a0, a1, a2, a3) {
          return fn.apply(this, arguments);
        };
      case 5:
        return function(a0, a1, a2, a3, a4) {
          return fn.apply(this, arguments);
        };
      case 6:
        return function(a0, a1, a2, a3, a4, a5) {
          return fn.apply(this, arguments);
        };
      case 7:
        return function(a0, a1, a2, a3, a4, a5, a6) {
          return fn.apply(this, arguments);
        };
      case 8:
        return function(a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.apply(this, arguments);
        };
      case 9:
        return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.apply(this, arguments);
        };
      case 10:
        return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.apply(this, arguments);
        };
      default:
        throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
    }
  }

  // node_modules/ramda/es/internal/_curryN.js
  function _curryN(length, received, fn) {
    return function() {
      var combined = [];
      var argsIdx = 0;
      var left = length;
      var combinedIdx = 0;
      while (combinedIdx < received.length || argsIdx < arguments.length) {
        var result;
        if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
          result = received[combinedIdx];
        } else {
          result = arguments[argsIdx];
          argsIdx += 1;
        }
        combined[combinedIdx] = result;
        if (!_isPlaceholder(result)) {
          left -= 1;
        }
        combinedIdx += 1;
      }
      return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
    };
  }

  // node_modules/ramda/es/curryN.js
  var curryN = /* @__PURE__ */ _curry2(function curryN2(length, fn) {
    if (length === 1) {
      return _curry1(fn);
    }
    return _arity(length, _curryN(length, [], fn));
  });
  var curryN_default = curryN;

  // node_modules/ramda/es/internal/_curry3.js
  function _curry3(fn) {
    return function f3(a, b, c) {
      switch (arguments.length) {
        case 0:
          return f3;
        case 1:
          return _isPlaceholder(a) ? f3 : _curry2(function(_b, _c) {
            return fn(a, _b, _c);
          });
        case 2:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function(_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) ? _curry2(function(_b, _c) {
            return fn(a, _b, _c);
          }) : _curry1(function(_c) {
            return fn(a, b, _c);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function(_a, _b) {
            return fn(_a, _b, c);
          }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function(_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function(_b, _c) {
            return fn(a, _b, _c);
          }) : _isPlaceholder(a) ? _curry1(function(_a) {
            return fn(_a, b, c);
          }) : _isPlaceholder(b) ? _curry1(function(_b) {
            return fn(a, _b, c);
          }) : _isPlaceholder(c) ? _curry1(function(_c) {
            return fn(a, b, _c);
          }) : fn(a, b, c);
      }
    };
  }

  // node_modules/ramda/es/internal/_isArray.js
  var isArray_default = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
  };

  // node_modules/ramda/es/internal/_isTransformer.js
  function _isTransformer(obj) {
    return obj != null && typeof obj["@@transducer/step"] === "function";
  }

  // node_modules/ramda/es/internal/_dispatchable.js
  function _dispatchable(methodNames, transducerCreator, fn) {
    return function() {
      if (arguments.length === 0) {
        return fn();
      }
      var obj = arguments[arguments.length - 1];
      if (!isArray_default(obj)) {
        var idx = 0;
        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === "function") {
            return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
          }
          idx += 1;
        }
        if (_isTransformer(obj)) {
          var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
          return transducer(obj);
        }
      }
      return fn.apply(this, arguments);
    };
  }

  // node_modules/ramda/es/internal/_reduced.js
  function _reduced(x) {
    return x && x["@@transducer/reduced"] ? x : {
      "@@transducer/value": x,
      "@@transducer/reduced": true
    };
  }

  // node_modules/ramda/es/internal/_xfBase.js
  var xfBase_default = {
    init: function() {
      return this.xf["@@transducer/init"]();
    },
    result: function(result) {
      return this.xf["@@transducer/result"](result);
    }
  };

  // node_modules/ramda/es/internal/_map.js
  function _map(fn, functor) {
    var idx = 0;
    var len = functor.length;
    var result = Array(len);
    while (idx < len) {
      result[idx] = fn(functor[idx]);
      idx += 1;
    }
    return result;
  }

  // node_modules/ramda/es/internal/_isString.js
  function _isString(x) {
    return Object.prototype.toString.call(x) === "[object String]";
  }

  // node_modules/ramda/es/internal/_isArrayLike.js
  var _isArrayLike = /* @__PURE__ */ _curry1(function isArrayLike(x) {
    if (isArray_default(x)) {
      return true;
    }
    if (!x) {
      return false;
    }
    if (typeof x !== "object") {
      return false;
    }
    if (_isString(x)) {
      return false;
    }
    if (x.length === 0) {
      return true;
    }
    if (x.length > 0) {
      return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
    }
    return false;
  });
  var isArrayLike_default = _isArrayLike;

  // node_modules/ramda/es/internal/_xwrap.js
  var XWrap = /* @__PURE__ */ function() {
    function XWrap2(fn) {
      this.f = fn;
    }
    XWrap2.prototype["@@transducer/init"] = function() {
      throw new Error("init not implemented on XWrap");
    };
    XWrap2.prototype["@@transducer/result"] = function(acc) {
      return acc;
    };
    XWrap2.prototype["@@transducer/step"] = function(acc, x) {
      return this.f(acc, x);
    };
    return XWrap2;
  }();
  function _xwrap(fn) {
    return new XWrap(fn);
  }

  // node_modules/ramda/es/bind.js
  var bind = /* @__PURE__ */ _curry2(function bind2(fn, thisObj) {
    return _arity(fn.length, function() {
      return fn.apply(thisObj, arguments);
    });
  });
  var bind_default = bind;

  // node_modules/ramda/es/internal/_reduce.js
  function _arrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      acc = xf["@@transducer/step"](acc, list[idx]);
      if (acc && acc["@@transducer/reduced"]) {
        acc = acc["@@transducer/value"];
        break;
      }
      idx += 1;
    }
    return xf["@@transducer/result"](acc);
  }
  function _iterableReduce(xf, acc, iter) {
    var step = iter.next();
    while (!step.done) {
      acc = xf["@@transducer/step"](acc, step.value);
      if (acc && acc["@@transducer/reduced"]) {
        acc = acc["@@transducer/value"];
        break;
      }
      step = iter.next();
    }
    return xf["@@transducer/result"](acc);
  }
  function _methodReduce(xf, acc, obj, methodName) {
    return xf["@@transducer/result"](obj[methodName](bind_default(xf["@@transducer/step"], xf), acc));
  }
  var symIterator = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
  function _reduce(fn, acc, list) {
    if (typeof fn === "function") {
      fn = _xwrap(fn);
    }
    if (isArrayLike_default(list)) {
      return _arrayReduce(fn, acc, list);
    }
    if (typeof list["fantasy-land/reduce"] === "function") {
      return _methodReduce(fn, acc, list, "fantasy-land/reduce");
    }
    if (list[symIterator] != null) {
      return _iterableReduce(fn, acc, list[symIterator]());
    }
    if (typeof list.next === "function") {
      return _iterableReduce(fn, acc, list);
    }
    if (typeof list.reduce === "function") {
      return _methodReduce(fn, acc, list, "reduce");
    }
    throw new TypeError("reduce: list must be array or iterable");
  }

  // node_modules/ramda/es/internal/_xmap.js
  var XMap = /* @__PURE__ */ function() {
    function XMap2(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XMap2.prototype["@@transducer/init"] = xfBase_default.init;
    XMap2.prototype["@@transducer/result"] = xfBase_default.result;
    XMap2.prototype["@@transducer/step"] = function(result, input) {
      return this.xf["@@transducer/step"](result, this.f(input));
    };
    return XMap2;
  }();
  var _xmap = /* @__PURE__ */ _curry2(function _xmap2(f, xf) {
    return new XMap(f, xf);
  });
  var xmap_default = _xmap;

  // node_modules/ramda/es/internal/_has.js
  function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  // node_modules/ramda/es/internal/_isArguments.js
  var toString = Object.prototype.toString;
  var _isArguments = /* @__PURE__ */ function() {
    return toString.call(arguments) === "[object Arguments]" ? function _isArguments2(x) {
      return toString.call(x) === "[object Arguments]";
    } : function _isArguments2(x) {
      return _has("callee", x);
    };
  }();
  var isArguments_default = _isArguments;

  // node_modules/ramda/es/keys.js
  var hasEnumBug = !/* @__PURE__ */ {
    toString: null
  }.propertyIsEnumerable("toString");
  var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
  var hasArgsEnumBug = /* @__PURE__ */ function() {
    "use strict";
    return arguments.propertyIsEnumerable("length");
  }();
  var contains = function contains2(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };
  var keys = typeof Object.keys === "function" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys2(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) : /* @__PURE__ */ _curry1(function keys3(obj) {
    if (Object(obj) !== obj) {
      return [];
    }
    var prop, nIdx;
    var ks = [];
    var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);
    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== "length")) {
        ks[ks.length] = prop;
      }
    }
    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;
      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];
        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }
        nIdx -= 1;
      }
    }
    return ks;
  });
  var keys_default = keys;

  // node_modules/ramda/es/map.js
  var map = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _dispatchable(["fantasy-land/map", "map"], xmap_default, function map2(fn, functor) {
      switch (Object.prototype.toString.call(functor)) {
        case "[object Function]":
          return curryN_default(functor.length, function() {
            return fn.call(this, functor.apply(this, arguments));
          });
        case "[object Object]":
          return _reduce(function(acc, key) {
            acc[key] = fn(functor[key]);
            return acc;
          }, {}, keys_default(functor));
        default:
          return _map(fn, functor);
      }
    })
  );
  var map_default = map;

  // node_modules/ramda/es/internal/_isInteger.js
  var isInteger_default = Number.isInteger || function _isInteger(n) {
    return n << 0 === n;
  };

  // node_modules/ramda/es/reduce.js
  var reduce = /* @__PURE__ */ _curry3(_reduce);
  var reduce_default = reduce;

  // node_modules/ramda/es/values.js
  var values = /* @__PURE__ */ _curry1(function values2(obj) {
    var props = keys_default(obj);
    var len = props.length;
    var vals = [];
    var idx = 0;
    while (idx < len) {
      vals[idx] = obj[props[idx]];
      idx += 1;
    }
    return vals;
  });
  var values_default = values;

  // node_modules/ramda/es/internal/_assoc.js
  function _assoc(prop, val, obj) {
    if (isInteger_default(prop) && isArray_default(obj)) {
      var arr = [].concat(obj);
      arr[prop] = val;
      return arr;
    }
    var result = {};
    for (var p in obj) {
      result[p] = obj[p];
    }
    result[prop] = val;
    return result;
  }

  // node_modules/ramda/es/isNil.js
  var isNil = /* @__PURE__ */ _curry1(function isNil2(x) {
    return x == null;
  });
  var isNil_default = isNil;

  // node_modules/ramda/es/assocPath.js
  var assocPath = /* @__PURE__ */ _curry3(function assocPath2(path, val, obj) {
    if (path.length === 0) {
      return val;
    }
    var idx = path[0];
    if (path.length > 1) {
      var nextObj = !isNil_default(obj) && _has(idx, obj) ? obj[idx] : isInteger_default(path[1]) ? [] : {};
      val = assocPath2(Array.prototype.slice.call(path, 1), val, nextObj);
    }
    return _assoc(idx, val, obj);
  });
  var assocPath_default = assocPath;

  // node_modules/ramda/es/assoc.js
  var assoc = /* @__PURE__ */ _curry3(function assoc2(prop, val, obj) {
    return assocPath_default([prop], val, obj);
  });
  var assoc_default = assoc;

  // node_modules/ramda/es/internal/_cloneRegExp.js
  function _cloneRegExp(pattern) {
    return new RegExp(pattern.source, (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : ""));
  }

  // node_modules/ramda/es/type.js
  var type = /* @__PURE__ */ _curry1(function type2(val) {
    return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
  });
  var type_default = type;

  // node_modules/ramda/es/internal/_clone.js
  function _clone(value, refFrom, refTo, deep) {
    var copy = function copy2(copiedValue) {
      var len = refFrom.length;
      var idx = 0;
      while (idx < len) {
        if (value === refFrom[idx]) {
          return refTo[idx];
        }
        idx += 1;
      }
      refFrom[idx] = value;
      refTo[idx] = copiedValue;
      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
        }
      }
      return copiedValue;
    };
    switch (type_default(value)) {
      case "Object":
        return copy(Object.create(Object.getPrototypeOf(value)));
      case "Array":
        return copy([]);
      case "Date":
        return new Date(value.valueOf());
      case "RegExp":
        return _cloneRegExp(value);
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array":
        return value.slice();
      default:
        return value;
    }
  }

  // node_modules/ramda/es/internal/_pipe.js
  function _pipe(f, g) {
    return function() {
      return g.call(this, f.apply(this, arguments));
    };
  }

  // node_modules/ramda/es/internal/_checkForMethod.js
  function _checkForMethod(methodname, fn) {
    return function() {
      var length = arguments.length;
      if (length === 0) {
        return fn();
      }
      var obj = arguments[length - 1];
      return isArray_default(obj) || typeof obj[methodname] !== "function" ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
    };
  }

  // node_modules/ramda/es/slice.js
  var slice = /* @__PURE__ */ _curry3(
    /* @__PURE__ */ _checkForMethod("slice", function slice2(fromIndex, toIndex, list) {
      return Array.prototype.slice.call(list, fromIndex, toIndex);
    })
  );
  var slice_default = slice;

  // node_modules/ramda/es/tail.js
  var tail = /* @__PURE__ */ _curry1(
    /* @__PURE__ */ _checkForMethod(
      "tail",
      /* @__PURE__ */ slice_default(1, Infinity)
    )
  );
  var tail_default = tail;

  // node_modules/ramda/es/pipe.js
  function pipe() {
    if (arguments.length === 0) {
      throw new Error("pipe requires at least one argument");
    }
    return _arity(arguments[0].length, reduce_default(_pipe, arguments[0], tail_default(arguments)));
  }

  // node_modules/ramda/es/internal/_toISOString.js
  var pad = function pad2(n) {
    return (n < 10 ? "0" : "") + n;
  };
  var _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d) {
    return d.toISOString();
  } : function _toISOString3(d) {
    return d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "." + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
  };

  // node_modules/ramda/es/internal/_filter.js
  function _filter(fn, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    while (idx < len) {
      if (fn(list[idx])) {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
    return result;
  }

  // node_modules/ramda/es/internal/_isObject.js
  function _isObject(x) {
    return Object.prototype.toString.call(x) === "[object Object]";
  }

  // node_modules/ramda/es/internal/_xfilter.js
  var XFilter = /* @__PURE__ */ function() {
    function XFilter2(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XFilter2.prototype["@@transducer/init"] = xfBase_default.init;
    XFilter2.prototype["@@transducer/result"] = xfBase_default.result;
    XFilter2.prototype["@@transducer/step"] = function(result, input) {
      return this.f(input) ? this.xf["@@transducer/step"](result, input) : result;
    };
    return XFilter2;
  }();
  var _xfilter = /* @__PURE__ */ _curry2(function _xfilter2(f, xf) {
    return new XFilter(f, xf);
  });
  var xfilter_default = _xfilter;

  // node_modules/ramda/es/filter.js
  var filter = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _dispatchable(["fantasy-land/filter", "filter"], xfilter_default, function(pred, filterable) {
      return _isObject(filterable) ? _reduce(function(acc, key) {
        if (pred(filterable[key])) {
          acc[key] = filterable[key];
        }
        return acc;
      }, {}, keys_default(filterable)) : _filter(pred, filterable);
    })
  );
  var filter_default = filter;

  // node_modules/ramda/es/internal/_xreduceBy.js
  var XReduceBy = /* @__PURE__ */ function() {
    function XReduceBy2(valueFn, valueAcc, keyFn, xf) {
      this.valueFn = valueFn;
      this.valueAcc = valueAcc;
      this.keyFn = keyFn;
      this.xf = xf;
      this.inputs = {};
    }
    XReduceBy2.prototype["@@transducer/init"] = xfBase_default.init;
    XReduceBy2.prototype["@@transducer/result"] = function(result) {
      var key;
      for (key in this.inputs) {
        if (_has(key, this.inputs)) {
          result = this.xf["@@transducer/step"](result, this.inputs[key]);
          if (result["@@transducer/reduced"]) {
            result = result["@@transducer/value"];
            break;
          }
        }
      }
      this.inputs = null;
      return this.xf["@@transducer/result"](result);
    };
    XReduceBy2.prototype["@@transducer/step"] = function(result, input) {
      var key = this.keyFn(input);
      this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
      this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
      return result;
    };
    return XReduceBy2;
  }();
  var _xreduceBy = /* @__PURE__ */ _curryN(4, [], function _xreduceBy2(valueFn, valueAcc, keyFn, xf) {
    return new XReduceBy(valueFn, valueAcc, keyFn, xf);
  });
  var xreduceBy_default = _xreduceBy;

  // node_modules/ramda/es/reduceBy.js
  var reduceBy = /* @__PURE__ */ _curryN(
    4,
    [],
    /* @__PURE__ */ _dispatchable([], xreduceBy_default, function reduceBy2(valueFn, valueAcc, keyFn, list) {
      return _reduce(function(acc, elt) {
        var key = keyFn(elt);
        var value = valueFn(_has(key, acc) ? acc[key] : _clone(valueAcc, [], [], false), elt);
        if (value && value["@@transducer/reduced"]) {
          return _reduced(acc);
        }
        acc[key] = value;
        return acc;
      }, {}, list);
    })
  );
  var reduceBy_default = reduceBy;

  // node_modules/ramda/es/remove.js
  var remove = /* @__PURE__ */ _curry3(function remove2(start2, count, list) {
    var result = Array.prototype.slice.call(list, 0);
    result.splice(start2, count);
    return result;
  });
  var remove_default = remove;

  // node_modules/ramda/es/internal/_dissoc.js
  function _dissoc(prop, obj) {
    if (obj == null) {
      return obj;
    }
    if (isInteger_default(prop) && isArray_default(obj)) {
      return remove_default(prop, 1, obj);
    }
    var result = {};
    for (var p in obj) {
      result[p] = obj[p];
    }
    delete result[prop];
    return result;
  }

  // node_modules/ramda/es/dissocPath.js
  function _shallowCloneObject(prop, obj) {
    if (isInteger_default(prop) && isArray_default(obj)) {
      return [].concat(obj);
    }
    var result = {};
    for (var p in obj) {
      result[p] = obj[p];
    }
    return result;
  }
  var dissocPath = /* @__PURE__ */ _curry2(function dissocPath2(path, obj) {
    if (obj == null) {
      return obj;
    }
    switch (path.length) {
      case 0:
        return obj;
      case 1:
        return _dissoc(path[0], obj);
      default:
        var head = path[0];
        var tail2 = Array.prototype.slice.call(path, 1);
        if (obj[head] == null) {
          return _shallowCloneObject(head, obj);
        } else {
          return assoc_default(head, dissocPath2(tail2, obj[head]), obj);
        }
    }
  });
  var dissocPath_default = dissocPath;

  // node_modules/ramda/es/dissoc.js
  var dissoc = /* @__PURE__ */ _curry2(function dissoc2(prop, obj) {
    return dissocPath_default([prop], obj);
  });
  var dissoc_default = dissoc;

  // node_modules/ramda/es/forEach.js
  var forEach = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _checkForMethod("forEach", function forEach2(fn, list) {
      var len = list.length;
      var idx = 0;
      while (idx < len) {
        fn(list[idx]);
        idx += 1;
      }
      return list;
    })
  );
  var forEach_default = forEach;

  // node_modules/ramda/es/groupBy.js
  var groupBy = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _checkForMethod(
      "groupBy",
      /* @__PURE__ */ reduceBy_default(function(acc, item) {
        acc.push(item);
        return acc;
      }, [])
    )
  );
  var groupBy_default = groupBy;

  // node_modules/ramda/es/mapAccum.js
  var mapAccum = /* @__PURE__ */ _curry3(function mapAccum2(fn, acc, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    var tuple = [acc];
    while (idx < len) {
      tuple = fn(tuple[0], list[idx]);
      result[idx] = tuple[1];
      idx += 1;
    }
    return [tuple[0], result];
  });
  var mapAccum_default = mapAccum;

  // node_modules/ramda/es/mapObjIndexed.js
  var mapObjIndexed = /* @__PURE__ */ _curry2(function mapObjIndexed2(fn, obj) {
    return _reduce(function(acc, key) {
      acc[key] = fn(obj[key], key, obj);
      return acc;
    }, {}, keys_default(obj));
  });
  var mapObjIndexed_default = mapObjIndexed;

  // node_modules/ramda/es/sum.js
  var sum = /* @__PURE__ */ reduce_default(add_default, 0);
  var sum_default = sum;

  // node_modules/ramda/es/omit.js
  var omit = /* @__PURE__ */ _curry2(function omit2(names, obj) {
    var result = {};
    var index = {};
    var idx = 0;
    var len = names.length;
    while (idx < len) {
      index[names[idx]] = 1;
      idx += 1;
    }
    for (var prop in obj) {
      if (!index.hasOwnProperty(prop)) {
        result[prop] = obj[prop];
      }
    }
    return result;
  });
  var omit_default = omit;

  // node_modules/ramda/es/trim.js
  var hasProtoTrim = typeof String.prototype.trim === "function";

  // node_modules/peerjs/dist/bundler.mjs
  var import_peerjs_js_binarypack = __toESM(require_binarypack(), 1);

  // node_modules/webrtc-adapter/src/js/utils.js
  var logDisabled_ = true;
  var deprecationWarnings_ = true;
  function extractVersion(uastring, expr, pos) {
    const match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  }
  function wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    const proto = window2.RTCPeerConnection.prototype;
    const nativeAddEventListener = proto.addEventListener;
    proto.addEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap) {
        return nativeAddEventListener.apply(this, arguments);
      }
      const wrappedCallback = (e) => {
        const modifiedEvent = wrapper(e);
        if (modifiedEvent) {
          if (cb.handleEvent) {
            cb.handleEvent(modifiedEvent);
          } else {
            cb(modifiedEvent);
          }
        }
      };
      this._eventMap = this._eventMap || {};
      if (!this._eventMap[eventNameToWrap]) {
        this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
      }
      this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
      return nativeAddEventListener.apply(this, [
        nativeEventName,
        wrappedCallback
      ]);
    };
    const nativeRemoveEventListener = proto.removeEventListener;
    proto.removeEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      if (!this._eventMap[eventNameToWrap].has(cb)) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
      this._eventMap[eventNameToWrap].delete(cb);
      if (this._eventMap[eventNameToWrap].size === 0) {
        delete this._eventMap[eventNameToWrap];
      }
      if (Object.keys(this._eventMap).length === 0) {
        delete this._eventMap;
      }
      return nativeRemoveEventListener.apply(this, [
        nativeEventName,
        unwrappedCb
      ]);
    };
    Object.defineProperty(proto, "on" + eventNameToWrap, {
      get() {
        return this["_on" + eventNameToWrap];
      },
      set(cb) {
        if (this["_on" + eventNameToWrap]) {
          this.removeEventListener(
            eventNameToWrap,
            this["_on" + eventNameToWrap]
          );
          delete this["_on" + eventNameToWrap];
        }
        if (cb) {
          this.addEventListener(
            eventNameToWrap,
            this["_on" + eventNameToWrap] = cb
          );
        }
      },
      enumerable: true,
      configurable: true
    });
  }
  function disableLog(bool) {
    if (typeof bool !== "boolean") {
      return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
    }
    logDisabled_ = bool;
    return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
  }
  function disableWarnings(bool) {
    if (typeof bool !== "boolean") {
      return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
    }
    deprecationWarnings_ = !bool;
    return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
  }
  function log() {
    if (typeof window === "object") {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== "undefined" && typeof console.log === "function") {
        console.log.apply(console, arguments);
      }
    }
  }
  function deprecated(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
  }
  function detectBrowser(window2) {
    const result = { browser: null, version: null };
    if (typeof window2 === "undefined" || !window2.navigator) {
      result.browser = "Not a browser.";
      return result;
    }
    const { navigator: navigator2 } = window2;
    if (navigator2.mozGetUserMedia) {
      result.browser = "firefox";
      result.version = extractVersion(
        navigator2.userAgent,
        /Firefox\/(\d+)\./,
        1
      );
    } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection && !window2.RTCIceGatherer) {
      result.browser = "chrome";
      result.version = extractVersion(
        navigator2.userAgent,
        /Chrom(e|ium)\/(\d+)\./,
        2
      );
    } else if (navigator2.mediaDevices && navigator2.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
      result.browser = "edge";
      result.version = extractVersion(
        navigator2.userAgent,
        /Edge\/(\d+).(\d+)$/,
        2
      );
    } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
      result.browser = "safari";
      result.version = extractVersion(
        navigator2.userAgent,
        /AppleWebKit\/(\d+)\./,
        1
      );
      result.supportsUnifiedPlan = window2.RTCRtpTransceiver && "currentDirection" in window2.RTCRtpTransceiver.prototype;
    } else {
      result.browser = "Not a supported browser.";
      return result;
    }
    return result;
  }
  function isObject(val) {
    return Object.prototype.toString.call(val) === "[object Object]";
  }
  function compactObject(data) {
    if (!isObject(data)) {
      return data;
    }
    return Object.keys(data).reduce(function(accumulator, key) {
      const isObj = isObject(data[key]);
      const value = isObj ? compactObject(data[key]) : data[key];
      const isEmptyObject = isObj && !Object.keys(value).length;
      if (value === void 0 || isEmptyObject) {
        return accumulator;
      }
      return Object.assign(accumulator, { [key]: value });
    }, {});
  }
  function walkStats(stats, base, resultSet) {
    if (!base || resultSet.has(base.id)) {
      return;
    }
    resultSet.set(base.id, base);
    Object.keys(base).forEach((name) => {
      if (name.endsWith("Id")) {
        walkStats(stats, stats.get(base[name]), resultSet);
      } else if (name.endsWith("Ids")) {
        base[name].forEach((id2) => {
          walkStats(stats, stats.get(id2), resultSet);
        });
      }
    });
  }
  function filterStats(result, track, outbound) {
    const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
    const filteredResult = /* @__PURE__ */ new Map();
    if (track === null) {
      return filteredResult;
    }
    const trackStats = [];
    result.forEach((value) => {
      if (value.type === "track" && value.trackIdentifier === track.id) {
        trackStats.push(value);
      }
    });
    trackStats.forEach((trackStat) => {
      result.forEach((stats) => {
        if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
          walkStats(result, stats, filteredResult);
        }
      });
    });
    return filteredResult;
  }

  // node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js
  var chrome_shim_exports = {};
  __export(chrome_shim_exports, {
    fixNegotiationNeeded: () => fixNegotiationNeeded,
    shimAddTrackRemoveTrack: () => shimAddTrackRemoveTrack,
    shimAddTrackRemoveTrackWithNative: () => shimAddTrackRemoveTrackWithNative,
    shimGetDisplayMedia: () => shimGetDisplayMedia,
    shimGetSendersWithDtmf: () => shimGetSendersWithDtmf,
    shimGetStats: () => shimGetStats,
    shimGetUserMedia: () => shimGetUserMedia,
    shimMediaStream: () => shimMediaStream,
    shimOnTrack: () => shimOnTrack,
    shimPeerConnection: () => shimPeerConnection,
    shimSenderReceiverGetStats: () => shimSenderReceiverGetStats
  });

  // node_modules/webrtc-adapter/src/js/chrome/getusermedia.js
  var logging = log;
  function shimGetUserMedia(window2, browserDetails) {
    const navigator2 = window2 && window2.navigator;
    if (!navigator2.mediaDevices) {
      return;
    }
    const constraintsToChrome_ = function(c) {
      if (typeof c !== "object" || c.mandatory || c.optional) {
        return c;
      }
      const cc = {};
      Object.keys(c).forEach((key) => {
        if (key === "require" || key === "advanced" || key === "mediaSource") {
          return;
        }
        const r = typeof c[key] === "object" ? c[key] : { ideal: c[key] };
        if (r.exact !== void 0 && typeof r.exact === "number") {
          r.min = r.max = r.exact;
        }
        const oldname_ = function(prefix, name) {
          if (prefix) {
            return prefix + name.charAt(0).toUpperCase() + name.slice(1);
          }
          return name === "deviceId" ? "sourceId" : name;
        };
        if (r.ideal !== void 0) {
          cc.optional = cc.optional || [];
          let oc = {};
          if (typeof r.ideal === "number") {
            oc[oldname_("min", key)] = r.ideal;
            cc.optional.push(oc);
            oc = {};
            oc[oldname_("max", key)] = r.ideal;
            cc.optional.push(oc);
          } else {
            oc[oldname_("", key)] = r.ideal;
            cc.optional.push(oc);
          }
        }
        if (r.exact !== void 0 && typeof r.exact !== "number") {
          cc.mandatory = cc.mandatory || {};
          cc.mandatory[oldname_("", key)] = r.exact;
        } else {
          ["min", "max"].forEach((mix) => {
            if (r[mix] !== void 0) {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_(mix, key)] = r[mix];
            }
          });
        }
      });
      if (c.advanced) {
        cc.optional = (cc.optional || []).concat(c.advanced);
      }
      return cc;
    };
    const shimConstraints_ = function(constraints, func) {
      if (browserDetails.version >= 61) {
        return func(constraints);
      }
      constraints = JSON.parse(JSON.stringify(constraints));
      if (constraints && typeof constraints.audio === "object") {
        const remap = function(obj, a, b) {
          if (a in obj && !(b in obj)) {
            obj[b] = obj[a];
            delete obj[a];
          }
        };
        constraints = JSON.parse(JSON.stringify(constraints));
        remap(constraints.audio, "autoGainControl", "googAutoGainControl");
        remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
        constraints.audio = constraintsToChrome_(constraints.audio);
      }
      if (constraints && typeof constraints.video === "object") {
        let face = constraints.video.facingMode;
        face = face && (typeof face === "object" ? face : { ideal: face });
        const getSupportedFacingModeLies = browserDetails.version < 66;
        if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
          delete constraints.video.facingMode;
          let matches;
          if (face.exact === "environment" || face.ideal === "environment") {
            matches = ["back", "rear"];
          } else if (face.exact === "user" || face.ideal === "user") {
            matches = ["front"];
          }
          if (matches) {
            return navigator2.mediaDevices.enumerateDevices().then((devices) => {
              devices = devices.filter((d) => d.kind === "videoinput");
              let dev = devices.find((d) => matches.some((match) => d.label.toLowerCase().includes(match)));
              if (!dev && devices.length && matches.includes("back")) {
                dev = devices[devices.length - 1];
              }
              if (dev) {
                constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
              }
              constraints.video = constraintsToChrome_(constraints.video);
              logging("chrome: " + JSON.stringify(constraints));
              return func(constraints);
            });
          }
        }
        constraints.video = constraintsToChrome_(constraints.video);
      }
      logging("chrome: " + JSON.stringify(constraints));
      return func(constraints);
    };
    const shimError_ = function(e) {
      if (browserDetails.version >= 64) {
        return e;
      }
      return {
        name: {
          PermissionDeniedError: "NotAllowedError",
          PermissionDismissedError: "NotAllowedError",
          InvalidStateError: "NotAllowedError",
          DevicesNotFoundError: "NotFoundError",
          ConstraintNotSatisfiedError: "OverconstrainedError",
          TrackStartError: "NotReadableError",
          MediaDeviceFailedDueToShutdown: "NotAllowedError",
          MediaDeviceKillSwitchOn: "NotAllowedError",
          TabCaptureError: "AbortError",
          ScreenCaptureError: "AbortError",
          DeviceCaptureError: "AbortError"
        }[e.name] || e.name,
        message: e.message,
        constraint: e.constraint || e.constraintName,
        toString() {
          return this.name + (this.message && ": ") + this.message;
        }
      };
    };
    const getUserMedia_ = function(constraints, onSuccess, onError) {
      shimConstraints_(constraints, (c) => {
        navigator2.webkitGetUserMedia(c, onSuccess, (e) => {
          if (onError) {
            onError(shimError_(e));
          }
        });
      });
    };
    navigator2.getUserMedia = getUserMedia_.bind(navigator2);
    if (navigator2.mediaDevices.getUserMedia) {
      const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
      navigator2.mediaDevices.getUserMedia = function(cs) {
        return shimConstraints_(cs, (c) => origGetUserMedia(c).then((stream) => {
          if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach((track) => {
              track.stop();
            });
            throw new DOMException("", "NotFoundError");
          }
          return stream;
        }, (e) => Promise.reject(shimError_(e))));
      };
    }
  }

  // node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js
  function shimGetDisplayMedia(window2, getSourceId) {
    if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
      return;
    }
    if (!window2.navigator.mediaDevices) {
      return;
    }
    if (typeof getSourceId !== "function") {
      console.error("shimGetDisplayMedia: getSourceId argument is not a function");
      return;
    }
    window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
      return getSourceId(constraints).then((sourceId) => {
        const widthSpecified = constraints.video && constraints.video.width;
        const heightSpecified = constraints.video && constraints.video.height;
        const frameRateSpecified = constraints.video && constraints.video.frameRate;
        constraints.video = {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: sourceId,
            maxFrameRate: frameRateSpecified || 3
          }
        };
        if (widthSpecified) {
          constraints.video.mandatory.maxWidth = widthSpecified;
        }
        if (heightSpecified) {
          constraints.video.mandatory.maxHeight = heightSpecified;
        }
        return window2.navigator.mediaDevices.getUserMedia(constraints);
      });
    };
  }

  // node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js
  function shimMediaStream(window2) {
    window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;
  }
  function shimOnTrack(window2) {
    if (typeof window2 === "object" && window2.RTCPeerConnection && !("ontrack" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "ontrack", {
        get() {
          return this._ontrack;
        },
        set(f) {
          if (this._ontrack) {
            this.removeEventListener("track", this._ontrack);
          }
          this.addEventListener("track", this._ontrack = f);
        },
        enumerable: true,
        configurable: true
      });
      const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
      window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
        if (!this._ontrackpoly) {
          this._ontrackpoly = (e) => {
            e.stream.addEventListener("addtrack", (te) => {
              let receiver;
              if (window2.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers().find((r) => r.track && r.track.id === te.track.id);
              } else {
                receiver = { track: te.track };
              }
              const event = new Event("track");
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = { receiver };
              event.streams = [e.stream];
              this.dispatchEvent(event);
            });
            e.stream.getTracks().forEach((track) => {
              let receiver;
              if (window2.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers().find((r) => r.track && r.track.id === track.id);
              } else {
                receiver = { track };
              }
              const event = new Event("track");
              event.track = track;
              event.receiver = receiver;
              event.transceiver = { receiver };
              event.streams = [e.stream];
              this.dispatchEvent(event);
            });
          };
          this.addEventListener("addstream", this._ontrackpoly);
        }
        return origSetRemoteDescription.apply(this, arguments);
      };
    } else {
      wrapPeerConnectionEvent(window2, "track", (e) => {
        if (!e.transceiver) {
          Object.defineProperty(
            e,
            "transceiver",
            { value: { receiver: e.receiver } }
          );
        }
        return e;
      });
    }
  }
  function shimGetSendersWithDtmf(window2) {
    if (typeof window2 === "object" && window2.RTCPeerConnection && !("getSenders" in window2.RTCPeerConnection.prototype) && "createDTMFSender" in window2.RTCPeerConnection.prototype) {
      const shimSenderWithDtmf = function(pc, track) {
        return {
          track,
          get dtmf() {
            if (this._dtmf === void 0) {
              if (track.kind === "audio") {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };
      if (!window2.RTCPeerConnection.prototype.getSenders) {
        window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
          this._senders = this._senders || [];
          return this._senders.slice();
        };
        const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
        window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
          let sender = origAddTrack.apply(this, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(this, track);
            this._senders.push(sender);
          }
          return sender;
        };
        const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
        window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
          origRemoveTrack.apply(this, arguments);
          const idx = this._senders.indexOf(sender);
          if (idx !== -1) {
            this._senders.splice(idx, 1);
          }
        };
      }
      const origAddStream = window2.RTCPeerConnection.prototype.addStream;
      window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        this._senders = this._senders || [];
        origAddStream.apply(this, [stream]);
        stream.getTracks().forEach((track) => {
          this._senders.push(shimSenderWithDtmf(this, track));
        });
      };
      const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
      window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
        this._senders = this._senders || [];
        origRemoveStream.apply(this, [stream]);
        stream.getTracks().forEach((track) => {
          const sender = this._senders.find((s) => s.track === track);
          if (sender) {
            this._senders.splice(this._senders.indexOf(sender), 1);
          }
        });
      };
    } else if (typeof window2 === "object" && window2.RTCPeerConnection && "getSenders" in window2.RTCPeerConnection.prototype && "createDTMFSender" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !("dtmf" in window2.RTCRtpSender.prototype)) {
      const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
      Object.defineProperty(window2.RTCRtpSender.prototype, "dtmf", {
        get() {
          if (this._dtmf === void 0) {
            if (this.track.kind === "audio") {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  }
  function shimGetStats(window2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    const origGetStats = window2.RTCPeerConnection.prototype.getStats;
    window2.RTCPeerConnection.prototype.getStats = function getStats() {
      const [selector, onSucc, onErr] = arguments;
      if (arguments.length > 0 && typeof selector === "function") {
        return origGetStats.apply(this, arguments);
      }
      if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== "function")) {
        return origGetStats.apply(this, []);
      }
      const fixChromeStats_ = function(response) {
        const standardReport = {};
        const reports = response.result();
        reports.forEach((report) => {
          const standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: "local-candidate",
              remotecandidate: "remote-candidate"
            }[report.type] || report.type
          };
          report.names().forEach((name) => {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });
        return standardReport;
      };
      const makeMapStats = function(stats) {
        return new Map(Object.keys(stats).map((key) => [key, stats[key]]));
      };
      if (arguments.length >= 2) {
        const successCallbackWrapper_ = function(response) {
          onSucc(makeMapStats(fixChromeStats_(response)));
        };
        return origGetStats.apply(this, [
          successCallbackWrapper_,
          selector
        ]);
      }
      return new Promise((resolve, reject) => {
        origGetStats.apply(this, [
          function(response) {
            resolve(makeMapStats(fixChromeStats_(response)));
          },
          reject
        ]);
      }).then(onSucc, onErr);
    };
  }
  function shimSenderReceiverGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {
      return;
    }
    if (!("getStats" in window2.RTCRtpSender.prototype)) {
      const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
          const senders = origGetSenders.apply(this, []);
          senders.forEach((sender) => sender._pc = this);
          return senders;
        };
      }
      const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
          const sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window2.RTCRtpSender.prototype.getStats = function getStats() {
        const sender = this;
        return this._pc.getStats().then((result) => filterStats(result, sender.track, true));
      };
    }
    if (!("getStats" in window2.RTCRtpReceiver.prototype)) {
      const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
          const receivers = origGetReceivers.apply(this, []);
          receivers.forEach((receiver) => receiver._pc = this);
          return receivers;
        };
      }
      wrapPeerConnectionEvent(window2, "track", (e) => {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window2.RTCRtpReceiver.prototype.getStats = function getStats() {
        const receiver = this;
        return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
      };
    }
    if (!("getStats" in window2.RTCRtpSender.prototype && "getStats" in window2.RTCRtpReceiver.prototype)) {
      return;
    }
    const origGetStats = window2.RTCPeerConnection.prototype.getStats;
    window2.RTCPeerConnection.prototype.getStats = function getStats() {
      if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {
        const track = arguments[0];
        let sender;
        let receiver;
        let err;
        this.getSenders().forEach((s) => {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        this.getReceivers().forEach((r) => {
          if (r.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r;
            }
          }
          return r.track === track;
        });
        if (err || sender && receiver) {
          return Promise.reject(new DOMException(
            "There are more than one sender or receiver for the track.",
            "InvalidAccessError"
          ));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException(
          "There is no sender or receiver for the track.",
          "InvalidAccessError"
        ));
      }
      return origGetStats.apply(this, arguments);
    };
  }
  function shimAddTrackRemoveTrackWithNative(window2) {
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
    };
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      const sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      stream.getTracks().forEach((track) => {
        const alreadyExists = this.getSenders().find((s) => s.track === track);
        if (alreadyExists) {
          throw new DOMException(
            "Track already exists.",
            "InvalidAccessError"
          );
        }
      });
      const existingSenders = this.getSenders();
      origAddStream.apply(this, arguments);
      const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };
    const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
    window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            this._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (this._shimmedLocalStreams[streamId].length === 1) {
            delete this._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  }
  function shimAddTrackRemoveTrack(window2, browserDetails) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (window2.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
      return shimAddTrackRemoveTrackWithNative(window2);
    }
    const origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      const nativeStreams = origGetLocalStreams.apply(this);
      this._reverseStreams = this._reverseStreams || {};
      return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
    };
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      stream.getTracks().forEach((track) => {
        const alreadyExists = this.getSenders().find((s) => s.track === track);
        if (alreadyExists) {
          throw new DOMException(
            "Track already exists.",
            "InvalidAccessError"
          );
        }
      });
      if (!this._reverseStreams[stream.id]) {
        const newStream = new window2.MediaStream(stream.getTracks());
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(this, [stream]);
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
      delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
      delete this._streams[stream.id];
    };
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
      if (this.signalingState === "closed") {
        throw new DOMException(
          "The RTCPeerConnection's signalingState is 'closed'.",
          "InvalidStateError"
        );
      }
      const streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 || !streams[0].getTracks().find((t) => t === track)) {
        throw new DOMException(
          "The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.",
          "NotSupportedError"
        );
      }
      const alreadyExists = this.getSenders().find((s) => s.track === track);
      if (alreadyExists) {
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
      }
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      const oldStream = this._streams[stream.id];
      if (oldStream) {
        oldStream.addTrack(track);
        Promise.resolve().then(() => {
          this.dispatchEvent(new Event("negotiationneeded"));
        });
      } else {
        const newStream = new window2.MediaStream([track]);
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        this.addStream(newStream);
      }
      return this.getSenders().find((s) => s.track === track);
    };
    function replaceInternalStreamId(pc, description) {
      let sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach((internalId) => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(
          new RegExp(internalStream.id, "g"),
          externalStream.id
        );
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      let sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach((internalId) => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(
          new RegExp(externalStream.id, "g"),
          internalStream.id
        );
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp
      });
    }
    ["createOffer", "createAnswer"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = { [method]() {
        const args = arguments;
        const isLegacyCall = arguments.length && typeof arguments[0] === "function";
        if (isLegacyCall) {
          return nativeMethod.apply(this, [
            (description) => {
              const desc = replaceInternalStreamId(this, description);
              args[0].apply(null, [desc]);
            },
            (err) => {
              if (args[1]) {
                args[1].apply(null, err);
              }
            },
            arguments[2]
          ]);
        }
        return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));
      } };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
    const origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
    window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(this, arguments);
      }
      arguments[0] = replaceExternalStreamId(this, arguments[0]);
      return origSetLocalDescription.apply(this, arguments);
    };
    const origLocalDescription = Object.getOwnPropertyDescriptor(
      window2.RTCPeerConnection.prototype,
      "localDescription"
    );
    Object.defineProperty(
      window2.RTCPeerConnection.prototype,
      "localDescription",
      {
        get() {
          const description = origLocalDescription.get.apply(this);
          if (description.type === "") {
            return description;
          }
          return replaceInternalStreamId(this, description);
        }
      }
    );
    window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
      if (this.signalingState === "closed") {
        throw new DOMException(
          "The RTCPeerConnection's signalingState is 'closed'.",
          "InvalidStateError"
        );
      }
      if (!sender._pc) {
        throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
      }
      const isLocal = sender._pc === this;
      if (!isLocal) {
        throw new DOMException(
          "Sender was not created by this connection.",
          "InvalidAccessError"
        );
      }
      this._streams = this._streams || {};
      let stream;
      Object.keys(this._streams).forEach((streamid) => {
        const hasTrack = this._streams[streamid].getTracks().find((track) => sender.track === track);
        if (hasTrack) {
          stream = this._streams[streamid];
        }
      });
      if (stream) {
        if (stream.getTracks().length === 1) {
          this.removeStream(this._reverseStreams[stream.id]);
        } else {
          stream.removeTrack(sender.track);
        }
        this.dispatchEvent(new Event("negotiationneeded"));
      }
    };
  }
  function shimPeerConnection(window2, browserDetails) {
    if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {
      window2.RTCPeerConnection = window2.webkitRTCPeerConnection;
    }
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (browserDetails.version < 53) {
      ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
        const nativeMethod = window2.RTCPeerConnection.prototype[method];
        const methodObj = { [method]() {
          arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
          return nativeMethod.apply(this, arguments);
        } };
        window2.RTCPeerConnection.prototype[method] = methodObj[method];
      });
    }
  }
  function fixNegotiationNeeded(window2, browserDetails) {
    wrapPeerConnectionEvent(window2, "negotiationneeded", (e) => {
      const pc = e.target;
      if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {
        if (pc.signalingState !== "stable") {
          return;
        }
      }
      return e;
    });
  }

  // node_modules/webrtc-adapter/src/js/edge/edge_shim.js
  var edge_shim_exports = {};
  __export(edge_shim_exports, {
    shimGetDisplayMedia: () => shimGetDisplayMedia2,
    shimGetUserMedia: () => shimGetUserMedia2,
    shimPeerConnection: () => shimPeerConnection2,
    shimReplaceTrack: () => shimReplaceTrack
  });

  // node_modules/webrtc-adapter/src/js/edge/filtericeservers.js
  function filterIceServers(iceServers, edgeVersion) {
    let hasTurn = false;
    iceServers = JSON.parse(JSON.stringify(iceServers));
    return iceServers.filter((server) => {
      if (server && (server.urls || server.url)) {
        let urls = server.urls || server.url;
        if (server.url && !server.urls) {
          deprecated("RTCIceServer.url", "RTCIceServer.urls");
        }
        const isString = typeof urls === "string";
        if (isString) {
          urls = [urls];
        }
        urls = urls.filter((url) => {
          if (url.indexOf("stun:") === 0) {
            return false;
          }
          const validTurn = url.startsWith("turn") && !url.startsWith("turn:[") && url.includes("transport=udp");
          if (validTurn && !hasTurn) {
            hasTurn = true;
            return true;
          }
          return validTurn && !hasTurn;
        });
        delete server.url;
        server.urls = isString ? urls[0] : urls;
        return !!urls.length;
      }
    });
  }

  // node_modules/webrtc-adapter/src/js/edge/edge_shim.js
  var import_rtcpeerconnection_shim = __toESM(require_rtcpeerconnection());

  // node_modules/webrtc-adapter/src/js/edge/getusermedia.js
  function shimGetUserMedia2(window2) {
    const navigator2 = window2 && window2.navigator;
    const shimError_ = function(e) {
      return {
        name: { PermissionDeniedError: "NotAllowedError" }[e.name] || e.name,
        message: e.message,
        constraint: e.constraint,
        toString() {
          return this.name;
        }
      };
    };
    const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).catch((e) => Promise.reject(shimError_(e)));
    };
  }

  // node_modules/webrtc-adapter/src/js/edge/getdisplaymedia.js
  function shimGetDisplayMedia2(window2) {
    if (!("getDisplayMedia" in window2.navigator)) {
      return;
    }
    if (!window2.navigator.mediaDevices) {
      return;
    }
    if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
      return;
    }
    window2.navigator.mediaDevices.getDisplayMedia = window2.navigator.getDisplayMedia.bind(window2.navigator);
  }

  // node_modules/webrtc-adapter/src/js/edge/edge_shim.js
  function shimPeerConnection2(window2, browserDetails) {
    if (window2.RTCIceGatherer) {
      if (!window2.RTCIceCandidate) {
        window2.RTCIceCandidate = function RTCIceCandidate2(args) {
          return args;
        };
      }
      if (!window2.RTCSessionDescription) {
        window2.RTCSessionDescription = function RTCSessionDescription2(args) {
          return args;
        };
      }
      if (browserDetails.version < 15025) {
        const origMSTEnabled = Object.getOwnPropertyDescriptor(
          window2.MediaStreamTrack.prototype,
          "enabled"
        );
        Object.defineProperty(window2.MediaStreamTrack.prototype, "enabled", {
          set(value) {
            origMSTEnabled.set.call(this, value);
            const ev = new Event("enabled");
            ev.enabled = value;
            this.dispatchEvent(ev);
          }
        });
      }
    }
    if (window2.RTCRtpSender && !("dtmf" in window2.RTCRtpSender.prototype)) {
      Object.defineProperty(window2.RTCRtpSender.prototype, "dtmf", {
        get() {
          if (this._dtmf === void 0) {
            if (this.track.kind === "audio") {
              this._dtmf = new window2.RTCDtmfSender(this);
            } else if (this.track.kind === "video") {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
    if (window2.RTCDtmfSender && !window2.RTCDTMFSender) {
      window2.RTCDTMFSender = window2.RTCDtmfSender;
    }
    const RTCPeerConnectionShim = (0, import_rtcpeerconnection_shim.default)(
      window2,
      browserDetails.version
    );
    window2.RTCPeerConnection = function RTCPeerConnection2(config) {
      if (config && config.iceServers) {
        config.iceServers = filterIceServers(
          config.iceServers,
          browserDetails.version
        );
        log("ICE servers after filtering:", config.iceServers);
      }
      return new RTCPeerConnectionShim(config);
    };
    window2.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
  }
  function shimReplaceTrack(window2) {
    if (window2.RTCRtpSender && !("replaceTrack" in window2.RTCRtpSender.prototype)) {
      window2.RTCRtpSender.prototype.replaceTrack = window2.RTCRtpSender.prototype.setTrack;
    }
  }

  // node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js
  var firefox_shim_exports = {};
  __export(firefox_shim_exports, {
    shimAddTransceiver: () => shimAddTransceiver,
    shimCreateAnswer: () => shimCreateAnswer,
    shimCreateOffer: () => shimCreateOffer,
    shimGetDisplayMedia: () => shimGetDisplayMedia3,
    shimGetParameters: () => shimGetParameters,
    shimGetUserMedia: () => shimGetUserMedia3,
    shimOnTrack: () => shimOnTrack2,
    shimPeerConnection: () => shimPeerConnection3,
    shimRTCDataChannel: () => shimRTCDataChannel,
    shimReceiverGetStats: () => shimReceiverGetStats,
    shimRemoveStream: () => shimRemoveStream,
    shimSenderGetStats: () => shimSenderGetStats
  });

  // node_modules/webrtc-adapter/src/js/firefox/getusermedia.js
  function shimGetUserMedia3(window2, browserDetails) {
    const navigator2 = window2 && window2.navigator;
    const MediaStreamTrack = window2 && window2.MediaStreamTrack;
    navigator2.getUserMedia = function(constraints, onSuccess, onError) {
      deprecated(
        "navigator.getUserMedia",
        "navigator.mediaDevices.getUserMedia"
      );
      navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
    };
    if (!(browserDetails.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
      const remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
      navigator2.mediaDevices.getUserMedia = function(c) {
        if (typeof c === "object" && typeof c.audio === "object") {
          c = JSON.parse(JSON.stringify(c));
          remap(c.audio, "autoGainControl", "mozAutoGainControl");
          remap(c.audio, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeGetUserMedia(c);
      };
      if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
        const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
        MediaStreamTrack.prototype.getSettings = function() {
          const obj = nativeGetSettings.apply(this, arguments);
          remap(obj, "mozAutoGainControl", "autoGainControl");
          remap(obj, "mozNoiseSuppression", "noiseSuppression");
          return obj;
        };
      }
      if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
        const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
        MediaStreamTrack.prototype.applyConstraints = function(c) {
          if (this.kind === "audio" && typeof c === "object") {
            c = JSON.parse(JSON.stringify(c));
            remap(c, "autoGainControl", "mozAutoGainControl");
            remap(c, "noiseSuppression", "mozNoiseSuppression");
          }
          return nativeApplyConstraints.apply(this, [c]);
        };
      }
    }
  }

  // node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js
  function shimGetDisplayMedia3(window2, preferredMediaSource) {
    if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
      return;
    }
    if (!window2.navigator.mediaDevices) {
      return;
    }
    window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
      if (!(constraints && constraints.video)) {
        const err = new DOMException("getDisplayMedia without video constraints is undefined");
        err.name = "NotFoundError";
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = { mediaSource: preferredMediaSource };
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return window2.navigator.mediaDevices.getUserMedia(constraints);
    };
  }

  // node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js
  function shimOnTrack2(window2) {
    if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
      Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return { receiver: this.receiver };
        }
      });
    }
  }
  function shimPeerConnection3(window2, browserDetails) {
    if (typeof window2 !== "object" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {
      return;
    }
    if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {
      window2.RTCPeerConnection = window2.mozRTCPeerConnection;
    }
    if (browserDetails.version < 53) {
      ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
        const nativeMethod = window2.RTCPeerConnection.prototype[method];
        const methodObj = { [method]() {
          arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
          return nativeMethod.apply(this, arguments);
        } };
        window2.RTCPeerConnection.prototype[method] = methodObj[method];
      });
    }
    const modernStatsTypes = {
      inboundrtp: "inbound-rtp",
      outboundrtp: "outbound-rtp",
      candidatepair: "candidate-pair",
      localcandidate: "local-candidate",
      remotecandidate: "remote-candidate"
    };
    const nativeGetStats = window2.RTCPeerConnection.prototype.getStats;
    window2.RTCPeerConnection.prototype.getStats = function getStats() {
      const [selector, onSucc, onErr] = arguments;
      return nativeGetStats.apply(this, [selector || null]).then((stats) => {
        if (browserDetails.version < 53 && !onSucc) {
          try {
            stats.forEach((stat) => {
              stat.type = modernStatsTypes[stat.type] || stat.type;
            });
          } catch (e) {
            if (e.name !== "TypeError") {
              throw e;
            }
            stats.forEach((stat, i) => {
              stats.set(i, Object.assign({}, stat, {
                type: modernStatsTypes[stat.type] || stat.type
              }));
            });
          }
        }
        return stats;
      }).then(onSucc, onErr);
    };
  }
  function shimSenderGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
      return;
    }
    if (window2.RTCRtpSender && "getStats" in window2.RTCRtpSender.prototype) {
      return;
    }
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
    }
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window2.RTCRtpSender.prototype.getStats = function getStats() {
      return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
    };
  }
  function shimReceiverGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
      return;
    }
    if (window2.RTCRtpSender && "getStats" in window2.RTCRtpReceiver.prototype) {
      return;
    }
    const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => receiver._pc = this);
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window2, "track", (e) => {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window2.RTCRtpReceiver.prototype.getStats = function getStats() {
      return this._pc.getStats(this.track);
    };
  }
  function shimRemoveStream(window2) {
    if (!window2.RTCPeerConnection || "removeStream" in window2.RTCPeerConnection.prototype) {
      return;
    }
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      deprecated("removeStream", "removeTrack");
      this.getSenders().forEach((sender) => {
        if (sender.track && stream.getTracks().includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
  }
  function shimRTCDataChannel(window2) {
    if (window2.DataChannel && !window2.RTCDataChannel) {
      window2.RTCDataChannel = window2.DataChannel;
    }
  }
  function shimAddTransceiver(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;
    if (origAddTransceiver) {
      window2.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
        this.setParametersPromises = [];
        const initParameters = arguments[1];
        const shouldPerformCheck = initParameters && "sendEncodings" in initParameters;
        if (shouldPerformCheck) {
          initParameters.sendEncodings.forEach((encodingParam) => {
            if ("rid" in encodingParam) {
              const ridRegex = /^[a-z0-9]{0,16}$/i;
              if (!ridRegex.test(encodingParam.rid)) {
                throw new TypeError("Invalid RID value provided.");
              }
            }
            if ("scaleResolutionDownBy" in encodingParam) {
              if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
                throw new RangeError("scale_resolution_down_by must be >= 1.0");
              }
            }
            if ("maxFramerate" in encodingParam) {
              if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                throw new RangeError("max_framerate must be >= 0.0");
              }
            }
          });
        }
        const transceiver = origAddTransceiver.apply(this, arguments);
        if (shouldPerformCheck) {
          const { sender } = transceiver;
          const params2 = sender.getParameters();
          if (!("encodings" in params2) || params2.encodings.length === 1 && Object.keys(params2.encodings[0]).length === 0) {
            params2.encodings = initParameters.sendEncodings;
            sender.sendEncodings = initParameters.sendEncodings;
            this.setParametersPromises.push(
              sender.setParameters(params2).then(() => {
                delete sender.sendEncodings;
              }).catch(() => {
                delete sender.sendEncodings;
              })
            );
          }
        }
        return transceiver;
      };
    }
  }
  function shimGetParameters(window2) {
    if (!(typeof window2 === "object" && window2.RTCRtpSender)) {
      return;
    }
    const origGetParameters = window2.RTCRtpSender.prototype.getParameters;
    if (origGetParameters) {
      window2.RTCRtpSender.prototype.getParameters = function getParameters() {
        const params2 = origGetParameters.apply(this, arguments);
        if (!("encodings" in params2)) {
          params2.encodings = [].concat(this.sendEncodings || [{}]);
        }
        return params2;
      };
    }
  }
  function shimCreateOffer(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
    window2.RTCPeerConnection.prototype.createOffer = function createOffer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises).then(() => {
          return origCreateOffer.apply(this, arguments);
        }).finally(() => {
          this.setParametersPromises = [];
        });
      }
      return origCreateOffer.apply(this, arguments);
    };
  }
  function shimCreateAnswer(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;
    window2.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises).then(() => {
          return origCreateAnswer.apply(this, arguments);
        }).finally(() => {
          this.setParametersPromises = [];
        });
      }
      return origCreateAnswer.apply(this, arguments);
    };
  }

  // node_modules/webrtc-adapter/src/js/safari/safari_shim.js
  var safari_shim_exports = {};
  __export(safari_shim_exports, {
    shimAudioContext: () => shimAudioContext,
    shimCallbacksAPI: () => shimCallbacksAPI,
    shimConstraints: () => shimConstraints,
    shimCreateOfferLegacy: () => shimCreateOfferLegacy,
    shimGetUserMedia: () => shimGetUserMedia4,
    shimLocalStreamsAPI: () => shimLocalStreamsAPI,
    shimRTCIceServerUrls: () => shimRTCIceServerUrls,
    shimRemoteStreamsAPI: () => shimRemoteStreamsAPI,
    shimTrackEventTransceiver: () => shimTrackEventTransceiver
  });
  function shimLocalStreamsAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    if (!("getLocalStreams" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!("addStream" in window2.RTCPeerConnection.prototype)) {
      const _addTrack = window2.RTCPeerConnection.prototype.addTrack;
      window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (!this._localStreams.includes(stream)) {
          this._localStreams.push(stream);
        }
        stream.getAudioTracks().forEach((track) => _addTrack.call(
          this,
          track,
          stream
        ));
        stream.getVideoTracks().forEach((track) => _addTrack.call(
          this,
          track,
          stream
        ));
      };
      window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, ...streams) {
        if (streams) {
          streams.forEach((stream) => {
            if (!this._localStreams) {
              this._localStreams = [stream];
            } else if (!this._localStreams.includes(stream)) {
              this._localStreams.push(stream);
            }
          });
        }
        return _addTrack.apply(this, arguments);
      };
    }
    if (!("removeStream" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        const index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        const tracks = stream.getTracks();
        this.getSenders().forEach((sender) => {
          if (tracks.includes(sender.track)) {
            this.removeTrack(sender);
          }
        });
      };
    }
  }
  function shimRemoteStreamsAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    if (!("getRemoteStreams" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!("onaddstream" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "onaddstream", {
        get() {
          return this._onaddstream;
        },
        set(f) {
          if (this._onaddstream) {
            this.removeEventListener("addstream", this._onaddstream);
            this.removeEventListener("track", this._onaddstreampoly);
          }
          this.addEventListener("addstream", this._onaddstream = f);
          this.addEventListener("track", this._onaddstreampoly = (e) => {
            e.streams.forEach((stream) => {
              if (!this._remoteStreams) {
                this._remoteStreams = [];
              }
              if (this._remoteStreams.includes(stream)) {
                return;
              }
              this._remoteStreams.push(stream);
              const event = new Event("addstream");
              event.stream = stream;
              this.dispatchEvent(event);
            });
          });
        }
      });
      const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
      window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
        const pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener("track", this._onaddstreampoly = function(e) {
            e.streams.forEach((stream) => {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              const event = new Event("addstream");
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  }
  function shimCallbacksAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    const prototype = window2.RTCPeerConnection.prototype;
    const origCreateOffer = prototype.createOffer;
    const origCreateAnswer = prototype.createAnswer;
    const setLocalDescription = prototype.setLocalDescription;
    const setRemoteDescription = prototype.setRemoteDescription;
    const addIceCandidate = prototype.addIceCandidate;
    prototype.createOffer = function createOffer(successCallback, failureCallback) {
      const options = arguments.length >= 2 ? arguments[2] : arguments[0];
      const promise = origCreateOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
      const options = arguments.length >= 2 ? arguments[2] : arguments[0];
      const promise = origCreateAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    let withCallback = function(description, successCallback, failureCallback) {
      const promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;
    withCallback = function(description, successCallback, failureCallback) {
      const promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;
    withCallback = function(candidate, successCallback, failureCallback) {
      const promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  }
  function shimGetUserMedia4(window2) {
    const navigator2 = window2 && window2.navigator;
    if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
      const mediaDevices = navigator2.mediaDevices;
      const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
      navigator2.mediaDevices.getUserMedia = (constraints) => {
        return _getUserMedia(shimConstraints(constraints));
      };
    }
    if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
      navigator2.getUserMedia = function getUserMedia(constraints, cb, errcb) {
        navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);
      }.bind(navigator2);
    }
  }
  function shimConstraints(constraints) {
    if (constraints && constraints.video !== void 0) {
      return Object.assign(
        {},
        constraints,
        { video: compactObject(constraints.video) }
      );
    }
    return constraints;
  }
  function shimRTCIceServerUrls(window2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    const OrigPeerConnection = window2.RTCPeerConnection;
    window2.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        const newIceServers = [];
        for (let i = 0; i < pcConfig.iceServers.length; i++) {
          let server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty("urls") && server.hasOwnProperty("url")) {
            deprecated("RTCIceServer.url", "RTCIceServer.urls");
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    if ("generateCertificate" in OrigPeerConnection) {
      Object.defineProperty(window2.RTCPeerConnection, "generateCertificate", {
        get() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  }
  function shimTrackEventTransceiver(window2) {
    if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
      Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return { receiver: this.receiver };
        }
      });
    }
  }
  function shimCreateOfferLegacy(window2) {
    const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
    window2.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === "sendrecv") {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection("sendonly");
            } else {
              audioTransceiver.direction = "sendonly";
            }
          } else if (audioTransceiver.direction === "recvonly") {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection("inactive");
            } else {
              audioTransceiver.direction = "inactive";
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
          this.addTransceiver("audio");
        }
        if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === "sendrecv") {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection("sendonly");
            } else {
              videoTransceiver.direction = "sendonly";
            }
          } else if (videoTransceiver.direction === "recvonly") {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection("inactive");
            } else {
              videoTransceiver.direction = "inactive";
            }
          }
        } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
          this.addTransceiver("video");
        }
      }
      return origCreateOffer.apply(this, arguments);
    };
  }
  function shimAudioContext(window2) {
    if (typeof window2 !== "object" || window2.AudioContext) {
      return;
    }
    window2.AudioContext = window2.webkitAudioContext;
  }

  // node_modules/webrtc-adapter/src/js/common_shim.js
  var common_shim_exports = {};
  __export(common_shim_exports, {
    removeExtmapAllowMixed: () => removeExtmapAllowMixed,
    shimAddIceCandidateNullOrEmpty: () => shimAddIceCandidateNullOrEmpty,
    shimConnectionState: () => shimConnectionState,
    shimMaxMessageSize: () => shimMaxMessageSize,
    shimRTCIceCandidate: () => shimRTCIceCandidate,
    shimSendThrowTypeError: () => shimSendThrowTypeError
  });
  var import_sdp = __toESM(require_sdp());
  function shimRTCIceCandidate(window2) {
    if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "foundation" in window2.RTCIceCandidate.prototype) {
      return;
    }
    const NativeRTCIceCandidate = window2.RTCIceCandidate;
    window2.RTCIceCandidate = function RTCIceCandidate2(args) {
      if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substr(2);
      }
      if (args.candidate && args.candidate.length) {
        const nativeCandidate = new NativeRTCIceCandidate(args);
        const parsedCandidate = import_sdp.default.parseCandidate(args.candidate);
        const augmentedCandidate = Object.assign(
          nativeCandidate,
          parsedCandidate
        );
        augmentedCandidate.toJSON = function toJSON2() {
          return {
            candidate: augmentedCandidate.candidate,
            sdpMid: augmentedCandidate.sdpMid,
            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
            usernameFragment: augmentedCandidate.usernameFragment
          };
        };
        return augmentedCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
    wrapPeerConnectionEvent(window2, "icecandidate", (e) => {
      if (e.candidate) {
        Object.defineProperty(e, "candidate", {
          value: new window2.RTCIceCandidate(e.candidate),
          writable: "false"
        });
      }
      return e;
    });
  }
  function shimMaxMessageSize(window2, browserDetails) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (!("sctp" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "sctp", {
        get() {
          return typeof this._sctp === "undefined" ? null : this._sctp;
        }
      });
    }
    const sctpInDescription = function(description) {
      if (!description || !description.sdp) {
        return false;
      }
      const sections = import_sdp.default.splitSections(description.sdp);
      sections.shift();
      return sections.some((mediaSection) => {
        const mLine = import_sdp.default.parseMLine(mediaSection);
        return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
      });
    };
    const getRemoteFirefoxVersion = function(description) {
      const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      const version = parseInt(match[1], 10);
      return version !== version ? -1 : version;
    };
    const getCanSendMaxMessageSize = function(remoteIsFirefox) {
      let canSendMaxMessageSize = 65536;
      if (browserDetails.browser === "firefox") {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            canSendMaxMessageSize = 16384;
          } else {
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails.version < 60) {
          canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };
    const getMaxMessageSize = function(description, remoteIsFirefox) {
      let maxMessageSize = 65536;
      if (browserDetails.browser === "firefox" && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }
      const match = import_sdp.default.matchPrefix(
        description.sdp,
        "a=max-message-size:"
      );
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substr(19), 10);
      } else if (browserDetails.browser === "firefox" && remoteIsFirefox !== -1) {
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      this._sctp = null;
      if (browserDetails.browser === "chrome" && browserDetails.version >= 76) {
        const { sdpSemantics } = this.getConfiguration();
        if (sdpSemantics === "plan-b") {
          Object.defineProperty(this, "sctp", {
            get() {
              return typeof this._sctp === "undefined" ? null : this._sctp;
            },
            enumerable: true,
            configurable: true
          });
        }
      }
      if (sctpInDescription(arguments[0])) {
        const isFirefox = getRemoteFirefoxVersion(arguments[0]);
        const canSendMMS = getCanSendMaxMessageSize(isFirefox);
        const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
        let maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }
        const sctp = {};
        Object.defineProperty(sctp, "maxMessageSize", {
          get() {
            return maxMessageSize;
          }
        });
        this._sctp = sctp;
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  }
  function shimSendThrowTypeError(window2) {
    if (!(window2.RTCPeerConnection && "createDataChannel" in window2.RTCPeerConnection.prototype)) {
      return;
    }
    function wrapDcSend(dc, pc) {
      const origDataChannelSend = dc.send;
      dc.send = function send() {
        const data = arguments[0];
        const length = data.length || data.size || data.byteLength;
        if (dc.readyState === "open" && pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    const origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;
    window2.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
      const dataChannel = origCreateDataChannel.apply(this, arguments);
      wrapDcSend(dataChannel, this);
      return dataChannel;
    };
    wrapPeerConnectionEvent(window2, "datachannel", (e) => {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }
  function shimConnectionState(window2) {
    if (!window2.RTCPeerConnection || "connectionState" in window2.RTCPeerConnection.prototype) {
      return;
    }
    const proto = window2.RTCPeerConnection.prototype;
    Object.defineProperty(proto, "connectionState", {
      get() {
        return {
          completed: "connected",
          checking: "connecting"
        }[this.iceConnectionState] || this.iceConnectionState;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(proto, "onconnectionstatechange", {
      get() {
        return this._onconnectionstatechange || null;
      },
      set(cb) {
        if (this._onconnectionstatechange) {
          this.removeEventListener(
            "connectionstatechange",
            this._onconnectionstatechange
          );
          delete this._onconnectionstatechange;
        }
        if (cb) {
          this.addEventListener(
            "connectionstatechange",
            this._onconnectionstatechange = cb
          );
        }
      },
      enumerable: true,
      configurable: true
    });
    ["setLocalDescription", "setRemoteDescription"].forEach((method) => {
      const origMethod = proto[method];
      proto[method] = function() {
        if (!this._connectionstatechangepoly) {
          this._connectionstatechangepoly = (e) => {
            const pc = e.target;
            if (pc._lastConnectionState !== pc.connectionState) {
              pc._lastConnectionState = pc.connectionState;
              const newEvent = new Event("connectionstatechange", e);
              pc.dispatchEvent(newEvent);
            }
            return e;
          };
          this.addEventListener(
            "iceconnectionstatechange",
            this._connectionstatechangepoly
          );
        }
        return origMethod.apply(this, arguments);
      };
    });
  }
  function removeExtmapAllowMixed(window2, browserDetails) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (browserDetails.browser === "chrome" && browserDetails.version >= 71) {
      return;
    }
    if (browserDetails.browser === "safari" && browserDetails.version >= 605) {
      return;
    }
    const nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
      if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
        const sdp = desc.sdp.split("\n").filter((line) => {
          return line.trim() !== "a=extmap-allow-mixed";
        }).join("\n");
        if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {
          arguments[0] = new window2.RTCSessionDescription({
            type: desc.type,
            sdp
          });
        } else {
          desc.sdp = sdp;
        }
      }
      return nativeSRD.apply(this, arguments);
    };
  }
  function shimAddIceCandidateNullOrEmpty(window2, browserDetails) {
    if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;
    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
      return;
    }
    window2.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      if ((browserDetails.browser === "chrome" && browserDetails.version < 78 || browserDetails.browser === "firefox" && browserDetails.version < 68 || browserDetails.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }

  // node_modules/webrtc-adapter/src/js/adapter_factory.js
  function adapterFactory({ window: window2 } = {}, options = {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true
  }) {
    const logging2 = log;
    const browserDetails = detectBrowser(window2);
    const adapter2 = {
      browserDetails,
      commonShim: common_shim_exports,
      extractVersion,
      disableLog,
      disableWarnings
    };
    switch (browserDetails.browser) {
      case "chrome":
        if (!chrome_shim_exports || !shimPeerConnection || !options.shimChrome) {
          logging2("Chrome shim is not included in this adapter release.");
          return adapter2;
        }
        if (browserDetails.version === null) {
          logging2("Chrome shim can not determine version, not shimming.");
          return adapter2;
        }
        logging2("adapter.js shimming chrome.");
        adapter2.browserShim = chrome_shim_exports;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails);
        shimGetUserMedia(window2, browserDetails);
        shimMediaStream(window2, browserDetails);
        shimPeerConnection(window2, browserDetails);
        shimOnTrack(window2, browserDetails);
        shimAddTrackRemoveTrack(window2, browserDetails);
        shimGetSendersWithDtmf(window2, browserDetails);
        shimGetStats(window2, browserDetails);
        shimSenderReceiverGetStats(window2, browserDetails);
        fixNegotiationNeeded(window2, browserDetails);
        shimRTCIceCandidate(window2, browserDetails);
        shimConnectionState(window2, browserDetails);
        shimMaxMessageSize(window2, browserDetails);
        shimSendThrowTypeError(window2, browserDetails);
        removeExtmapAllowMixed(window2, browserDetails);
        break;
      case "firefox":
        if (!firefox_shim_exports || !shimPeerConnection3 || !options.shimFirefox) {
          logging2("Firefox shim is not included in this adapter release.");
          return adapter2;
        }
        logging2("adapter.js shimming firefox.");
        adapter2.browserShim = firefox_shim_exports;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails);
        shimGetUserMedia3(window2, browserDetails);
        shimPeerConnection3(window2, browserDetails);
        shimOnTrack2(window2, browserDetails);
        shimRemoveStream(window2, browserDetails);
        shimSenderGetStats(window2, browserDetails);
        shimReceiverGetStats(window2, browserDetails);
        shimRTCDataChannel(window2, browserDetails);
        shimAddTransceiver(window2, browserDetails);
        shimGetParameters(window2, browserDetails);
        shimCreateOffer(window2, browserDetails);
        shimCreateAnswer(window2, browserDetails);
        shimRTCIceCandidate(window2, browserDetails);
        shimConnectionState(window2, browserDetails);
        shimMaxMessageSize(window2, browserDetails);
        shimSendThrowTypeError(window2, browserDetails);
        break;
      case "edge":
        if (!edge_shim_exports || !shimPeerConnection2 || !options.shimEdge) {
          logging2("MS edge shim is not included in this adapter release.");
          return adapter2;
        }
        logging2("adapter.js shimming edge.");
        adapter2.browserShim = edge_shim_exports;
        shimGetUserMedia2(window2, browserDetails);
        shimGetDisplayMedia2(window2, browserDetails);
        shimPeerConnection2(window2, browserDetails);
        shimReplaceTrack(window2, browserDetails);
        shimMaxMessageSize(window2, browserDetails);
        shimSendThrowTypeError(window2, browserDetails);
        break;
      case "safari":
        if (!safari_shim_exports || !options.shimSafari) {
          logging2("Safari shim is not included in this adapter release.");
          return adapter2;
        }
        logging2("adapter.js shimming safari.");
        adapter2.browserShim = safari_shim_exports;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails);
        shimRTCIceServerUrls(window2, browserDetails);
        shimCreateOfferLegacy(window2, browserDetails);
        shimCallbacksAPI(window2, browserDetails);
        shimLocalStreamsAPI(window2, browserDetails);
        shimRemoteStreamsAPI(window2, browserDetails);
        shimTrackEventTransceiver(window2, browserDetails);
        shimGetUserMedia4(window2, browserDetails);
        shimAudioContext(window2, browserDetails);
        shimRTCIceCandidate(window2, browserDetails);
        shimMaxMessageSize(window2, browserDetails);
        shimSendThrowTypeError(window2, browserDetails);
        removeExtmapAllowMixed(window2, browserDetails);
        break;
      default:
        logging2("Unsupported browser!");
        break;
    }
    return adapter2;
  }

  // node_modules/webrtc-adapter/src/js/adapter_core.js
  var adapter = adapterFactory({ window: typeof window === "undefined" ? void 0 : window });
  var adapter_core_default = adapter;

  // node_modules/peerjs/dist/bundler.mjs
  function $parcel$export(e, n, v, s) {
    Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
  }
  var $af8cf1f663f490f4$var$webRTCAdapter = adapter_core_default.default || adapter_core_default;
  var $af8cf1f663f490f4$export$25be9502477c137d = new (function() {
    function class_1() {
      this.isIOS = [
        "iPad",
        "iPhone",
        "iPod"
      ].includes(navigator.platform);
      this.supportedBrowsers = [
        "firefox",
        "chrome",
        "safari"
      ];
      this.minFirefoxVersion = 59;
      this.minChromeVersion = 72;
      this.minSafariVersion = 605;
    }
    class_1.prototype.isWebRTCSupported = function() {
      return typeof RTCPeerConnection !== "undefined";
    };
    class_1.prototype.isBrowserSupported = function() {
      var browser = this.getBrowser();
      var version = this.getVersion();
      var validBrowser = this.supportedBrowsers.includes(browser);
      if (!validBrowser)
        return false;
      if (browser === "chrome")
        return version >= this.minChromeVersion;
      if (browser === "firefox")
        return version >= this.minFirefoxVersion;
      if (browser === "safari")
        return !this.isIOS && version >= this.minSafariVersion;
      return false;
    };
    class_1.prototype.getBrowser = function() {
      return $af8cf1f663f490f4$var$webRTCAdapter.browserDetails.browser;
    };
    class_1.prototype.getVersion = function() {
      return $af8cf1f663f490f4$var$webRTCAdapter.browserDetails.version || 0;
    };
    class_1.prototype.isUnifiedPlanSupported = function() {
      var browser = this.getBrowser();
      var version = $af8cf1f663f490f4$var$webRTCAdapter.browserDetails.version || 0;
      if (browser === "chrome" && version < this.minChromeVersion)
        return false;
      if (browser === "firefox" && version >= this.minFirefoxVersion)
        return true;
      if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype))
        return false;
      var tempPc;
      var supported = false;
      try {
        tempPc = new RTCPeerConnection();
        tempPc.addTransceiver("audio");
        supported = true;
      } catch (e) {
      } finally {
        if (tempPc)
          tempPc.close();
      }
      return supported;
    };
    class_1.prototype.toString = function() {
      return "Supports:\n    browser:".concat(this.getBrowser(), "\n    version:").concat(this.getVersion(), "\n    isIOS:").concat(this.isIOS, "\n    isWebRTCSupported:").concat(this.isWebRTCSupported(), "\n    isBrowserSupported:").concat(this.isBrowserSupported(), "\n    isUnifiedPlanSupported:").concat(this.isUnifiedPlanSupported());
    };
    return class_1;
  }())();
  var $06cb531ed7840f78$var$DEFAULT_CONFIG = {
    iceServers: [
      {
        urls: "stun:stun.l.google.com:19302"
      },
      {
        urls: [
          "turn:eu-0.turn.peerjs.com:3478",
          "turn:us-0.turn.peerjs.com:3478"
        ],
        username: "peerjs",
        credential: "peerjsp"
      }
    ],
    sdpSemantics: "unified-plan"
  };
  var $06cb531ed7840f78$var$Util = function() {
    function Util() {
      this.CLOUD_HOST = "0.peerjs.com";
      this.CLOUD_PORT = 443;
      this.chunkedBrowsers = {
        Chrome: 1,
        chrome: 1
      };
      this.chunkedMTU = 16300;
      this.defaultConfig = $06cb531ed7840f78$var$DEFAULT_CONFIG;
      this.browser = $af8cf1f663f490f4$export$25be9502477c137d.getBrowser();
      this.browserVersion = $af8cf1f663f490f4$export$25be9502477c137d.getVersion();
      this.supports = function() {
        var supported = {
          browser: $af8cf1f663f490f4$export$25be9502477c137d.isBrowserSupported(),
          webRTC: $af8cf1f663f490f4$export$25be9502477c137d.isWebRTCSupported(),
          audioVideo: false,
          data: false,
          binaryBlob: false,
          reliable: false
        };
        if (!supported.webRTC)
          return supported;
        var pc;
        try {
          pc = new RTCPeerConnection($06cb531ed7840f78$var$DEFAULT_CONFIG);
          supported.audioVideo = true;
          var dc = void 0;
          try {
            dc = pc.createDataChannel("_PEERJSTEST", {
              ordered: true
            });
            supported.data = true;
            supported.reliable = !!dc.ordered;
            try {
              dc.binaryType = "blob";
              supported.binaryBlob = !$af8cf1f663f490f4$export$25be9502477c137d.isIOS;
            } catch (e) {
            }
          } catch (e) {
          } finally {
            if (dc)
              dc.close();
          }
        } catch (e) {
        } finally {
          if (pc)
            pc.close();
        }
        return supported;
      }();
      this.pack = import_peerjs_js_binarypack.default.pack;
      this.unpack = import_peerjs_js_binarypack.default.unpack;
      this._dataCount = 1;
    }
    Util.prototype.noop = function() {
    };
    Util.prototype.validateId = function(id2) {
      return !id2 || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(id2);
    };
    Util.prototype.chunk = function(blob) {
      var chunks = [];
      var size = blob.size;
      var total = Math.ceil(size / $06cb531ed7840f78$export$7debb50ef11d5e0b.chunkedMTU);
      var index = 0;
      var start2 = 0;
      while (start2 < size) {
        var end = Math.min(size, start2 + $06cb531ed7840f78$export$7debb50ef11d5e0b.chunkedMTU);
        var b = blob.slice(start2, end);
        var chunk = {
          __peerData: this._dataCount,
          n: index,
          data: b,
          total
        };
        chunks.push(chunk);
        start2 = end;
        index++;
      }
      this._dataCount++;
      return chunks;
    };
    Util.prototype.blobToArrayBuffer = function(blob, cb) {
      var fr = new FileReader();
      fr.onload = function(evt) {
        if (evt.target)
          cb(evt.target.result);
      };
      fr.readAsArrayBuffer(blob);
      return fr;
    };
    Util.prototype.binaryStringToArrayBuffer = function(binary) {
      var byteArray = new Uint8Array(binary.length);
      for (var i = 0; i < binary.length; i++)
        byteArray[i] = binary.charCodeAt(i) & 255;
      return byteArray.buffer;
    };
    Util.prototype.randomToken = function() {
      return Math.random().toString(36).slice(2);
    };
    Util.prototype.isSecure = function() {
      return location.protocol === "https:";
    };
    return Util;
  }();
  var $06cb531ed7840f78$export$7debb50ef11d5e0b = new $06cb531ed7840f78$var$Util();
  var $26088d7da5b03f69$exports = {};
  $parcel$export($26088d7da5b03f69$exports, "Peer", () => $26088d7da5b03f69$export$ecd1fc136c422448, (v) => $26088d7da5b03f69$export$ecd1fc136c422448 = v);
  var $ac9b757d51178e15$exports = {};
  var $ac9b757d51178e15$var$has = Object.prototype.hasOwnProperty;
  var $ac9b757d51178e15$var$prefix = "~";
  function $ac9b757d51178e15$var$Events() {
  }
  if (Object.create) {
    $ac9b757d51178e15$var$Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new $ac9b757d51178e15$var$Events().__proto__)
      $ac9b757d51178e15$var$prefix = false;
  }
  function $ac9b757d51178e15$var$EE(fn, context, once2) {
    this.fn = fn;
    this.context = context;
    this.once = once2 || false;
  }
  function $ac9b757d51178e15$var$addListener(emitter, event, fn, context, once2) {
    if (typeof fn !== "function")
      throw new TypeError("The listener must be a function");
    var listener = new $ac9b757d51178e15$var$EE(fn, context || emitter, once2), evt = $ac9b757d51178e15$var$prefix ? $ac9b757d51178e15$var$prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [
        emitter._events[evt],
        listener
      ];
    return emitter;
  }
  function $ac9b757d51178e15$var$clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new $ac9b757d51178e15$var$Events();
    else
      delete emitter._events[evt];
  }
  function $ac9b757d51178e15$var$EventEmitter() {
    this._events = new $ac9b757d51178e15$var$Events();
    this._eventsCount = 0;
  }
  $ac9b757d51178e15$var$EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events)
      if ($ac9b757d51178e15$var$has.call(events, name))
        names.push($ac9b757d51178e15$var$prefix ? name.slice(1) : name);
    if (Object.getOwnPropertySymbols)
      return names.concat(Object.getOwnPropertySymbols(events));
    return names;
  };
  $ac9b757d51178e15$var$EventEmitter.prototype.listeners = function listeners(event) {
    var evt = $ac9b757d51178e15$var$prefix ? $ac9b757d51178e15$var$prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [
        handlers.fn
      ];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)
      ee[i] = handlers[i].fn;
    return ee;
  };
  $ac9b757d51178e15$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = $ac9b757d51178e15$var$prefix ? $ac9b757d51178e15$var$prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  $ac9b757d51178e15$var$EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = $ac9b757d51178e15$var$prefix ? $ac9b757d51178e15$var$prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len = arguments.length, args, i;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++)
        args[i - 1] = arguments[i];
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length = listeners2.length, j;
      for (i = 0; i < length; i++) {
        if (listeners2[i].once)
          this.removeListener(event, listeners2[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners2[i].fn.call(listeners2[i].context);
            break;
          case 2:
            listeners2[i].fn.call(listeners2[i].context, a1);
            break;
          case 3:
            listeners2[i].fn.call(listeners2[i].context, a1, a2);
            break;
          case 4:
            listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++)
                args[j - 1] = arguments[j];
            listeners2[i].fn.apply(listeners2[i].context, args);
        }
      }
    }
    return true;
  };
  $ac9b757d51178e15$var$EventEmitter.prototype.on = function on(event, fn, context) {
    return $ac9b757d51178e15$var$addListener(this, event, fn, context, false);
  };
  $ac9b757d51178e15$var$EventEmitter.prototype.once = function once(event, fn, context) {
    return $ac9b757d51178e15$var$addListener(this, event, fn, context, true);
  };
  $ac9b757d51178e15$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once2) {
    var evt = $ac9b757d51178e15$var$prefix ? $ac9b757d51178e15$var$prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      $ac9b757d51178e15$var$clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once2 || listeners2.once) && (!context || listeners2.context === context))
        $ac9b757d51178e15$var$clearEvent(this, evt);
    } else {
      for (var i = 0, events = [], length = listeners2.length; i < length; i++)
        if (listeners2[i].fn !== fn || once2 && !listeners2[i].once || context && listeners2[i].context !== context)
          events.push(listeners2[i]);
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        $ac9b757d51178e15$var$clearEvent(this, evt);
    }
    return this;
  };
  $ac9b757d51178e15$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = $ac9b757d51178e15$var$prefix ? $ac9b757d51178e15$var$prefix + event : event;
      if (this._events[evt])
        $ac9b757d51178e15$var$clearEvent(this, evt);
    } else {
      this._events = new $ac9b757d51178e15$var$Events();
      this._eventsCount = 0;
    }
    return this;
  };
  $ac9b757d51178e15$var$EventEmitter.prototype.off = $ac9b757d51178e15$var$EventEmitter.prototype.removeListener;
  $ac9b757d51178e15$var$EventEmitter.prototype.addListener = $ac9b757d51178e15$var$EventEmitter.prototype.on;
  $ac9b757d51178e15$var$EventEmitter.prefixed = $ac9b757d51178e15$var$prefix;
  $ac9b757d51178e15$var$EventEmitter.EventEmitter = $ac9b757d51178e15$var$EventEmitter;
  $ac9b757d51178e15$exports = $ac9b757d51178e15$var$EventEmitter;
  var $1615705ecc6adca3$exports = {};
  $parcel$export($1615705ecc6adca3$exports, "LogLevel", () => $1615705ecc6adca3$export$243e62d78d3b544d, (v) => $1615705ecc6adca3$export$243e62d78d3b544d = v);
  $parcel$export($1615705ecc6adca3$exports, "default", () => $1615705ecc6adca3$export$2e2bcd8739ae039, (v) => $1615705ecc6adca3$export$2e2bcd8739ae039 = v);
  var $1615705ecc6adca3$var$__read = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = {
        error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var $1615705ecc6adca3$var$__spreadArray = function(to, from, pack) {
    if (pack || arguments.length === 2) {
      for (var i = 0, l = from.length, ar; i < l; i++)
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var $1615705ecc6adca3$var$LOG_PREFIX = "PeerJS: ";
  var $1615705ecc6adca3$export$243e62d78d3b544d;
  (function($1615705ecc6adca3$export$243e62d78d3b544d2) {
    $1615705ecc6adca3$export$243e62d78d3b544d2[$1615705ecc6adca3$export$243e62d78d3b544d2["Disabled"] = 0] = "Disabled";
    $1615705ecc6adca3$export$243e62d78d3b544d2[$1615705ecc6adca3$export$243e62d78d3b544d2["Errors"] = 1] = "Errors";
    $1615705ecc6adca3$export$243e62d78d3b544d2[$1615705ecc6adca3$export$243e62d78d3b544d2["Warnings"] = 2] = "Warnings";
    $1615705ecc6adca3$export$243e62d78d3b544d2[$1615705ecc6adca3$export$243e62d78d3b544d2["All"] = 3] = "All";
  })($1615705ecc6adca3$export$243e62d78d3b544d || ($1615705ecc6adca3$export$243e62d78d3b544d = {}));
  var $1615705ecc6adca3$var$Logger = function() {
    function Logger() {
      this._logLevel = $1615705ecc6adca3$export$243e62d78d3b544d.Disabled;
    }
    Object.defineProperty(Logger.prototype, "logLevel", {
      get: function() {
        return this._logLevel;
      },
      set: function(logLevel) {
        this._logLevel = logLevel;
      },
      enumerable: false,
      configurable: true
    });
    Logger.prototype.log = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++)
        args[_i] = arguments[_i];
      if (this._logLevel >= $1615705ecc6adca3$export$243e62d78d3b544d.All)
        this._print.apply(this, $1615705ecc6adca3$var$__spreadArray([
          $1615705ecc6adca3$export$243e62d78d3b544d.All
        ], $1615705ecc6adca3$var$__read(args), false));
    };
    Logger.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++)
        args[_i] = arguments[_i];
      if (this._logLevel >= $1615705ecc6adca3$export$243e62d78d3b544d.Warnings)
        this._print.apply(this, $1615705ecc6adca3$var$__spreadArray([
          $1615705ecc6adca3$export$243e62d78d3b544d.Warnings
        ], $1615705ecc6adca3$var$__read(args), false));
    };
    Logger.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++)
        args[_i] = arguments[_i];
      if (this._logLevel >= $1615705ecc6adca3$export$243e62d78d3b544d.Errors)
        this._print.apply(this, $1615705ecc6adca3$var$__spreadArray([
          $1615705ecc6adca3$export$243e62d78d3b544d.Errors
        ], $1615705ecc6adca3$var$__read(args), false));
    };
    Logger.prototype.setLogFunction = function(fn) {
      this._print = fn;
    };
    Logger.prototype._print = function(logLevel) {
      var rest = [];
      for (var _i = 1; _i < arguments.length; _i++)
        rest[_i - 1] = arguments[_i];
      var copy = $1615705ecc6adca3$var$__spreadArray([
        $1615705ecc6adca3$var$LOG_PREFIX
      ], $1615705ecc6adca3$var$__read(rest), false);
      for (var i in copy)
        if (copy[i] instanceof Error)
          copy[i] = "(" + copy[i].name + ") " + copy[i].message;
      if (logLevel >= $1615705ecc6adca3$export$243e62d78d3b544d.All)
        console.log.apply(console, $1615705ecc6adca3$var$__spreadArray([], $1615705ecc6adca3$var$__read(copy), false));
      else if (logLevel >= $1615705ecc6adca3$export$243e62d78d3b544d.Warnings)
        console.warn.apply(console, $1615705ecc6adca3$var$__spreadArray([
          "WARNING"
        ], $1615705ecc6adca3$var$__read(copy), false));
      else if (logLevel >= $1615705ecc6adca3$export$243e62d78d3b544d.Errors)
        console.error.apply(console, $1615705ecc6adca3$var$__spreadArray([
          "ERROR"
        ], $1615705ecc6adca3$var$__read(copy), false));
    };
    return Logger;
  }();
  var $1615705ecc6adca3$export$2e2bcd8739ae039 = new $1615705ecc6adca3$var$Logger();
  var $31d11a8d122cb4b7$exports = {};
  $parcel$export($31d11a8d122cb4b7$exports, "Socket", () => $31d11a8d122cb4b7$export$4798917dbf149b79, (v) => $31d11a8d122cb4b7$export$4798917dbf149b79 = v);
  var $60fadef21a2daafc$export$3157d57b4135e3bc;
  (function($60fadef21a2daafc$export$3157d57b4135e3bc2) {
    $60fadef21a2daafc$export$3157d57b4135e3bc2["Data"] = "data";
    $60fadef21a2daafc$export$3157d57b4135e3bc2["Media"] = "media";
  })($60fadef21a2daafc$export$3157d57b4135e3bc || ($60fadef21a2daafc$export$3157d57b4135e3bc = {}));
  var $60fadef21a2daafc$export$9547aaa2e39030ff;
  (function($60fadef21a2daafc$export$9547aaa2e39030ff2) {
    $60fadef21a2daafc$export$9547aaa2e39030ff2["BrowserIncompatible"] = "browser-incompatible";
    $60fadef21a2daafc$export$9547aaa2e39030ff2["Disconnected"] = "disconnected";
    $60fadef21a2daafc$export$9547aaa2e39030ff2["InvalidID"] = "invalid-id";
    $60fadef21a2daafc$export$9547aaa2e39030ff2["InvalidKey"] = "invalid-key";
    $60fadef21a2daafc$export$9547aaa2e39030ff2["Network"] = "network";
    $60fadef21a2daafc$export$9547aaa2e39030ff2["PeerUnavailable"] = "peer-unavailable";
    $60fadef21a2daafc$export$9547aaa2e39030ff2["SslUnavailable"] = "ssl-unavailable";
    $60fadef21a2daafc$export$9547aaa2e39030ff2["ServerError"] = "server-error";
    $60fadef21a2daafc$export$9547aaa2e39030ff2["SocketError"] = "socket-error";
    $60fadef21a2daafc$export$9547aaa2e39030ff2["SocketClosed"] = "socket-closed";
    $60fadef21a2daafc$export$9547aaa2e39030ff2["UnavailableID"] = "unavailable-id";
    $60fadef21a2daafc$export$9547aaa2e39030ff2["WebRTC"] = "webrtc";
  })($60fadef21a2daafc$export$9547aaa2e39030ff || ($60fadef21a2daafc$export$9547aaa2e39030ff = {}));
  var $60fadef21a2daafc$export$89f507cf986a947;
  (function($60fadef21a2daafc$export$89f507cf986a9472) {
    $60fadef21a2daafc$export$89f507cf986a9472["Binary"] = "binary";
    $60fadef21a2daafc$export$89f507cf986a9472["BinaryUTF8"] = "binary-utf8";
    $60fadef21a2daafc$export$89f507cf986a9472["JSON"] = "json";
  })($60fadef21a2daafc$export$89f507cf986a947 || ($60fadef21a2daafc$export$89f507cf986a947 = {}));
  var $60fadef21a2daafc$export$3b5c4a4b6354f023;
  (function($60fadef21a2daafc$export$3b5c4a4b6354f0232) {
    $60fadef21a2daafc$export$3b5c4a4b6354f0232["Message"] = "message";
    $60fadef21a2daafc$export$3b5c4a4b6354f0232["Disconnected"] = "disconnected";
    $60fadef21a2daafc$export$3b5c4a4b6354f0232["Error"] = "error";
    $60fadef21a2daafc$export$3b5c4a4b6354f0232["Close"] = "close";
  })($60fadef21a2daafc$export$3b5c4a4b6354f023 || ($60fadef21a2daafc$export$3b5c4a4b6354f023 = {}));
  var $60fadef21a2daafc$export$adb4a1754da6f10d;
  (function($60fadef21a2daafc$export$adb4a1754da6f10d2) {
    $60fadef21a2daafc$export$adb4a1754da6f10d2["Heartbeat"] = "HEARTBEAT";
    $60fadef21a2daafc$export$adb4a1754da6f10d2["Candidate"] = "CANDIDATE";
    $60fadef21a2daafc$export$adb4a1754da6f10d2["Offer"] = "OFFER";
    $60fadef21a2daafc$export$adb4a1754da6f10d2["Answer"] = "ANSWER";
    $60fadef21a2daafc$export$adb4a1754da6f10d2["Open"] = "OPEN";
    $60fadef21a2daafc$export$adb4a1754da6f10d2["Error"] = "ERROR";
    $60fadef21a2daafc$export$adb4a1754da6f10d2["IdTaken"] = "ID-TAKEN";
    $60fadef21a2daafc$export$adb4a1754da6f10d2["InvalidKey"] = "INVALID-KEY";
    $60fadef21a2daafc$export$adb4a1754da6f10d2["Leave"] = "LEAVE";
    $60fadef21a2daafc$export$adb4a1754da6f10d2["Expire"] = "EXPIRE";
  })($60fadef21a2daafc$export$adb4a1754da6f10d || ($60fadef21a2daafc$export$adb4a1754da6f10d = {}));
  var $0d1ed891c5cb27c0$exports = {};
  $0d1ed891c5cb27c0$exports = JSON.parse('{"name":"peerjs","version":"1.4.7","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz St\xFCckler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","So\u0308ren Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.js","browser-unminified":"dist/peerjs.js","types":"dist/types.d.ts","engines":{"node":">= 10"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"context":"browser","outputFormat":"global","optimize":true,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"},"browser-unminified":{"context":"browser","outputFormat":"global","optimize":false,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build","prepublishOnly":"npm run build","test":"mocha -r ts-node/register -r jsdom-global/register test/**/*.ts","format":"prettier --write .","semantic-release":"semantic-release"},"devDependencies":{"@parcel/config-default":"^2.5.0","@parcel/packager-ts":"^2.5.0","@parcel/transformer-typescript-tsc":"^2.5.0","@parcel/transformer-typescript-types":"^2.5.0","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.18","chai":"^4.3.6","git-authors-cli":"^1.0.40","jsdom":"^19.0.0","jsdom-global":"^3.0.2","mocha":"^9.2.0","mock-socket":"8.0.5","parcel":"^2.5.0","parcel-transformer-tsc-sourcemaps":"^1.0.2","prettier":"^2.6.2","semantic-release":"^19.0.2","standard":"^16.0.4","ts-node":"^10.5.0","typescript":"^4.5.5"},"dependencies":{"@swc/helpers":"^0.3.13","eventemitter3":"^4.0.7","peerjs-js-binarypack":"1.0.1","webrtc-adapter":"^7.7.1"}}');
  var $31d11a8d122cb4b7$var$__extends = function() {
    var extendStatics = function(d1, b1) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      return extendStatics(d1, b1);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var $31d11a8d122cb4b7$var$__read = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = {
        error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var $31d11a8d122cb4b7$var$__spreadArray = function(to, from, pack) {
    if (pack || arguments.length === 2) {
      for (var i = 0, l = from.length, ar; i < l; i++)
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var $31d11a8d122cb4b7$var$__values = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var $31d11a8d122cb4b7$export$4798917dbf149b79 = function(_super) {
    $31d11a8d122cb4b7$var$__extends($31d11a8d122cb4b7$export$4798917dbf149b792, _super);
    function $31d11a8d122cb4b7$export$4798917dbf149b792(secure, host, port, path, key, pingInterval) {
      if (pingInterval === void 0)
        pingInterval = 5e3;
      var _this = _super.call(this) || this;
      _this.pingInterval = pingInterval;
      _this._disconnected = true;
      _this._messagesQueue = [];
      var wsProtocol = secure ? "wss://" : "ws://";
      _this._baseUrl = wsProtocol + host + ":" + port + path + "peerjs?key=" + key;
      return _this;
    }
    $31d11a8d122cb4b7$export$4798917dbf149b792.prototype.start = function(id2, token) {
      var _this = this;
      this._id = id2;
      var wsUrl = "".concat(this._baseUrl, "&id=").concat(id2, "&token=").concat(token);
      if (!!this._socket || !this._disconnected)
        return;
      this._socket = new WebSocket(wsUrl + "&version=" + $0d1ed891c5cb27c0$exports.version);
      this._disconnected = false;
      this._socket.onmessage = function(event) {
        var data;
        try {
          data = JSON.parse(event.data);
          $1615705ecc6adca3$exports.default.log("Server message received:", data);
        } catch (e) {
          $1615705ecc6adca3$exports.default.log("Invalid server message", event.data);
          return;
        }
        _this.emit($60fadef21a2daafc$export$3b5c4a4b6354f023.Message, data);
      };
      this._socket.onclose = function(event) {
        if (_this._disconnected)
          return;
        $1615705ecc6adca3$exports.default.log("Socket closed.", event);
        _this._cleanup();
        _this._disconnected = true;
        _this.emit($60fadef21a2daafc$export$3b5c4a4b6354f023.Disconnected);
      };
      this._socket.onopen = function() {
        if (_this._disconnected)
          return;
        _this._sendQueuedMessages();
        $1615705ecc6adca3$exports.default.log("Socket open");
        _this._scheduleHeartbeat();
      };
    };
    $31d11a8d122cb4b7$export$4798917dbf149b792.prototype._scheduleHeartbeat = function() {
      var _this = this;
      this._wsPingTimer = setTimeout(function() {
        _this._sendHeartbeat();
      }, this.pingInterval);
    };
    $31d11a8d122cb4b7$export$4798917dbf149b792.prototype._sendHeartbeat = function() {
      if (!this._wsOpen()) {
        $1615705ecc6adca3$exports.default.log("Cannot send heartbeat, because socket closed");
        return;
      }
      var message = JSON.stringify({
        type: $60fadef21a2daafc$export$adb4a1754da6f10d.Heartbeat
      });
      this._socket.send(message);
      this._scheduleHeartbeat();
    };
    $31d11a8d122cb4b7$export$4798917dbf149b792.prototype._wsOpen = function() {
      return !!this._socket && this._socket.readyState === 1;
    };
    $31d11a8d122cb4b7$export$4798917dbf149b792.prototype._sendQueuedMessages = function() {
      var e_1, _a;
      var copiedQueue = $31d11a8d122cb4b7$var$__spreadArray([], $31d11a8d122cb4b7$var$__read(this._messagesQueue), false);
      this._messagesQueue = [];
      try {
        for (var copiedQueue_1 = $31d11a8d122cb4b7$var$__values(copiedQueue), copiedQueue_1_1 = copiedQueue_1.next(); !copiedQueue_1_1.done; copiedQueue_1_1 = copiedQueue_1.next()) {
          var message = copiedQueue_1_1.value;
          this.send(message);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (copiedQueue_1_1 && !copiedQueue_1_1.done && (_a = copiedQueue_1.return))
            _a.call(copiedQueue_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    $31d11a8d122cb4b7$export$4798917dbf149b792.prototype.send = function(data) {
      if (this._disconnected)
        return;
      if (!this._id) {
        this._messagesQueue.push(data);
        return;
      }
      if (!data.type) {
        this.emit($60fadef21a2daafc$export$3b5c4a4b6354f023.Error, "Invalid message");
        return;
      }
      if (!this._wsOpen())
        return;
      var message = JSON.stringify(data);
      this._socket.send(message);
    };
    $31d11a8d122cb4b7$export$4798917dbf149b792.prototype.close = function() {
      if (this._disconnected)
        return;
      this._cleanup();
      this._disconnected = true;
    };
    $31d11a8d122cb4b7$export$4798917dbf149b792.prototype._cleanup = function() {
      if (this._socket) {
        this._socket.onopen = this._socket.onmessage = this._socket.onclose = null;
        this._socket.close();
        this._socket = void 0;
      }
      clearTimeout(this._wsPingTimer);
    };
    return $31d11a8d122cb4b7$export$4798917dbf149b792;
  }($ac9b757d51178e15$exports.EventEmitter);
  var $353dee38f9ab557b$exports = {};
  $parcel$export($353dee38f9ab557b$exports, "MediaConnection", () => $353dee38f9ab557b$export$4a84e95a2324ac29, (v) => $353dee38f9ab557b$export$4a84e95a2324ac29 = v);
  var $77f14d3e81888156$exports = {};
  $parcel$export($77f14d3e81888156$exports, "Negotiator", () => $77f14d3e81888156$export$89e6bb5ad64bf4a, (v) => $77f14d3e81888156$export$89e6bb5ad64bf4a = v);
  var $77f14d3e81888156$var$__assign = function() {
    $77f14d3e81888156$var$__assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return $77f14d3e81888156$var$__assign.apply(this, arguments);
  };
  var $77f14d3e81888156$var$__awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var $77f14d3e81888156$var$__generator = function(thisArg, body) {
    var _ = {
      label: 0,
      sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    }, f, y, t, g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([
          n,
          v
        ]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [
              op[0] & 2,
              t.value
            ];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [
                0
              ];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [
            6,
            e
          ];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };
  var $77f14d3e81888156$export$89e6bb5ad64bf4a = function() {
    function $77f14d3e81888156$export$89e6bb5ad64bf4a2(connection) {
      this.connection = connection;
    }
    $77f14d3e81888156$export$89e6bb5ad64bf4a2.prototype.startConnection = function(options) {
      var peerConnection = this._startPeerConnection();
      this.connection.peerConnection = peerConnection;
      if (this.connection.type === $60fadef21a2daafc$export$3157d57b4135e3bc.Media && options._stream)
        this._addTracksToConnection(options._stream, peerConnection);
      if (options.originator) {
        if (this.connection.type === $60fadef21a2daafc$export$3157d57b4135e3bc.Data) {
          var dataConnection = this.connection;
          var config = {
            ordered: !!options.reliable
          };
          var dataChannel = peerConnection.createDataChannel(dataConnection.label, config);
          dataConnection.initialize(dataChannel);
        }
        this._makeOffer();
      } else
        this.handleSDP("OFFER", options.sdp);
    };
    $77f14d3e81888156$export$89e6bb5ad64bf4a2.prototype._startPeerConnection = function() {
      $1615705ecc6adca3$exports.default.log("Creating RTCPeerConnection.");
      var peerConnection = new RTCPeerConnection(this.connection.provider.options.config);
      this._setupListeners(peerConnection);
      return peerConnection;
    };
    $77f14d3e81888156$export$89e6bb5ad64bf4a2.prototype._setupListeners = function(peerConnection) {
      var _this = this;
      var peerId = this.connection.peer;
      var connectionId = this.connection.connectionId;
      var connectionType = this.connection.type;
      var provider = this.connection.provider;
      $1615705ecc6adca3$exports.default.log("Listening for ICE candidates.");
      peerConnection.onicecandidate = function(evt) {
        if (!evt.candidate || !evt.candidate.candidate)
          return;
        $1615705ecc6adca3$exports.default.log("Received ICE candidates for ".concat(peerId, ":"), evt.candidate);
        provider.socket.send({
          type: $60fadef21a2daafc$export$adb4a1754da6f10d.Candidate,
          payload: {
            candidate: evt.candidate,
            type: connectionType,
            connectionId
          },
          dst: peerId
        });
      };
      peerConnection.oniceconnectionstatechange = function() {
        switch (peerConnection.iceConnectionState) {
          case "failed":
            $1615705ecc6adca3$exports.default.log("iceConnectionState is failed, closing connections to " + peerId);
            _this.connection.emit("error", new Error("Negotiation of connection to " + peerId + " failed."));
            _this.connection.close();
            break;
          case "closed":
            $1615705ecc6adca3$exports.default.log("iceConnectionState is closed, closing connections to " + peerId);
            _this.connection.emit("error", new Error("Connection to " + peerId + " closed."));
            _this.connection.close();
            break;
          case "disconnected":
            $1615705ecc6adca3$exports.default.log("iceConnectionState changed to disconnected on the connection with " + peerId);
            break;
          case "completed":
            peerConnection.onicecandidate = $06cb531ed7840f78$export$7debb50ef11d5e0b.noop;
            break;
        }
        _this.connection.emit("iceStateChanged", peerConnection.iceConnectionState);
      };
      $1615705ecc6adca3$exports.default.log("Listening for data channel");
      peerConnection.ondatachannel = function(evt) {
        $1615705ecc6adca3$exports.default.log("Received data channel");
        var dataChannel = evt.channel;
        var connection = provider.getConnection(peerId, connectionId);
        connection.initialize(dataChannel);
      };
      $1615705ecc6adca3$exports.default.log("Listening for remote stream");
      peerConnection.ontrack = function(evt) {
        $1615705ecc6adca3$exports.default.log("Received remote stream");
        var stream = evt.streams[0];
        var connection = provider.getConnection(peerId, connectionId);
        if (connection.type === $60fadef21a2daafc$export$3157d57b4135e3bc.Media) {
          var mediaConnection = connection;
          _this._addStreamToMediaConnection(stream, mediaConnection);
        }
      };
    };
    $77f14d3e81888156$export$89e6bb5ad64bf4a2.prototype.cleanup = function() {
      $1615705ecc6adca3$exports.default.log("Cleaning up PeerConnection to " + this.connection.peer);
      var peerConnection = this.connection.peerConnection;
      if (!peerConnection)
        return;
      this.connection.peerConnection = null;
      peerConnection.onicecandidate = peerConnection.oniceconnectionstatechange = peerConnection.ondatachannel = peerConnection.ontrack = function() {
      };
      var peerConnectionNotClosed = peerConnection.signalingState !== "closed";
      var dataChannelNotClosed = false;
      if (this.connection.type === $60fadef21a2daafc$export$3157d57b4135e3bc.Data) {
        var dataConnection = this.connection;
        var dataChannel = dataConnection.dataChannel;
        if (dataChannel)
          dataChannelNotClosed = !!dataChannel.readyState && dataChannel.readyState !== "closed";
      }
      if (peerConnectionNotClosed || dataChannelNotClosed)
        peerConnection.close();
    };
    $77f14d3e81888156$export$89e6bb5ad64bf4a2.prototype._makeOffer = function() {
      return $77f14d3e81888156$var$__awaiter(this, void 0, Promise, function() {
        var peerConnection, provider, offer, payload, dataConnection, err_2, err_1_1;
        return $77f14d3e81888156$var$__generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              peerConnection = this.connection.peerConnection;
              provider = this.connection.provider;
              _a.label = 1;
            case 1:
              _a.trys.push([
                1,
                7,
                ,
                8
              ]);
              return [
                4,
                peerConnection.createOffer(this.connection.options.constraints)
              ];
            case 2:
              offer = _a.sent();
              $1615705ecc6adca3$exports.default.log("Created offer.");
              if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === "function")
                offer.sdp = this.connection.options.sdpTransform(offer.sdp) || offer.sdp;
              _a.label = 3;
            case 3:
              _a.trys.push([
                3,
                5,
                ,
                6
              ]);
              return [
                4,
                peerConnection.setLocalDescription(offer)
              ];
            case 4:
              _a.sent();
              $1615705ecc6adca3$exports.default.log("Set localDescription:", offer, "for:".concat(this.connection.peer));
              payload = {
                sdp: offer,
                type: this.connection.type,
                connectionId: this.connection.connectionId,
                metadata: this.connection.metadata,
                browser: $06cb531ed7840f78$export$7debb50ef11d5e0b.browser
              };
              if (this.connection.type === $60fadef21a2daafc$export$3157d57b4135e3bc.Data) {
                dataConnection = this.connection;
                payload = $77f14d3e81888156$var$__assign($77f14d3e81888156$var$__assign({}, payload), {
                  label: dataConnection.label,
                  reliable: dataConnection.reliable,
                  serialization: dataConnection.serialization
                });
              }
              provider.socket.send({
                type: $60fadef21a2daafc$export$adb4a1754da6f10d.Offer,
                payload,
                dst: this.connection.peer
              });
              return [
                3,
                6
              ];
            case 5:
              err_2 = _a.sent();
              if (err_2 != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer") {
                provider.emitError($60fadef21a2daafc$export$9547aaa2e39030ff.WebRTC, err_2);
                $1615705ecc6adca3$exports.default.log("Failed to setLocalDescription, ", err_2);
              }
              return [
                3,
                6
              ];
            case 6:
              return [
                3,
                8
              ];
            case 7:
              err_1_1 = _a.sent();
              provider.emitError($60fadef21a2daafc$export$9547aaa2e39030ff.WebRTC, err_1_1);
              $1615705ecc6adca3$exports.default.log("Failed to createOffer, ", err_1_1);
              return [
                3,
                8
              ];
            case 8:
              return [
                2
              ];
          }
        });
      });
    };
    $77f14d3e81888156$export$89e6bb5ad64bf4a2.prototype._makeAnswer = function() {
      return $77f14d3e81888156$var$__awaiter(this, void 0, Promise, function() {
        var peerConnection, provider, answer, err_3, err_1_2;
        return $77f14d3e81888156$var$__generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              peerConnection = this.connection.peerConnection;
              provider = this.connection.provider;
              _a.label = 1;
            case 1:
              _a.trys.push([
                1,
                7,
                ,
                8
              ]);
              return [
                4,
                peerConnection.createAnswer()
              ];
            case 2:
              answer = _a.sent();
              $1615705ecc6adca3$exports.default.log("Created answer.");
              if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === "function")
                answer.sdp = this.connection.options.sdpTransform(answer.sdp) || answer.sdp;
              _a.label = 3;
            case 3:
              _a.trys.push([
                3,
                5,
                ,
                6
              ]);
              return [
                4,
                peerConnection.setLocalDescription(answer)
              ];
            case 4:
              _a.sent();
              $1615705ecc6adca3$exports.default.log("Set localDescription:", answer, "for:".concat(this.connection.peer));
              provider.socket.send({
                type: $60fadef21a2daafc$export$adb4a1754da6f10d.Answer,
                payload: {
                  sdp: answer,
                  type: this.connection.type,
                  connectionId: this.connection.connectionId,
                  browser: $06cb531ed7840f78$export$7debb50ef11d5e0b.browser
                },
                dst: this.connection.peer
              });
              return [
                3,
                6
              ];
            case 5:
              err_3 = _a.sent();
              provider.emitError($60fadef21a2daafc$export$9547aaa2e39030ff.WebRTC, err_3);
              $1615705ecc6adca3$exports.default.log("Failed to setLocalDescription, ", err_3);
              return [
                3,
                6
              ];
            case 6:
              return [
                3,
                8
              ];
            case 7:
              err_1_2 = _a.sent();
              provider.emitError($60fadef21a2daafc$export$9547aaa2e39030ff.WebRTC, err_1_2);
              $1615705ecc6adca3$exports.default.log("Failed to create answer, ", err_1_2);
              return [
                3,
                8
              ];
            case 8:
              return [
                2
              ];
          }
        });
      });
    };
    $77f14d3e81888156$export$89e6bb5ad64bf4a2.prototype.handleSDP = function(type3, sdp) {
      return $77f14d3e81888156$var$__awaiter(this, void 0, Promise, function() {
        var peerConnection, provider, self2, err_4;
        return $77f14d3e81888156$var$__generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              sdp = new RTCSessionDescription(sdp);
              peerConnection = this.connection.peerConnection;
              provider = this.connection.provider;
              $1615705ecc6adca3$exports.default.log("Setting remote description", sdp);
              self2 = this;
              _a.label = 1;
            case 1:
              _a.trys.push([
                1,
                5,
                ,
                6
              ]);
              return [
                4,
                peerConnection.setRemoteDescription(sdp)
              ];
            case 2:
              _a.sent();
              $1615705ecc6adca3$exports.default.log("Set remoteDescription:".concat(type3, " for:").concat(this.connection.peer));
              if (!(type3 === "OFFER"))
                return [
                  3,
                  4
                ];
              return [
                4,
                self2._makeAnswer()
              ];
            case 3:
              _a.sent();
              _a.label = 4;
            case 4:
              return [
                3,
                6
              ];
            case 5:
              err_4 = _a.sent();
              provider.emitError($60fadef21a2daafc$export$9547aaa2e39030ff.WebRTC, err_4);
              $1615705ecc6adca3$exports.default.log("Failed to setRemoteDescription, ", err_4);
              return [
                3,
                6
              ];
            case 6:
              return [
                2
              ];
          }
        });
      });
    };
    $77f14d3e81888156$export$89e6bb5ad64bf4a2.prototype.handleCandidate = function(ice) {
      return $77f14d3e81888156$var$__awaiter(this, void 0, Promise, function() {
        var candidate, sdpMLineIndex, sdpMid, peerConnection, provider, err_5;
        return $77f14d3e81888156$var$__generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              $1615705ecc6adca3$exports.default.log("handleCandidate:", ice);
              candidate = ice.candidate;
              sdpMLineIndex = ice.sdpMLineIndex;
              sdpMid = ice.sdpMid;
              peerConnection = this.connection.peerConnection;
              provider = this.connection.provider;
              _a.label = 1;
            case 1:
              _a.trys.push([
                1,
                3,
                ,
                4
              ]);
              return [
                4,
                peerConnection.addIceCandidate(new RTCIceCandidate({
                  sdpMid,
                  sdpMLineIndex,
                  candidate
                }))
              ];
            case 2:
              _a.sent();
              $1615705ecc6adca3$exports.default.log("Added ICE candidate for:".concat(this.connection.peer));
              return [
                3,
                4
              ];
            case 3:
              err_5 = _a.sent();
              provider.emitError($60fadef21a2daafc$export$9547aaa2e39030ff.WebRTC, err_5);
              $1615705ecc6adca3$exports.default.log("Failed to handleCandidate, ", err_5);
              return [
                3,
                4
              ];
            case 4:
              return [
                2
              ];
          }
        });
      });
    };
    $77f14d3e81888156$export$89e6bb5ad64bf4a2.prototype._addTracksToConnection = function(stream, peerConnection) {
      $1615705ecc6adca3$exports.default.log("add tracks from stream ".concat(stream.id, " to peer connection"));
      if (!peerConnection.addTrack)
        return $1615705ecc6adca3$exports.default.error("Your browser does't support RTCPeerConnection#addTrack. Ignored.");
      stream.getTracks().forEach(function(track) {
        peerConnection.addTrack(track, stream);
      });
    };
    $77f14d3e81888156$export$89e6bb5ad64bf4a2.prototype._addStreamToMediaConnection = function(stream, mediaConnection) {
      $1615705ecc6adca3$exports.default.log("add stream ".concat(stream.id, " to media connection ").concat(mediaConnection.connectionId));
      mediaConnection.addStream(stream);
    };
    return $77f14d3e81888156$export$89e6bb5ad64bf4a2;
  }();
  var $0b3b332fd86c5202$exports = {};
  $parcel$export($0b3b332fd86c5202$exports, "BaseConnection", () => $0b3b332fd86c5202$export$23a2a68283c24d80, (v) => $0b3b332fd86c5202$export$23a2a68283c24d80 = v);
  var $0b3b332fd86c5202$var$__extends = function() {
    var extendStatics = function(d1, b1) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      return extendStatics(d1, b1);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var $0b3b332fd86c5202$export$23a2a68283c24d80 = function(_super) {
    $0b3b332fd86c5202$var$__extends($0b3b332fd86c5202$export$23a2a68283c24d802, _super);
    function $0b3b332fd86c5202$export$23a2a68283c24d802(peer2, provider, options) {
      var _this = _super.call(this) || this;
      _this.peer = peer2;
      _this.provider = provider;
      _this.options = options;
      _this._open = false;
      _this.metadata = options.metadata;
      return _this;
    }
    Object.defineProperty($0b3b332fd86c5202$export$23a2a68283c24d802.prototype, "open", {
      get: function() {
        return this._open;
      },
      enumerable: false,
      configurable: true
    });
    return $0b3b332fd86c5202$export$23a2a68283c24d802;
  }($ac9b757d51178e15$exports.EventEmitter);
  var $353dee38f9ab557b$var$__extends = function() {
    var extendStatics = function(d1, b1) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      return extendStatics(d1, b1);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var $353dee38f9ab557b$var$__assign = function() {
    $353dee38f9ab557b$var$__assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return $353dee38f9ab557b$var$__assign.apply(this, arguments);
  };
  var $353dee38f9ab557b$var$__values = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var $353dee38f9ab557b$export$4a84e95a2324ac29 = function(_super) {
    $353dee38f9ab557b$var$__extends($353dee38f9ab557b$export$4a84e95a2324ac292, _super);
    function $353dee38f9ab557b$export$4a84e95a2324ac292(peerId, provider, options) {
      var _this = _super.call(this, peerId, provider, options) || this;
      _this._localStream = _this.options._stream;
      _this.connectionId = _this.options.connectionId || $353dee38f9ab557b$export$4a84e95a2324ac292.ID_PREFIX + $06cb531ed7840f78$export$7debb50ef11d5e0b.randomToken();
      _this._negotiator = new $77f14d3e81888156$exports.Negotiator(_this);
      if (_this._localStream)
        _this._negotiator.startConnection({
          _stream: _this._localStream,
          originator: true
        });
      return _this;
    }
    Object.defineProperty($353dee38f9ab557b$export$4a84e95a2324ac292.prototype, "type", {
      get: function() {
        return $60fadef21a2daafc$export$3157d57b4135e3bc.Media;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($353dee38f9ab557b$export$4a84e95a2324ac292.prototype, "localStream", {
      get: function() {
        return this._localStream;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($353dee38f9ab557b$export$4a84e95a2324ac292.prototype, "remoteStream", {
      get: function() {
        return this._remoteStream;
      },
      enumerable: false,
      configurable: true
    });
    $353dee38f9ab557b$export$4a84e95a2324ac292.prototype.addStream = function(remoteStream) {
      $1615705ecc6adca3$exports.default.log("Receiving stream", remoteStream);
      this._remoteStream = remoteStream;
      _super.prototype.emit.call(this, "stream", remoteStream);
    };
    $353dee38f9ab557b$export$4a84e95a2324ac292.prototype.handleMessage = function(message) {
      var type3 = message.type;
      var payload = message.payload;
      switch (message.type) {
        case $60fadef21a2daafc$export$adb4a1754da6f10d.Answer:
          this._negotiator.handleSDP(type3, payload.sdp);
          this._open = true;
          break;
        case $60fadef21a2daafc$export$adb4a1754da6f10d.Candidate:
          this._negotiator.handleCandidate(payload.candidate);
          break;
        default:
          $1615705ecc6adca3$exports.default.warn("Unrecognized message type:".concat(type3, " from peer:").concat(this.peer));
          break;
      }
    };
    $353dee38f9ab557b$export$4a84e95a2324ac292.prototype.answer = function(stream, options) {
      var e_1, _a;
      if (options === void 0)
        options = {};
      if (this._localStream) {
        $1615705ecc6adca3$exports.default.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?");
        return;
      }
      this._localStream = stream;
      if (options && options.sdpTransform)
        this.options.sdpTransform = options.sdpTransform;
      this._negotiator.startConnection($353dee38f9ab557b$var$__assign($353dee38f9ab557b$var$__assign({}, this.options._payload), {
        _stream: stream
      }));
      var messages = this.provider._getMessages(this.connectionId);
      try {
        for (var messages_1 = $353dee38f9ab557b$var$__values(messages), messages_1_1 = messages_1.next(); !messages_1_1.done; messages_1_1 = messages_1.next()) {
          var message = messages_1_1.value;
          this.handleMessage(message);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (messages_1_1 && !messages_1_1.done && (_a = messages_1.return))
            _a.call(messages_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      this._open = true;
    };
    $353dee38f9ab557b$export$4a84e95a2324ac292.prototype.close = function() {
      if (this._negotiator) {
        this._negotiator.cleanup();
        this._negotiator = null;
      }
      this._localStream = null;
      this._remoteStream = null;
      if (this.provider) {
        this.provider._removeConnection(this);
        this.provider = null;
      }
      if (this.options && this.options._stream)
        this.options._stream = null;
      if (!this.open)
        return;
      this._open = false;
      _super.prototype.emit.call(this, "close");
    };
    $353dee38f9ab557b$export$4a84e95a2324ac292.ID_PREFIX = "mc_";
    return $353dee38f9ab557b$export$4a84e95a2324ac292;
  }($0b3b332fd86c5202$exports.BaseConnection);
  var $3356170d7bce7f20$exports = {};
  $parcel$export($3356170d7bce7f20$exports, "DataConnection", () => $3356170d7bce7f20$export$d365f7ad9d7df9c9, (v) => $3356170d7bce7f20$export$d365f7ad9d7df9c9 = v);
  var $3014d862dcc9946b$exports = {};
  $parcel$export($3014d862dcc9946b$exports, "EncodingQueue", () => $3014d862dcc9946b$export$c6913ae0ed687038, (v) => $3014d862dcc9946b$export$c6913ae0ed687038 = v);
  var $3014d862dcc9946b$var$__extends = function() {
    var extendStatics = function(d1, b1) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      return extendStatics(d1, b1);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var $3014d862dcc9946b$export$c6913ae0ed687038 = function(_super) {
    $3014d862dcc9946b$var$__extends($3014d862dcc9946b$export$c6913ae0ed6870382, _super);
    function $3014d862dcc9946b$export$c6913ae0ed6870382() {
      var _this = _super.call(this) || this;
      _this.fileReader = new FileReader();
      _this._queue = [];
      _this._processing = false;
      _this.fileReader.onload = function(evt) {
        _this._processing = false;
        if (evt.target)
          _this.emit("done", evt.target.result);
        _this.doNextTask();
      };
      _this.fileReader.onerror = function(evt) {
        $1615705ecc6adca3$exports.default.error("EncodingQueue error:", evt);
        _this._processing = false;
        _this.destroy();
        _this.emit("error", evt);
      };
      return _this;
    }
    Object.defineProperty($3014d862dcc9946b$export$c6913ae0ed6870382.prototype, "queue", {
      get: function() {
        return this._queue;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($3014d862dcc9946b$export$c6913ae0ed6870382.prototype, "size", {
      get: function() {
        return this.queue.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($3014d862dcc9946b$export$c6913ae0ed6870382.prototype, "processing", {
      get: function() {
        return this._processing;
      },
      enumerable: false,
      configurable: true
    });
    $3014d862dcc9946b$export$c6913ae0ed6870382.prototype.enque = function(blob) {
      this.queue.push(blob);
      if (this.processing)
        return;
      this.doNextTask();
    };
    $3014d862dcc9946b$export$c6913ae0ed6870382.prototype.destroy = function() {
      this.fileReader.abort();
      this._queue = [];
    };
    $3014d862dcc9946b$export$c6913ae0ed6870382.prototype.doNextTask = function() {
      if (this.size === 0)
        return;
      if (this.processing)
        return;
      this._processing = true;
      this.fileReader.readAsArrayBuffer(this.queue.shift());
    };
    return $3014d862dcc9946b$export$c6913ae0ed6870382;
  }($ac9b757d51178e15$exports.EventEmitter);
  var $3356170d7bce7f20$var$__extends = function() {
    var extendStatics = function(d1, b1) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      return extendStatics(d1, b1);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var $3356170d7bce7f20$var$__values = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var $3356170d7bce7f20$export$d365f7ad9d7df9c9 = function(_super) {
    $3356170d7bce7f20$var$__extends($3356170d7bce7f20$export$d365f7ad9d7df9c92, _super);
    function $3356170d7bce7f20$export$d365f7ad9d7df9c92(peerId, provider, options) {
      var _this = _super.call(this, peerId, provider, options) || this;
      _this.stringify = JSON.stringify;
      _this.parse = JSON.parse;
      _this._buffer = [];
      _this._bufferSize = 0;
      _this._buffering = false;
      _this._chunkedData = {};
      _this._encodingQueue = new $3014d862dcc9946b$exports.EncodingQueue();
      _this.connectionId = _this.options.connectionId || $3356170d7bce7f20$export$d365f7ad9d7df9c92.ID_PREFIX + $06cb531ed7840f78$export$7debb50ef11d5e0b.randomToken();
      _this.label = _this.options.label || _this.connectionId;
      _this.serialization = _this.options.serialization || $60fadef21a2daafc$export$89f507cf986a947.Binary;
      _this.reliable = !!_this.options.reliable;
      _this._encodingQueue.on("done", function(ab) {
        _this._bufferedSend(ab);
      });
      _this._encodingQueue.on("error", function() {
        $1615705ecc6adca3$exports.default.error("DC#".concat(_this.connectionId, ": Error occured in encoding from blob to arraybuffer, close DC"));
        _this.close();
      });
      _this._negotiator = new $77f14d3e81888156$exports.Negotiator(_this);
      _this._negotiator.startConnection(_this.options._payload || {
        originator: true
      });
      return _this;
    }
    Object.defineProperty($3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype, "type", {
      get: function() {
        return $60fadef21a2daafc$export$3157d57b4135e3bc.Data;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype, "dataChannel", {
      get: function() {
        return this._dc;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype, "bufferSize", {
      get: function() {
        return this._bufferSize;
      },
      enumerable: false,
      configurable: true
    });
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype.initialize = function(dc) {
      this._dc = dc;
      this._configureDataChannel();
    };
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype._configureDataChannel = function() {
      var _this = this;
      if (!$06cb531ed7840f78$export$7debb50ef11d5e0b.supports.binaryBlob || $06cb531ed7840f78$export$7debb50ef11d5e0b.supports.reliable)
        this.dataChannel.binaryType = "arraybuffer";
      this.dataChannel.onopen = function() {
        $1615705ecc6adca3$exports.default.log("DC#".concat(_this.connectionId, " dc connection success"));
        _this._open = true;
        _this.emit("open");
      };
      this.dataChannel.onmessage = function(e) {
        $1615705ecc6adca3$exports.default.log("DC#".concat(_this.connectionId, " dc onmessage:"), e.data);
        _this._handleDataMessage(e);
      };
      this.dataChannel.onclose = function() {
        $1615705ecc6adca3$exports.default.log("DC#".concat(_this.connectionId, " dc closed for:"), _this.peer);
        _this.close();
      };
    };
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype._handleDataMessage = function(_a) {
      var _this = this;
      var data = _a.data;
      var datatype = data.constructor;
      var isBinarySerialization = this.serialization === $60fadef21a2daafc$export$89f507cf986a947.Binary || this.serialization === $60fadef21a2daafc$export$89f507cf986a947.BinaryUTF8;
      var deserializedData = data;
      if (isBinarySerialization) {
        if (datatype === Blob) {
          $06cb531ed7840f78$export$7debb50ef11d5e0b.blobToArrayBuffer(data, function(ab) {
            var unpackedData = $06cb531ed7840f78$export$7debb50ef11d5e0b.unpack(ab);
            _this.emit("data", unpackedData);
          });
          return;
        } else if (datatype === ArrayBuffer)
          deserializedData = $06cb531ed7840f78$export$7debb50ef11d5e0b.unpack(data);
        else if (datatype === String) {
          var ab1 = $06cb531ed7840f78$export$7debb50ef11d5e0b.binaryStringToArrayBuffer(data);
          deserializedData = $06cb531ed7840f78$export$7debb50ef11d5e0b.unpack(ab1);
        }
      } else if (this.serialization === $60fadef21a2daafc$export$89f507cf986a947.JSON)
        deserializedData = this.parse(data);
      if (deserializedData.__peerData) {
        this._handleChunk(deserializedData);
        return;
      }
      _super.prototype.emit.call(this, "data", deserializedData);
    };
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype._handleChunk = function(data) {
      var id2 = data.__peerData;
      var chunkInfo = this._chunkedData[id2] || {
        data: [],
        count: 0,
        total: data.total
      };
      chunkInfo.data[data.n] = data.data;
      chunkInfo.count++;
      this._chunkedData[id2] = chunkInfo;
      if (chunkInfo.total === chunkInfo.count) {
        delete this._chunkedData[id2];
        var data_1 = new Blob(chunkInfo.data);
        this._handleDataMessage({
          data: data_1
        });
      }
    };
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype.close = function() {
      this._buffer = [];
      this._bufferSize = 0;
      this._chunkedData = {};
      if (this._negotiator) {
        this._negotiator.cleanup();
        this._negotiator = null;
      }
      if (this.provider) {
        this.provider._removeConnection(this);
        this.provider = null;
      }
      if (this.dataChannel) {
        this.dataChannel.onopen = null;
        this.dataChannel.onmessage = null;
        this.dataChannel.onclose = null;
        this._dc = null;
      }
      if (this._encodingQueue) {
        this._encodingQueue.destroy();
        this._encodingQueue.removeAllListeners();
        this._encodingQueue = null;
      }
      if (!this.open)
        return;
      this._open = false;
      _super.prototype.emit.call(this, "close");
    };
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype.send = function(data, chunked) {
      if (!this.open) {
        _super.prototype.emit.call(this, "error", new Error("Connection is not open. You should listen for the `open` event before sending messages."));
        return;
      }
      if (this.serialization === $60fadef21a2daafc$export$89f507cf986a947.JSON)
        this._bufferedSend(this.stringify(data));
      else if (this.serialization === $60fadef21a2daafc$export$89f507cf986a947.Binary || this.serialization === $60fadef21a2daafc$export$89f507cf986a947.BinaryUTF8) {
        var blob = $06cb531ed7840f78$export$7debb50ef11d5e0b.pack(data);
        if (!chunked && blob.size > $06cb531ed7840f78$export$7debb50ef11d5e0b.chunkedMTU) {
          this._sendChunks(blob);
          return;
        }
        if (!$06cb531ed7840f78$export$7debb50ef11d5e0b.supports.binaryBlob)
          this._encodingQueue.enque(blob);
        else
          this._bufferedSend(blob);
      } else
        this._bufferedSend(data);
    };
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype._bufferedSend = function(msg) {
      if (this._buffering || !this._trySend(msg)) {
        this._buffer.push(msg);
        this._bufferSize = this._buffer.length;
      }
    };
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype._trySend = function(msg) {
      var _this = this;
      if (!this.open)
        return false;
      if (this.dataChannel.bufferedAmount > $3356170d7bce7f20$export$d365f7ad9d7df9c92.MAX_BUFFERED_AMOUNT) {
        this._buffering = true;
        setTimeout(function() {
          _this._buffering = false;
          _this._tryBuffer();
        }, 50);
        return false;
      }
      try {
        this.dataChannel.send(msg);
      } catch (e) {
        $1615705ecc6adca3$exports.default.error("DC#:".concat(this.connectionId, " Error when sending:"), e);
        this._buffering = true;
        this.close();
        return false;
      }
      return true;
    };
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype._tryBuffer = function() {
      if (!this.open)
        return;
      if (this._buffer.length === 0)
        return;
      var msg = this._buffer[0];
      if (this._trySend(msg)) {
        this._buffer.shift();
        this._bufferSize = this._buffer.length;
        this._tryBuffer();
      }
    };
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype._sendChunks = function(blob) {
      var e_1, _a;
      var blobs = $06cb531ed7840f78$export$7debb50ef11d5e0b.chunk(blob);
      $1615705ecc6adca3$exports.default.log("DC#".concat(this.connectionId, " Try to send ").concat(blobs.length, " chunks..."));
      try {
        for (var blobs_1 = $3356170d7bce7f20$var$__values(blobs), blobs_1_1 = blobs_1.next(); !blobs_1_1.done; blobs_1_1 = blobs_1.next()) {
          var blob_1 = blobs_1_1.value;
          this.send(blob_1, true);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (blobs_1_1 && !blobs_1_1.done && (_a = blobs_1.return))
            _a.call(blobs_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.prototype.handleMessage = function(message) {
      var payload = message.payload;
      switch (message.type) {
        case $60fadef21a2daafc$export$adb4a1754da6f10d.Answer:
          this._negotiator.handleSDP(message.type, payload.sdp);
          break;
        case $60fadef21a2daafc$export$adb4a1754da6f10d.Candidate:
          this._negotiator.handleCandidate(payload.candidate);
          break;
        default:
          $1615705ecc6adca3$exports.default.warn("Unrecognized message type:", message.type, "from peer:", this.peer);
          break;
      }
    };
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.ID_PREFIX = "dc_";
    $3356170d7bce7f20$export$d365f7ad9d7df9c92.MAX_BUFFERED_AMOUNT = 8388608;
    return $3356170d7bce7f20$export$d365f7ad9d7df9c92;
  }($0b3b332fd86c5202$exports.BaseConnection);
  var $9e85b3e1327369e6$exports = {};
  $parcel$export($9e85b3e1327369e6$exports, "API", () => $9e85b3e1327369e6$export$2c4e825dc9120f87, (v) => $9e85b3e1327369e6$export$2c4e825dc9120f87 = v);
  var $9e85b3e1327369e6$var$__awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var $9e85b3e1327369e6$var$__generator = function(thisArg, body) {
    var _ = {
      label: 0,
      sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    }, f, y, t, g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([
          n,
          v
        ]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [
              op[0] & 2,
              t.value
            ];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };
            case 5:
              _.label++;
              y = op[1];
              op = [
                0
              ];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [
            6,
            e
          ];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };
  var $9e85b3e1327369e6$export$2c4e825dc9120f87 = function() {
    function $9e85b3e1327369e6$export$2c4e825dc9120f872(_options) {
      this._options = _options;
    }
    $9e85b3e1327369e6$export$2c4e825dc9120f872.prototype._buildRequest = function(method) {
      var protocol = this._options.secure ? "https" : "http";
      var _a = this._options, host = _a.host, port = _a.port, path = _a.path, key = _a.key;
      var url = new URL("".concat(protocol, "://").concat(host, ":").concat(port).concat(path).concat(key, "/").concat(method));
      url.searchParams.set("ts", "".concat(Date.now()).concat(Math.random()));
      url.searchParams.set("version", $0d1ed891c5cb27c0$exports.version);
      return fetch(url.href, {
        referrerPolicy: this._options.referrerPolicy
      });
    };
    $9e85b3e1327369e6$export$2c4e825dc9120f872.prototype.retrieveId = function() {
      return $9e85b3e1327369e6$var$__awaiter(this, void 0, Promise, function() {
        var response, error_1, pathError;
        return $9e85b3e1327369e6$var$__generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([
                0,
                2,
                ,
                3
              ]);
              return [
                4,
                this._buildRequest("id")
              ];
            case 1:
              response = _a.sent();
              if (response.status !== 200)
                throw new Error("Error. Status:".concat(response.status));
              return [
                2,
                response.text()
              ];
            case 2:
              error_1 = _a.sent();
              $1615705ecc6adca3$exports.default.error("Error retrieving ID", error_1);
              pathError = "";
              if (this._options.path === "/" && this._options.host !== $06cb531ed7840f78$export$7debb50ef11d5e0b.CLOUD_HOST)
                pathError = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer.";
              throw new Error("Could not get an ID from the server." + pathError);
            case 3:
              return [
                2
              ];
          }
        });
      });
    };
    $9e85b3e1327369e6$export$2c4e825dc9120f872.prototype.listAllPeers = function() {
      return $9e85b3e1327369e6$var$__awaiter(this, void 0, Promise, function() {
        var response, helpfulError, error_2;
        return $9e85b3e1327369e6$var$__generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([
                0,
                2,
                ,
                3
              ]);
              return [
                4,
                this._buildRequest("peers")
              ];
            case 1:
              response = _a.sent();
              if (response.status !== 200) {
                if (response.status === 401) {
                  helpfulError = "";
                  if (this._options.host === $06cb531ed7840f78$export$7debb50ef11d5e0b.CLOUD_HOST)
                    helpfulError = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.";
                  else
                    helpfulError = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.";
                  throw new Error("It doesn't look like you have permission to list peers IDs. " + helpfulError);
                }
                throw new Error("Error. Status:".concat(response.status));
              }
              return [
                2,
                response.json()
              ];
            case 2:
              error_2 = _a.sent();
              $1615705ecc6adca3$exports.default.error("Error retrieving list peers", error_2);
              throw new Error("Could not get list peers from the server." + error_2);
            case 3:
              return [
                2
              ];
          }
        });
      });
    };
    return $9e85b3e1327369e6$export$2c4e825dc9120f872;
  }();
  var $26088d7da5b03f69$var$__extends = function() {
    var extendStatics = function(d1, b1) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      return extendStatics(d1, b1);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var $26088d7da5b03f69$var$__assign = function() {
    $26088d7da5b03f69$var$__assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return $26088d7da5b03f69$var$__assign.apply(this, arguments);
  };
  var $26088d7da5b03f69$var$__values = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var $26088d7da5b03f69$var$__read = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = {
        error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var $26088d7da5b03f69$var$PeerOptions = function() {
    function PeerOptions() {
    }
    return PeerOptions;
  }();
  var $26088d7da5b03f69$export$ecd1fc136c422448 = function(_super) {
    $26088d7da5b03f69$var$__extends($26088d7da5b03f69$export$ecd1fc136c4224482, _super);
    function $26088d7da5b03f69$export$ecd1fc136c4224482(id1, options) {
      var _this = _super.call(this) || this;
      _this._id = null;
      _this._lastServerId = null;
      _this._destroyed = false;
      _this._disconnected = false;
      _this._open = false;
      _this._connections = /* @__PURE__ */ new Map();
      _this._lostMessages = /* @__PURE__ */ new Map();
      var userId;
      if (id1 && id1.constructor == Object)
        options = id1;
      else if (id1)
        userId = id1.toString();
      options = $26088d7da5b03f69$var$__assign({
        debug: 0,
        host: $06cb531ed7840f78$export$7debb50ef11d5e0b.CLOUD_HOST,
        port: $06cb531ed7840f78$export$7debb50ef11d5e0b.CLOUD_PORT,
        path: "/",
        key: $26088d7da5b03f69$export$ecd1fc136c4224482.DEFAULT_KEY,
        token: $06cb531ed7840f78$export$7debb50ef11d5e0b.randomToken(),
        config: $06cb531ed7840f78$export$7debb50ef11d5e0b.defaultConfig,
        referrerPolicy: "strict-origin-when-cross-origin"
      }, options);
      _this._options = options;
      if (_this._options.host === "/")
        _this._options.host = window.location.hostname;
      if (_this._options.path) {
        if (_this._options.path[0] !== "/")
          _this._options.path = "/" + _this._options.path;
        if (_this._options.path[_this._options.path.length - 1] !== "/")
          _this._options.path += "/";
      }
      if (_this._options.secure === void 0 && _this._options.host !== $06cb531ed7840f78$export$7debb50ef11d5e0b.CLOUD_HOST)
        _this._options.secure = $06cb531ed7840f78$export$7debb50ef11d5e0b.isSecure();
      else if (_this._options.host == $06cb531ed7840f78$export$7debb50ef11d5e0b.CLOUD_HOST)
        _this._options.secure = true;
      if (_this._options.logFunction)
        $1615705ecc6adca3$exports.default.setLogFunction(_this._options.logFunction);
      $1615705ecc6adca3$exports.default.logLevel = _this._options.debug || 0;
      _this._api = new $9e85b3e1327369e6$exports.API(options);
      _this._socket = _this._createServerConnection();
      if (!$06cb531ed7840f78$export$7debb50ef11d5e0b.supports.audioVideo && !$06cb531ed7840f78$export$7debb50ef11d5e0b.supports.data) {
        _this._delayedAbort($60fadef21a2daafc$export$9547aaa2e39030ff.BrowserIncompatible, "The current browser does not support WebRTC");
        return _this;
      }
      if (!!userId && !$06cb531ed7840f78$export$7debb50ef11d5e0b.validateId(userId)) {
        _this._delayedAbort($60fadef21a2daafc$export$9547aaa2e39030ff.InvalidID, 'ID "'.concat(userId, '" is invalid'));
        return _this;
      }
      if (userId)
        _this._initialize(userId);
      else
        _this._api.retrieveId().then(function(id2) {
          return _this._initialize(id2);
        }).catch(function(error) {
          return _this._abort($60fadef21a2daafc$export$9547aaa2e39030ff.ServerError, error);
        });
      return _this;
    }
    Object.defineProperty($26088d7da5b03f69$export$ecd1fc136c4224482.prototype, "id", {
      get: function() {
        return this._id;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($26088d7da5b03f69$export$ecd1fc136c4224482.prototype, "options", {
      get: function() {
        return this._options;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($26088d7da5b03f69$export$ecd1fc136c4224482.prototype, "open", {
      get: function() {
        return this._open;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($26088d7da5b03f69$export$ecd1fc136c4224482.prototype, "socket", {
      get: function() {
        return this._socket;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($26088d7da5b03f69$export$ecd1fc136c4224482.prototype, "connections", {
      get: function() {
        var e_1, _a;
        var plainConnections = /* @__PURE__ */ Object.create(null);
        try {
          for (var _b = $26088d7da5b03f69$var$__values(this._connections), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = $26088d7da5b03f69$var$__read(_c.value, 2), k = _d[0], v = _d[1];
            plainConnections[k] = v;
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return plainConnections;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($26088d7da5b03f69$export$ecd1fc136c4224482.prototype, "destroyed", {
      get: function() {
        return this._destroyed;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty($26088d7da5b03f69$export$ecd1fc136c4224482.prototype, "disconnected", {
      get: function() {
        return this._disconnected;
      },
      enumerable: false,
      configurable: true
    });
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype._createServerConnection = function() {
      var _this = this;
      var socket = new $31d11a8d122cb4b7$exports.Socket(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval);
      socket.on($60fadef21a2daafc$export$3b5c4a4b6354f023.Message, function(data) {
        _this._handleMessage(data);
      });
      socket.on($60fadef21a2daafc$export$3b5c4a4b6354f023.Error, function(error) {
        _this._abort($60fadef21a2daafc$export$9547aaa2e39030ff.SocketError, error);
      });
      socket.on($60fadef21a2daafc$export$3b5c4a4b6354f023.Disconnected, function() {
        if (_this.disconnected)
          return;
        _this.emitError($60fadef21a2daafc$export$9547aaa2e39030ff.Network, "Lost connection to server.");
        _this.disconnect();
      });
      socket.on($60fadef21a2daafc$export$3b5c4a4b6354f023.Close, function() {
        if (_this.disconnected)
          return;
        _this._abort($60fadef21a2daafc$export$9547aaa2e39030ff.SocketClosed, "Underlying socket is already closed.");
      });
      return socket;
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype._initialize = function(id2) {
      this._id = id2;
      this.socket.start(id2, this._options.token);
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype._handleMessage = function(message) {
      var e_2, _a;
      var type3 = message.type;
      var payload = message.payload;
      var peerId = message.src;
      switch (type3) {
        case $60fadef21a2daafc$export$adb4a1754da6f10d.Open:
          this._lastServerId = this.id;
          this._open = true;
          this.emit("open", this.id);
          break;
        case $60fadef21a2daafc$export$adb4a1754da6f10d.Error:
          this._abort($60fadef21a2daafc$export$9547aaa2e39030ff.ServerError, payload.msg);
          break;
        case $60fadef21a2daafc$export$adb4a1754da6f10d.IdTaken:
          this._abort($60fadef21a2daafc$export$9547aaa2e39030ff.UnavailableID, 'ID "'.concat(this.id, '" is taken'));
          break;
        case $60fadef21a2daafc$export$adb4a1754da6f10d.InvalidKey:
          this._abort($60fadef21a2daafc$export$9547aaa2e39030ff.InvalidKey, 'API KEY "'.concat(this._options.key, '" is invalid'));
          break;
        case $60fadef21a2daafc$export$adb4a1754da6f10d.Leave:
          $1615705ecc6adca3$exports.default.log("Received leave message from ".concat(peerId));
          this._cleanupPeer(peerId);
          this._connections.delete(peerId);
          break;
        case $60fadef21a2daafc$export$adb4a1754da6f10d.Expire:
          this.emitError($60fadef21a2daafc$export$9547aaa2e39030ff.PeerUnavailable, "Could not connect to peer ".concat(peerId));
          break;
        case $60fadef21a2daafc$export$adb4a1754da6f10d.Offer:
          var connectionId = payload.connectionId;
          var connection = this.getConnection(peerId, connectionId);
          if (connection) {
            connection.close();
            $1615705ecc6adca3$exports.default.warn("Offer received for existing Connection ID:".concat(connectionId));
          }
          if (payload.type === $60fadef21a2daafc$export$3157d57b4135e3bc.Media) {
            var mediaConnection = new $353dee38f9ab557b$exports.MediaConnection(peerId, this, {
              connectionId,
              _payload: payload,
              metadata: payload.metadata
            });
            connection = mediaConnection;
            this._addConnection(peerId, connection);
            this.emit("call", mediaConnection);
          } else if (payload.type === $60fadef21a2daafc$export$3157d57b4135e3bc.Data) {
            var dataConnection = new $3356170d7bce7f20$exports.DataConnection(peerId, this, {
              connectionId,
              _payload: payload,
              metadata: payload.metadata,
              label: payload.label,
              serialization: payload.serialization,
              reliable: payload.reliable
            });
            connection = dataConnection;
            this._addConnection(peerId, connection);
            this.emit("connection", dataConnection);
          } else {
            $1615705ecc6adca3$exports.default.warn("Received malformed connection type:".concat(payload.type));
            return;
          }
          var messages = this._getMessages(connectionId);
          try {
            for (var messages_1 = $26088d7da5b03f69$var$__values(messages), messages_1_1 = messages_1.next(); !messages_1_1.done; messages_1_1 = messages_1.next()) {
              var message_1 = messages_1_1.value;
              connection.handleMessage(message_1);
            }
          } catch (e_2_1) {
            e_2 = {
              error: e_2_1
            };
          } finally {
            try {
              if (messages_1_1 && !messages_1_1.done && (_a = messages_1.return))
                _a.call(messages_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
          break;
        default:
          if (!payload) {
            $1615705ecc6adca3$exports.default.warn("You received a malformed message from ".concat(peerId, " of type ").concat(type3));
            return;
          }
          var connectionId = payload.connectionId;
          var connection = this.getConnection(peerId, connectionId);
          if (connection && connection.peerConnection)
            connection.handleMessage(message);
          else if (connectionId)
            this._storeMessage(connectionId, message);
          else
            $1615705ecc6adca3$exports.default.warn("You received an unrecognized message:", message);
          break;
      }
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype._storeMessage = function(connectionId, message) {
      if (!this._lostMessages.has(connectionId))
        this._lostMessages.set(connectionId, []);
      this._lostMessages.get(connectionId).push(message);
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype._getMessages = function(connectionId) {
      var messages = this._lostMessages.get(connectionId);
      if (messages) {
        this._lostMessages.delete(connectionId);
        return messages;
      }
      return [];
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype.connect = function(peer2, options) {
      if (options === void 0)
        options = {};
      if (this.disconnected) {
        $1615705ecc6adca3$exports.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available.");
        this.emitError($60fadef21a2daafc$export$9547aaa2e39030ff.Disconnected, "Cannot connect to new Peer after disconnecting from server.");
        return;
      }
      var dataConnection = new $3356170d7bce7f20$exports.DataConnection(peer2, this, options);
      this._addConnection(peer2, dataConnection);
      return dataConnection;
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype.call = function(peer2, stream, options) {
      if (options === void 0)
        options = {};
      if (this.disconnected) {
        $1615705ecc6adca3$exports.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect.");
        this.emitError($60fadef21a2daafc$export$9547aaa2e39030ff.Disconnected, "Cannot connect to new Peer after disconnecting from server.");
        return;
      }
      if (!stream) {
        $1615705ecc6adca3$exports.default.error("To call a peer, you must provide a stream from your browser's `getUserMedia`.");
        return;
      }
      var mediaConnection = new $353dee38f9ab557b$exports.MediaConnection(peer2, this, $26088d7da5b03f69$var$__assign($26088d7da5b03f69$var$__assign({}, options), {
        _stream: stream
      }));
      this._addConnection(peer2, mediaConnection);
      return mediaConnection;
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype._addConnection = function(peerId, connection) {
      $1615705ecc6adca3$exports.default.log("add connection ".concat(connection.type, ":").concat(connection.connectionId, " to peerId:").concat(peerId));
      if (!this._connections.has(peerId))
        this._connections.set(peerId, []);
      this._connections.get(peerId).push(connection);
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype._removeConnection = function(connection) {
      var connections = this._connections.get(connection.peer);
      if (connections) {
        var index = connections.indexOf(connection);
        if (index !== -1)
          connections.splice(index, 1);
      }
      this._lostMessages.delete(connection.connectionId);
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype.getConnection = function(peerId, connectionId) {
      var e_3, _a;
      var connections = this._connections.get(peerId);
      if (!connections)
        return null;
      try {
        for (var connections_1 = $26088d7da5b03f69$var$__values(connections), connections_1_1 = connections_1.next(); !connections_1_1.done; connections_1_1 = connections_1.next()) {
          var connection = connections_1_1.value;
          if (connection.connectionId === connectionId)
            return connection;
        }
      } catch (e_3_1) {
        e_3 = {
          error: e_3_1
        };
      } finally {
        try {
          if (connections_1_1 && !connections_1_1.done && (_a = connections_1.return))
            _a.call(connections_1);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return null;
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype._delayedAbort = function(type3, message) {
      var _this = this;
      setTimeout(function() {
        _this._abort(type3, message);
      }, 0);
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype._abort = function(type3, message) {
      $1615705ecc6adca3$exports.default.error("Aborting!");
      this.emitError(type3, message);
      if (!this._lastServerId)
        this.destroy();
      else
        this.disconnect();
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype.emitError = function(type3, err) {
      $1615705ecc6adca3$exports.default.error("Error:", err);
      var error;
      if (typeof err === "string")
        error = new Error(err);
      else
        error = err;
      error.type = type3;
      this.emit("error", error);
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype.destroy = function() {
      if (this.destroyed)
        return;
      $1615705ecc6adca3$exports.default.log("Destroy peer with ID:".concat(this.id));
      this.disconnect();
      this._cleanup();
      this._destroyed = true;
      this.emit("close");
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype._cleanup = function() {
      var e_4, _a;
      try {
        for (var _b = $26088d7da5b03f69$var$__values(this._connections.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var peerId = _c.value;
          this._cleanupPeer(peerId);
          this._connections.delete(peerId);
        }
      } catch (e_4_1) {
        e_4 = {
          error: e_4_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      this.socket.removeAllListeners();
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype._cleanupPeer = function(peerId) {
      var e_5, _a;
      var connections = this._connections.get(peerId);
      if (!connections)
        return;
      try {
        for (var connections_2 = $26088d7da5b03f69$var$__values(connections), connections_2_1 = connections_2.next(); !connections_2_1.done; connections_2_1 = connections_2.next()) {
          var connection = connections_2_1.value;
          connection.close();
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (connections_2_1 && !connections_2_1.done && (_a = connections_2.return))
            _a.call(connections_2);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype.disconnect = function() {
      if (this.disconnected)
        return;
      var currentId = this.id;
      $1615705ecc6adca3$exports.default.log("Disconnect peer with ID:".concat(currentId));
      this._disconnected = true;
      this._open = false;
      this.socket.close();
      this._lastServerId = currentId;
      this._id = null;
      this.emit("disconnected", currentId);
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype.reconnect = function() {
      if (this.disconnected && !this.destroyed) {
        $1615705ecc6adca3$exports.default.log("Attempting reconnection to server with ID ".concat(this._lastServerId));
        this._disconnected = false;
        this._initialize(this._lastServerId);
      } else if (this.destroyed)
        throw new Error("This peer cannot reconnect to the server. It has already been destroyed.");
      else if (!this.disconnected && !this.open)
        $1615705ecc6adca3$exports.default.error("In a hurry? We're still trying to make the initial connection!");
      else
        throw new Error("Peer ".concat(this.id, " cannot reconnect because it is not disconnected from the server!"));
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.prototype.listAllPeers = function(cb) {
      var _this = this;
      if (cb === void 0)
        cb = function(_) {
        };
      this._api.listAllPeers().then(function(peers) {
        return cb(peers);
      }).catch(function(error) {
        return _this._abort($60fadef21a2daafc$export$9547aaa2e39030ff.ServerError, error);
      });
    };
    $26088d7da5b03f69$export$ecd1fc136c4224482.DEFAULT_KEY = "peerjs";
    return $26088d7da5b03f69$export$ecd1fc136c4224482;
  }($ac9b757d51178e15$exports.EventEmitter);
  var $70d766613f57b014$export$2e2bcd8739ae039 = $26088d7da5b03f69$exports.Peer;

  // src/index.ts
  var params = new Proxy(new URLSearchParams(window.location.search), {
    get: (searchParams, prop) => searchParams.get(prop)
  });
  var peer = new $26088d7da5b03f69$export$ecd1fc136c422448();
  var userDialog = document.getElementById("user-info-dialog");
  var hostDialog = document.getElementById("host-info-dialog");
  var userList = document.getElementById("users");
  var state = {
    host: {
      conn: null
    },
    me: {},
    el: {
      main: document.getElementById("content")
    },
    connections: {},
    users: {},
    game: {
      type: "story-pointing" /* storyPointing */,
      mode: "wait" /* wait */
    },
    matches: [],
    theme: {
      name: "Minimalist" /* minimalist */,
      tearDown: () => null
    }
  };
  window.state = state;
  window.main = state.el.main;
  state.el.main.addEventListener("click", (event) => {
    const el = event.target;
    if (el.type !== "button") {
      return;
    }
    if (el.name === "restart") {
      console.debug("restart game");
      el.classList.toggle("hidden");
      state.el.main.children[state.game.type].children["reveal"].classList.toggle("hidden");
      state.el.main.children[state.game.type].children["results"].innerHTML = "";
      state.users = map_default((user) => {
        return omit_default(["voted", "vote"], user);
      }, state.users);
      state.me = omit_default(["voted", "vote"], state.me);
      listUsers();
      forEach_default((conn) => {
        console.debug("time to reveal all votes");
        conn.send({ action: "restart_game", payload: true });
        conn.send({ action: "refresh_users", payload: state.users });
      }, values_default(state.connections));
      state.game.mode = "play" /* play */;
      return;
    }
    if (el.name === "reveal") {
      console.debug("reveal something");
      state.users[state.me.name].vote = state.me.vote;
      el.classList.toggle("hidden");
      state.el.main.children[state.game.type].children["restart"].classList.toggle("hidden");
      forEach_default((conn) => {
        console.debug("time to reveal all votes");
        conn.send({ action: "reveal_vote", payload: true });
      }, values_default(state.connections));
      state.game.mode = "reveal" /* reveal */;
      return;
    }
    state.me.voted = true;
    state.me.vote = el.value;
    console.debug("state.me", state.me);
    if (state.me.category !== "host") {
      state.host.conn.send({ action: "user_voted", payload: { name: state.me.name } });
    } else {
      state.users[state.me.name].voted = true;
      listUsers();
      forEach_default((conn) => {
        console.debug("send user list to all players");
        console.debug("conn", conn);
        conn.send({ action: "refresh_users", payload: state.users });
      }, values_default(state.connections));
    }
  });
  var settingsButton = document.getElementById("settings");
  var setTheme = () => {
    if (state.theme.name === "Minimalist" /* minimalist */) {
      return;
    }
    if (state.theme.name === "Migration" /* migration */) {
      Promise.resolve().then(() => (init_migration(), migration_exports)).then((obj) => {
        console.debug("obj", obj);
        state.theme.tearDown = obj.tearDown;
      }).catch((err) => {
        console.error(err);
      });
    }
    if (state.theme.name === "Waves" /* waves */) {
      Promise.resolve().then(() => (init_waves(), waves_exports)).then((obj) => {
        console.debug("obj", obj);
        state.theme.tearDown = obj.tearDown;
      }).catch((err) => {
        console.error(err);
      });
    }
  };
  setTheme();
  var shuffle = (array) => {
    let currentIndex = array.length, randomIndex;
    while (currentIndex > 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;
      [array[currentIndex], array[randomIndex]] = [
        array[randomIndex],
        array[currentIndex]
      ];
    }
    return array;
  };
  var showResults = (votes, average) => {
    const main = state.el.main;
    const game = main.children[state.game.type];
    const results = game.children.results;
    results.append(`average: ${average.toFixed(2)}`);
    results.append(`  votes: ${shuffle(votes)}`);
  };
  var revealVotes = () => {
    const votes = pipe(
      filter_default((user) => {
        return user.vote !== null;
      }),
      map_default((user) => {
        return user.vote;
      })
    )(values_default(state.users));
    console.debug("votes", votes);
    const average = sum_default(votes) / votes.length;
    showResults(votes, average);
    forEach_default((conn) => {
      console.debug("send user list to all players");
      console.debug("conn", conn);
      conn.send({ action: "show_results", payload: {
        votes,
        average
      } });
    }, values_default(state.connections));
    state.game.mode = "reveal" /* reveal */;
  };
  var initalizeGame = () => {
    const main = state.el.main;
    forEach_default((el) => {
      el.classList.add("hidden");
    }, main.children);
    const game = main.children[state.game.type];
    game.classList.toggle("hidden");
    if (state.me.category === "host") {
      console.debug("test");
      game.children["reveal"].classList.remove("hidden");
    }
    state.game.mode = "play" /* play */;
  };
  var listUsers = () => {
    userList.innerHTML = "";
    console.debug("state", state);
    console.debug("values(state.users)", values_default(state.users));
    const usersByCategory = groupBy_default((user) => {
      return user.details.category;
    }, values_default(state.users));
    const userLists = mapObjIndexed_default((users, category) => {
      const figure = document.createElement("figure");
      const figCaption = document.createElement("figcaption");
      figCaption.innerText = category;
      figure.appendChild(figCaption);
      const ul = document.createElement("ul");
      const listItems = map_default((user) => {
        const li = document.createElement("li");
        li.innerText = `${user.details.name}${user.voted ? " \u{1F5F9}" : " \u2610"}`;
        return li;
      }, users);
      ul.append(...listItems);
      figure.appendChild(ul);
      return figure;
    }, usersByCategory);
    console.debug("userLists", userLists);
    userList.append("Players", ...values_default(userLists));
  };
  peer.on("open", (id2) => {
    const hostId = params.hostId;
    const main = state.el.main;
    console.debug(`My peer ID is ${id2}`);
    const shareButton = document.getElementById("share-copy");
    shareButton.addEventListener("click", (event) => {
      navigator.clipboard.writeText(`${location.href}?hostId=${id2}`);
    });
    hostDialog.addEventListener("close", (e) => {
      console.debug("e", e);
      console.debug("userDialog.returnValue", hostDialog.returnValue);
      const hostForm = e.target.firstElementChild;
      const hostInfo = new FormData(hostForm);
      const user = {};
      hostInfo.forEach((value, key) => user[key] = value);
      console.debug("hostInfo", hostInfo);
      localStorage.setItem("host", JSON.stringify(user));
      state.users[user.name] = { voted: false, details: user };
      state.me = user;
      state.theme.name = user.theme;
      setTheme();
      main.children["host-loading"].classList.toggle("hidden");
      listUsers();
    });
    if (hostId) {
      settingsButton.addEventListener("click", (event) => {
        userDialog.showModal();
      });
    } else {
      settingsButton.addEventListener("click", (event) => {
        hostDialog.showModal();
      });
      shareButton.classList.toggle("hidden");
      const user = JSON.parse(localStorage.getItem("host"));
      if (user) {
        state.users[user.name] = { voted: false, details: user };
        state.me = user;
        listUsers();
        console.debug("main", main);
        main.children["host-loading"].classList.toggle("hidden");
      } else {
        if (typeof hostDialog.showModal === "function") {
          hostDialog.showModal();
        }
      }
    }
    peer.on("connection", (conn) => {
      conn.on("open", () => {
        conn.on("data", (data) => {
          const payload = data.payload;
          console.debug("data", data);
          switch (data.action) {
            case "ping":
              console.debug("connection started...", payload);
              break;
            case "remove_user":
              console.debug("User informs host they're leaving", payload);
              state.users = dissoc_default(payload.name, state.users);
              state.connections = dissoc_default(payload.name, state.connections);
              console.debug("state", state);
              forEach_default((conn2) => {
                console.debug("send user list to all players");
                console.debug("conn", conn2);
                conn2.send({ action: "refresh_users", payload: state.users });
              }, values_default(state.connections));
              listUsers();
              break;
            case "reveal_vote":
              console.debug("Counting votes");
              state.users[payload.name].vote = payload.vote;
              const voteCountExpected = mapAccum_default((acc, user) => {
                const voted = user.voted ? 1 : 0;
                return [acc + voted, voted];
              }, 0, values_default(state.users));
              console.debug("voteCountExpected", voteCountExpected);
              const voteCountActual = mapAccum_default((acc, user) => {
                const vote = user.vote ? 1 : 0;
                return [acc + vote, vote];
              }, 0, values_default(state.users));
              if (voteCountActual[0] === voteCountExpected[0]) {
                revealVotes();
              }
              break;
            case "user_voted":
              console.debug("new user added to host!", payload);
              state.users[payload.name].voted = true;
              forEach_default((conn2) => {
                console.debug("send user list to all players");
                console.debug("conn", conn2);
                conn2.send({ action: "refresh_users", payload: state.users });
              }, values_default(state.connections));
              listUsers();
              break;
            case "add_user":
              console.debug("new user added to host!", payload);
              state.users[payload.name] = { voted: false, details: payload };
              state.connections[payload.name] = conn;
              forEach_default((conn2) => {
                console.debug("send user list to all players");
                console.debug("conn", conn2);
                conn2.send({ action: "refresh_users", payload: state.users });
              }, values_default(state.connections));
              conn.send({ action: "initalize_game", payload: state.game });
              if (values_default(state.users).length > 1 && state.game.mode === "wait" /* wait */) {
                initalizeGame();
              }
              listUsers();
              break;
            default:
              console.log("default");
              break;
          }
        });
        conn.send({ action: "ping", payload: "Welcome!" });
      });
    });
    if (hostId) {
      const conn = peer.connect(hostId);
      state.host.conn = conn;
      console.debug("conn", conn);
      console.debug("hostId", hostId);
      conn.on("open", () => {
        userDialog.addEventListener("close", (e) => {
          console.debug("e", e);
          console.debug("userDialog.returnValue", userDialog.returnValue);
          const userForm = e.target.firstElementChild;
          const userInfo = new FormData(userForm);
          const user = {};
          userInfo.forEach((value, key) => user[key] = value);
          localStorage.setItem("user", JSON.stringify(user));
          console.debug("userInfo", userInfo);
          console.debug("user", user);
          state.theme.name = user.theme;
          setTheme();
          state.me = user;
          conn.send({ action: "add_user", payload: user });
          listUsers();
        });
        if (typeof userDialog.showModal === "function") {
          const user = JSON.parse(localStorage.getItem("user"));
          if (user) {
            conn.send({ action: "add_user", payload: user });
            state.me = user;
            state.theme.name = user.theme;
            setTheme();
          } else {
            userDialog.showModal();
          }
        }
        window.addEventListener("beforeunload", (event) => {
          event.returnValue = "";
          conn.send({ action: "remove_user", payload: state.me });
          return null;
        });
        conn.on("data", (data) => {
          console.debug("From Host", data);
          const payload = data.payload;
          console.debug("data", data);
          switch (data.action) {
            case "ping":
              console.debug("Host says hello", payload);
              break;
            case "refresh_users":
              console.debug("new users!", payload);
              state.users = payload;
              listUsers();
              break;
            case "show_results":
              showResults(payload.votes, payload.average);
              break;
            case "restart_game":
              state.me = omit_default(["votes", "vote"], state.me);
              state.el.main.children[state.game.type].children["results"].innerHTML = "";
              break;
            case "reveal_vote":
              conn.send({ action: "reveal_vote", payload: {
                name: state.me.name,
                vote: state.me.vote
              } });
              break;
            case "add_user":
              console.debug("new user!", payload);
              state.users[payload.name] = { voted: false, details: payload };
              listUsers();
              break;
            case "initalize_game":
              state.game.type = payload.type;
              initalizeGame();
              break;
            default:
              console.log("default");
              break;
          }
        });
        conn.send({ action: "ping", payload: "I've arrived!" });
      });
    }
    if (typeof hostDialog.showModal !== "function") {
      hostDialog.hidden = true;
    }
    if (typeof userDialog.showModal !== "function") {
      userDialog.hidden = true;
    }
  });
})();
/*! p5.js v1.5.0 October 18, 2022 */
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */
